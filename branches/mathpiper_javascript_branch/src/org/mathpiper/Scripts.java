package org.mathpiper;

import java.util.HashMap;

import java.util.Map;

public class Scripts {

    private HashMap scriptMap = null;

    public Scripts() {

        scriptMap = new HashMap();

        String[] scriptString;


        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(MathPiperInitLoad,{});\nRule(MathPiperInitLoad, 0, 1, True)\n[\n    /* This is the basic initialization file for MathPiper. It gets loaded\n     * each time MathPiper is started. All the basic files are loaded.\n     */\n\n    /* Set up drivers, configurable in the .mpiperrc\n     *   Bind(MultiNomialDriver,\"multivar.rep/sparsenomial.mpi\");\n     *     or\n     *   Bind(MultiNomialDriver,\"multivar.rep/partialdensenomial.mpi\");\n     */\n\n    /* The truly required files (MathPiper NEEDS to load). */\n    // syntax must be loaded first\n    //LoadScriptOnce(\"initialization.rep/stdopers.mpi\");\n    StandardOperatorsLoad();\n\n\n    //TODO remove? LoadScriptOnce(\"base.rep/math.mpi\");\n\n    //LoadScriptOnce(\"patterns.rep/code.mpi\");\n    // at this point <-- can be used\n\n    //LoadScriptOnce(\"deffunc.rep/code.mpi\");\n\n    // at this point := and Function() can be used\n\n    //LoadScriptOnce(\"constants.rep/code.mpi\");\n    //LoadScriptOnce(\"initialization.rep/standard.mpi\");\n\n    //LoadScriptOnce(\"initialization.rep/stdarith.mpi\");\n    //Standard arithmetic is now initialized in SynchronousInterpreter.java.\n\n    // at this point arithmetic can be used\n\n    /* Load the def files for the other modules. The def files contain lists\n     * of functions defined in that file. So, in solve.def you can find the\n     * functions defined in the file solve. Each time a function is invoked\n     * for which the interpreter can not find a definition, the file is loaded.\n     */\n\n    /*\n    Rulebase(LoadPackages,{packages});\n    Rule(LoadPackages, 1, 1, True)\n    [\n            If(IsEqual(packages,{}), True,\n            [\n                    DefLoad(First(packages));\n                    LoadPackages(Rest(packages));\n            ]);\n    ];\n\n    LoadScriptOnce(\"initialization.rep/packages.mpi\");\n    LoadPackages(DefFileList());\n    */\n\n    // The multivar routines are not all properly initialized until the first time\n    // one of them is called.  This may come too late for some operations that try\n    // to use them  before they have been initialized.  The following call should\n    // take care of this problem.\n    //LoadScriptOnce(\"multivar.rep/code.mpi\");\n\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/mathpiperinit/mathpiperinit.mpw";
        scriptMap.put("MathPiperInitLoad",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of Nth that allows extending. */\nRulebase(\"Nth\",{alist,aindex});\nRule(\"Nth\",2,10,\n    And?(IsEqual(IsFunction(alist),True),\n            IsEqual(IsInteger(aindex),True),\n            Not?(IsEqual(First(FunctionToList(alist)),Nth))\n            ))\n     MathNth(alist,aindex);\n\n\n\n\nRule(\"Nth\",2,14,\n     And?(IsEqual(IsString(alist),True),IsList(aindex))\n    )\n[\n  Local(result);\n  result:=\"\";\n  ForEach(i,aindex) [ result := result : StringMidGet(i,1,alist); ];\n  result;\n];\n\nRule(\"Nth\",2,15,IsEqual(IsString(alist),True))\n[\n  StringMidGet(aindex,1,alist);\n];\n\n\nRule(\"Nth\",2,20,IsEqual(IsList(aindex),True))\n[\n  Map({{ii},alist[ii]},{aindex});\n];\n\nRule(\"Nth\",2,30,\n   And?(\n           IsEqual(IsGeneric(alist),True),\n           IsEqual(GenericTypeName(alist),\"Array\"),\n           IsEqual(IsInteger(aindex),True)\n          )\n    )\n[\n  ArrayGet(alist,aindex);\n];\n\n\n\nRule(\"Nth\",2,40,IsEqual(IsString(aindex),True))\n[\n  Local(as);\n  as := Assoc(aindex,alist);\n  If (Not?(IsEqual(as,Empty)),Bind(as,Nth(as,2)));\n  as;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/A_Nth.mpw";
        scriptMap.put("Nth",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"ArgumentsCount\",{aLeft}) Length(FunctionToList(aLeft))-1;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/ArgumentsCount.mpw";
        scriptMap.put("ArgumentsCount",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Denominator\",*);\n\n1 # Denominator(_x / _y)      <-- y;\n1 # Denominator(-_x/ _y)      <-- y;\n2 # Denominator(x_IsNumber)   <-- 1;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/Denominator.mpw";
        scriptMap.put("Denominator",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # IsNonObject(Object(_x)) <-- False;\n20 # IsNonObject(_x)         <-- True;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/IsNonObject.mpw";
        scriptMap.put("IsNonObject",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Numerator\",*);\n\n1 # Numerator(_x / _y)      <-- x;\n1 # Numerator(-_x/ _y)      <-- -x;\n2 # Numerator(x_IsNumber)   <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/Numerator.mpw";
        scriptMap.put("Numerator",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\na_IsNonNegativeInteger & b_IsNonNegativeInteger <-- BitAnd(a,b);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/ampersand_operator.mpw";
        scriptMap.put("&",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"==\",{left,right});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/equals_equals_operator.mpw";
        scriptMap.put("==",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"!==\",{left,right});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/exclamationpoint_equals_equals_operator.mpw";
        scriptMap.put("!==",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"--\",{aVar})\n[\n   MacroBind(aVar,SubtractN(Eval(aVar),1));\n\n   Eval(aVar);\n];\n\nUnFence(\"--\",1);\n\nHoldArgument(\"--\",aVar);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/minus_minus_operator.mpw";
        scriptMap.put("--",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//\"+-;/-;*-;^-;:=-;:=+\" These were in the def list.\n\n/* See the documentation on the assignment of the precedence of the rules.\n */\n\n/* Some very basic functions that are used always any way... */\n\n/* Implementation of numeric mode */\n\n//Retract(\"N\",*);\n\nLocalSymbols(numericMode)\n[\n\n  numericMode := False;\n\n  // N function: evaluate numerically with given precision.\n  LocalSymbols(previousNumericMode, previousPrecision, numericResult) \n  Macro(\"N\",{expression, precision})\n  [\n    //If(InVerboseMode(),\n    //    [Tell(\"N\",{expression,precision}); Tell(\"  \",{@expression,@precision});]\n    //);\n    \n    // we were in non-numeric mode\n    Local(previousNumericMode, previousPrecision, numericResult, exception);\n\n    previousPrecision := BuiltinPrecisionGet();\n    //If(InVerboseMode(),Tell(\"  \",previousPrecision));\n    BuiltinPrecisionSet(@precision+5);\n\n    AssignCachedConstantsN();\n\n    previousNumericMode := numericMode;\n    numericMode         := True;\n    exception         := False;\n\n    //ExceptionCatch(Bind(numericResult, Eval(@expression)),Bind(exception,ExceptionGet()));\n\n    ExceptionCatch( numericResult:=Eval(@expression), exception := ExceptionGet() );\n    //If(InVerboseMode(),Tell(\"  1\",numericResult));\n\n    If(IsDecimal(numericResult), numericResult := RoundToN(numericResult, @precision));\n    //If(InVerboseMode(),Tell(\"  2\",numericResult));\n\n    numericMode := previousNumericMode;\n\n    If(Not? numericMode, [ ClearCachedConstantsN(); ] );\n\n    BuiltinPrecisionSet(previousPrecision);\n\n    Check(exception =? False, exception[\"type\"], exception[\"message\"]);\n\n    numericResult;\n\n  ];\n\n\n\n\n  // N function: evaluate numerically with default precision.\n  LocalSymbols(precision,heldExpression) \n  Macro(\"N\",{expression})\n  [\n     Local(precision, heldExpression);\n     precision      :=  BuiltinPrecisionGet();\n     heldExpression :=  Hold(@expression);\n\n     `N(@heldExpression, @precision);\n  ];\n\n  \n  // NoN function.\n  LocalSymbols(result) \n  Macro(\"NonN\",{expression})\n  [\n    Local(result);\n    GlobalPush(numericMode);\n    numericMode := False;\n    result      := (@expression);\n    numericMode := GlobalPop();\n    result;\n  ];\n\n\n  // InNumericMode function.\n  Function(\"InNumericMode\",{}) numericMode;\n\n]; //LocalSymbols(numericMode)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/numeric.mpw";
        scriptMap.put("N",scriptString);
        scriptMap.put("NonN",scriptString);
        scriptMap.put("InNumericMode",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\na_IsNonNegativeInteger % b_IsPositiveInteger <-- Modulo(a,b);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/percent_operator.mpw";
        scriptMap.put("%",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"++\",{aVar})\n[\n   MacroBind(aVar,AddN(Eval(aVar),1));\n\n   Eval(aVar);\n];\n\nUnFence(\"++\",1);\n\nHoldArgument(\"++\",aVar);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/plus_plus_operator.mpw";
        scriptMap.put("++",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\na_IsNonNegativeInteger | b_IsNonNegativeInteger <-- BitOr(a,b);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/standard/vertical_bar_operator.mpw";
        scriptMap.put("|",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Multiplication */\n\n50  # x_IsNumber * y_IsNumber <-- MultiplyN(x,y);\n100 #  1  * _x  <-- x;\n100 # _x  *  1  <-- x;\n100 # (_f  * _x)_(f=? -1)  <-- -x;\n100 # (_x  * _f)_(f=? -1)  <-- -x;\n105 # (f_IsNegativeNumber * _x)  <-- -(-f)*x;\n105 # (_x * f_IsNegativeNumber)  <-- -(-f)*x;\n\n95 # x_IsMatrix * y_IsMatrix <--\n[\n   Local(i,j,k,row,result);\n   result:=ZeroMatrix(Length(x),Length(y[1]));\n   For(i:=1,i<=?Length(x),i++)\n   For(j:=1,j<=?Length(y),j++)\n   For(k:=1,k<=?Length(y[1]),k++)\n   [\n     row:=result[i];\n     row[k]:= row[k]+x[i][j]*y[j][k];\n   ];\n   result;\n];\n\n\n96 # x_IsMatrix * y_IsList <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(x),i++)\n   [ DestructiveInsert(result,i,Dot(x[i], y)); ];\n   result;\n];\n\n\n97 # (x_IsList * y_IsNonObject)_Not?(IsList(y)) <-- y*x;\n98 # (x_IsNonObject * y_IsList)_Not?(IsList(x)) <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(y),i++)\n   [ DestructiveInsert(result,i,x * y[i]); ];\n   result;\n];\n\n\n50  # _x * Undefined <-- Undefined;\n50  # Undefined * _y <-- Undefined;\n\n\n100  # 0 * y_IsInfinity <-- Undefined;\n100  # x_IsInfinity * 0 <-- Undefined;\n\n101 # 0    * (_x) <-- 0;\n101 # (_x) *    0 <-- 0;\n\n100 # x_IsNumber * (y_IsNumber * _z) <-- (x*y)*z;\n100 # x_IsNumber * (_y * z_IsNumber) <-- (x*z)*y;\n\n100 # (_x * _y) * _y <-- x * y^2;\n100 # (_x * _y) * _x <-- y * x^2;\n100 # _y * (_x * _y) <-- x * y^2;\n100 # _x * (_x * _y) <-- y * x^2;\n100 # _x * (_y / _z) <-- (x*y)/z;\n// fractions\n100 # (_y / _z) * _x <-- (x*y)/z;\n100 # (_x * y_IsNumber)_Not?(IsNumber(x)) <-- y*x;\n\n100 # (_x) * (_x) ^ (n_IsConstant) <-- x^(n+1);\n100 # (_x) ^ (n_IsConstant) * (_x) <-- x^(n+1);\n100 # (_x * _y)* _x ^ n_IsConstant <-- y * x^(n+1);\n100 # (_y * _x)* _x ^ n_IsConstant <-- y * x^(n+1);\n100 # Sqrt(_x) * (_x) ^ (n_IsConstant) <-- x^(n+1/2);\n100 # (_x) ^ (n_IsConstant) * Sqrt(_x) <-- x^(n+1/2);\n100 # Sqrt(_x) * (_x) <-- x^(3/2);\n100 # (_x) * Sqrt(_x) <-- x^(3/2);\n\n105 # x_IsNumber * -(_y) <-- (-x)*y;\n105 # (-(_x)) * (y_IsNumber) <-- (-y)*x;\n\n106 # _x * -(_y) <-- -(x*y);\n106 # (- _x) * _y <-- -(x*y);\n\n107 # -( (-(_x))/(_y)) <-- x/y;\n107 # -( (_x)/(-(_y))) <-- x/y;\n\n\n250  # x_IsNumber * y_IsInfinity <-- Sign(x)*y;\n250  # x_IsInfinity * y_IsNumber <-- Sign(y)*x;\n\n\n/* Note: this rule MUST be past all the transformations on\n * matrices, since they are lists also.\n */\n230 # (aLeft_IsList * aRight_IsList)_(Length(aLeft)=?Length(aRight)) <--\n         Map(\"*\",{aLeft,aRight});\n// fractions\n242 # (x_IsInteger / y_IsInteger) * (v_IsInteger / w_IsInteger) <-- (x*v)/(y*w);\n243 #  x_IsInteger * (y_IsInteger / z_IsInteger) <--  (x*y)/z;\n243 #  (y_IsInteger / z_IsInteger) * x_IsInteger <--  (x*y)/z;\n\n400 # (_x) * (_x) <-- x^2;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdarith/asterisk_operator.mpw";
        scriptMap.put("*",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Faster version of raising power to 0.5 */\n50 # _x ^ (1/2) <-- Sqrt(x);\n50 # (x_IsPositiveNumber ^ (1/2))_IsInteger(SqrtN(x)) <-- SqrtN(x);\n58 # 1 ^ n_IsInfinity <-- Undefined;\n59 # _x ^ 1 <-- x;\n59 # 1 ^ _n <-- 1;\n59 # x_IsZero ^ y_IsZero <-- Undefined;\n60 # (x_IsZero ^ n_IsRationalOrNumber)_(n>?0) <-- 0;\n60 # (x_IsZero ^ n_IsRationalOrNumber)_(n<?0) <-- Infinity;\n// This is to fix:\n// In> 0.0000^2\n// Result: 0.0000^2;\n// In> 0.0^2/2\n// Result: 0.0^2/2;\n//60 # (x_IsNumber ^ n_IsRationalOrNumber)_(x+1=1) <-- 0;\n\n59 # _x ^ Undefined <-- Undefined;\n59 # Undefined ^ _x <-- Undefined;\n\n/* Regular raising to the power. */\n61 # Infinity ^ (y_IsNegativeNumber) <-- 0;\n61 # (-Infinity) ^ (y_IsNegativeNumber) <-- 0;\n//61 # x_IsPositiveNumber ^ y_IsPositiveNumber <-- PowerN(x,y);\n//61 # x_IsPositiveNumber ^ y_IsNegativeNumber <-- (1/PowerN(x,-y));\n// integer powers are very fast\n61 # x_IsPositiveNumber ^ y_IsPositiveInteger <-- MathIntPower(x,y);\n61 # x_IsPositiveNumber ^ y_IsNegativeInteger <-- 1/MathIntPower(x,-y);\n65 # (x_IsPositiveNumber ^ y_IsNumber)_InNumericMode() <-- Exp(y*Ln(x));\n\n90 # (-_x)^m_IsEven <-- x^m;\n91 # (x_IsConstant ^ (m_IsOdd / p_IsOdd))_(IsNegativeNumber(Re(N(Eval(x))))) <--\n     -((-x)^(m/p));\n92 # (x_IsNegativeNumber ^ y_IsNumber)_InNumericMode() <-- Exp(y*Ln(x));\n\n\n70  # (_x ^ m_IsRationalOrNumber) ^ n_IsRationalOrNumber <-- x^(n*m);\n\n80 # (x_IsNumber/y_IsNumber) ^ n_IsPositiveInteger <-- x^n/y^n;\n80 # (x_IsNumber/y_IsNumber) ^ n_IsNegativeInteger <-- y^(-n)/x^(-n);\n80 # x_IsNegativeNumber ^ n_IsEven <-- (-x)^n;\n80 # x_IsNegativeNumber ^ n_IsOdd <-- -((-x)^n);\n\n\n100  # ((_x)*(_x ^ _m)) <-- x^(m+1);\n100  # ((_x ^ _m)*(_x)) <-- x^(m+1);\n100  # ((_x ^ _n)*(_x ^ _m)) <-- x^(m+n);\n\n100  # ((x_IsNumber)^(n_IsInteger/(_m)))_(n>?1) <-- MathIntPower(x,n)^(1/m);\n\n100 # Sqrt(_n)^(m_IsEven) <-- n^(m/2);\n\n100 # Abs(_a)^n_IsEven <-- a^n;\n100 # Abs(_a)^n_IsOdd <-- Sign(a)*a^n;\n\n\n200 # x_IsMatrix ^ n_IsPositiveInteger <-- x*(x^(n-1));\n204 # (xlist_IsList ^ nlist_IsList)_(Length(xlist)=?Length(nlist)) <--\n         Map(\"^\",{xlist,nlist});\n205 # (xlist_IsList ^ n_IsConstant)_(Not?(IsList(n))) <--\n         Map({{xx},xx^n},{xlist});\n206 # (_x ^ n_IsList)_(Not?(IsList(x))) <-- Map({{xx},x^xx},{n});\n249 # x_IsInfinity ^ 0 <-- Undefined;\n250 # Infinity ^ (_n) <-- Infinity;\n250 # Infinity ^ (_x_IsComplex) <-- Infinity;\n250 # ((-Infinity) ^ (n_IsNumber))_(IsEven(n)) <-- Infinity;\n250 # ((-Infinity) ^ (n_IsNumber))_(IsOdd(n)) <-- -Infinity;\n\n250 # (x_IsNumber ^ Infinity)_(x>? -1 And? x <? 1) <-- 0;\n250 # (x_IsNumber ^ Infinity)_(x>? 1) <-- Infinity;\n\n// these Magnitude(x)s should probably be changed to Abs(x)s\n\n250 # (x_IsComplex ^ Infinity)_(Magnitude(x) >? 1) <-- Infinity;\n250 # (x_IsComplex ^ Infinity)_(Magnitude(x) <? -1) <-- -Infinity;\n250 # (x_IsComplex ^ Infinity)_(Magnitude(x) >? -1 And? Magnitude(x) <? 1) <-- 0;\n\n250 # (x_IsNumber ^ -Infinity)_(x>? -1 And? x <? 1) <-- Infinity;\n250 # (x_IsNumber ^ -Infinity)_(x<? -1) <-- 0;\n250 # (x_IsNumber ^ -Infinity)_(x>? 1) <-- 0;\n\n255 # (x_IsComplex ^ Infinity)_(Abs(x) =? 1) <-- Undefined;\n255 # (x_IsComplex ^ -Infinity)_(Abs(x) =? 1) <-- Undefined;\n\n\n\n400 # _x ^ 0 <-- 1;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdarith/caret_operator.mpw";
        scriptMap.put("^",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Subtraction arity 1 */\n\n//50 # -0 <-- 0;\n51 # -Undefined <-- Undefined;\n54 # - (- _x)      <-- x;\n55 # (- (x_IsNumber)) <-- SubtractN(0,x);\n100 # _x - n_IsConstant*(_x)   <-- (1-n)*x;\n100 # n_IsConstant*(_x) - _x   <-- (n-1)*x;\n\n110 # - (_x - _y) <-- y-x;\n111 # - (x_IsNumber / _y) <-- (-x)/y;        \nLocalSymbols(x)\n[\n  200 # - (x_IsList) <-- MapSingle(\"-\",x);\n];\n\n/* Subtraction arity 2 */\n50  # x_IsNumber - y_IsNumber <-- SubtractN(x,y);\n50  # x_IsNumber - y_IsNumber <-- SubtractN(x,y);\n60  # Infinity - Infinity <-- Undefined;\n100 # 0 - _x <-- -x;\n100 # _x - 0 <-- x;\n100 # _x - _x <-- 0;\n\n110 # _x - (- _y) <-- x + y;\n110 # _x - (y_IsNegativeNumber) <-- x + (-y);\n111 # (_x + _y)- _x <-- y;\n111 # (_x + _y)- _y <-- x;\n112 # _x - (_x + _y) <-- - y;\n112 # _y - (_x + _y) <-- - x;\n113 # (- _x) - _y <-- -(x+y);\n113 # (x_IsNegativeNumber) - _y <-- -((-x)+y);\n113 # (x_IsNegativeNumber)/_y - _z <-- -((-x)/y+z);\n\n\n/* TODO move to this precedence everywhere? */\nLocalSymbols(x,y,xarg,yarg)\n[\n  10 # ((x_IsList) - (y_IsList))_(Length(x)=?Length(y)) <--\n  [\n    Map({{xarg,yarg},xarg-yarg},{x,y});\n  ];\n];\n\n240 # (x_IsList - y_IsNonObject)_Not?(IsList(y)) <-- -(y-x);\n\n241 # (x_IsNonObject - y_IsList)_Not?(IsList(x)) <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(y),i++)\n   [ DestructiveInsert(result,i,x - y[i]); ];\n   result;\n];\n\n250 # z_IsInfinity - Complex(_x,_y) <-- Complex(-x+z,-y);\n250 # Complex(_x,_y) - z_IsInfinity <-- Complex(x-z,y);\n\n251 # z_IsInfinity - _x <-- z;\n251 # _x - z_IsInfinity <-- -z;\n\n250 # Undefined - _y <-- Undefined;\n250 # _x - Undefined <-- Undefined;\n// fractions\n210 # x_IsNumber - (y_IsNumber / z_IsNumber) <--(x*z-y)/z;\n210 # (y_IsNumber / z_IsNumber) - x_IsNumber <--(y-x*z)/z;\n210 # (x_IsNumber / v_IsNumber) - (y_IsNumber / z_IsNumber) <--(x*z-y*v)/(v*z);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdarith/minus_operator.mpw";
        scriptMap.put("-",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Addition */\n\n100 # + _x  <-- x;\n\n50 # x_IsNumber + y_IsNumber <-- AddN(x,y);\n\n100 # 0 + _x    <-- x;\n100 # _x + 0    <-- x;\n100 # _x + _x   <-- 2*x;\n100 # _x + n_IsConstant*(_x)   <-- (n+1)*x;\n100 # n_IsConstant*(_x) + _x   <-- (n+1)*x;\n101 # _x + - _y <-- x-y;\n101 # _x + (- _y)/(_z) <-- x-(y/z);\n101 # (- _y)/(_z) + _x  <-- x-(y/z);\n101 # (- _x) + _y <-- y-x;\n102 # _x + y_IsNegativeNumber <-- x-(-y);\n102 # _x + y_IsNegativeNumber * _z <-- x-((-y)*z);\n102 # _x + (y_IsNegativeNumber)/(_z) <-- x-((-y)/z);\n102 # (y_IsNegativeNumber)/(_z) + _x  <-- x-((-y)/z);\n102 # (x_IsNegativeNumber) + _y <-- y-(-x);\n// fractions\n150 # _n1 / _d + _n2 / _d <-- (n1+n2)/d;\n\n200 # (x_IsNumber + _y)_Not?(IsNumber(y)) <-- y+x;\n200 # ((_y + x_IsNumber) + _z)_Not?(IsNumber(y) Or? IsNumber(z)) <-- (y+z)+x;\n200 # ((x_IsNumber + _y) + z_IsNumber)_Not?(IsNumber(y)) <-- y+(x+z);\n200 # ((_x + y_IsNumber) + z_IsNumber)_Not?(IsNumber(x)) <-- x+(y+z);\n// fractions\n210 # x_IsNumber + (y_IsNumber / z_IsNumber) <--(x*z+y)/z;\n210 # (y_IsNumber / z_IsNumber) + x_IsNumber <--(x*z+y)/z;\n210 # (x_IsNumber / v_IsNumber) + (y_IsNumber / z_IsNumber) <--(x*z+y*v)/(v*z);\n\n\n//  220 # + x_IsList          <-- MapSingle(\"+\",x);        // this rule is never active\n\n220 # (xlist_IsList + ylist_IsList)_(Length(xlist)=?Length(ylist)) <-- Map(\"+\",{xlist,ylist});\n\nSumListSide(_x, y_IsList) <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(y),i++)\n   [ DestructiveInsert(result,i,x + y[i]); ];\n   result;\n];\n\n240 # (x_IsList + _y)_Not?(IsList(y)) <-- SumListSide(y,x);\n241 # (_x + y_IsList)_Not?(IsList(x)) <-- SumListSide(x,y);\n\n250 # z_IsInfinity + Complex(_x,_y) <-- Complex(x+z,y);\n250 # Complex(_x,_y) + z_IsInfinity <-- Complex(x+z,y);\n\n251 # z_IsInfinity + _x <-- z;\n251 # _x + z_IsInfinity <-- z;\n\n\n250 # Undefined + _y <-- Undefined;\n250 # _x + Undefined <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdarith/plus_operator.mpw";
        scriptMap.put("+",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Division */\n\n50 # 0 / 0 <-- Undefined;\n\n52 # x_IsPositiveNumber / 0 <-- Infinity;\n52 # x_IsNegativeNumber / 0 <-- -Infinity;\n55 # (_x / y_IsNumber)_(IsZero(y)) <-- Undefined;\n55 # 0 / _x <-- 0;\n// unnecessary rule (see #100 below). TODO: REMOVE\n//55 # x_IsNumber / y_IsNegativeNumber <-- (-x)/(-y);\n\n56 # (x_IsNonZeroInteger / y_IsNonZeroInteger)_(GcdN(x,y) >? 1) <--\n     [\n       Local(gcd);\n       Bind(x,x);\n       Bind(y,y);\n       Bind(gcd,GcdN(x,y));\n       QuotientN(x,gcd)/QuotientN(y,gcd);\n     ];\n\n57 # ((x_IsNonZeroInteger * _expr) / y_IsNonZeroInteger)_(GcdN(x,y) >? 1) <--\n     [\n       Local(gcd);\n       Bind(x,x);\n       Bind(y,y);\n       Bind(gcd,GcdN(x,y));\n       (QuotientN(x,gcd)*expr)/QuotientN(y,gcd);\n     ];\n\n57 # ((x_IsNonZeroInteger) / (y_IsNonZeroInteger * _expr))_(GcdN(x,y) >? 1) <--\n     [\n       Local(gcd);\n       Bind(x,x);\n       Bind(y,y);\n       Bind(gcd,GcdN(x,y));\n       QuotientN(x,gcd)/(QuotientN(y,gcd)*expr);\n     ];\n\n57 # ((x_IsNonZeroInteger * _p) / (y_IsNonZeroInteger * _q))_(GcdN(x,y) >? 1) <--\n     [\n       Local(gcd);\n       Bind(x,x);\n       Bind(y,y);\n       Bind(gcd,GcdN(x,y));\n       (QuotientN(x,gcd)*p)/(QuotientN(y,gcd)*q);\n     ];\n\n60 # (x_IsDecimal / y_IsNumber)  <-- DivideN(x,y);\n60 # (x_IsNumber  / y_IsDecimal) <-- DivideN(x,y); \n60 # (x_IsNumber  / y_IsNumber)_(InNumericMode()) <-- DivideN(x,y);\n\n\n90 # x_IsInfinity / y_IsInfinity <-- Undefined;\n95  # x_IsInfinity / y_IsNumber <-- Sign(y)*x;\n95  # x_IsInfinity / y_IsComplex <-- Infinity;\n\n90 # Undefined / _y <-- Undefined;\n90 # _y / Undefined <-- Undefined;\n\n\n100 # _x / _x <-- 1;\n100 # _x /  1 <-- x;\n100 # (_x / y_IsNegativeNumber) <-- -x/(-y);\n100 # (_x / - _y) <-- -x/y;\n\n150 # (_x) / (_x) ^ (n_IsConstant) <-- x^(1-n);\n150 # (_x) ^ (n_IsConstant) * (_x) <-- x^(n-1);\n150 # Sqrt(_x) / (_x) ^ (n_IsConstant) <-- x^(1/2-n);\n150 # (_x) ^ (n_IsConstant) / Sqrt(_x) <-- x^(n-1/2);\n150 # (_x) / Sqrt(_x) <-- Sqrt(x);\n\n// fractions\n200 # (_x / _y)/ _z <-- x/(y*z);\n230 # _x / (_y / _z) <-- (x*z)/y;\n\n240 # (xlist_IsList / ylist_IsList)_(Length(xlist)=?Length(ylist)) <--\n         Map(\"/\",{xlist,ylist});\n\n\n250 # (x_IsList / _y)_(Not?(IsList(y))) <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(x),i++)\n   [ DestructiveInsert(result,i,x[i] / y); ];\n   result;\n];\n\n250 # (_x / y_IsList)_(Not?(IsList(x))) <--\n[\n   Local(i,result);\n   result:={};\n   For(i:=1,i<=?Length(y),i++)\n   [ DestructiveInsert(result,i,x/y[i]); ];\n   result;\n];\n\n250 # _x / Infinity <-- 0;\n250 # _x / (-Infinity) <-- 0;\n\n\n400 # 0 / _x <-- 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdarith/slash_operator.mpw";
        scriptMap.put("/",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n\nRulebase(StandardOperatorsLoad,{});\nRule(StandardOperatorsLoad, 0, 1, True)\n[\n    /* stdopers is loaded immediately after MathPiper is started. It contains\n     * the definitions of the infix operators, so the parser can already\n     * parse expressions containing these operators, even though the\n     * function hasn't been defined yet.\n     */\n\n    Infix(\"=?\",90);\n    Infix(\"And?\",1000);\n    RightAssociativeSet(\"And?\");\n    Infix(\"Or?\", 1010);\n    Prefix(\"Not?\", 100);\n    Infix(\"<?\",90);\n    Infix(\">?\",90);\n    Infix(\"<=?\",90);\n    Infix(\">=?\",90);\n    Infix(\"!=?\",90);\n\n    Infix(\":=\",10000);\n    RightAssociativeSet(\":=\");\n\n    Infix(\"+\",70);\n    Infix(\"-\",70);\n    RightPrecedenceSet(\"-\",40);\n    Infix(\"/\",30);\n    Infix(\"*\",40);\n    Infix(\"^\",20);\n    LeftPrecedenceSet(\"^\",19); //Added to make expressions like x^n^2 unambiguous.\n    RightAssociativeSet(\"^\");\n    Prefix(\"+\",50);\n    Prefix(\"-\",50);\n    RightPrecedenceSet(\"-\",40);\n    Bodied(\"For\",60000);\n    Bodied(\"Until\",60000);\n    Postfix(\"++\",5);\n    Postfix(\"--\",5);\n    Bodied(\"ForEach\",60000);\n    Infix(\"<<\",10);\n    Infix(\">>\",10);\n    Bodied(\"Differentiate\",60000);\n    Bodied(\"Deriv\",60000);\n    Infix(\"X\",30);\n    Infix(\".\",30);\n    Infix(\"o\",30);\n    Postfix(\"!\", 30);\n    Postfix(\"!!\", 30);\n    Infix(\"***\", 50);\n    Bodied(\"Integrate\",60000);\n\n    Bodied(\"Limit\",60000);\n\n    Bodied(\"EchoTime\", 60000);\n\n    Bodied(\"Repeat\", 60000);\n\n    Infix(\"->\",600);\n\n    /* functional operators */\n    Infix(\":\",70);\n    RightAssociativeSet(\":\");\n    Infix(\"@\",600);\n    Infix(\"/@\",600);\n    Infix(\"..\",600);\n\n    Bodied(\"Taylor\",60000);\n    Bodied(\"Taylor1\",60000);\n    Bodied(\"Taylor2\",60000);\n    Bodied(\"Taylor3\",60000);\n    Bodied(\"InverseTaylor\",60000);\n\n    Infix(\"<--\",10000);\n    Infix(\"#\",9900);\n\n    Bodied(\"TSum\",60000);\n    Bodied(\"TExplicitSum\",60000);\n    Bodied(\"TD\",5);  /* Tell the MathPiper interpreter that TD is to be used as TD(i)f */\n\n    /* Operator to be used for non-evaluating comparisons */\n    Infix(\"==\",90);\n    Infix(\"!==\",90);\n\n    /* Operators needed for propositional logic theorem prover */\n    Infix(\"=>\",10000); /* implication, read as 'implies' */\n\n\n    Bodied(\"if\",5);\n    Infix(\"else\",60000);\n    RightAssociativeSet(\"else\");\n    /* Bitwise operations we REALLY need. Perhaps we should define them\n       also as MathPiper operators?\n     */\n    Infix(\"&\",50);\n    Infix(\"|\",50);\n    Infix(\"%\",50);\n\n    /* local pattern replacement operators */\n    Infix(\"/:\",20000);\n    Infix(\"/::\",20000);\n    Infix(\"<-\",10000);\n\n    /* Operators used for manual layout */\n    Infix(\"<>\", PrecedenceGet(\"=?\"));\n    Infix(\"<=>\", PrecedenceGet(\"=?\"));\n\n    /* Operators for Solve: Where and AddTo */\n    Infix(\"Where\", 11000);\n    Infix(\"AddTo\", 2000);\n\n    Bodied(\"Function\",60000);\n    Bodied(\"Macro\",60000);\n\n    Bodied(Assert, 60000);\n\n    // Defining very simple functions, in scripts that can be converted to plugin.\n    Bodied(\"Defun\",0);\n\n    Bodied(\"TemplateFunction\",60000);\n\n    Bodied(\"Taylor3'TaylorCoefs\",0);\n\n    Infix(\":*:\",3);\n\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/a_initialization/stdopers/stdopers.mpw";
        scriptMap.put("StandardOperatorsLoad",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nArrayCreateFromList(list):=\n[\n  Local(result,i);\n  result:=ArrayCreate(Length(list),0);\n  i:=1;\n  While (list !=? {})\n  [\n    result[i]:=First(list);\n    i++;\n    list:=Rest(list);\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/array/ArrayCreateFromList.mpw";
        scriptMap.put("ArrayCreateFromList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nArrayToList(array):= (array[1 .. ArraySize(array) ]);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/array/ArrayToList.mpw";
        scriptMap.put("ArrayToList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Assoc : given an assoc list like for example l:={{a,2},{b,3}},\n   Assoc(b,l) will return {b,3}. if the key is not in the list,\n   it will return the atom Empty.\n*/\n\nFunction(\"Assoc\",{key,list})  Builtin'Assoc(key,list);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/assoc/Assoc.mpw";
        scriptMap.put("Assoc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Delete an element of an associative list.\nLocalSymbols(hash, key, element, hash'expr)\n[\n\n/// AssocDelete(hash,{\"key\", value})\n10 # AssocDelete(hash_IsList, element_IsList) <--\n[\n        Local(index);\n        index := Find(hash, element);\n        If(\n                index >? 0,\n                DestructiveDelete(hash, index)\n        );\n        index>?0;        // return False if nothing found\n\n];\n\n\n/// AssocDelete(hash, \"key\")\n20 # AssocDelete(hash_IsList, key_IsString) <--\n[\n        AssocDelete(hash, Builtin'Assoc(key, hash));\n];\n\n30 # AssocDelete(hash_IsList, Empty) <-- False;\n\n//HoldArgument(\"AssocDelete\", hash);\n//UnFence(\"AssocDelete\", 1);\n//UnFence(\"AssocDelete\", 2);\n\n];        // LocalSymbols(hash, ...)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/assoc/AssocDelete.mpw";
        scriptMap.put("AssocDelete",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nAssocIndices(associndiceslist_IsList) <--\n  DestructiveReverse(MapSingle(\"First\",associndiceslist));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/assoc/AssocIndices.mpw";
        scriptMap.put("AssocIndices",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nAssocValues(assocvalueslist_IsList) <--\n  DestructiveReverse(MapSingle(Lambda({x},First(Rest(x))),assocvalueslist));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/assoc/AssocValues.mpw";
        scriptMap.put("AssocValues",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDefun(\"CosN\",{x})Trigonometry(x,0.0,1.0,1.0);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/CosN.mpw";
        scriptMap.put("CosN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "// jak: This seems to be less accurute than MathExpTaylor0 for numbers which are greater than 1.\n/// ExpN(x). Algorithm: for x<0, divide 1 by ExpN(-x); for x>1, compute ExpN(x/2)^2 recursively; for 0<x<1, use the Taylor series.\n// (This is not optimal; it would be much better to use SumTaylorNum and DoublingMinus1 from elemfuncs.mpi. But this should be debugged for now, since ExpN is important for many algorithms.)\n/// TODO FIXME: No precision tracking yet. (i.e. the correct number of digits is not always there in the answer)\n\nDefun(\"ExpN\", {x})\n        If(IsEqual(x,0),1,\n         If(IsLessThan(x,0),DivideN(1, ExpN(MathNegate(x))),\n          If(IsGreaterThan(x,1), MathExpDoubling(MathExpTaylor0(MathMul2Exp(x,MathNegate(MathBitCount(x)))), MathBitCount(x)), MathExpTaylor0(x)\n        )));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/ExpN.mpw";
        scriptMap.put("ExpN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Identity transformation, compute Exp(x) from value=Exp(x/2^n) by squaring the value n times\nDefun(\"MathExpDoubling\", {value, n})\n[\n        Local(shift, result);\n        Bind(shift, n);\n        Bind(result, value);\n        While (IsGreaterThan(shift,0))        // will lose 'shift' bits of precision here\n        [\n                Bind(result, MultiplyN(result, result));\n                Bind(shift, AddN(shift,MathNegate(1)));\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathExpDoubling.mpw";
        scriptMap.put("MathExpDoubling",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// simple Taylor expansion, use only for 0<=x<1\nDefun(\"MathExpTaylor0\",{x})\n[\n  Check(x<=?1 And? x>=?0,\"\",\" Argument must be between 0 and 1 inclusive.\");\n  Local(i,aResult,term,eps);\n  // Exp(x)=Sum(i=0 to Inf)  x^(i) /(i)!\n  // Which incrementally becomes the algorithm:\n  //\n  // i <- 0\n  Bind(i,0);\n  // sum <- 1\n  Bind(aResult,1.0);\n  // term <- 1\n  Bind(term,1.0);\n  Bind(eps,MathIntPower(10,MathNegate(BuiltinPrecisionGet())));\n  // While (term>?epsilon)\n  \n  While(IsGreaterThan(AbsN(term),eps))\n  [\n    //   i <- i+1\n    Bind(i,AddN(i,1));\n    //   term <- term*x/(i)\n    Bind(term,DivideN(MultiplyN(term,x),i));\n    //   sum <- sum+term\n    Bind(aResult,AddN(aResult,term));\n  ];\n  aResult;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathExpTaylor0.mpw";
        scriptMap.put("MathExpTaylor0",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// power function for non-integer argument y -- use ExpN and LogN\n/* Serge, I disabled this one for now, until we get a compiled version of LogN that does not hang in\n   an infinite loop. The C++ version of LogN never terminates, so I mapped LogN to your Internal'LnNum\n   which of course does a much better job of it. Corollary is that this function can be defined when we also\n   have Internal'LnNum in this file.\nDefun(\"MathFloatPower\", {x,y})\n        If(IsInteger(y), False, ExpN(MultiplyN(y,LogN(x))));\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathFloatPower.mpw";
        scriptMap.put("MathFloatPower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// power x^y only for integer y (perhaps negative)\nDefun(\"MathIntPower\", {x,y})\n        If(IsEqual(x,0),0,If(IsEqual(x,1),1,\n         If(IsInteger(y),If(IsLessThan(y,0), // negative power, need to convert x to float to save time, since x^(-n) is never going to be integer anyway\n          DivideN(1, PositiveIntPower(AddN(x,0.),MathNegate(y))),\n           // now the positive integer y calculation - note that x might still be integer\n          PositiveIntPower(x,y)\n         ),        // floating-point calculation is absent, return False\n         False)\n        ));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathIntPower.mpw";
        scriptMap.put("MathIntPower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// MathMul2Exp: multiply x by 2^n quickly (for integer n)\n// this should really be implemented in the core as a call to BigNumber::ShiftRight or ShiftLeft\nDefun(\"MathMul2Exp\", {x,n})        // avoid roundoff by not calculating 1/2^n separately\n        If(IsGreaterThan(n,0), MultiplyN(x, MathIntPower(2,n)), DivideN(x, MathIntPower(2,MathNegate(n))));\n// this doesn't work because ShiftLeft/Right don't yet work on floats\n//        If(IsGreaterThan(n,0), ShiftLeft(x,n), ShiftRight(x,n)\n//        );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathMul2Exp.mpw";
        scriptMap.put("MathMul2Exp",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDefun(\"MathPi\",{})\n[\n  // Newton's method for finding pi:\n  // x[0] := 3.1415926\n  // x[n+1] := x[n] + Sin(x[n])\n  Local(initialPrec,curPrec,result,aPrecision);\n  Bind(aPrecision,BuiltinPrecisionGet());\n        Bind(initialPrec, aPrecision);        // target precision of first iteration, will be computed below\n  Bind(curPrec, 40);  // precision of the initial guess\n  Bind(result, 3.141592653589793238462643383279502884197169399);    // initial guess\n\n        // optimize precision sequence\n        While (IsGreaterThan(initialPrec, MultiplyN(curPrec,3)))\n  [\n                Bind(initialPrec, FloorN(DivideN(AddN(initialPrec,2),3)));\n  ];\n        Bind(curPrec, initialPrec);\n  While (Not?(IsGreaterThan(curPrec, aPrecision)))\n  [\n                 // start of iteration code\n    // Get Sin(result)\n    BuiltinPrecisionSet(curPrec);\n    Bind(result,AddN(result,SinN(result)));\n    // Calculate new result: result := result + Sin(result);\n                // end of iteration code\n                // decide whether we are at end of loop now\n                If (IsEqual(curPrec, aPrecision),        // if we are exactly at full precision, it's the last iteration\n    [\n                        Bind(curPrec, AddN(aPrecision,1));        // terminate loop\n    ],\n    [\n                        Bind(curPrec, MultiplyN(curPrec,3));        // precision triples at each iteration\n                        // need to guard against overshooting precision\n                         If (IsGreaterThan(curPrec, aPrecision),\n      [\n                                Bind(curPrec, aPrecision);        // next will be the last iteration\n      ]);\n                ]);\n  ];\n  BuiltinPrecisionSet(aPrecision);\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/MathPi.mpw";
        scriptMap.put("MathPi",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// first define the binary exponentiation algorithm, MathIntPower.\n// Later, the PowerN function will be defined through IntPower and MathLn/ExpN. Note that ExpN uses IntPower.\n\n// power x^n only for non-negative integer n\nDefun(\"PositiveIntPower\", {x,n})\n[\n  Local(result,unit);\n  If(IsLessThan(n,0), False,\n  [\n        Bind(unit,1);         // this is a constant, initial value of the power\n        Bind(result, unit);\n        If(IsEqual(n,0),unit,\n         If(IsEqual(n,1),x,\n          [\n                While(IsGreaterThan(n,0))\n                [\n                        If(\n                                IsEqual(BitAnd(n,1), 1),\n//                                If(\n//                                        IsEqual(result,unit), // if result is already assigned\n//                                        Bind(result, x), // avoid multiplication\n                                        Bind(result, MultiplyN(result,x))\n//                                )\n                        );\n                        Bind(x, MultiplyN(x,x));\n                        Bind(n,ShiftRight(n,1));\n                ];\n                result;\n          ]\n         )\n        );\n  ]);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/PositiveIntPower.mpw";
        scriptMap.put("PositiveIntPower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// power function that works for all real x, y\n/// FIXME: No precision tracking yet.\n\n/* Serge, as MathFloatPower cannot be defined yet, I made the \"avoid PowerN(num,float) explicit :-)\n*/\nDefun(\"PowerN\", {x,y})\n// avoid PowerN(0,float)\n        If(IsEqual(x,0),0, If(IsEqual(x,1),1,\n          If(IsInteger(y), MathIntPower(x,y), False/*MathFloatPower(x,y)*/)\n        ));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/PowerN.mpw";
        scriptMap.put("PowerN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDefun(\"SinN\",{x})Trigonometry(x,1.0,x,x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/SinN.mpw";
        scriptMap.put("SinN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDefun(\"TanN\",{x})DivideN(SinN(x),CosN(x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/TanN.mpw";
        scriptMap.put("TanN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDefun(\"Trigonometry\",{x,i,sum,term})\n[\n  Local(x2,orig,eps,previousPrec,newPrec);\n  Bind(previousPrec,BuiltinPrecisionGet());\n  Bind(newPrec,AddN(BuiltinPrecisionGet(),2));\n  Bind(x2,MultiplyN(x,x));\n  BuiltinPrecisionSet(newPrec);\n  Bind(eps,MathIntPower(10,MathNegate(previousPrec)));\n  While(IsGreaterThan(AbsN(term),eps))\n  [\n    Bind(term,MultiplyN(term,x2));\n    Bind(i,AddN(i,1.0));\n    Bind(term,DivideN(term,i));\n    Bind(i,AddN(i,1.0));\n    Bind(term,DivideN(MathNegate(term),i));\n    BuiltinPrecisionSet(previousPrec);\n    Bind(sum, AddN(sum, term));\n    BuiltinPrecisionSet(newPrec);\n  ];\n  BuiltinPrecisionSet(previousPrec);\n  sum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/base/Trigonometry.mpw";
        scriptMap.put("Trigonometry",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// http://en.wikipedia.org/wiki/Computus#Anonymous_Gregorian_algorithm\nEaster(year) := [\n\n    Check(IsPositiveInteger(year), \"Argument\", \"The argument must be a positive integer\");\n\n    Local(a,b,c,d,e,f,g,h,i,k,L,m,month,day);\n\n    a := Modulo(year, 19);\n    b := Quotient(year, 100);\n    c := Modulo(year, 100);\n    d := Quotient(b, 4);\n    e := Modulo(b, 4);\n    f := Quotient(b + 8, 25);\n    g := Quotient(b - f + 1, 3);\n    h := Modulo(19*a + b - d - g + 15, 30);\n    i := Quotient(c, 4);\n    k := Modulo(c, 4);\n    L := Modulo(32 + 2*e + 2*i - h - k, 7);\n    m := Quotient(a + 11*h + 22*L, 451);\n    month := Quotient(h + L - 7*m + 114, 31);\n    day := Modulo(h + L - 7*m + 114, 31) + 1;\n\n    { month, day };\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/calendar/Easter.mpw";
        scriptMap.put("Easter",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Binomials -- now using partial factorial for speed */\n// BinomialCoefficient(n,m) = BinomialCoefficient(n, n-m)\n10 # BinomialCoefficient(0,0)                 <-- 1;\n10 # BinomialCoefficient(n_IsPositiveInteger,m_IsNonNegativeInteger)_(2*m <=? n) <-- ((n-m+1) *** n) / m!;\n15 # BinomialCoefficient(n_IsPositiveInteger,m_IsNonNegativeInteger)_(2*m >? n And? m <=? n) <-- BinomialCoefficient(n, n-m);\n20 # BinomialCoefficient(n_IsInteger,m_IsInteger) <-- 0;\n\nCombinations(n,m) := BinomialCoefficient(n,m);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/combinatorics/Combinations.mpw";
        scriptMap.put("Combinations",scriptString);
        scriptMap.put("BinomialCoefficient",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"PermutationsList\",{result,list})\n[\n  If(Length(list) =? 0,\n  [\n    result;\n  ],\n  [\n    Local(head);\n    Local(newresult);\n    Local(i);\n    head:=list[1];\n    newresult:={};\n    ForEach(item,result)\n    [\n      For(i:=Length(item)+1,i>?0,i--)\n      [\n        DestructiveInsert(newresult,1,Insert(item,i,head));\n      ];\n    ];\n    newresult:=DestructiveReverse(newresult);\n    PermutationsList(newresult,Rest(list));\n  ]);\n];\n\n\nFunction(\"PermutationsList\",{list})\n[\n  PermutationsList({{}},list);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/combinatorics/PermutationsList.mpw";
        scriptMap.put("PermutationsList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Arg(Complex(Cos(_x),Sin(_x))) <-- x;\n10 # Arg(x_IsZero) <-- Undefined;\n15 # Arg(x_IsPositiveReal) <-- 0;\n15 # Arg(x_IsNegativeReal) <-- Pi;\n20 # Arg(Complex(r_IsZero,i_IsConstant)) <-- Sign(i)*Pi/2;\n30 # Arg(Complex(r_IsPositiveReal,i_IsConstant)) <-- ArcTan(i/r);\n40 # Arg(Complex(r_IsNegativeReal,i_IsPositiveReal)) <-- Pi+ArcTan(i/r);\n50 # Arg(Complex(r_IsNegativeReal,i_IsNegativeReal)) <-- ArcTan(i/r)-Pi;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Arg.mpw";
        scriptMap.put("Arg",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n0 # Complex(_r,i_IsZero) <-- r;\n2 # Complex(Complex(_r1,_i1),_i2) <-- Complex(r1,i1+i2);\n2 # Complex(_r1,Complex(_r2,_i2)) <-- Complex(r1-i2,r2);\n\n6 # Complex(Undefined,_x) <-- Undefined;\n6 # Complex(_x,Undefined) <-- Undefined;\n\n\n/* Addition */\n\n110 # Complex(_r1,_i1) + Complex(_r2,_i2) <-- Complex(r1+r2,i1+i2);\n300 # Complex(_r,_i) + x_IsConstant <-- Complex(r+x,i);\n300 # x_IsConstant + Complex(_r,_i) <-- Complex(r+x,i);\n\n110 # - Complex(_r,_i) <-- Complex(-r,-i);\n\n300 # Complex(_r,_i) - x_IsConstant <-- Complex(r-x,i);\n300 # x_IsConstant - Complex(_r,_i) <-- Complex((-r)+x,-i);\n111 # Complex(_r1,_i1) - Complex(_r2,_i2) <-- Complex(r1-r2,i1-i2);\n\n/* Multiplication */\n110 # Complex(_r1,_i1) * Complex(_r2,_i2) <-- Complex(r1*r2-i1*i2,r1*i2+r2*i1);\n/* right now this is slower than above\n110 # Complex(_r1,_i1) * Complex(_r2,_i2) <--\n[        // the Karatsuba trick\n        Local(A,B);\n        A:=r1*r2;\n        B:=i1*i2;\n        Complex(A-B,(r1+i1)*(r2+i2)-A-B);\n];\n*/\n\n\n// Multiplication in combination with complex numbers in the light of infinity\n250 # Complex(r_IsZero,_i) * x_IsInfinity <-- Complex(0,i*x);\n250 # Complex(_r,i_IsZero) * x_IsInfinity <-- Complex(r*x,0);\n251 # Complex(_r,_i) * x_IsInfinity <-- Complex(r*x,i*x);\n\n250 # x_IsInfinity * Complex(r_IsZero,_i) <-- Complex(0,i*x);\n250 # x_IsInfinity * Complex(_r,i_IsZero) <-- Complex(r*x,0);\n251 # x_IsInfinity * Complex(_r,_i) <-- Complex(r*x,i*x);\n\n\n300 # Complex(_r,_i) * y_IsConstant <-- Complex(r*y,i*y);\n300 # y_IsConstant * Complex(_r,_i) <-- Complex(r*y,i*y);\n\n330 # Complex(_r,_i) * (y_IsConstant / _z) <-- (Complex(r*y,i*y))/z;\n330 # (y_IsConstant / _z) * Complex(_r,_i) <-- (Complex(r*y,i*y))/z;\n\n\n110 # x_IsConstant / Complex(_r,_i) <-- (x*Conjugate(Complex(r,i)))/(r^2+i^2);\n\n\n300 # Complex(_r,_i) / y_IsConstant <-- Complex(r/y,i/y);\n\n110 # (_x ^ Complex(_r,_i)) <-- Exp(Complex(r,i)*Ln(x));\n\n110 # Sqrt(Complex(_r,_i)) <-- Exp(Ln(Complex(r,i))/2);\n110 # (Complex(_r,_i) ^ x_IsRationalOrNumber)_(Not?(IsInteger(x))) <-- Exp(x*Ln(Complex(r,i)));\n\n// This is commented out because it used PowerN so (2*I)^(-10) became a floating-point number. Now everything is handled by binary algorithm below\n//120 # Complex(r_IsZero,_i) ^ n_IsInteger <-- {1,I,-1,-I}[1+Modulo(n,4)] * i^n;\n\n123 # Complex(_r, _i) ^ n_IsNegativeInteger <-- 1/Complex(r, i)^(-n);\n\n124 # Complex(_r, _i) ^ (p_IsZero) <-- 1;        // cannot have Complex(0,0) here\n\n125 # Complex(_r, _i) ^ n_IsPositiveInteger <--\n[\n        // use binary method\n        Local(result, x);\n        x:=Complex(r,i);\n        result:=1;\n        While(n >? 0)\n        [\n                if ((n&1) =? 1)\n                [\n                  result := result*x;\n                ];\n                x := x*x;\n                n := n>>1;\n        ];\n        result;\n];\n\n\n/*[        // this method is disabled b/c it suffers from severe roundoff errors\n  Local(rr,ii,count,sign);\n  rr:=r^n;\n  ii:=0;\n  For(count:=1,count<=?n,count:=count+2) [\n    sign:=If(IsZero(Modulo(count-1,4)),1,-1);\n    ii:=ii+sign*BinomialCoefficient(n,count)*i^count*r^(n-count);\n    If(count<?n,\n      rr:=rr-sign*BinomialCoefficient(n,count+1)*i^(count+1)*r^(n-count-1));\n  ];\n  Complex(rr,ii);\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Complex.mpw";
        scriptMap.put("Complex",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(a,x)\n[\nFunction(\"Conjugate\",{a})\n  Substitute(a,{{x},Type(x)=?\"Complex\"},{{x},Complex(x[1],-(x[2]))});\n]; // LocalSymbols(a,x)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Conjugate.mpw";
        scriptMap.put("Conjugate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//\n// II is the imaginary number Sqrt(-1), and remains that way.\n// The difference is it isn't converted to the form Complex(x,y).\n//\n\n10 # II^n_IsNegativeInteger <-- (-II)^(-n);\n20 # (II^_n)_(IsEven(n) =? True) <-- (-1)^(n>>1);\n20 # (II^_n)_(IsOdd(n)  =? True) <--  II*(-1)^(n>>1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/II.mpw";
        scriptMap.put("II",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Imaginary parts */\n110 # Im(Complex(_r,_i)) <-- i;\n120 # Im(Undefined) <-- Undefined;\n300 # Im(_x) <-- 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Im.mpw";
        scriptMap.put("Im",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nImII(_c) <-- NN(c)[2];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/ImII.mpw";
        scriptMap.put("ImII",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* All things you can request a real and imaginary part for are complex */\n1 # IsComplex(x_IsRationalOrNumber)     <-- True;\n2 # IsComplex(Complex(_r,_i)) <-- True;\n3 # IsComplex(_x)             <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/IsComplex.mpw";
        scriptMap.put("IsComplex",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsComplexII(_c) <-- (ImII(c) !=? 0);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/IsComplexII.mpw";
        scriptMap.put("IsComplexII",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNotComplex(x) := Not?(IsComplex(x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/IsNotComplex.mpw";
        scriptMap.put("IsNotComplex",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Magnitude\",{x}) [\n        Sqrt(Re(x)^2 + Im(x)^2);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Magnitude.mpw";
        scriptMap.put("Magnitude",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(complexReduce) [\n\n  Bind(complexReduce,\n    Hold(\n    {\n      Exp(x_IsComplexII) <- Exp(ReII(x))*(Cos(ImII(x))+II*Sin(ImII(x)))\n    }));\n\n  NN(_c) <--\n  [\n    Local(result);\n    c := (c /:: complexReduce);\n    result := Coef(Expand(c,II),II,{0,1});\n    result;\n  ];\n\n]; //LocalSymbols(complexReduce)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/NN.mpw";
        scriptMap.put("NN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*Real parts */\n110 # Re(Complex(_r,_i)) <-- r;\n120 # Re(Undefined) <-- Undefined;\n300 # Re(_x) <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/Re.mpw";
        scriptMap.put("Re",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nReII(_c) <-- NN(c)[1];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/complex/ReII.mpw";
        scriptMap.put("ReII",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions.\nI\nCachedConstant\nAssignCachedConstants\nClearCachedConstants\n*/\n\n/* Definition of constants. */\n\n/* TODO:\n * There is a problem with defining I this way: if I is used, but the\n * file \"complex\" has not been loaded, the interpreter can not deal\n * with \"Complex\".\n *\n * Note:tk:10/9/09: Perhaps use SetGlobalLazyVariable(I,Hold(Complex(0,1)));\n */\n\nSetGlobalLazyVariable(I,Complex(0,1));\n\n//////////////////////////////////////////////////\n/// Cached constants support and definition of Pi\n//////////////////////////////////////////////////\n\n//TODO: here we wrap the entire file in LocalSymbols, this is inefficient in that it slows loading of this file. Needs optimization.\nLocalSymbols(CacheOfConstantsN) [\n\n/// declare a new cached constant C'atom and its associated function C'atom().\n/// C'atom() will call C'func() at current precision to evaluate C'atom if it has not yet been cached at that precision. (note: any arguments to C'func() must be included)\nRulebase(\"CachedConstant\", {C'cache, C'atom, C'func});\nUnFence(\"CachedConstant\", 3);        // not sure if this is useful\nHoldArgument(\"CachedConstant\", C'func);\nHoldArgument(\"CachedConstant\", C'cache);        // name of the cache\n// check syntax: must be called on an atom and a function\nRule(\"CachedConstant\", 3, 10, And?(IsAtom(C'atom), IsFunction(C'func)))\n[\n         Local(C'name,C'functionName);\n        Bind(C'name, ToString(C'atom));        // this is for later conveniences\n  Bind(C'functionName,ConcatStrings(\"Internal'\",C'name));\n\n        If(        // create the cache it if it does not already exist\n                IsAtom(Eval(C'cache)),\n                MacroBind(Eval(C'cache), {})\n        );\n//        Write({\"debug step 0: \", C'cache, Eval(C'cache), C'atom, C'func, C'name});\n        // check that the constant is not already defined\n        If(\n          IsEqual(Builtin'Assoc(C'name, Eval(C'cache)), Empty),        // the constant is not already defined, so need to define \"C'atom\" and the corresponding function \"C'atom\"()\n          [        // e.g. C'atom evaluates to Pi, C'cache to a name e.g. CacheOfConstantsN, which is bound to a hash\n                MacroUnbind(C'atom);\n//                Write({\"debug step 1: \", Cache'name, C'cache, Eval(C'cache)});\n                // add the new constant to the cache\n//                MacroBind(Cache'name, Insert(Eval(C'cache), 1, {C'name, 0, 0}));\n                DestructiveInsert(Eval(C'cache), 1, {C'name, 0, 0});\n//                Write({\"debug step 2: \", Cache'name, C'cache, Eval(C'cache)});\n                // define the new function \"C'atom\"()\n                // note: this should not use N() because it may be called from inside N() itself\n\n                MacroRulebase(C'functionName, {});\n                `( Rule(@C'functionName, 0, 1024, True)\n                [\n                        Local(new'prec, new'C, cached'C);\n                        Bind(new'prec, BuiltinPrecisionGet());\n                        // fetch the cache entry for this constant\n                        // note that this procedure will store the name of the cache here in this statement as Eval(C'cache)\n                        Bind(cached'C, Builtin'Assoc(@C'name, @C'cache));\n                        If( MathNth(cached'C, 2) !=? new'prec,\n                          [        // need to recalculate at current precision\n                                If(IsEqual(InVerboseMode(),True), Echo(\"CachedConstant: Info: constant \", @C'name, \" is being recalculated at precision \", new'prec));\n                                Bind(new'C, RoundTo(Eval(@C'func),new'prec));\n                                DestructiveReplace(cached'C, 2, new'prec);\n                                DestructiveReplace(cached'C, 3, new'C);\n                                new'C;\n                          ],\n                          // return cached value of C'atom\n                          MathNth(cached'C, 3)\n                        );\n                ]);\n\n                // calculate C'atom at current precision for the first time\n//                Eval(ListToFunction({C'atom}));        // \"C'name\"();\n                // we do not need this until the constant is used; it will just slow us down\n          ],\n          // the constant is defined\n          Echo(\"CachedConstant: Warning: constant \", C'atom, \" already defined\")\n        );\n];\n\nRule(\"CachedConstant\", 3, 20, True)\n        Echo(\"CachedConstant: Error: \", C'atom, \" must be an atom and \", C'func, \" must be a function.\");\n\n/// assign numerical values to all cached constants: using fixed cache \"CacheOfConstantsN\"\n// this is called from N()\nFunction(\"AssignCachedConstantsN\", {})\n[\n        Local(var,fname);\n        ForEach(var, AssocIndices(CacheOfConstantsN))\n        [\n                MacroUnbind(ToAtom(var));\n    Bind(fname,ConcatStrings(\"Internal'\",var));\n    Bind(var,ToAtom(var));\n                // this way the routine Internal'Pi() will be actually called only when the variable 'Pi' is used, etcetera.\n    `SetGlobalLazyVariable((@var), ListToFunction({ToAtom(fname)}));\n        ];\n];\nUnFence(\"AssignCachedConstantsN\", 0);\n\n/// clear values from all cached constants: using fixed cache \"CacheOfConstantsN\"\n// this is called from N()\nFunction(\"ClearCachedConstantsN\", {})\n[\n        Local(c'entry);\n        ForEach(c'entry, CacheOfConstantsN)\n                MacroUnbind(ToAtom(c'entry[1]));\n];\nUnFence(\"ClearCachedConstantsN\", 0);\n\n/// declare some constants now\nCachedConstant(CacheOfConstantsN, Pi,\n[// it seems necessary to precompute Pi to a few more digits\n// so that Cos(0.5*Pi)=0 at precision 10\n// FIXME: find a better solution\n        Local(result,old'prec);\n  Bind(old'prec,BuiltinPrecisionGet());\nIf(IsEqual(InVerboseMode(),True), Echo(\"Recalculating Pi at precision \",old'prec+5));\n        BuiltinPrecisionSet(BuiltinPrecisionGet()+5);\n        result := MathPi();\nIf(IsEqual(InVerboseMode(),True),Echo(\"Switching back to precision \",old'prec));\n        BuiltinPrecisionSet(old'prec);\n        result;\n]\n);\nCachedConstant(CacheOfConstantsN, gamma, GammaConstNum());\nCachedConstant(CacheOfConstantsN, GoldenRatio, N( (1+Sqrt(5))/2 ) );\nCachedConstant(CacheOfConstantsN, Catalan, CatalanConstNum() );\n\n]; // LocalSymbols(CacheOfConstantsN)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/constants/constants.mpw";
        scriptMap.put("I",scriptString);
        scriptMap.put("CachedConstant",scriptString);
        scriptMap.put("AssignCachedConstantsN",scriptString);
        scriptMap.put("ClearCachedConstantsN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Defining a For function */\nTemplateFunction(\"For\",{start,predicate,increment,body})\n[\n  Eval(start);\n  While (IsEqual(Eval(predicate),True))\n  [\n    Eval(body);\n    Eval(increment);\n  ];\n];\nUnFence(\"For\",4);\nHoldArgumentNumber(\"For\",4,1);\nHoldArgumentNumber(\"For\",4,2);\nHoldArgumentNumber(\"For\",4,3);\nHoldArgumentNumber(\"For\",4,4);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/For.mpw";
        scriptMap.put("For",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ForEach\" , *);\n\n/*TODO remove? Not yet. If the code above (ForEachExperimental) can be made to work we can do away with this version. */\nTemplateFunction(\"ForEach\",{item,listOrString,body})\n[\n  If(And?(IsEqual(IsGeneric(listOrString),True),\n         IsEqual(GenericTypeName(listOrString),\"Array\")\n         ),\n    `ForEachInArray(@item,listOrString,@body),\n    [\n\n      MacroLocal(item);\n      \n      If(IsString(listOrString),\n      [\n          \n          Local(index, stringLength);\n          \n          stringLength := Length(listOrString);\n          \n          index := 1;\n          While(index <=? stringLength )\n          [\n             MacroBind(item,listOrString[index] );\n             \n             Eval(body);\n             \n             index++;\n          ];\n\n      ],\n      [\n          Local(foreachtail);\n          Bind(foreachtail,listOrString);\n          While(Not?(IsEqual(foreachtail,{})))\n          [\n            MacroBind(item,First(foreachtail));\n            Eval(body);\n            Bind(foreachtail,Rest(foreachtail));\n          ];\n      ]);\n    ]);\n];\nUnFence(\"ForEach\",3);\nHoldArgumentNumber(\"ForEach\",3,1);\nHoldArgumentNumber(\"ForEach\",3,3);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/ForEach.mpw";
        scriptMap.put("ForEach",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(i,nr)\n[\n  TemplateFunction(\"ForEachInArray\",{item,list,body})\n  [\n    Local(i,nr);\n    MacroLocal(item);\n    Bind(i,1);\n    Bind(nr,Length(list));\n    While(i<=?nr)\n    [\n      MacroBind(item,list[i]);\n      Eval(body);\n      Bind(i,AddN(i,1));\n    ];\n  ];\n];\n\nUnFence(\"ForEachInArray\",3);\nHoldArgumentNumber(\"ForEachInArray\",3,1);\nHoldArgumentNumber(\"ForEachInArray\",3,3);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/ForEachInArray.mpw";
        scriptMap.put("ForEachInArray",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Lambda was introduced as a form of pure function that can be passed on to the function Apply as a first argument.\n * The original method, passing it in as a list, had the disadvantage that the list was evaluated, which caused the\n * arguments to be evaluated too. This resulted in unwanted behaviour sometimes (expressions being prematurely evaluated\n * in the body of the pure function). The arguments to Lambda are not evaluated.\n */\nDefMacroRulebase(\"Lambda\",{args,body});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/Lambda.mpw";
        scriptMap.put("Lambda",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nTemplateFunction(\"Until\",{predicate,body})\n[\n  Eval(body);\n  While (IsEqual(Eval(predicate),False))\n  [\n    Eval(body);\n  ];\n  True;\n];\nUnFence(\"Until\",2);\nHoldArgumentNumber(\"Until\",2,1);\nHoldArgumentNumber(\"Until\",2,2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/Until.mpw";
        scriptMap.put("Until",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"else\",{ifthen,otherwise});\n\n0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) =? True) <-- Eval(body);\n\n0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) =? False) <-- Eval(otherwise);\n\n1 # (if (_predicate) _body else _otherwise) <--\n    ListToFunction({ToAtom(\"else\"),\n            ListToFunction({ToAtom(\"if\"), (Eval(predicate)), body}),\n            otherwise});\n\nHoldArgument(\"else\",ifthen);\n\nHoldArgument(\"else\",otherwise);\n\nUnFence(\"else\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/else.mpw";
        scriptMap.put("else",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"if\",{predicate,body});\n\n(if(True) _body) <-- Eval(body);\n\nHoldArgument(\"if\",body);\n\nUnFence(\"if\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/contolflow/if.mpw";
        scriptMap.put("if",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nTraceExp\nDebug\nProfile\nDebugRun\nDebugStep\nDebugStepOver\nDebugBreakAt\nDebugRemoveBreakAt\nDebugStop\nDebugVerbose\nDebugAddBreakpoint\nBreakpointsClear\nDebugCallstack\nDebugBreakIf\nDebugLocals\nEchoTime\nDebugShowCode\n*/\n\nLocalSymbols(TraceStart,TraceEnter,TraceLeave,DebugStart,DebugEnter,\n             DebugLeave,ProfileStart,ProfileEnter,result,\n             WriteLines,ClearScreenString,Debug'FileLoaded, Debug'FileLines, Debug'NrLines,\n             debugstepoverfile, debugstepoverline) [\n\nTraceStart() := [indent := 0;];\nTraceEnter() :=\n[\n    indent++;\n    Space(2*indent);\n    Echo(\"Enter \",CustomEval'Expression());\n];\nTraceLeave() :=\n[\n    Space(2*indent);\n    Echo(\"Leave \",CustomEval'Result());\n    indent--;\n];\nMacro(TraceExp,{expression})\n[\n    TraceStart();\n    CustomEval(TraceEnter(),TraceLeave(),CustomEval'Stop(),@expression);\n];\n\n\n\nDebugStart():=\n[\n   debugging:=True;\n   debugstopdepth := -1;\n   breakpoints:={};\n   filebreakpoints := {};\n   debugstopped:=False;\n   debugverbose:=False;\n   debugcallstack:={};\n   breakpredicate:=False;\n];\nDebugRun():= [debugging:=False;True;];\nDebugStep():=[debugging:=False;nextdebugging:=True;];\n\nDebugStepOver():=\n[\n  debugging:=False;\n  debugstepoverfile := DebugFile(CustomEval'Expression());\n  debugstepoverline := DebugLine(CustomEval'Expression());\n  debugstopdepth := Length(debugcallstack);\n];\nDebugBreakAt(file,line):=\n[\n  Check(InDebugMode(), \"Mode\", \"DebugBreakAt only supported in the debug build of MathPiper\");\n  If(filebreakpoints[file] =? Empty,filebreakpoints[file]:={});\n  DestructiveAppend(filebreakpoints[file],line);\n];\nDebugRemoveBreakAt(file,line):=\n[\n  Check(InDebugMode(), \"Mode\", \"DebugRemoveBreakAt only supported in the debug build of MathPiper\");\n  If(filebreakpoints[file] =? Empty,filebreakpoints[file]:={});\n  filebreakpoints[file] := Difference(filebreakpoints[file],{line});\n];\n\n\nDebugStop():=[debugging:=False;debugstopped:=True;CustomEval'Stop();];\nDebugVerbose(verbose):=[debugverbose:=verbose;];\nDebugAddBreakpoint(fname_IsString) <-- [ breakpoints := fname:breakpoints;];\nMacro(DebugBreakIf,{predicate})\n[\n  breakpredicate:= Hold(@predicate);\n];\n\nBreakpointsClear() <--\n[\n  breakpredicate:=False;\n  breakpoints := {};\n];\nMacro(DebugLocals,{})\n[\n  Echo(\"\");\n  Echo(\"*************** Current locals on the stack ****************\");\n  ForEach(item,CustomEval'Locals())\n  [\n    Echo(\"      \",item,\" : \",Eval(item));\n  ];\n  Echo(\"\");\n];\nDebugCallstack() <--\n[\n  Echo(\"\");\n  Echo(\"*************** Function call stack ****************\");\n  ForEach(item,debugcallstack)\n  [\n    if(IsFunction(item))\n      Echo(\"      Function \",Type(item),\" : \",item)\n    else\n      Echo(\"      Variable \",item);\n  ];\n  Echo(\"\");\n];\n\nMacro(DebugEnter,{})\n[\n  debugcallstack := CustomEval'Expression():debugcallstack;\n  // custom breakpoint (custom predicate thought up by the programmer)\n  If(debugging =? False And?\n      Eval(breakpredicate) =? True,\n      [\n        breakpredicate:=False;\n        debugging:=True;\n      ]);\n\n  If(debugging =? False And? InDebugMode(),\n  [\n    Local(file,line);\n    file := DebugFile(CustomEval'Expression());\n    If(filebreakpoints[file] !=? Empty,\n    [\n      line := DebugLine(CustomEval'Expression());\n      If(Not?(file =? debugstepoverfile And? line =? debugstepoverline) And?\n         Contains(filebreakpoints[file],line),\n         [\n           debugging:=True;\n         ]\n        );\n    ]);\n  ]);\n\n\n  // the standard breakpoint\n  If(debugging =? False And?\n      IsFunction(CustomEval'Expression()) And?\n      Contains(breakpoints,Type(CustomEval'Expression())),   debugging:=True);\n   nextdebugging:=False;\n   If (debugging,\n   [\n     If(InDebugMode(),DebugShowCode());\n     Echo(\">>> \",CustomEval'Expression());\n     While(debugging)\n     [\n        Echo(\"DebugResult: \",Eval(PipeFromString(ReadCmdLineString(\"Debug> \"):\";\")Read()));\n    //      If(debugging,Echo(\"DebugResult: \",debugRes));\n       If(IsExitRequested(),debugging:=False);\n     ];\n    ]);\n   debugging:=nextdebugging;\n\n   If(IsExitRequested(),debugstopped:=True);\n\n];\nMacro(DebugLeave,{})\n[\n  If(debugging =? False And? debugstopdepth >=? 0 And? Length(debugcallstack) =? debugstopdepth,\n  [\n    debugstepoverline := -1;\n    debugging := True;\n    debugstopdepth := -1;\n  ]);\n\n  debugcallstack := Rest(debugcallstack);\n  If(debugverbose,Echo(CustomEval'Result(),\" <-- \",CustomEval'Expression()));\n];\nMacro(Debug,{expression})\nPipeToStdout()\n[\n   DebugStart();\n   CustomEval(DebugEnter(),DebugLeave(),If(debugstopped,Check(False, \"Debug\", \"\"),[debugging:=True;debugcallstack := Rest(debugcallstack);]),@expression);\n];\n\n\nProfileStart():=\n[\n    profilefn:={};\n];\n10 # ProfileEnter()_(IsFunction(CustomEval'Expression())) <--\n[\n    Local(fname);\n    fname:=Type(CustomEval'Expression());\n    If(profilefn[fname]=?Empty,profilefn[fname]:=0);\n    profilefn[fname] := profilefn[fname]+1;\n];\nMacro(Profile,{expression})\n[\n    ProfileStart();\n    CustomEval(ProfileEnter(),True,CustomEval'Stop(),@expression);\n    ForEach(item,profilefn)\n      Echo(\"Function \",item[1],\" called \",item[2],\" times\");\n];\n\n/// Measure the time taken by evaluation and print results.\nMacro(EchoTime,{expression})\n[\n        Local(result);\n        Echo(Time()Bind(result, @expression), \"seconds taken.\");\n        result;\n];\n\n\n\n// ClearScreenString : the ascii escape codes to clear the screen\nClearScreenString := UnicodeToString(27):\"[2J\":UnicodeToString(27):\"[1;1H\";\n\n// WriteLines: do the actual outputting of lines of a file to screen\nWriteLines(filename,lines,from,nrlines,breakpoints,current):=\n[\n  Local(i,nr);\n  nr:=Length(lines);\n  WriteString(ClearScreenString);\n  Echo(\"File \",filename,\" at line \",current);\n  For(i:=from,i<?from+nrlines And? i<?nr,i++)\n  [\n\n    if (current =? i)\n      WriteString(\">\")\n    else\n      WriteString(\" \");\n    if (Contains(breakpoints,i))\n      WriteString(\"*\")\n    else\n      WriteString(\" \");\n    WriteString(\"| \");\n    Echo(lines[i][1]);\n  ];\n];\nDebug'FileLoaded := \"\";\nDebug'FileLines := {};\nDebug'NrLines:=20;\n\n//\n// DebugShowCode: show the part of the file we are currently executing (based on the\n// value returned by CustomEval'Expression() ).\n//\n// Currently unimplemented, should we remove?\n//\nDebugShowCode():=\n[\n  False;\n];\n\n]; //LocalSymbols\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/debug/debug.mpw";
        scriptMap.put("TraceExp",scriptString);
        scriptMap.put("Debug",scriptString);
        scriptMap.put("Profile",scriptString);
        scriptMap.put("DebugRun",scriptString);
        scriptMap.put("DebugStep",scriptString);
        scriptMap.put("DebugStepOver",scriptString);
        scriptMap.put("DebugBreakAt",scriptString);
        scriptMap.put("DebugRemoveBreakAt",scriptString);
        scriptMap.put("DebugStop",scriptString);
        scriptMap.put("DebugVerbose",scriptString);
        scriptMap.put("DebugAddBreakpoint",scriptString);
        scriptMap.put("BreakpointsClear",scriptString);
        scriptMap.put("DebugCallstack",scriptString);
        scriptMap.put("DebugBreakIf",scriptString);
        scriptMap.put("DebugLocals",scriptString);
        scriptMap.put("EchoTime",scriptString);
        scriptMap.put("DebugShowCode",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(Verbose) [\n\n  Bind(Verbose,False);\n\n\n  Function(\"V\",{aNumberBody})\n  [\n    Local(prevVerbose,result);\n    Bind(prevVerbose,Verbose);\n    Bind(Verbose,True);\n    Bind(result,Eval(aNumberBody));\n    Bind(Verbose,prevVerbose);\n    result;\n  ];\n\n\n  Function(\"InVerboseMode\",{}) Verbose;\n\n]; // LocalSymbols(Verbose)\n\nHoldArgument(\"V\",aNumberBody);\nUnFence(\"V\",1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/debug/verbose_mode.mpw";
        scriptMap.put("V",scriptString);
        scriptMap.put("InVerboseMode",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Set of functions to define very simple functions. There are scripts that can\n   be compiled to plugins. So MathPiper either loads the plugin, or loads the\n   scripts at this point. The functions in these plugins need to be defined with\n   these \"Defun\" functions.\n */\nDefMacroRulebase(\"Defun\",{func,args,body});\nRule(\"Defun\",3,0,True)\n[\n  Local(nrargs);\n  Bind(nrargs,Length(@args));\n  Retract(@func, `(@nrargs));\n  Rulebase(@func,@args);\n  Local(fn,bd);\n  Bind(fn,Hold(@func)); Bind(bd,Hold(@body));\n  `Rule(@fn, @nrargs, 0,True)(@bd);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/Defun.mpw";
        scriptMap.put("Defun",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Defining a macro-like function that declares a function\n * with only one rule.\n */\nRulebase(\"Function\",{oper,args,body});\n\n\n\n// function with variable number of arguments: Function(\"func\",{x,y, ...})body;\nRule(\"Function\",3,2047,\n        And?(IsGreaterThan(Length(args), 1), IsEqual( MathNth(args, Length(args)), ToAtom(\"...\") ))\n)\n[\n  DestructiveDelete(args,Length(args));        // remove trailing \"...\"\n  Retract(oper,Length(args));\n  MacroRulebaseListed(oper,args);\n  MacroRule(oper,Length(args),1025,True) body;        // at precedence 1025, for flexibility\n];\n\n// function with a fixed number of arguments\nRule(\"Function\",3,2048,True)\n[\n  Retract(oper,Length(args));\n  MacroRulebase(oper,args);\n  MacroRule(oper,Length(args),1025,True) body;\n];\n\n\n/// shorthand function declarations\nRulebase(\"Function\",{oper});\n// function with variable number of arguments: Function() f(x,y, ...)\nRule(\"Function\",1,2047,\n        And?(IsFunction(oper), IsGreaterThan(Length(oper), 1), IsEqual( MathNth(oper, Length(oper)), ToAtom(\"...\") ))\n)\n[\n        Local(args);\n        Bind(args,Rest(FunctionToList(oper)));\n        DestructiveDelete(args,Length(args));        // remove trailing \"...\"\n        If(RulebaseDefined(Type(oper),Length(args)),\n                False,        // do nothing\n                MacroRulebaseListed(Type(oper),args)\n        );\n];\n\n\n// function with a fixed number of arguments\nRule(\"Function\",1,2048,\n        And?(IsFunction(oper))\n)\n[\n        Local(args);\n        Bind(args,Rest(FunctionToList(oper)));\n        If(RulebaseDefined(Type(oper),Length(args)),\n                False,        // do nothing\n                MacroRulebase(Type(oper),args)\n        );\n];\n\n\nHoldArgument(\"Function\",oper);\nHoldArgument(\"Function\",args);\nHoldArgument(\"Function\",body);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/Function.mpw";
        scriptMap.put("Function",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"HoldArgumentNumber\",{function,arity,index})\n[\n  Local(args);\n  args:=RulebaseArgumentsList(function,arity);\n/* Echo({\"holdnr \",args}); */\n  ApplyFast(\"HoldArgument\",{function,args[index]});\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/HoldArgumentNumber.mpw";
        scriptMap.put("HoldArgumentNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Macro\",{oper,args,body});\nHoldArgument(\"Macro\",oper);\nHoldArgument(\"Macro\",args);\nHoldArgument(\"Macro\",body);\n\n// macro with variable number of arguments: Macro(\"func\",{x,y, ...})body;\nRule(\"Macro\",3,2047,\n        And?(IsGreaterThan(Length(args), 1), IsEqual( MathNth(args, Length(args)), ToAtom(\"...\") ))\n)\n[\n  DestructiveDelete(args,Length(args));        // remove trailing \"...\"\n  Retract(oper,Length(args));\n  `DefMacroRulebaseListed(@oper,@args);\n  MacroRule(oper,Length(args),1025,True) body;        // at precedence 1025, for flexibility\n];\n\n// macro with a fixed number of arguments\nRule(\"Macro\",3,2048,True)\n[\n  Retract(oper,Length(args));\n  `DefMacroRulebase(@oper,@args);\n  MacroRule(oper,Length(args),1025,True) body;\n];\n\nRulebase(\"Macro\",{oper});\n// macro with variable number of arguments: Macro() f(x,y, ...)\nRule(\"Macro\",1,2047,\n        And?(IsFunction(oper), IsGreaterThan(Length(oper), 1), IsEqual( MathNth(oper, Length(oper)), ToAtom(\"...\") ))\n)\n[\n        Local(args,name);\n        Bind(args,Rest(FunctionToList(oper)));\n        DestructiveDelete(args,Length(args));        // remove trailing \"...\"\n  Bind(name,Type(oper));\n        If(RulebaseDefined(Type(oper),Length(args)),\n                False,        // do nothing\n                `DefMacroRulebaseListed(@name,@args)\n        );\n];\n// macro with a fixed number of arguments\nRule(\"Macro\",1,2048,\n        And?(IsFunction(oper))\n)\n[\n        Local(args,name);\n        Bind(args,Rest(FunctionToList(oper)));\n  Bind(name,Type(oper));\n        If(RulebaseDefined(Type(oper),Length(args)),\n                False,        // do nothing\n                [\n      `DefMacroRulebase(@name,@args);\n    ]\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/Macro.mpw";
        scriptMap.put("Macro",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"TemplateFunction\",{oper,args,body});\n\nHoldArgument(\"TemplateFunction\",oper);\n\nHoldArgument(\"TemplateFunction\",args);\n\nHoldArgument(\"TemplateFunction\",body);\n\nRule(\"TemplateFunction\",3,2047,True)\n[\n  Retract(oper,Length(args));\n  Local(arglist);\n  arglist:=FlatCopy(args);\n\n  DestructiveAppend(arglist,{args,ListToFunction({Hold,body})});\n  arglist:=ApplyFast(\"LocalSymbols\",arglist);\n\n  MacroRulebase(oper,arglist[1]);\n  MacroRule(oper,Length(args),1025,True) arglist[2];\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/TemplateFunction.mpw";
        scriptMap.put("TemplateFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\nRulebase(\"Unholdable\",{var});\n\nHoldArgument(\"Unholdable\",var);\n\nUnFence(\"Unholdable\",1);\n\nRule(\"Unholdable\",1,10,IsEqual(Type(Eval(var)),\"Eval\"))\n[\n    MacroBind(var,Eval(Eval(var)));\n    //Echo({\"unheld\",var,Eval(var)});\n];\n\n\nRule(\"Unholdable\",1,20,True)\n[\n    //Echo({\"held\"});\n  True;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/Unholdable.mpw";
        scriptMap.put("Unholdable",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* := assignment. */\nRulebase(\":=\",{aLeftAssign,aRightAssign});\nUnFence(\":=\",2);\nHoldArgument(\":=\",aLeftAssign);\nHoldArgument(\":=\",aRightAssign);\n\n/* := assignment. */\n// assign a variable\nRule(\":=\",2,0,IsAtom(aLeftAssign))\n[\n  Check( Not? IsNumber(aLeftAssign), \"Argument\", \"Only a variable can be placed on the left side of an := operator.\" );\n\n  MacroBind(aLeftAssign,Eval(aRightAssign));\n\n  Eval(aLeftAssign);\n];\n\n\n\n// assign lists\nRule(\":=\",2,0,IsList(aLeftAssign))\n[\n  Map(\":=\",{aLeftAssign,Eval(aRightAssign)});\n];\n\n// auxiliary function to help assign arrays using :=\nRulebase(\"AssignArray\",{setlistterm,setlistindex,setlistresult});\nUnFence(\"AssignArray\",3);\nRule(\"AssignArray\",3,1,IsString(setlistindex))\n[\n  Local(item);\n  item:=Assoc(setlistindex,setlistterm);\n  If(item =? Empty,\n     DestructiveInsert(setlistterm,1,{setlistindex,setlistresult}),\n     DestructiveReplace(item,2,setlistresult)\n     );\n  True;\n];\n// assign generic arrays\nRule(\"AssignArray\",3,1,\n   And?(\n           IsEqual(IsGeneric(setlistterm),True),\n           IsEqual(GenericTypeName(setlistterm),\"Array\")\n          )\n    )\n[\n  ArraySet(setlistterm,setlistindex,setlistresult);\n];\n\n\nRule(\"AssignArray\",3,2,True)\n[\n  DestructiveReplace(setlistterm ,setlistindex, setlistresult);\n  True;\n];\n\n// a[x] := ... assigns to an array element\nRule(\":=\",2,10,IsFunction(aLeftAssign) And? (First(FunctionToList(aLeftAssign)) =? Nth))\n[\n Local(frst,scnd);\n\n Local(lst);\n Bind(lst,(FunctionToList(aLeftAssign)));\n Bind(lst,Rest(lst));\n Bind(frst, Eval(First(lst)));\n Bind(lst,Rest(lst));\n Bind(scnd, Eval(First(lst)));\n\n AssignArray(frst,scnd,Eval(aRightAssign));\n];\n\n// f(x):=... defines a new function\nRule(\":=\",2,30,IsFunction(aLeftAssign) And? Not?(IsEqual(aLeftAssign[0], ToAtom(\":=\"))) )\n[\n  Check( Not? IsEqual(aLeftAssign[0], ToAtom(\"/\")), \"Argument\", \"Only a variable can be placed on the left side of an := operator.\" );\n\n  Local(oper,args,arity);\n  Bind(oper,ToString(aLeftAssign[0]));\n  Bind(args,Rest(FunctionToList(aLeftAssign)));\n  If(\n        And?(IsGreaterThan(Length(args), 1), IsEqual( MathNth(args, Length(args)), ToAtom(\"...\") )),\n        // function with variable number of arguments\n        [\n          DestructiveDelete(args,Length(args));        // remove trailing \"...\"\n          Bind(arity,Length(args));\n          Retract(oper,arity);\n          MacroRulebaseListed(oper, args);\n        ],\n        // function with a fixed number of arguments\n        [\n          Bind(arity,Length(args));\n          Retract(oper,arity);\n          MacroRulebase(oper, args);\n        ]\n  );\n  Unholdable(aRightAssign);\n  MacroRule(oper,arity,1025,True) aRightAssign;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deffunc/colon_equals_operator.mpw";
        scriptMap.put(":=",scriptString);
        scriptMap.put("AssignArray",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Curl\", {aFunc, aBasis});\n\nRule(\"Curl\", 2, 1, Length(aBasis)=?Length(aFunc))\n        {\n                Apply(\"Differentiate\",{aBasis[2],aFunc[3]})-Apply(\"Differentiate\",{aBasis[3],aFunc[2]}),\n                Apply(\"Differentiate\",{aBasis[3],aFunc[1]})-Apply(\"Differentiate\",{aBasis[1],aFunc[3]}),\n                Apply(\"Differentiate\",{aBasis[1],aFunc[2]})-Apply(\"Differentiate\",{aBasis[2],aFunc[1]})\n        };\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deriv/Curl.mpw";
        scriptMap.put("Curl",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n5 # (Deriv(_var,1)_func) <-- Deriv(var)func;\n5 # (Deriv(_var,0)_func) <-- func;\n10 # (Deriv(_var,n_IsPositiveInteger)_func) <-- Deriv(var)Deriv(var,n-1)func;\n10 # (Deriv(_var,n_IsNegativeInteger)_func) <-- Check(0, \"Math\", \"Negative derivative\");\n\n\n// Need to clean out Sec(x) and friends\n0 # (Deriv(_var) (_var)) <-- 1;\n1 # (Deriv(_var)func_IsAtom) <-- 0;\n2 # (Deriv(_var)_x + _y) <--  (Deriv(var)x) + (Deriv(var)y);\n2 # (Deriv(_var)- (_x) ) <-- -Deriv(var)x;\n2 # (Deriv(_var)_x - _y) <--  (Deriv(var)x) - (Deriv(var)y);\n2 # (Deriv(_var)_x * _y) <-- (x*Deriv(var)y) + (Deriv(var)x)*y;\n2 # (Deriv(_var)Sin(_x)) <--  (Deriv(var)x)*Cos(x);\n2 # (Deriv(_var)Sinh(_x))<--  (Deriv(var)x)*Cosh(x);\n2 # (Deriv(_var)Cosh(_x))<--  (Deriv(var)x)*Sinh(x);\n2 # (Deriv(_var)Cos(_x)) <-- -(Deriv(var)x)*Sin(x);\n2 # (Deriv(_var)Csc(_x)) <--  -(Deriv(var)x)*Csc(x)*Cot(x);\n2 # (Deriv(_var)Csch(_x)) <-- -(Deriv(var)x)*Csch(x)*Coth(x);\n2 # (Deriv(_var)Sec(_x)) <--  (Deriv(var)x)*Sec(x)*Tan(x);\n2 # (Deriv(_var)Sech(_x)) <-- -(Deriv(var)x)*Sech(x)*Tanh(x);\n2 # (Deriv(_var)Cot(_x)) <--  -(Deriv(var)x)*Csc(x)^2;\n2 # (Deriv(_var)Coth(_x)) <--  (Deriv(var)x)*Csch(x)^2;\n\n2 # (Deriv(_var)Tan(_x)) <-- ((Deriv(var) x) / (Cos(x)^2));\n2 # (Deriv(_var)Tanh(_x)) <-- (Deriv(var)x)*Sech(x)^2;\n\n2 # (Deriv(_var)Exp(_x)) <--  (Deriv(var)x)*Exp(x);\n\n// When dividing by a constant, this is faster\n2 # (Deriv(_var)(_x / _y))_(IsFreeOf(var,y)) <-- (Deriv(var) x) / y;\n3 # (Deriv(_var)(_x / _y)) <--\n    (y* (Deriv(var) x) - x* (Deriv(var) y))/ (y^2);\n\n2 # (Deriv(_var)Ln(_x)) <-- ((Deriv(var) x) / x);\n2 # (Deriv(_var)(_x ^ _n))_(IsRationalOrNumber(n) Or? IsFreeOf(var, n)) <--\n    n * (Deriv(var) x) * (x ^ (n - 1));\n\n//2 # (Deriv(_var)(Abs(_x)))  <-- Sign(x)*(Deriv(var)x);\n2 # (Deriv(_var)(Abs(_x)))  <-- (x/Abs(x))*(Deriv(var)x);\n2 # (Deriv(_var)(Sign(_x))) <-- 0;\n\n2 # (Deriv(_var)(if(_cond)(_body))) <--\n        ListToFunction({ToAtom(\"if\"),cond,Deriv(var)body});\n2 # (Deriv(_var)((_left) else (_right))) <--\n        ListToFunction({ToAtom(\"else\"), (Deriv(var)left), (Deriv(var)right) } );\n\n3 # (Deriv(_var)(_x ^ _n)) <-- (x^n)*Deriv(var)(n*Ln(x));\n\n2 # (Deriv(_var)ArcSin(_x)) <-- (Deriv(var) x)/Sqrt(1 - (x^2));\n2 # (Deriv(_var)ArcCos(_x)) <-- -(Deriv(var)x)/Sqrt(1 - (x^2));\n2 # (Deriv(_var)ArcTan(_x)) <-- (Deriv(var) x)/(1 + x^2);\n\n2 # (Deriv(_var)ArcSinh(_x)) <-- (Deriv(var) x)/Sqrt((x^2) + 1);\n2 # (Deriv(_var)ArcCosh(_x)) <-- (Deriv(var) x)/Sqrt((x^2) - 1);\n2 # (Deriv(_var)ArcTanh(_x)) <-- (Deriv(var) x)/(1 - x^2);\n\n2 # (Deriv(_var)Sqrt(_x)) <-- ((Deriv(var)x)/(2*Sqrt(x)));\n2 # (Deriv(_var)Complex(_r,_i)) <-- Complex(Deriv(var)r,Deriv(var)i);\n\nLocalSymbols(var,var2,a,b,y)[\n   2 # (Deriv(_var)Integrate(_var)(_y)) <-- y;\n   2 # (Deriv(_var)Integrate(_var2,_a,_b)(y_IsFreeOf(var))) <--\n         (Deriv(var)b)*(y Where var2 == b) -\n         (Deriv(var)a)*(y Where var2 == a);\n   3 # (Deriv(_var)Integrate(_var2,_a,_b)(_y)) <--\n         (Deriv(var)b)*(y Where var2 == b) -\n         (Deriv(var)a)*(y Where var2 == a) +\n         Integrate(var2,a,b) Deriv(var) y;\n ];\n\n\n\n2 # (Deriv(_var)func_IsList)_(Not?(IsList(var))) <--\n    Map(\"Deriv\",{FillList(var,Length(func)),func});\n\n\n2 # (Deriv(_var)UniVariate(_var,_first,_coefs)) <--\n[\n  Local(result,m,i);\n  result:=FlatCopy(coefs);\n  m:=Length(result);\n  For(i:=1,i<=?m,i++)\n  [\n    result[i] := result[i] * (first+i-1);\n  ];\n  UniVariate(var,first-1,result);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deriv/Deriv.mpw";
        scriptMap.put("Deriv",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Differentiate\",{aVar,aFunc});\nRulebase(\"Differentiate\",{aVar,aCount,aFunc});\n\nRule(\"Differentiate\",2,1,IsList(aVar) And? Not?(IsList(aFunc)))\n        Map(\"Differentiate\",{aVar,FillList(aFunc, Length(aVar))});\nRule(\"Differentiate\",2,1,IsList(aVar) And? IsList(aFunc))\n        Map(\"Differentiate\",{aVar,aFunc});\n\nRule(\"Differentiate\",2,3,True)\n[\n  MacroLocal(aVar);\n  Apply(\"Deriv\",{aVar,1,aFunc});\n];\n\nRule(\"Differentiate\",3,1,IsList(aVar) And? Not?(IsList(aFunc)))\n        Map(\"Differentiate\",{aVar,\n                 FillList(aCount, Length(aVar)),\n                 FillList(aFunc, Length(aVar))});\nRule(\"Differentiate\",3,1,IsList(aVar) And? IsList(aFunc))\n        Map(\"Differentiate\",{aVar,\n                 FillList(aCount, Length(aVar)),\n                 aFunc});\nRule(\"Differentiate\",3,3,True)\n[\n  MacroLocal(aVar);\n  Apply(\"Deriv\",{aVar,aCount,aFunc});\n];\n\n\nHoldArgument(\"Differentiate\",aVar);\nHoldArgument(\"Differentiate\",aFunc);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deriv/Differentiate.mpw";
        scriptMap.put("Differentiate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Diverge\", {aFunc, aBasis});\nRule(\"Diverge\", 2, 1, IsList(aBasis) And? IsList(aFunc) And? Length(aBasis) =? Length(aFunc))\n        Add(Map(\"Differentiate\", {aBasis,aFunc}));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/deriv/Diverge.mpw";
        scriptMap.put("Diverge",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nEquationLeft(_symbolicEquation)_(Type(symbolicEquation) =? \"==\")  <--\n[\n    Local(listForm);\n    \n    listForm := FunctionToList(symbolicEquation);\n    \n    listForm[2];\n];\n";
        scriptString[2] = "/org/mathpiper/scripts4/equations/EquationLeft.mpw";
        scriptMap.put("EquationLeft",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nEquationRight(_symbolicEquation)_(Type(symbolicEquation) =? \"==\")  <--\n[\n    Local(listForm);\n    \n    listForm := FunctionToList(symbolicEquation);\n    \n    listForm[3];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/equations/EquationRight.mpw";
        scriptMap.put("EquationRight",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(lastcoef,OrdBuild, AddFoundSolutionSingle , AddFoundSolution, Fct, MkfactD,p)\n[\n\nLastCoef(_vector,_p) <--\n[\n  Local(n);\n  n:=Length(vector);\n  Add(vector*p^(0 .. (n-1)));\n];\n\n/*\nOrd(vector,q):=\n[\n  Local(n);\n  n:=Length(vector);\n  q*Coef(Simplify(LastCoef(vector,p+q)-LastCoef(vector,p)),q,1);\n];\n*/\n\nOrdBuild(vector,q):=\n[\n  Local(i,result,n);\n  Bind(i,2);\n  Bind(result, 0);\n  Bind(n, Length(vector));\n  While (i<=?n)\n  [\n    Bind(result,result+(i-1)*vector[i]*p^(i-2));\n    Bind(i, i+2);\n  ];\n  q*result;\n];\n\n\nFunction(AddFoundSolutionSingle,{p})\n[\n  Local(calc);\n//  If ( Not? Contains(result,p),\n//  [\n    Bind(calc, Eval(lastcoef));\n    If (IsEqual(calc, 0),\n    [\n      Local(newlist,count,root);\n      count:=0;\n      root := p;\n      Local(rem);\n\n      rem:={-root,1};\n      {testpoly,rem}:=MkfactD(testpoly,rem);\n\n      rem:={-root,1};\n      {newlist,rem}:=MkfactD(poly,rem);\n      While (rem =? {})\n      [\n        count++;\n        Bind(poly,newlist);\n        rem:={-root,1};\n        {newlist,rem}:=MkfactD(poly,rem);\n      ];\n\n      Local(lgcd,lc);\n      Bind(lgcd,Gcd({andiv,an,root}));\n      Bind(lc,Quotient(an,lgcd));\n      Bind(result,{var+ (-(Quotient(root,lgcd)/lc)),count}:result);\n      Bind(andiv,Quotient(andiv,lgcd^count));\n      Bind(anmul,anmul*lc^count);\n\n//      factor:=(x-root);\n//      Bind(result,{factor,count}:result);\n\n      Local(p,q);\n      Bind(lastcoef, LastCoef(testpoly,p));\n      Bind(ord, OrdBuild(testpoly,q));\n    ]);\n//  ]);\n];\nUnFence(AddFoundSolutionSingle,1);\n\nFunction(AddFoundSolution,{p})\n[\n  AddFoundSolutionSingle(p);\n  AddFoundSolutionSingle(-2*q+p);\n];\nUnFence(AddFoundSolution,1);\n\nFunction(Fct,{poly,var})\n[\n  Local(maxNrRoots,result,ord,p,q,accu,calc,twoq,mask);\n\n  Local(gcd);\n  [\n    Bind(gcd,Gcd(poly));\n    If(poly[Length(poly)] <? 0,Bind(gcd, gcd * -1));\n    Bind(poly,poly/gcd);\n  ];\n\n  Local(unrat);\n  Bind(unrat,Lcm(MapSingle(\"Denominator\",poly)));\n  Bind(poly,unrat*poly);\n\n  Local(origdegree);\n  Bind(origdegree,Length(poly)-1);\n\n  Local(an,andiv,anmul);\n  Bind(an,poly[Length(poly)]);\n  Bind(poly,poly* (an^((origdegree-1) .. -1)));\n  Bind(andiv,an^(origdegree-1));\n  Bind(anmul,1);\n\n  Local(leadingcoef,lowestcoef);\n  Bind(leadingcoef,poly[Length(poly)]);\n  [\n    Local(i);\n    Bind(i,1);\n    Bind(lowestcoef,Abs(poly[i]));\n    While (lowestcoef =? 0 And? i<=?Length(poly))\n    [\n      Bind(i,i+1);\n      Bind(lowestcoef,Abs(poly[i]));\n    ];\n  ];\n  // testpoly is the square-free version of the polynomial, used for finding\n  // the factors. the original polynomials is kept around to find the\n  // multiplicity of the factor.\n  Local(testpoly);\n//  Bind(testpoly,Mkc(Quotient(polynom,Monic(Gcd(polynom,Deriv(var)polynom))),var));\n  Local(deriv);\n  // First determine a derivative of the original polynomial\n  deriv:=Rest(poly);\n  [\n    Local(i);\n    For (i:=1,i<=?Length(deriv),i++)\n    [\n      deriv[i] := deriv[i]*i;\n    ];\n//    Echo(\"POLY = \",poly);\n//    Echo(\"DERIV = \",deriv);\n  ];\n  [\n    Local(q,r,next);\n    q:=poly;\n    r:=deriv;\n    While(r !=? {})\n    [\n//Echo(q,r);\n      next := MkfactD(q,r)[2];\n      q:=r;\n      r:=next;\n    ];\n    // now q is the gcd of the polynomial and its first derivative.\n\n    // Make it monic\n    q:=q/q[Length(q)];\n    testpoly:=MkfactD(poly,q)[1];\n//Echo(\"TESTPOLY = \",testpoly);\n  ];\n\n//  Bind(testpoly,poly); //@@@\n\n  Bind(maxNrRoots,Length(testpoly)-1);\n  Bind(result, {});\n\n  Bind(lastcoef, LastCoef(testpoly,p));\n  Bind(ord, OrdBuild(testpoly,q));\n\n  Bind(accu,{});\n  Bind(q,1);\n  Bind(twoq,MultiplyN(q,2));\n  Bind(mask,AddN(twoq,MathNegate(1)));\n  if (IsEven(testpoly[1]))\n  [\n    Bind(accu,0:accu);\n    AddFoundSolutionSingle(0);\n  ];\n  Bind(p,1);\n  Bind(calc, Eval(lastcoef));\n  If (IsEven(calc),\n  [\n    Bind(accu,1:accu);\n    AddFoundSolution(1);\n  ]);\n  Bind(q,twoq);\n  Bind(twoq,MultiplyN(q,2));\n  Bind(mask,AddN(twoq,MathNegate(1)));\n  While(Length(result)<?maxNrRoots And? Length(accu)>?0 And? q<=?Abs(testpoly[1]))\n  [\n    Local(newaccu);\n    Bind(newaccu,{});\n    ForEach(p,accu)\n    [\n      Bind(calc,Eval(lastcoef));\n      If (IsLessThan(calc,0),\n        Bind(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))\n         );\n      Bind(calc, BitAnd(calc, mask));\n      If ( IsEqual(calc, 0),\n      [\n        Bind(newaccu, p:newaccu);\n        AddFoundSolutionSingle(-2*q+p);\n      ]);\n      Bind(calc, AddN(calc, Eval(ord)));\n      If (IsLessThan(calc,0),\n        Bind(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))\n         );\n      Bind(calc, BitAnd(calc, mask));\n      If ( IsEqual(calc, 0),\n      [\n        Bind(newaccu, AddN(p,q):newaccu);\n        AddFoundSolution(AddN(p,q));\n      ]);\n    ];\n    Bind(accu, newaccu);\n    Bind(q,twoq);\n    Bind(twoq,MultiplyN(q,2));\n    Bind(mask,AddN(twoq,MathNegate(1)));\n\n//Echo(\"q = \",q);\n//Echo(\"Length is\",Length(accu),\"accu = \",accu);\n//Echo(\"result = \",result);\n  ];\n\n  // If the polynom is not one, it is a polynomial which is not reducible any further\n  // with this algorithm, return as is.\n  Bind(poly,poly*an^(0 .. (Length(poly)-1)));\n  Bind(poly,gcd*anmul*poly);\n  //TODO had to add this if statement, what was andiv again, and why would it become zero? This happens with for example Factor(2*x^2)\n  If(Not? IsZero(unrat * andiv ),Bind(poly,poly/(unrat * andiv )));\n  If(poly !=? {1},\n  [\n    result:={(Add(poly*var^(0 .. (Length(poly)-1)))),1}:result;\n  ]);\n  result;\n];\n\n\n\nBinaryFactors(expr):=\n[\n  Local(result,uni,coefs);\n  uni:=MakeUni(expr,VarList(expr)[1]);\n  uni:=FunctionToList(uni);\n  coefs:=uni[4];\n  coefs:=Concat(ZeroVector(uni[3]),coefs);\n  result:=Fct(coefs,uni[2]);\n//  Echo(result,list);\n//  Echo((Add(list*x^(0 .. (Length(list)-1)))));\n//  Product(x-result)*(Add(list*x^(0 .. (Length(list)-1))));\n  result;\n];\n\n\n\nMkfactD(numer,denom):=\n[\n  Local(q,r,i,j,ln,ld,nq);\n  DropEndZeroes(numer);\n  DropEndZeroes(denom);\n  Bind(numer,Reverse(numer));\n  Bind(denom,Reverse(denom));\n  Bind(ln,Length(numer));\n  Bind(ld,Length(denom));\n  Bind(q,FillList(0,ln));\n  Bind(r,FillList(0,ln));\n\n  Bind(i,1);\n  If(ld>?0,\n  [\n    While(Length(numer)>=?Length(denom))\n    [\n      Bind(nq,numer[1]/denom[1]);\n      q[ln-(Length(numer)-ld)] := nq;\n      For(j:=1,j<=?Length(denom),j++)\n      [\n        numer[j] := (numer[j] - nq*denom[j]);\n      ];\n      r[i] := r[1] + numer[1];\n\n      Bind(numer, Rest(numer));\n      i++;\n    ];\n  ]);\n  For(j:=0,j<?Length(numer),j++)\n  [\n    r[i+j] := r[i+j] + numer[j+1];\n  ];\n  Bind(q,Reverse(q));\n  Bind(r,Reverse(r));\n  DropEndZeroes(q);\n  DropEndZeroes(r);\n  {q,r};\n];\n\n]; //LocalSymbols\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/BinaryFactors.mpw";
        scriptMap.put("BinaryFactors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* FW: pass FW the result of Factors, and it will show it in the\n * form of p0^n0*p1^n1*...\n */\n\n\n5  # FW(_list)_(Length(list) =? 0) <-- 1;\n10 # FW(_list)_(Length(list) =? 1) <-- FWatom(list[1]);\n20 # FW(_list) <--\n[\n  Local(result);\n  result:=FWatom(First(list));\n  ForEach(item,Rest(list))\n  [\n   result := ListToFunction({ ToAtom(\"*\"),result,FWatom(item)});\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FW.mpw";
        scriptMap.put("FW",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # FWatom({_a,1}) <-- a;\n20 # FWatom({_a,_n}) <-- ListToFunction({ToAtom(\"^\"),a, n});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FWatom.mpw";
        scriptMap.put("FWatom",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"FactorCancel\",*);\n\n10 # FactorCancel( p_IsRational ) <-- Factor(p);\n\n15 # FactorCancel( p_IsRationalFunction ) <--\n[\n    If(InVerboseMode(),Tell(FactorCancel,p));\n    Local(pp,ff,n,d,fn,fd,f,tnu,newn,newd,s,k);\n    pp   := Simplify(p);\n    If(InVerboseMode(),Tell(\"  \",pp));\n    ff   := Factors(pp);\n    If(InVerboseMode(),Tell(\"  \",ff));\n    tnu  := {ff[1]};\n    If(IsListOfLists(ff), tnu  := RemoveDuplicates(Transpose(ff)[1]));\n    newn := {};\n    newd := {};\n    If(InVerboseMode(),Tell(\"      \",tnu));\n    ForEach(f,tnu)\n    [\n       s := Select(ff,Lambda({X},X[1]=?f));\n       If(InVerboseMode(),Tell(\"      \",{f,s}));\n       If( s !=? {},\n         [\n            k := Sum(Transpose(s)[2]);\n            If(InVerboseMode(),Tell(\"      \",{s,k}));\n            If( k >? 0, DestructiveAppend(newn,{f,k}) );\n            If( k <? 0, DestructiveAppend(newd,{f,-k}) );\n         ],\n         [\n            k := 1;\n            DestructiveAppend(newn,{f,k});\n         ]\n       );\n    ];\n    If(InVerboseMode(),Tell(\"    \",{newn,newd}));\n    FW(newn)/FW(newd);\n];\n\n20 # FactorCancel( _p ) <-- Factor(p);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorCancel.mpw";
        scriptMap.put("FactorCancel",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  numbers\n\n// The bud of an Quadratic Seive algorithm\n// congruence solving code must be written first\nFunction(\"FactorQS\",{n})[\n        Local(x,k,fb,j);\n        // optimal number of primes in factor base\n        // according to Fundamental Number Theory with Applications - Mollin, p130\n        k:=Round(N(Sqrt(Exp(Sqrt(Ln(n)*Ln(Ln(n)))))));\n        fb:=ZeroVector(k);\n        For(j:=1,j<=?k,j++)[\n                fb[j]:=NextPrime(j);\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorQS.mpw";
        scriptMap.put("FactorQS",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  numbers\n\n/// Middle level function: returns a list of prime factors and their powers.\n/// E.g. FactorizeInt(50) returns {{2, 1}, {5, 2}}.\n1# FactorizeInt(0) <-- {};\n1# FactorizeInt(1) <-- {};\n\n3# FactorizeInt(n_IsInteger) <--\n[\n  Local(small'powers);\n  n := Abs(n);        // just in case we are given a negative number\n  // first, find powers of 2, 3, ..., p with p=257 currently -- this speeds up PollardRho and should avoids its worst-case performance\n  // do a quick check first - this will save us time especially if we want to move 257 up a lot\n  If(\n          Gcd(ProductPrimesTo257(), n) >? 1,        // if this is > 1, we need to separate some factors. Gcd() is very fast\n        small'powers := TrialFactorize(n, 257),        // value is {n1, {p1,q1}, {p2,q2}, ...} and n1=1 if completely factorized into these factors, and the remainder otherwise\n        small'powers := {n}        // pretend we had run TrialFactorize without success\n  );\n  n := small'powers[1];        // remainder\n  If(n=?1, Rest(small'powers),\n  // if n!=?1, need to factorize the remainder with Pollard Rho algorithm\n          [\n                  //If(InVerboseMode(), Echo({\"FactorizeInt: Info: remaining number \", n}));\n                SortFactorList(\n                    PollardCombineLists(Rest(small'powers), PollardRhoFactorize(n))\n                );\n          ]\n  );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorizeInt.mpw";
        scriptMap.put("FactorizeInt",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"FactorsBinomials\",*);\n\n10 # FactorsBinomials( _x + y_IsFreeOf(x) ) <-- {x+y,1};\n\n10 # FactorsBinomials( _x - y_IsFreeOf(x) ) <-- {x-y,1};\n\n10 # FactorsBinomials( c_IsConstant * _x + y_IsFreeOf(x) ) <-- {c*x+y,1};\n\n10 # FactorsBinomials( c_IsConstant * _x - y_IsFreeOf(x) ) <-- {c*x-y,1};\n\n10 # FactorsBinomials( _x^m_IsOdd + _y ) <--\n[\n    If(InVerboseMode(),Tell(\"FactorsBinomialssum\",{x,m,y}));\n    Local(nn,qq, r);\n    nn := (m-1)/2;\n    qq := (y^(1/m));\n    If(InVerboseMode(),Tell(\"  FBinsum1\",{nn,qq}));\n    r := {{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}};\n];\n\n\n12 # FactorsBinomials( c_IsConstant * _x^m_IsOdd + _y ) <--\n[\n    If(InVerboseMode(),Tell(\"FactorsBinomialssum\",{c,x,m,y}));\n    Local(nn,qq, r);\n    nn := (m-1)/2;\n    qq := ((y/c)^(1/m));\n    If(InVerboseMode(),Tell(\"  FBinsum.1b\",{nn,qq}));\n    If( c=?1,\n          r := {{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}},\n          r := {{c,1},{x+qq,1},{Sum(k,0,m-1,(-1)^k*qq^k*x^(m-1-k)),1}}\n    );  \n];\n\n\n10 # FactorsBinomials( _x^m_IsInteger - _y ) <--\n[\n    If(InVerboseMode(),Tell(\"FactorsBinomialsdif\",{x,m,y}));\n    Local(pp,qq,r,L);\n    pp := m-1;\n    qq := (y^(1/m));\n    If(IsNumber(y),qq:=GuessRational(N(qq)));\n    If(InVerboseMode(),Tell(\"  FBindif.1\",{pp,qq}));\n    \n    if      (m =? 2)\n        [\n            L := FunctionToList(y);\n            If(And?(L[1]=?ToAtom(\"^\"),L[3]=?2),qq:=L[2]);\n            r := {{x+qq,1},{x-qq,1}};\n        ]\n    else if (m =? 4)\n        [r := {{x+qq,1},{x-qq,1},{x^2+qq^2,1}};]\n    else if (m =? 6)\n        [r := {{x+qq,1},{x-qq,1},{x^2+x*qq+qq^2,1},{x^2-x*qq+qq^2,1}};]\n    else\n        [r := {{x-qq,1},{Sum(k,0,pp,qq^k*x^(pp-k)),1}};];\n    r;\n];\n\n\n12 # xFactorsBinomials( c_IsConstant * _x^m_IsInteger - _y ) <--\n[\n    If(InVerboseMode(),Tell(\"FactorsBinomialsdif\",{c,x,m,y}));\n    Local(aa,bb,c0,r);\n    aa := c^(1/m);\n    bb := ((y)^(1/m));\n    If(IsNumber(y),bb:=GuessRational(N(bb)));\n    If(InVerboseMode(),Tell(\"  FBindif.1b\",{aa,bb}));\n    r  := FactorsBinomials( (aa*x)^m - bb^m );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorsBinomials.mpw";
        scriptMap.put("FactorsBinomials",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"FactorsMonomial\",*);\n\n10 # FactorsMonomial(expr_IsMonomial) <--\n[\n  If(InVerboseMode(),Tell(\"FactorsMonomial\",expr));\n  Local(den,num,Ns,flat,prod,quot,result,f,ff);\n  If( IsRationalFunction(expr),\n    [\n      den := Denominator(expr);\n      num := Flatten(Numerator(expr),\"*\");\n    ],\n    [\n      den := 1;\n      num := Flatten(expr,\"*\");\n    ]\n  );\n  If(InVerboseMode(),Tell(\"     \",{num,den}));\n  Ns  := Select(num, \"IsComplex\");\n  If(InVerboseMode(),Tell(\"     \",Ns));\n  If( Ns =? {},\n       If( den !=? 1, DestructiveInsert(num,1,1/den)),\n       DestructiveReplace(num,Find(num,Ns[1]),Ns[1]/den)\n  );\n  If(InVerboseMode(),Tell(\"     \",num));\n  result := {};\n  ForEach(f,num)\n  [\n      If( IsComplex(f), \n          DestructiveAppend(result,{(f),1}),\n          If( IsAtom(f),\n              DestructiveAppend(result,{f,1}),\n              DestructiveAppend(result,DestructiveDelete(FunctionToList(f),1))\n          )\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorsMonomial.mpw";
        scriptMap.put("FactorsMonomial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"FactorsPolynomialOverIntegers\",*);\n//Retract(\"TryToReduceSpecialPolynomial\",*);\n\n//---------------------------------------------------------------------------\n\n10 # FactorsPolynomialOverIntegers(_expr)_IsPolynomialOverIntegers(expr) <--\n[\n    Local(x);\n    x := VarList(expr)[1];\n    FactorsPolynomialOverIntegers(expr,x);\n\n];\n\n15 # FactorsPolynomialOverIntegers(_expr) <-- expr;\n\n\n10 # FactorsPolynomialOverIntegers(_expr,_var)_(IsPolynomialOverIntegers(expr,var)) <--\n[\n    Local(factorsList,factListTransp,factrs,multiplicities,factrsUnMonic);\n    Local(polyFactors,normalizations,normDivisor,polyFactors,factList);\n    Local(n,result,newResult,gtotal,r,rr,d,g);\n    factorsList := BinaryFactors(expr);\n    /*  \n     *  BinaryFactors is the internal MathPiper function that\n     *  creates a double list of factors and their multiplicities\n     */\n    \n    // By transposing factorsList (which has the form of a list of \n    // lists, hence a matrix), we convert it into a form which has \n    // a list of all the factors first, followed by a list of all \n    // the corresponding multiplicities.\n    \n    factListTransp := Transpose(factorsList);\n    factrs := factListTransp[1];\n    multiplicities := factListTransp[2];\n        \n    // Now, these factors are probably all in \"monic\" form, with the \n    // coefficient of the highest power of x in each factor being \n    // equal to 1, and all the \"normalizing\" factors being combined \n    // into a new leading numeric factor.  We want to undo this\n    // monic-ization.  The function Together() will accomplish this \n    // for each separate factor, while leaving untouched factors \n    // which do not need changing.\n    \n    factrsUnMonic := MapSingle(\"Together\",factrs);\n        \n    // The result of this step is that each factor which had been \n    // \"normalized\" to a monic has now be un-normalized into a \n    // rational function consisting of a non-monic polynomial \n    // divided by a number.  Now we just collect all the non-monic \n    // polynomials into one list, and all the normalizing denominators\n    // into another.\n    \n    {polyFactors,normalizations}:=Transpose(MapSingle(\"GetNumerDenom\",factrsUnMonic));\n        \n    // The next step is to make sure that each of the normalizing \n    // numbers is raised to the power of its corresponding \n    // multiplicity. Then all these powers of numbers are \n    // multiplied together, to form the overall normilizing \n    // divisor which must be used to remove the extra factor (if \n    // any) introduced during the monic-ization process.  All this \n    // is condensed into one line of Functional code\n            \n    normDivisor := Product(Map(\"^\",{normalizations,multiplicities}));\n    \n    //  Notice that normDivisors is exactly equal in value to the\n    // 'extra' numeric factor introduced by the monic-ization, if\n    // any was indeed so introduced (it doesn't happen under all\n    // circumstances).  I believe this will always be true, but I \n    // have not taken the time to prove it.  So I proceed in a \n    // more general way.\n    \n    polyFactors[1] := Simplify(polyFactors[1]/normDivisor);\n    \n    // We can now replace the first sub-list in factListTransp by\n    // the un-monic-ized version\n    \n    factListTransp[1] := polyFactors;\n    factList := Transpose(factListTransp);\n    \n    \n    // .... and that is (supposedly) the answer.\n    result := factList;\n    \n    // However, let's find out if any of the factors needs more treatment.\n    Local(newResult,gtotal,d,g,rr);\n    newResult := {};\n    gtotal    := 1;\n    ForEach(r,result) [\n        d := Degree(r[1],var);\n        g := Gcd(Coef(r[1],var,0 .. d));\n        If( g >? 1,   //  need to remove common numerical factor\n               [ gtotal:=g*gtotal; \n                 r[1]:=Simplify(r[1]/g);\n               ]\n          );\n        If(d >? 2,\n            [\n                //  polynomial is NOT irreducible, but can we reduce it?\n                rr := TryToReduceSpecialPolynomial(r[1]);\n                If( IsList(rr),newResult := Concat(newResult,rr) );\n            ],\n                If( r !=? {1,1}, newResult := r:newResult )\n          );\n    ];  \n    If(gtotal>?1,newResult:={gtotal,1}:newResult);\n    newResult;\n];\n\n\n//---------------------------------------------------------------------------\n//                      S P E C I A L    C A S E S\n//---------------------------------------------------------------------------\n/*\n * Given an unreduced polynomial over the integers, of degree > 2, \n * which was found as one of the \"factors\" of a polynomial over \n * the integers, we know that it is factorable into irreducible \n * quadratics.  This function tries to find such quadratic factors.\n *     Lacking a good general attack on this problem, we will turn\n * to special cases which we happen to be able to solve.\n */\n \n10 # TryToReduceSpecialPolynomial(_x^4+_x^2+1) <-- {{x^2+x+1,1},{x^2-x+1,1}};\n\n10 # TryToReduceSpecialPolynomial(_x^6-1) <-- {{x+1,1},{x-1,1},{x^2+x+1,1},{x^2-x+1,1}};\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorsPolynomialOverIntegers.mpw";
        scriptMap.put("FactorsPolynomialOverIntegers",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"FactorsSmallInteger\",*);\n\n10 # FactorsSmallInteger( N_IsInteger ) <--\n[\n        Local(n, power, prime, result, limit);\n    n      := Abs(N);         // make sure its positive\n    limit  := Ceil(SqrtN(n)); // upper bound for largest possible factor \n        prime  := 2;                  // first prime\n    result := {};\n        While( prime <=? limit And? n >? 1 And? prime*prime <=? n )\n        [        // find the max power of prime which divides n\n                {n, power} := FindPrimeFactor(n, prime);\n                If(        power >? 0,        DestructiveAppend(result, {prime,power}) );\n                prime := NextPseudoPrime(prime);        // faster than NextPrime and we don't need real primes here\n        ];\n        // Add the last prime (with multiplicity 1) to end of list \n        If( n >? 1, DestructiveAppend(result, {n,1}) );\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FactorsSmallInteger.mpw";
        scriptMap.put("FactorsSmallInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  numbers\n\n/// Auxiliary function. Return the power of a given prime contained in a given integer and remaining integer.\n/// E.g. FindPrimeFactor(63, 3) returns {7, 2} and FindPrimeFactor(42,17) returns {42, 0}\n// use variable step loops, like in IntLog()\nFindPrimeFactor(n, prime) :=\n[\n        Local(power, factor, old'factor, step);\n        power := 1;\n        old'factor := 1;        // in case the power should be 0\n        factor := prime;\n        // first loop: increase step\n        While(Modulo(n, factor)=?0)        // avoid division, just compute Modulo()\n        [\n                old'factor := factor;        // save old value here, avoid sqrt\n                factor := factor^2;\n                power := power*2;\n        ];\n        power := Quotient(power,2);\n        factor := old'factor;\n        n := Quotient(n, factor);\n        // second loop: decrease step\n        step := Quotient(power,2);\n        While(step>?0 And? n >? 1)\n        [\n                factor := prime^step;\n                If(\n                        Modulo(n, factor)=?0,\n                        [\n                                n := Quotient(n, factor);\n                                power := power + step;\n                        ]\n                );\n                step := Quotient(step, 2);\n        ];\n        {n, power};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FindPrimeFactor.mpw";
        scriptMap.put("FindPrimeFactor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// numbers\n\n/* simpler method but slower on worstcase such as p^n or n! */\nFindPrimeFactorSimple(n, prime) :=\n[\n        Local(power, factor);\n        power := 0;\n        factor := prime;\n        While(Modulo(n, factor)=?0)\n        [\n                factor := factor*prime;\n                power++;\n        ];\n        {n/(factor/prime), power};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/FindPrimeFactorSimple.mpw";
        scriptMap.put("FindPrimeFactorSimple",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"CanBeMonomial\",*);\n//Retract(\"IsMonomial\",*);\n//Retract(\"FactorsMonomial\",*);\n\n10 # CanBeMonomial(_expr)<--Not? (HasFunc(expr,ToAtom(\"+\")) Or? HasFunc(expr,ToAtom(\"-\")));\n\n10 # IsMonomial(expr_CanBeMonomial) <-- \n[\n    Local(r);\n    If( IsRationalFunction(expr),\n        r := (VarList(Denominator(expr)) =? {}),\n        r := True\n    );\n];\n\n15 # IsMonomial(_expr) <-- False;\n\n\n10 # FactorsMonomial(expr_IsMonomial) <--\n[\n  If(InVerboseMode(),Tell(\"FactorsMonomial\",expr));\n  Local(den,num,Ns,flat,prod,quot,result,f,ff);\n  If( IsRationalFunction(expr),\n    [\n      den := Denominator(expr);\n      num := Flatten(Numerator(expr),\"*\");\n    ],\n    [\n      den := 1;\n      num := Flatten(expr,\"*\");\n    ]\n  );\n  If(InVerboseMode(),Tell(\"     \",{num,den}));\n  Ns  := Select(num, \"IsComplex\");\n  If(InVerboseMode(),Tell(\"     \",Ns));\n  If( Ns =? {},\n       If( den !=? 1, DestructiveInsert(num,1,1/den)),\n       DestructiveReplace(num,Find(num,Ns[1]),Ns[1]/den)\n  );\n  If(InVerboseMode(),Tell(\"     \",num));\n  result := {};\n  ForEach(f,num)\n  [\n      If( IsComplex(f), \n          DestructiveAppend(result,{(f),1}),\n          If( IsAtom(f),\n              DestructiveAppend(result,{f,1}),\n              DestructiveAppend(result,DestructiveDelete(FunctionToList(f),1))\n          )\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/Monomials.mpw";
        scriptMap.put("Monomials",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  polynomials\n\n10 # Roots(poly_CanBeUni) <--\n[\n  Local(factors,result,uni,root,i,deg);\n  factors:=Factors(poly);\n  result:={};\n  ForEach(item,factors)\n  [\n    uni:=MakeUni(item[1]);\n    deg:=Degree(uni);\n    If(deg >? 0 And? deg <? 3,\n      [\n        root:= PSolve(uni);\n        If(Not? IsList(root),root:={root});\n        For(i:=0,i<?item[2],i++)\n          result:= Concat(root, result);\n      ]\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/Roots.mpw";
        scriptMap.put("Roots",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  polynomials\n\n10 # RootsWithMultiples(poly_CanBeUni) <--\n[\n  Local(factors,result,uni,root,i,deg);\n  factors:=Factors(poly);\n  result:={};\n  ForEach(item,factors)\n  [\n    uni:=MakeUni(item[1]);\n\n    deg:=Degree(uni);\n    If(deg >? 0 And? deg <? 3,\n      [\n        root:= PSolve(uni);\n        If(Not? IsList(root),root:={root});\n        For(i:=1,i<=?Length(root),i++)\n          result:= Concat({{root[i],item[2]}}, result);\n      ]\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/RootsWithMultiples.mpw";
        scriptMap.put("RootsWithMultiples",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Sort the list of prime factors using HeapSort()\nLocalSymbols(a,b, list) [\n\nSortFactorList(list) := HeapSort(list, {{a,b}, a[1]<?b[1]});\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/SortFactorList.mpw";
        scriptMap.put("SortFactorList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  numbers\n\n//todo:tk:This functions was commented out for some reason.\n\n/// Simple trial factorization: can be very slow for integers > 1,000,000.\n/// Try all prime factors up to Sqrt(n).\n/// Resulting factors are automatically sorted.\n/// This function is not used any more.\n/*\n2# TrialFactorize(n_IsPrimePower) <-- {GetPrimePower(n)};\n3# TrialFactorize(n_IsInteger) <--\n[\n        Local(factorization);\n        factorization := TrialFactorize(n, n);        // TrialFactorize will limit to Sqrt(n) automatically\n        If(\n                First(factorization) = 1,        // all factors were smaller than Sqrt(n)\n                Rest(factorization),\n                // the first element needs to be replaced\n                Concat(Rest(factorization), {{First(factorization),1}})\n        );\n];\n*/\n\n\n/// Auxiliary function. Factorizes by trials. Return prime factors up to given limit and the remaining number.\n/// E.g. TrialFactorize(42, 2) returns {21, {{2, 1}}} and TrialFactorize(37, 4) returns {37}\nTrialFactorize(n, limit) :=\n[\n        Local(power, prime, result);\n        result := {n};        // first element of result will be replaced by the final value of n\n        prime := 2;        // first prime\n        While(prime <=? limit And? n>?1 And? prime*prime <=? n)\n        [        // find the max power of prime which divides n\n                {n, power} := FindPrimeFactor(n, prime);\n                If(\n                        power>?0,\n                        DestructiveAppend(result, {prime,power})\n                );\n                prime := NextPseudoPrime(prime);        // faster than NextPrime and we don't need real primes here\n        ];\n        // replace the first element which was n by the new n\n        DestructiveReplace(result, 1, n);\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/TrialFactorize.mpw";
        scriptMap.put("TrialFactorize",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// This is so YacasFactor(Sin(x)) doesn't return FWatom(Sin(x))\n//Factor(_p) <-- FW(Factors(p));\n10 # Factor(p_CanBeUni) <-- FW(Factors(p));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/YacasFactor.mpw";
        scriptMap.put("Factor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/*\n * This is the fundamental factorization algorithm as created for Yacas, with\n * a few improvements.\n * It works for integers, rational numbers, Gaussian integers, and polynomials\n * When the argument is an integer, FactorizeInt() does the heavy lifting.\n * When the argument is a polynomial, BinaryFactors() is the workhorse.\n */\n \n\n10 # Factors(p_IsPositiveInteger) <--  FactorizeInt(p);\n\n11 # Factors(p_IsInteger) <-- FactorizeInt(p);\n\n12 # Factors(p_IsRational)_(Denominator(p) !=? 1) <-- {{YacasFactor(Numerator(p)) /YacasFactor(Denominator(p)) , 1}};\n     //Added to handle rational numbers with denominators that are not 1\n\n14 # Factors(p_IsGaussianInteger)        <-- GaussianFactors(p);\n\n20 # Factors(p_CanBeUni)_(Length(VarList(p)) =? 1) <--\n[\n    Local(x,d,coeffs,nterms,factorsList,result);\n    x := VarList(p)[1];\n    d := Degree(p,x);\n    /*  p is the polynomial, x is its (only) variable.  It IS Univariate */\n    /*  Let's find out how many terms this polynomial has.               */\n    coeffs := Coef(p,x,0 .. Degree(p,x));\n    nterms := Length(Select(coeffs, \"IsNotZero\"));\n    /*  If nterms = 2, it is a binomial, and might be most easily\n     *  factored by some special-purpose algorithms                      */\n    If( nterms =? 2 And? d >? 2,\n      [  result := FactorsBinomials(p);  ],    \n      [  // nterms !=? 2, so try other techniques\n        factorsList := BinaryFactors(p);\n           // BinaryFactors is the internal MathPiper function that\n           // creates a double list of factors and their multiplicities\n        /*\n         *  Now we check whether the input polynomial is \"over the \n         *  integers\", by examining all its coefficients\n         */\n        If( AllSatisfy(\"IsInteger\",coeffs),\n          [\n              // Yes -- all integer coefficients\n              result := FactorsPolynomialOverIntegers(p,x);\n          ],\n          [\n              // No -- at least one non-integer coefficient\n              // Check for FLOAT or RATIONAL coefficients\n              Local(notInt,rat,dd,lcm,newCoeffs,newPoly,facs);\n              notInt := Select(coeffs, Lambda({i},Not? IsInteger(i)));\n              rat := Rationalize(coeffs);            \n              dd  := MapSingle(\"Denominator\",rat);\n              lcm := Lcm(dd);\n              newCoeffs := lcm * rat;\n              newPoly := NormalForm(UniVariate(x,0,newCoeffs));\n              facs := FactorsPolynomialOverIntegers(newPoly);\n              If( InVerboseMode(), [\n                  Echo(\"coeffs \",coeffs);\n                  Echo(\"notInt \",notInt);\n                  Echo(\"rat \",rat);\n                  Echo(\"dd  \",dd);\n                  Echo(\"lcm \",lcm);\n                  Echo(\"newCoeffs \",newCoeffs);\n                  Echo(\"newPoly \",newPoly);\n                  Echo(\"facs \",facs);\n                 ]\n              );\n              result := {(1/lcm),1}:facs;\n              //NOT FINISHED YET\n        ]\n      );\n    ]\n   );\n      CombineNumericalFactors( result );\n];\n\n\n30 # Factors(p_CanBeUni) <--\n[\n    /* \n     * This may be a multi-variate polynomial, or it may be something else.\n     * Original YT function Factors() did not attempt to factor such.\n     *    If it is a multivariate polynomial, we will try certain\n     * Special cases which we can relatively easily factor.\n     *    If it is \"something else\", we will have to check, on a\n     * case-by-case basis.\n     */\n    Local(vl,nvars,coeffs,result);\n    vl     := VarList(p);\n    nvars  := Length(vl);\n    coeffs := Coef(p,x,0 .. 8);\n    If(InVerboseMode(),Tell(\"CBU\",{vl,nvars,coeffs}));\n    If (nvars >? 1, \n         [\n            If( InVerboseMode(), Echo(\" special \",p));\n            result := FactorsMultivariateSpecialCases(p);\n         ], \n            result := FactorsSomethingElse(p) \n       );\n       CombineNumericalFactors( result );\n];\n\n\n40 # Factors(_p) <--\n[\n    /*\n     * This may may be a polynomial with non-integer exponents.  Let's check.\n     */\n     If( InVerboseMode(), Echo(\"Possibly trying to factor polynomial with non-integral exponents\") );\n     Local( result);\n     //Echo(40,p);\n     //  NOT IMPLEMENTED YET\n     result := {{p,1}};\n     CombineNumericalFactors( result );\n     \n];\n\n//------------------------------------------------------------------------\n//                    S P E C I A L     C A S E S\n//------------------------------------------------------------------------\n\n10 # FactorsMultivariateSpecialCases(-_expr) <-- {-1,1}:FactorsMultivariateSpecialCases(expr);\n\n10 # FactorsMultivariateSpecialCases(x_IsAtom + y_IsAtom) <-- [If(InVerboseMode(),Tell(1));{{x+y,1}};];\n\n10 # FactorsMultivariateSpecialCases(x_IsAtom - y_IsAtom) <-- [If(InVerboseMode(),Tell(2));{{x-y,1}};];\n\n10 # FactorsMultivariateSpecialCases(_n*_x^p_IsInteger + _n*_y) <-- [If(InVerboseMode(),Tell(3));{n,1}:FactorsMultivariateSpecialCases(x+y);];\n\n10 # FactorsMultivariateSpecialCases(_n*_x^p_IsInteger - _n*_y) <-- [If(InVerboseMode(),Tell(4));{n,1}:FactorsMultivariateSpecialCases(x-y);];\n\n10 # FactorsMultivariateSpecialCases(n_IsInteger*_x + m_IsInteger*_y)_(Gcd(n,m)>?1) <-- {{Gcd(n,m),1},{(Simplify((n*x+m*y)/Gcd(n,m))),1}};\n\n10 # FactorsMultivariateSpecialCases(n_IsInteger*_x - m_IsInteger*_y)_(Gcd(n,m)>?1) <-- {{Gcd(n,m),1},{(Simplify((n*x-m*y)/Gcd(n,m))),1}};\n\n10 # FactorsMultivariateSpecialCases(_n*_x + _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x+y);\n\n10 # FactorsMultivariateSpecialCases(_n*_x - _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x-y);\n\n10 # FactorsMultivariateSpecialCases(_x^n_IsInteger - _y) <-- FactorsBinomials(x^n - y); \n\n10 # FactorsMultivariateSpecialCases(_x^n_IsInteger + _y) <-- FactorsBinomials(x^n + y); \n\n20 # FactorsSomethingElse(_p) <-- \n  [\n      If( InVerboseMode(),\n          [\n              ECHO(\"   *** FactorsSomethingElse: NOT IMPLEMENTED YET ***\");\n          ]\n      );\n      p;\n  ];\n\n//------------------------------------------------------------------------\n\n\n10 # CombineNumericalFactors( factrs_IsList ) <--\n  [\n      If( InVerboseMode(), Tell(\"Combine\",factrs) );\n      Local(q,a,b,t,f,err);\n      err := False;\n      t   := 1;\n      f   := {};\n      ForEach(q,factrs)\n      [\n          If( InVerboseMode(), Tell(1,q) );\n          If( IsList(q) And? Length(q)=?2,\n              [\n                  {a,b} := q;\n                  If( InVerboseMode(), Echo(\"     \",{a,b}) );\n                  If( IsNumericList( {a,b} ),\n                      t := t * a^b,\n                      f := {a,b}:f\n                  );\n              ],\n              err := True\n          );\n      ];\n      If( InVerboseMode(),\n        [\n            Echo(\"      t = \",t);\n            Echo(\"      f = \",f);\n            Echo(\"    err = \",err);\n        ]\n      );\n      If(Not? err And? t !=? 1, {t,1}:Reverse(f), factrs);\n  ];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/YacasFactors.mpw";
        scriptMap.put("Factors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"jFactorsPoly\",*);\n//Retract(\"HasRealCoefficients\",*);      \n//Retract(\"RealToRationalConvert\",*);\n//Retract(\"HasRationalCoefficients\",*);   \n//Retract(\"RationalToIntegerConvert\",*);\n//Retract(\"jFactorsPrimitivePart\",*);\n//Retract(\"jFactorsBivariateBinomial\",*);\n//Retract(\"jFactorsHomogeneousBivariate\",*);\n\n//Retract(\"jFB\",*);\n//Retract(\"jFac\",*);\n\n//Retract(\"FixUpMonicFactors\",*);\n//Retract(\"CombineNumericalFactors\",*);\n//Retract(\"IsPureRational\",*);\n\n/* -------------    POLYNOMIALS -- CAN BE UNI   --------------*/\n\n50 # jFactorsPoly( poly_CanBeUni ) <--\n[\n    If(InVerboseMode(),Tell(\"jFactorsPoly_100612\",poly));\n    Local(content,pp,ppFactors,monomialFactors,result,moreDetails);\n    Local(vars,nvars,disassem,degrees,mpoly,nterms,allCoeffs,allPowers);\n    Local(hasRealCoefficients,hasRationalCoefficients,isHomogeneous);\n    Local(extraFactor);\n    \n    moreDetails := False;\n    disassem  := DisassembleExpression(poly);\n    allCoeffs := disassem[3];\n\n    //  First, check to see if the polynomial has any REAL coefficients.\n    //  If so, convert to approximate integers (with divisor).\n    hasRealCoefficients := HasRealCoefficients(poly);\n    If( hasRealCoefficients, \n      [\n         Local(realPoly);\n         realPoly  := poly;   //  just in case -- save original form\n         allPowers := Flatten(disassem[2],\"List\");\n         poly      := RealToRationalConvert(poly);\n         // From now on we operate on a polynomial over Integers\n         hasRealCoefficients := False;          ]\n    );\n    \n    //  Also, check to see if the polynomial has Rational coeffs\n    hasRationalCoefficients := HasRationalCoefficients(poly);\n    If(hasRationalCoefficients, \n      [\n         Local(rationalPoly);\n         rationalPoly  := poly;   //  just in case -- save original form\n         If(InVerboseMode(),Tell(\"   RATIONAL\",rationalPoly));\n         // convert to equivalent polynomial over Integers\n         poly := RationalToIntegerConvert(poly);\n         // From now on we operate on a polynomial over Integers\n         hasRationalCoefficients := False;    \n      ]\n    );\n\n    // Now: get Content and Primitive Part\n    content := xContent( poly );\n    pp      := Simplify( poly / content );\n    If(IsBound(extraFactor),content := content / extraFactor);\n    If(InVerboseMode(),Tell(\"   \",{content,pp}));\n    //If(IsConstant(pp) And? Length(VarList(content))>?0,{content,pp}:={pp,content});\n    If( Length(VarList(pp))=?0, result := {{pp*content,1}},\n      [\n         //If(InVerboseMode(),Tell(\"  \",{content,pp}));\n         vars     := VarList(pp);\n         nvars    := Length(vars);\n         disassem := DisassembleExpression(pp);\n         nterms   := Length(disassem[3]);\n         degrees  := {};\n         allCoeffs         := disassem[3];\n         allPowers         := Flatten(disassem[2],\"List\");\n         If(nvars >? 0,\n           [\n             ForEach(v,vars)\n                [ DestructiveAppend(degrees,Degree(pp,v)); ];\n             isHomogeneous     := [\n                 // A polynomial is homogeneous of degree n \n                 // if all terms have degree n.   \n                 Local(sd,cmp); \n                 sd  := Sum /@ disassem[2];\n                 cmp := FillList(sd[1],Length(sd));\n                 IsZeroVector(sd - cmp);\n             ];\n           ]\n         );\n    \n         If(InVerboseMode() And? moreDetails,\n           [\n             Tell(\"               \",vars);\n             Tell(\"              \",nvars);\n             Tell(\"             \",nterms);\n             Tell(\"            \",degrees);\n             Tell(\"           \",disassem);\n             Tell(\"          \",allCoeffs);\n             Tell(\"          \",allPowers);\n             Tell(\"      \",isHomogeneous);\n             NewLine();\n           ]\n         );\n    \n         //  Does the Content have factors?  If so, get them.\n         //If(InVerboseMode(),NewLine());\n         monomialFactors := FactorsMonomial(content);\n         If(InVerboseMode(),Tell(\"  \",monomialFactors));\n    \n         //  OK.  Now factor the PrimitivePart\n         ppFactors := jFactorsPrimitivePart( pp );\n         If(InVerboseMode(),Tell(\"                    \",ppFactors));\n         If( Not? IsListOfLists(ppFactors), \n           [\n               Local(L,op,var,exp);\n               L := If(IsAtom(ppFactors[1]), ppFactors, FunctionToList(ppFactors[1]) );\n               If(InVerboseMode(),Tell(\"                    \",L));\n               If( L[1] =? ^, ppFactors := {L[2],L[3]} );\n               ppFactors := {ppFactors};\n           ]\n         );\n         If(InVerboseMode(),Tell(\"  \",ppFactors));\n    \n         // Next, include the factors of the Content, if any\n         If( monomialFactors[1][1] =? 1,\n             result := ppFactors,        \n             //result := Concat(monomialFactors,{ppFactors})    // hso 100801\n             result := Concat(monomialFactors,ppFactors)      // hso 100803\n         );\n      ]\n    );\n    \n    If(InVerboseMode(),\n      [\n          NewLine();\n          Tell(\"  \",monomialFactors);\n          Tell(\"        \",ppFactors);\n          Tell(\"  final    \",result);\n      ]\n    );\n    result;\n];\nUnFence(\"jFactorsPoly\",1);\n\n\n\n// -----------------  FACTOR PRIMITIVE PART  -----------------\n\n     //  special case: binomials\n60 # jFactorsPrimitivePart( _pp )_(isHomogeneous And? nterms=?2 And? nvars=?2) <--\n[\n    If(InVerboseMode(),Tell(\"Bivariate Binomial\",pp));\n    Local(ppFactors,isDiagonal);\n    isDiagonal := IsDiagonal(disassem[2]);   //  mod hso 10-11-25\n    ppFactors := If(isDiagonal,jFactorsBivariateBinomial(pp),jasFactorsInt(pp) );\n];\nUnFence(\"jFactorsPrimitivePart\",1);\n\n\n     //  special case: homogeneous bivariates\n65 # jFactorsPrimitivePart( _pp )_(isHomogeneous And? nterms>?1 And? nvars=?2) <--\n[\n    If(InVerboseMode(),Tell(\"Homogeneous and Bivariate\"));\n    Local(ppFactors);\n    ppFactors := jFactorsHomogeneousBivariate(disassem);\n];\nUnFence(\"jFactorsPrimitivePart\",1);\n\n\n     //  special case:  no variables in pp!\n70 # jFactorsPrimitivePart( _pp )_(nvars=?0) <--\n[\n    Local(ppFactors);\n    ppfactors := {};\n];\n\n\n     //  general case\n100 # jFactorsPrimitivePart( _pp ) <-- \n[\n    If(InVerboseMode(),Tell(\"jFactorsPrimitivePart_usingJAS\",pp));\n    Local(answer);\n    answer := If(IsMonomial(pp),{pp,1},jasFactorsInt(pp));\n    If(InVerboseMode(),Tell(\"          \",answer));\n    answer;\n];\nUnFence(\"jFactorsPrimitivePart\",1);\n\n// ------------------  HOMOGENEOUS BIVARIATE  ------------------\n\n10 # jFactorsHomogeneousBivariate( dis_IsList ) <-- \n[\n    If(InVerboseMode(),[NewLine();Tell(\"jFactorsHomogeneousBivariate\",dis);]);\n    Local(dis1,f,dis2,poly1,ppFactors,residuals);\n    Local(ii,lst,f,preassem);\n    dis1  := {{xi},{{X},{X[1]}} /@ dis[2],dis[3]};\n    If(InVerboseMode(),Tell(\"   \",dis1));\n    poly1 := Sum(ReassembleListTerms(dis1));\n    If(InVerboseMode(),Tell(\"   \",poly1));\n    ppFactors := BinaryFactors(poly1);\n    {ppFactors,residuals} := FixUpMonicFactors(ppFactors);\n    For(ii:=1,ii<=?Length(ppFactors),ii++)\n    [\n        f := ppFactors[ii];\n        If(InVerboseMode(),Tell(\"          \",f[1]));\n        lst := DisassembleExpression(f[1]);\n        If(InVerboseMode(),\n          [\n             Tell(\"               \",lst);\n             Tell(\"                            \",dis[1]);\n          ]\n        );\n        DestructiveReplace(lst,1,dis[1]);\n        DestructiveAppend(lst[2][1],0);\n        DestructiveAppend(lst[2][2],1);\n        If(Length(lst[2])=?3, DestructiveAppend(lst[2][3],2));\n        If(InVerboseMode(),Tell(\"               \",lst));\n        preassem  := Sum(ReassembleListTerms(lst)) ;\n        If(InVerboseMode(),Tell(\"               \",preassem));\n        ppFactors[ii][1] := preassem;\n    ];\n    If(InVerboseMode(),[Tell(\"   \",ppFactors); Tell(\"   \",residuals);NewLine();] );  \n    ppFactors;\n];\nUnFence(\"jFactorsHomogeneousBivariate\",1);\n\n// ---------------------   OTHER STUFF ------------------------\n\n10 # RealToRationalConvert( poly_IsPolynomial ) <--\n[\n    // If the polynomial has REAL coefficients, convert them to\n    // approximate RATIONALS\n    If(InVerboseMode(),[NewLine();Tell(\"  REAL\",poly);]);\n    Local(coeffs,gcd,lcm);\n    coeffs := Rationalize /@ (allCoeffs);\n    If(InVerboseMode(),[Tell(\"      to-Q\",coeffs);Tell(\"      to-Z\",coeffs);]);\n    Local(gcd,lcm);\n    gcd    := Gcd(Numerator /@ coeffs);\n    lcm    := Lcm(Denominator /@ coeffs);\n    If(InVerboseMode(),[Tell(\"       \",gcd);Tell(\"       \",lcm);]);\n    disassem[3] := coeffs;\n    allCoeffs   := coeffs;\n    poly        := Sum(ReassembleListTerms(disassem));\n    If(InVerboseMode(),Tell(\"   new\",poly));\n    poly;\n];\nUnFence(\"RealToRationalConvert\",1);\n\n\n10 # RationalToIntegerConvert( poly_IsPolynomial ) <--\n[\n    // If the polynomial has RATIONAL coefficients, convert to\n    // approximate INTEGER\n    Local(coeffs,gcd,lcm);\n    coeffs := allCoeffs;\n    If(InVerboseMode(),Tell(\"  \",coeffs));\n    lcm         := Lcm(Denominator /@ coeffs);\n    extraFactor := lcm;\n    If(InVerboseMode(),[Tell(\"     \",extraFactor);]);\n    poly := Simplify(extraFactor*poly);\n    If(InVerboseMode(),Tell(\"  new \",poly));\n    poly;\n];\nUnFence(\"RationalToIntegerConvert\",1);\n\n\n100 # CombineNumericalFactors( factrs_IsList ) <--\n[\n      If( InVerboseMode(), Tell(\"Combine\",factrs) );\n      Local(q,a,b,t,f,ff,err);\n      err := False;\n      t   := 1;\n      f   := {};\n      ForEach(q,factrs)\n      [\n          If( InVerboseMode(), Tell(1,q) );\n          If( IsList(q) And? Length(q)=?2,\n            [\n                {a,b} := q;\n                If( InVerboseMode(), Echo(\"     \",{a,b}) );\n                If( IsNumericList( {a,b} ),\n                    t := t * a^b,\n                    f := {a,b}:f\n                );\n            ],\n              err := True\n          );\n      ];\n      If( InVerboseMode(),\n        [\n            Echo(\"      t = \",t);\n            Echo(\"      f = \",f);\n            Echo(\"    err = \",err);\n        ]\n      );\n      ff := If(Not? err And? t !=? 1, {t,1}:Reverse(f), factrs);\n      ff := Select(Lambda({x},x!=?{1,1}),ff);\n      If(ff[1]<?0,ff[1]:=-ff[1]);\n];\n\n\n// ----------------  RATIONAL POLYNOMIALS  -----------------\n\n150 # jFactors( expr_IsRationalFunction )_\n        (IsPolynomial(Numerator(expr)) And? IsPolynomial(Denominator(expr))) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"jFactors_Rational_Function\",expr);]);\n    Local(Numer,Denom,fNumer,fDenom);\n    Numer  := Numerator(expr);\n    Denom  := Denominator(expr);\n    fNumer := jFactors(Numer);\n    fDenom := jFactors(Denom);\n    If(InVerboseMode(),[Tell(\"   \",fNumer); Tell(\"   \",fDenom);]);\n    fNumer/fDenom;\n];\n\n\n152 # jFactors( expr_IsRationalFunction )_\n        (IsConstant(Numerator(expr)) And? IsPolynomial(Denominator(expr))) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"jFactors_Rational_Denom\",expr);]);\n    Local(Numer,Denom,fNumer,fDenom);\n    Numer  := Numerator(expr);\n    Denom  := Denominator(expr);\n    fNumer := jFactors(Numer);\n    fDenom := jFactors(Denom);\n    If(InVerboseMode(),[Tell(\"   \",fNumer); Tell(\"   \",fDenom);]);\n    fNumer/fDenom;\n];\n\n\n// ----------   POSSIBLE NON-INTEGER EXPONENTS  ----------\n\n200 # jFactors( _expr )_(Length(VarList(expr)) =? 1) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"Some other kind of expression\",expr);]);\n    Local(dis,X,pows);\n    dis := DisassembleExpression(expr);\n    X   := VarList(expr)[1];\n    pows := matchPower /@ dis[1];\n    rats := NearRational /@ pows;\n    dis[1] := x^rats;\n    p := Sum(ReassembleListTerms(dis));\n    If(InVerboseMode(),Tell(\"    new \",p));\n    jFactors(p);\n];\n\n\n\n/*-------------------------------------------------------------------\n *  Factoring Binomial expressions of the form  A X^n � B Y^n,\n *     Uses JAS library, but converts to univariate equivalent\n *     before factoring. (JAS is inefficient for multivariate\n *     factoring when degree is large.)\n *-------------------------------------------------------------------*/\n\n10 # jFactorsBivariateBinomial( poly_IsPolynomial )_(Length(VarList(poly))=?2)  <--\n[\n    If(InVerboseMode(),Tell(jFactorsBivariateBinomial,poly));\n    Local(dis,n,X,Y,vars,A,B,s,Ar,Br,Arr,Brr,DAr,DBr,result);\n    dis := DisassembleExpression(poly);\n    If(InVerboseMode(),Tell(\"   \",dis));\n    n     := Maximum(dis[2])[1];\n    X     := dis[1][1];\n    Y     := dis[1][2];\n    vars  := dis[1];\n    A     := Abs(dis[3][1]);\n    B     := Abs(dis[3][2]);\n    s     := Sign(dis[3][1]*dis[3][2]);\n    //Ar    := NearRational(N(A^(1/n)));\n    //Br    := NearRational(N(B^(1/n)));\n    Ar    := N(A^(1/n));    Arr := Round(Ar);   DAr := Abs(Ar-Arr);\n    Br    := N(B^(1/n));    Brr := Round(Br);   DBr := Abs(Br-Brr);\n    If(InVerboseMode(),\n      [\n          Tell(\"       \",{n,X,Y}); \n          Tell(\"       \",{vars,A,B});\n          Tell(\"       \",{Ar,Br,s});\n          Tell(\"       \",{Arr,Brr});\n          Tell(\"       \",{DAr,DBr});\n          Tell(\"       \",dis);\n      ]\n    );\n    result := If( DAr <? 10^(-9) And? DBr <? 10^(-9), jFB(dis), {{poly,1}} );\n    result;\n];\nUnFence(\"jFactorsBivariateBinomial\",1);\n\n\n50 # jFB( dis_IsList )_(Length(dis)=?3 And? Length(dis[3])=?2) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"jFB\",dis);]);\n    Local(ns,ii,fn,mx,my,fac);\n    If(InVerboseMode(),\n      [\n         Tell(\"     \",n);\n         Tell(\"     \",{X,Y});\n         Tell(\"     \",{A,B,s});\n         Tell(\"     \",{Ar,Br});\n      ]\n    );\n    X     := Arr*X;\n    Y     := Brr*Y;\n    If(InVerboseMode(),Tell(\"     \",{X,Y}));\n    \n    fac  := jFac( X/Y,n,s);    //  factor using JAS and normalized variable\n    If(InVerboseMode(),\n      [\n          NewLine();\n          Tell(\"      \",X/Y);\n          Tell(\"      \",fac);\n      ]\n    );\n    \n    // now convert factorization back to actual variables if required\n    If( Y !=? 1,\n      [\n          Local(f,d,fs);\n          For(ii:=1,ii<=?Length(fac),ii++)\n          [\n              f := fac[ii][1];\n              d := Degree(f,x);\n              If(InVerboseMode(),Tell(\"             \",{ii,f,d}));\n              fs := Subst(x,X/Y) f;\n              If(InVerboseMode(),Tell(\"               \",{fs,d}));\n              fac[ii][1] := Simplify(Simplify(Y^d*fs));\n          ];\n      ]\n    );\n    fac;\n];\nUnFence(\"jFB\",1);\n\n\n\n60 # jFac( _var, n_IsPositiveInteger, s_IsInteger ) <--\n[\n    //  Uses JAS to factor polynomial of form x^n � 1.\n    If(InVerboseMode(),[NewLine();Tell(\"jFac\",{var,n,s});]);\n    Local(x,poly,result);\n    poly := x^n+s;\n    If(InVerboseMode(),Tell(\"   \",poly));\n    result := jasFactorsInt(poly);     \n];\nUnFence(\"jFac\",3);\n\n\n10 # IsPureRational( N_IsRational )_(Not? IsInteger(N)) <-- True;\n\n12 # IsPureRational( _N ) <-- False;\n\n10 # HasRealCoefficients( poly_IsPolynomial ) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsDecimal\")) >? 0);\n];\n\n10 # HasRealCoefficients( poly_IsMonomial ) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsDecimal\")) >? 0);\n];\n\n\n10 # HasRationalCoefficients( poly_IsPolynomial ) <--\n[\n    Local(disassem,answer);\n    If(InVerboseMode(),Tell(\"  HasRationalCoefficients\",poly));\n    disassem := DisassembleExpression(poly);\n    //Tell(\"              \",disassem);\n    answer := (Length(Select(disassem[3],\"IsPureRational\")) >? 0);\n    If(InVerboseMode(),Tell(\"   \",answer));\n    answer;\n];\n\n10 # HasRationalCoefficients( poly_IsMonomial) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsPureRational\")) >? 0);\n];\n\n\n10 # FixUpMonicFactors( factrs_IsList ) <--\n[\n    If(InVerboseMode(),[ NewLine(); Tell(\"   doing monic fixup\"); ] );\n    Local(factrsnew,residuals,f,uni,);\n    factrsnew := {};\n    residuals := {};\n    ForEach(f,factrs)\n    [\n        If(InVerboseMode(),Tell(\"               \",f));\n        uni := MakeUni(f[1]);\n        If(InVerboseMode(),Tell(\"                    \",uni));\n        If( Degree(f[1])=?1,\n          [\n            Local(cc,lcm,fnew);\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            cc      := Coef(f[1],uni[1],0 .. 1);\n            //Tell(\"                       \",cc);\n            lcm     := Lcm( Denominator /@ cc );\n            uni[3]  := lcm * cc;\n            fnew    := NormalForm(uni);\n            If( hasRationalCoefficients,\n              [\n                 DestructiveAppend(factrsnew,f);\n              ],\n              [ \n                 DestructiveAppend(factrsnew,{fnew,f[2]});\n              ]\n            );\n          ]\n        );\n        If( Degree(f[1])=?2,\n          [\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            Local(pq);\n            pq      := PrimitivePart(f[1]);\n            DestructiveAppend(factrsnew,{pq,f[2]});\n          ]\n        );\n        //  If any factors have degree >=3, store them in a 'residuals' array\n        //  for further analysis\n        If( Degree(f[1]) >? 2,\n          [\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            Local(pq);\n            pq      := PrimitivePart(f[1]);\n            DestructiveAppend(residuals,{pq,f[2]});\n            If(InVerboseMode(),Tell(\"                   appending to residuals\",pq));\n          ]\n        );       \n    ];\n    {factrsnew,residuals};\n];\nUnFence(\"FixUpMonicFactors\",1);\n\n\n//10 # matchPower(_Z^n_IsNumber) <-- n;\n\n//15 # matchPower(_Z) <-- 1;\n\n\n//========================================================================\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/jFactorsPoly.mpw";
        scriptMap.put("jFactorsPoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "/* PollardCombineLists combines two assoc lists used for factoring.\n   the first element in each item list is the factor, and the second\n   the exponent. Thus, an assoc list of {{2,3},{3,5}} means 2^3*3^5.\n*/\nPollardCombineLists(_left,_right) <--\n[\n  ForEach(item,right)\n  [\n    PollardMerge(left,item);\n  ];\n  left;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/pollardrho/PollardCombineLists.mpw";
        scriptMap.put("PollardCombineLists",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # PollardMerge(_list,{1,_n}) <-- True;\n10 # PollardMerge(_list,_item)_(Assoc(item[1],list) =? Empty) <--\n  DestructiveInsert(list,1,item);\n\n20 # PollardMerge(_list,_item) <--\n[\n  Local(assoc);\n  assoc := Assoc(item[1],list);\n  assoc[2]:=assoc[2]+item[2];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/pollardrho/PollardMerge.mpw";
        scriptMap.put("PollardMerge",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* This is Pollard's Rho method of factorizing, as described in\n * \"Modern Computer Algebra\". It is a rather fast algorithm for\n * factoring, but doesn't scale to polynomials regrettably.\n *\n * It acts 'by chance'. This is the Floyd cycle detection trick, where\n * you move x(i+1) = f(x(i)) and y(i+1) = f(f(y(i))), so the y goes twice\n * as fast as x, and for a certain i x(i) will be equal to y(i).\n *\n * \"Modern Computer Algebra\" reasons that if f(x) = (x^2+1) mod n for\n * the value n to be factored, then chances are good that gcd(x-y,n)\n * is a factor of n. The function x^2+1 is arbitrary, a higher order\n * polynomial could have been chosen also.\n *\n */\n\n/*\nWarning: The Pollard Rho algorithm cannot factor some numbers, e.g. 703, and\ncan enter an infinite loop. This currently results in an error message: \"failed to factorize\".\nHopefully the TrialFactorize() step will avoid these situations by excluding\nsmall prime factors.\nThis problem could also be circumvented by trying a different random initial value for x when a loop is encountered -- hopefully another initial value will not get into a loop. (currently this is not implemented)\n*/\n\n\n\n\n/// Polynomial for the Pollard Rho iteration\nPollardRhoPolynomial(_x) <-- x^2+1;\n\n2# PollardRhoFactorize(n_IsPrimePower) <-- {GetPrimePower(n)};\n3# PollardRhoFactorize(_n) <--\n[\n  Local(x,y,restarts,gcd,repeat);\n  gcd:=1;\n  restarts := 100;        // allow at most this many restartings of the algorithm\n  While(gcd =? 1 And? restarts>=?0)        // outer loop: this will be typically executed only once but it is needed to restart the iteration if it \"stalls\"\n  [\n          restarts--;\n    /* Pick a random value between 1 and n-1 */\n    x:= RandomInteger(n-1);\n\n    /* Initialize loop */\n    gcd:=1; y:=x;\n        repeat := 4;        // allow at most this many repetitions\n//                Echo({\"debug PollardRho: entering gcd loop, n=\", n});\n\n    /* loop until failure or success found */\n    While(gcd =? 1 And? repeat>=?0)\n    [\n      x:= Modulo( PollardRhoPolynomial(x), n);\n             y:= Modulo( PollardRhoPolynomial(\n                  Modulo( PollardRhoPolynomial(y), n)        // this is faster for large numbers\n          ), n);\n             If(x-y =? 0,\n                [\n                         gcd := 1;\n                         repeat--;        // guard against \"stalling\" in an infinite loop but allow a few repetitions\n                 ],\n                gcd:=Gcd(x-y,n)\n                );\n//                Echo({\"debug PollardRho: gcd=\",gcd,\" x=\", x,\" y=\", y});\n           ];\n        If(InVerboseMode() And? repeat<=?0, Echo({\"PollardRhoFactorize: Warning: stalled while factorizing \", n, \"; counters \", x, y}));\n  ];\n  Check(restarts>?0, \"Math\", \"PollardRhoFactorize: Error: failed to factorize \" : ToString(n));\n  If(InVerboseMode() And? gcd >? 1, Echo({\"PollardRhoFactorize: Info: while factorizing \", n, \" found factor \", gcd}));\n  /* Return result found */\n  PollardCombineLists(PollardRhoFactorize(gcd), PollardRhoFactorize(Quotient(n,gcd)));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/pollardrho/PollardRhoFactorize.mpw";
        scriptMap.put("PollardRhoFactorize",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*------------------------------------------------------------------------\n *  Finds the Content of a univariate or multivariate polynomial\n *      mod 100727 by hso:  conform to majority definition of \"Content\"\n *------------------------------------------------------------------------*/\n\n//Retract(\"xContent\",*);\n\n\n//10 # xContent( poly_IsPolynomial ) <--\n10 # xContent( poly_CanBeUni ) <--\n[\n    Local(disassem,gcdCoefs,lc,minExpts);\n    disassem := DisassembleExpression(poly);\n    gcdCoefs := Gcd(disassem[3]);\n    lc       := LeadingCoef(poly);\n    If(IsNegativeNumber(lc) And? gcdCoefs >? 0, gcdCoefs:=-gcdCoefs);\n    //minExpts := Minimum /@ Transpose(disassem[2]);\n    //gcdCoefs * Product(disassem[1]^minExpts);\n    gcdCoefs;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/xContent.mpw";
        scriptMap.put("xContent",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"xFactor\",*);\n\n10 # xFactor( p_CanBeUni ) <-- FW(xFactors(p));\n\n\n10 # xFactor( p_IsRationalFunction ) <--\n[\n    Local(fs,n,d);\n    fs := xFactors( p );\n    n  := FW(Numerator(fs));\n    d  := FW(Denominator(fs));\n    n/d;\n];\n\n\n10 # xFactor( L_IsList ) <-- \n[\n    Local (result,x,f);\n    result := {};\n    ForEach(x,L)\n    [\n        f := xFactors(x);\n        If( f =? {}, f := 0, f := FW(f) );\n        DestructiveAppend(result,f);\n    ];\n    result;\n];\n\n\n\n20 # xFactor( _expr ) <-- expr;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/xFactor.mpw";
        scriptMap.put("xFactor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*------------------------------------------------------------------------\n *  PENULTIMATE VERSION \n *    Started 091222\n *    revised 100108-22\n *    revised 100215\n *    revised 100301\n *------------------------------------------------------------------------*/\n\n//Retract(\"xFactors\",*);\n//Retract(\"xFactorsPrimitivePart\",*);\n//Retract(\"xFactorsUnivariate\",*);\n//Retract(\"xFactorsMultivariate\",*);\n//Retract(\"xFactorsHomogeneousBivariate\",*);\n//Retract(\"CheckForSpecialForms\",*);\n\n//Retract(\"ApproximateRealCoefficients\",*);\n//Retract(\"FixUpMonicFactors\",*);\n//Retract(\"CombineNumericalFactors\",*);\n//Retract(\"IsPureRational\",*);\n//Retract(\"HasRealCoefficients\",*);\n//Retract(\"HasRationalCoefficients\",*);\n//Retract(\"matchPower\",*);\n//Retract(\"IsIrreducible\",*);     //      NOT YET OPERATIONAL\n\n\n/* --------------    LISTS    ---------------*/\n\n10 # xFactors( L_IsList ) <-- xFactors /@ L;\n\n\n/* -------------    NUMBERS    --------------*/\n\n\n10 # xFactors(p_IsPositiveInteger) <--  \n[\n    If( p <? 1600, FactorsSmallInteger(p), FactorizeInt(p) );\n];\n\n\n12 # xFactors(p_IsNegativeInteger) <-- xFactors(-p);\n\n\n14 # xFactors(p_IsRational)_(Denominator(p) !=? 1) <-- \n             { {xFactor(Numerator(p)) / xFactor(Denominator(p) ) , 1} }; \n             \n\n16 # xFactors(p_IsGaussianInteger)        <-- GaussianFactors(p);\n\n\n18 # xFactors(_p)_(Length(VarList(p))=?0) <-- {{p,1}};\n\n\n\n/* -------------    POLYNOMIALS -- CAN BE UNI   --------------*/\n\n21 # xFactors( poly_CanBeUni ) <--\n[\n    If(InVerboseMode(),Tell(\"xFactors_can_be_uni_100122\",poly));\n    Local(content,pp,ppFactors,monomialFactors,result);\n    Local(vars,nvars,disassem,degrees,mpoly,nterms,allCoeffs,allPowers);\n    Local(hasRealCoefficients,hasRationalCoefficients,isHomogeneous);\n\n    //  First, check to see if the polynomial has any REAL coefficients.\n    //  If so, convert to approximate integers (with divisor).\n    hasRealCoefficients := HasRealCoefficients(poly);\n    If( hasRealCoefficients, \n      [\n         Local(realPoly);\n         realPoly  := poly;   //  just in case -- save original form\n         disassem  := DisassembleExpression(poly);\n         allCoeffs := disassem[3];\n         allPowers := Flatten(disassem[2],\"List\");\n         poly      := ApproximateRealCoefficients(poly);\n      ]\n    );\n    \n    //  Also, check to see if the polynomial has Rational coeffs\n    hasRationalCoefficients := HasRationalCoefficients(poly);\n    \n    // Now: get Content and Primitive Part\n    content := xContent( poly );\n    pp      := xPrimitivePart( poly, content );\n    If(InVerboseMode(),Tell(\"  \",{content,pp}));\n    vars     := VarList(pp);\n    nvars    := Length(vars);\n    disassem := DisassembleExpression(pp);\n    nterms   := Length(disassem[3]);\n    degrees  := {};\n    allCoeffs         := disassem[3];\n    allPowers         := Flatten(disassem[2],\"List\");\n    If(nvars >? 0,\n      [\n        ForEach(v,vars)\n           [ DestructiveAppend(degrees,Degree(pp,v)); ];\n        isHomogeneous     := [\n            // A polynomial is homogeneous of degree n \n            // if all terms have degree n.   \n            Local(sd,cmp); \n            sd  := Sum /@ disassem[2];\n            cmp := FillList(sd[1],Length(sd));\n            IsZeroVector(sd - cmp);\n        ];\n      ]\n    );\n    \n    // Experimental: \n    //   Attach a set of Meta-Keys to pp, describing\n    //   some of the above information\n    pp := MetaSet(pp,\"nvars\",nvars);\n    pp := MetaSet(pp,\"nterms\",nterms);\n    pp := MetaSet(pp,\"degrees\",degrees);\n    pp := MetaSet(pp,\"isHomogeneous\",isHomogeneous);\n    \n    If(InVerboseMode(),\n      [\n        Tell(\"               \",vars);\n        Tell(\"              \",nvars);\n        Tell(\"             \",nterms);\n        Tell(\"            \",degrees);\n        Tell(\"           \",disassem);\n        Tell(\"          \",allCoeffs);\n        Tell(\"          \",allPowers);\n        Tell(\"      \",isHomogeneous);\n        NewLine();\n      ]\n    );\n    \n    //  OK.  Now factor the PrimitivePart\n    ppFactors := xFactorsPrimitivePart( pp );\n\n    If(InVerboseMode(),[NewLine();Tell(\"  \",ppFactors);]);\n    \n    // Next, include the factors of the Content, if any\n    If(InVerboseMode(),NewLine());\n    monomialFactors := FactorsMonomial(content);\n    If(InVerboseMode(),[Tell(\"  \",monomialFactors);]);\n    If( monomialFactors[1][1] =? 1,\n        result := ppFactors,        \n        result := Concat(monomialFactors,ppFactors)\n    );\n    \n    If(InVerboseMode(),[NewLine();Tell(\"  final  \",result);]);\n    result;\n];\n\n\n\n// -----------------  FACTOR PRIMITIVE PART  -----------------\n\n     //  special case: binomials\n10 # xFactorsPrimitivePart( _pp )_(nterms=?2) <--\n[\n    If(InVerboseMode(),Tell(\"Binomial\"));\n    Local(ppFactors);\n    ppFactors := xFactorsBinomial(pp);\n];\nUnFence(\"xFactorsPrimitivePart\",1);\n\n\n     //  special case: homogeneous bivariates\n12 # xFactorsPrimitivePart( _pp )_(isHomogeneous And? nvars=?2) <--\n[\n    If(InVerboseMode(),Tell(\"Homogeneous and Bivariate\"));\n    Local(ppFactors);\n    ppFactors := xFactorsHomogeneousBivariate(disassem);\n];\nUnFence(\"xFactorsPrimitivePart\",1);\n\n\n     //  special case:  no variables in pp!\n14 # xFactorsPrimitivePart( _pp )_(nvars=?0) <--\n[\n    Local(ppFactors);\n    ppfactors := {};\n];\n\n\n     //  general case: univariate\n16 # xFactorsPrimitivePart( _pp )_(nvars=?1) <--  xFactorsUnivariate(pp);\nUnFence(\"xFactorsPrimitivePart\",1);\n\n\n     //  general case: multivariate\n18 # xFactorsPrimitivePart( _pp )_(nvars>?1) <-- xFactorsMultivariate(pp);\nUnFence(\"xFactorsPrimitivePart\",1);\n\n\n     //  catch-all: represents an ERROR CONDITION\n20 # xFactorsPrimitivePart( _pp ) <-- Tell(\"Should never get here!\");\nUnFence(\"xFactorsPrimitivePart\",1);\n\n\n\n// ----------------------  UNIVARIATE POLYNOMIALS  -----------------------\n\n30 # xFactorsUnivariate( poly_CanBeUni )_(Length(VarList(poly))=?1) <--\n[\n    Local(factrs,coeffs,deg,X,residuals,factrsnew);\n\n    If(InVerboseMode(),\n      [\n         NewLine();\n         Tell(\"xFactorsUnivariate\",poly);\n         Tell(\"       \",allCoeffs);\n      ]\n    );\n    \n    // OK, First, send it through MathPiper's basic factoring function\n    // for univariate polynomials\n    \n    factrs := BinaryFactors(poly);\n    If(InVerboseMode(),Tell(\"   output of BinaryFactors\",factrs));\n\n    //    Now fix-up the (monic) factors found above, to express them\n    // as linear in x with integer coefficients.  \n    //    Also, separate out any 'residual' factors -- defined here as\n    // factors of degree >? 2.\n    \n    {factrsnew,residuals} := FixUpMonicFactors(factrs);\n    \n    //  See if we can do something with the residuals\n    Local(residOut);\n    residOut := {};\n    If(Length(residuals) >? 0, residOut := xFactorsResiduals( residuals ) );\n    \n    If(InVerboseMode(),\n      [\n          NewLine();\n          Tell(\" just before end of univariate factoring\");\n          Tell(\"    \",factrs);\n          Tell(\"    \",factrsnew);\n          Tell(\"    \",residOut);\n      ]\n    );   \n    //  Finally, the output --------\n    Local(final);\n    If(Length(Union(factrsnew,residOut)) >? 0,\n        final := Concat(factrsnew,residOut),\n        final := factrs\n    );\n    CheckForSpecialForms( final );\n];   //   xFactorsUnivariate\nUnFence(\"xFactorsUnivariate\",1);\n\n\n// ----------------  MULTIVARIATE POLYNOMIALS  -----------------\n\n40 # xFactorsMultivariate( poly_CanBeUni )_(Length(VarList(poly))>?1) <--\n[\n    Local(factrs);\n    \n    If(InVerboseMode(),[NewLine();Tell(\"xFactorsMultivariate\",poly);]);\n    If( nterms =? 2,\n      [\n        If(InVerboseMode(),Tell(\"   Is Binomial\"));\n        factrs := xFactorsBinomial(poly); \n      ],\n      [\n        If(InVerboseMode(),Tell(\"   Has more than 2 terms\"));\n      ]\n    );\n    factrs;\n];\nUnFence(\"xFactorsMultivariate\",1);\n\n\n// ------------------  HOMOGENEOUS BIVARIATE  ------------------\n\n10 # xFactorsHomogeneousBivariate( dis_IsList ) <-- \n[\n    If(InVerboseMode(),[NewLine();Tell(\"xFactorsHomogeneousBivariate\",dis);]);\n    Local(dis1,f,lst,dis2,poly1,ppFactors,residuals,ii,preassem);\n    dis1  := {{xi},{{X},{X[1]}} /@ dis[2],dis[3]};\n    If(InVerboseMode(),Tell(\"   \",dis1));\n    poly1 := Sum(ReassembleListTerms(dis1));\n    If(InVerboseMode(),Tell(\"   \",poly1));\n    ppFactors := BinaryFactors(poly1);\n    {ppFactors,residuals} := FixUpMonicFactors(ppFactors);\n    For(ii:=1,ii<=?Length(ppFactors),ii++)\n    [\n        f := ppFactors[ii];\n        If(InVerboseMode(),Tell(\"          \",f[1]));\n        lst := DisassembleExpression(f[1]);\n        If(InVerboseMode(),\n          [\n             Tell(\"               \",lst);\n             Tell(\"                            \",dis[1]);\n          ]\n        );\n        DestructiveReplace(lst,1,dis[1]);\n        DestructiveAppend(lst[2][1],0);\n        DestructiveAppend(lst[2][2],1);\n        If(InVerboseMode(),Tell(\"               \",lst));\n        preassem  := Sum(ReassembleListTerms(lst)) ;\n        If(InVerboseMode(),Tell(\"               \",preassem));\n        ppFactors[ii][1] := preassem;\n    ];\n    If(InVerboseMode(),[Tell(\"   \",ppFactors); Tell(\"   \",residuals);NewLine();] );  \n    ppFactors;\n];\nUnFence(\"xFactorsHomogeneousBivariate\",1);\n\n\n// ------------------  SPECIAL FORMS  ------------------\n\n10 # CheckForSpecialForms( final_IsList ) <-- \n[\n    If(InVerboseMode(),[NewLine();Tell(\"CheckForSpecialForms\",final);]);\n    Local(LL,ii,fact,mult,dis,new);\n    new := {};\n    LL  := Length(final);\n    For(ii:=1,ii<=?LL,ii++)\n    [\n        fact := final[ii][1];\n        mult := final[ii][2];\n        If(InVerboseMode(),Tell(\"   \",{fact,mult}));\n        dis := DisassembleExpression( fact );\n        If(InVerboseMode(),Tell(\"   \",dis));\n        Local(var);\n        var := dis[1][1];\n        if ( dis[2]=?{{4},{2},{0}} And? dis[3]=?{1,1,1} )\n            [\n                Local(new1,new2);\n                new1 := {var^2-var+1,mult};\n                new2 := {var^2+var+1,mult};\n                DestructiveAppend(new,new1);\n                DestructiveAppend(new,new2);\n                If(InVerboseMode(),Tell(\"   \",new));\n            ]\n        else\n            [\n                If(InVerboseMode(),Tell(\"   no special form\"));\n                DestructiveAppend(new,{fact,mult});\n            ];\n        );\n    ];\n    new;\n];\n\n\n// ---------------------   OTHER STUFF ------------------------\n\n\n10 # ApproximateRealCoefficients( poly_IsPolynomial ) <--\n[\n    // If the polynomial has REAL coefficients, convert them to\n    // approximate integers\n    If(InVerboseMode(),[NewLine();Tell(\"  REAL\",poly);]);\n    Local(coeffs,gcd,lcm);\n    coeffs := Rationalize /@ (allCoeffs);\n    If(InVerboseMode(),[Tell(\"      to-Q\",coeffs);Tell(\"      to-Z\",coeffs);]);\n    Local(gcd,lcm);\n    gcd    := Gcd(Numerator /@ coeffs);\n    lcm    := Lcm(Denominator /@ coeffs);\n    If(InVerboseMode(),[Tell(\"       \",gcd);Tell(\"       \",lcm);]);\n    disassem[3] := coeffs;\n    allCoeffs   := coeffs;\n    poly        := Sum(ReassembleListTerms(disassem));\n    If(InVerboseMode(),Tell(\"   new\",poly));\n    poly;\n];\nUnFence(\"ApproximateRealCoefficients\",1);\n\n\n100 # CombineNumericalFactors( factrs_IsList ) <--\n[\n      If( InVerboseMode(), Tell(\"Combine\",factrs) );\n      Local(q,a,b,t,f,ff,err);\n      err := False;\n      t   := 1;\n      f   := {};\n      ForEach(q,factrs)\n      [\n          If( InVerboseMode(), Tell(1,q) );\n          If( IsList(q) And? Length(q)=?2,\n            [\n                {a,b} := q;\n                If( InVerboseMode(), Echo(\"     \",{a,b}) );\n                If( IsNumericList( {a,b} ),\n                    t := t * a^b,\n                    f := {a,b}:f\n                );\n            ],\n              err := True\n          );\n      ];\n      If( InVerboseMode(),\n        [\n            Echo(\"      t = \",t);\n            Echo(\"      f = \",f);\n            Echo(\"    err = \",err);\n        ]\n      );\n      ff := If(Not? err And? t !=? 1, {t,1}:Reverse(f), factrs);\n      ff := Select(Lambda({x},x!=?{1,1}),ff);\n      If(ff[1]<?0,ff[1]:=-ff[1]);\n];\n\n\n// ----------------  RATIONAL POLYNOMIALS  -----------------\n\n150 # xFactors( expr_IsRationalFunction )_\n        (IsPolynomial(Numerator(expr)) And? IsPolynomial(Denominator(expr))) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"xFactors_Rational_Function\",expr);]);\n    Local(Numer,Denom,fNumer,fDenom);\n    Numer  := Numerator(expr);\n    Denom  := Denominator(expr);\n    fNumer := xFactors(Numer);\n    fDenom := xFactors(Denom);\n    If(InVerboseMode(),[Tell(\"   \",fNumer); Tell(\"   \",fDenom);]);\n    fNumer/fDenom;\n];\n\n\n152 # xFactors( expr_IsRationalFunction )_\n        (IsConstant(Numerator(expr)) And? IsPolynomial(Denominator(expr))) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"xFactors_Rational_Denom\",expr);]);\n    Local(Numer,Denom,fNumer,fDenom);\n    Numer  := Numerator(expr);\n    Denom  := Denominator(expr);\n    fNumer := xFactors(Numer);\n    fDenom := xFactors(Denom);\n    If(InVerboseMode(),[Tell(\"   \",fNumer); Tell(\"   \",fDenom);]);\n    fNumer/fDenom;\n];\n\n\n// ----------   POSSIBLE NON-INTEGER EXPONENTS  ----------\n\n200 # xFactors( _expr )_(Length(VarList(expr)) =? 1) <--\n[\n    If(InVerboseMode(),[NewLine();Tell(\"Some other kind of expression\",expr);]);\n    Local(dis,X,pows);\n    dis := DisassembleExpression(expr);\n    X   := VarList(expr)[1];\n    pows := matchPower /@ dis[1];\n    rats := NearRational /@ pows;\n    dis[1] := x^rats;\n    p := Sum(ReassembleListTerms(dis));\n    If(InVerboseMode(),Tell(\"    new \",p));\n    xFactors(p);\n];\n\n\n\n\n10 # IsPureRational( N_IsRational )_(Not? IsInteger(N)) <-- True;\n\n12 # IsPureRational( _N ) <-- False;\n\n\n10 # HasRealCoefficients( poly_IsPolynomial ) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsDecimal\")) >? 0);\n];\n\n10 # HasRealCoefficients( poly_IsMonomial ) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsDecimal\")) >? 0);\n];\n\n\n10 # HasRationalCoefficients( poly_IsPolynomial ) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    //Tell(\"              \",disassem);\n    (Length(Select(disassem[3],\"IsPureRational\")) >? 0);\n];\n\n10 # HasRationalCoefficients( poly_IsMonomial) <--\n[\n    Local(disassem);\n    disassem := DisassembleExpression(poly);\n    (Length(Select(disassem[3],\"IsPureRational\")) >? 0);\n];\n\n\n10 # FixUpMonicFactors( factrs_IsList ) <--\n[\n    If(InVerboseMode(),[ NewLine(); Tell(\"   doing monic fixup\"); ] );\n    Local(factrsnew,residuals,uni);\n    factrsnew := {};\n    residuals := {};\n    ForEach(f,factrs)\n    [\n        If(InVerboseMode(),Tell(\"               \",f));\n        uni := MakeUni(f[1]);\n        If(InVerboseMode(),Tell(\"                    \",uni));\n        If( Degree(f[1])=?1,\n          [\n            Local(cc,lcm,fnew);\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            cc      := Coef(f[1],uni[1],0 .. 1);\n            //Tell(\"                       \",cc);\n            lcm     := Lcm( Denominator /@ cc );\n            uni[3]  := lcm * cc;\n            fnew    := NormalForm(uni);\n            If( hasRationalCoefficients,\n              [\n                 DestructiveAppend(factrsnew,f);\n              ],\n              [ \n                 DestructiveAppend(factrsnew,{fnew,f[2]});\n              ]\n            );\n          ]\n        );\n        If( Degree(f[1])=?2,\n          [\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            Local(pq);\n            pq      := PrimitivePart(f[1]);\n            DestructiveAppend(factrsnew,{pq,f[2]});\n          ]\n        );\n        //  If any factors have degree >=3, store them in a 'residuals' array\n        //  for further analysis\n        If( Degree(f[1]) >? 2,\n          [\n            If(InVerboseMode(),Tell(\"                          \",Degree(f[1])));\n            Local(pq);\n            pq      := PrimitivePart(f[1]);\n            DestructiveAppend(residuals,{pq,f[2]});\n            If(InVerboseMode(),Tell(\"                   appending to residuals\",pq));\n          ]\n        );       \n    ];\n    {factrsnew,residuals};\n];\nUnFence(\"FixUpMonicFactors\",1);\n\n10 # IsIrreducible( poly_IsPolynomial )_(Length(VarList(poly))=?1) <--\n[\n    //  If these tests return True, the polynomial IS irreducible..\n    //  If they return False, the reducibility of the polynomial is\n    //  not established, one way or the other.\n    //\n    // ----   THIS FUNCTION IS NOT YET COMPLETE OR USEABLE   ---\n    If(InVerboseMode(),Tell(\"IsIrreducible\",poly));\n    Local(var,deg,coeffs,num1);\n    var    := VarList(poly)[1];\n    deg    := Degree(poly);\n    coeffs := Coef(poly,var,deg .. 0);\n    If(InVerboseMode(),Tell(\"   \",deg));\n    Local(ii,res,nprimes);\n    nprimes := 0;\n    For(ii:=-3*deg,ii<=?3*deg,ii:=ii+3)\n    [\n        res := N(Subst(x,ii) poly);\n        //Tell(\"      \",{ii,res,IsPrime(res)});\n        If(Abs(res)=?1 Or? IsPrime(res), nprimes := nprimes + 1, );\n    ];\n    Tell(\"   \",nprimes);\n    If(nprimes >? 2*deg, True, False );\n];\n\n\n10 # matchPower(_Z^n_IsNumber) <-- n;\n\n15 # matchPower(_Z) <-- 1;\n\n\n//========================================================================\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/xFactors.mpw";
        scriptMap.put("xFactors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"xFactorsResiduals\",*);\n//Retract(\"trySQF\",*);\n//Retract(\"tryRealRoots\",*);\n//Retract(\"processRealRoots\",*);\n\n10 # xFactorsResiduals( residualList_IsList ) <--\n[\n    If(InVerboseMode(),[NewLine(); Tell(\"Residuals\",residualList);]);\n    If(InVerboseMode(),Tell(\"  --\",content));\n    If(InVerboseMode(),Tell(\"  --\",factrs));\n    If(InVerboseMode(),Tell(\"  --\",factrsnew));\n    If(InVerboseMode(),Tell(\"  --\",residuals));\n    If(InVerboseMode(),Tell(\"  -- original \",degrees));\n    Local(resid,sqf,sqfGood,rrGood);\n    \n    //  ---  see if Square-Free factoring can find some factors\n\n    residualList := trySQF(residualList);   //  hso\n    \n    If(InVerboseMode(),\n      [\n         Tell(\"   after trying SQF on all residuals\");\n         Tell(\"          \",sqfGood);\n         Tell(\"          \",factrsnew);\n         Tell(\"          \",residualList);\n         NewLine();\n      ]\n    );\n    \n    //  ---  see if there are any REAL roots to help with factoring\n\n    tryRealRoots(residualList);\n    \n    If(InVerboseMode(),\n      [\n         Tell(\"   after trying for REAL roots on all residuals\");\n         Tell(\"          \",rrGood);\n         Tell(\"          \",factrsnew);\n         Tell(\"          \",residuals);\n         Tell(\"          \",residualList);\n         NewLine();\n      ]\n    );\n\n     residOut;\n];\nUnFence(\"xFactorsResiduals\",1);\n\n\n\n10 # trySQF( residualList_IsList ) <--\n[\n    //--- First, try SquareFree factorization on these residuals \n    Local(resid,sqf);\n    If(InVerboseMode(),[NewLine(); Tell(\"trySQF\",residualList);]);\n    ForEach(resid,residualList)\n    [\n        If(InVerboseMode(),Tell(\"   \",resid));\n        \n        sqf := SquareFree(resid[1]);\n        If(InVerboseMode(),\n          [\n             Tell(\"          trying SQF\");\n             Tell(\"            \",resid[1]);\n             Tell(\"            \",sqf);\n          ]\n        );\n        If(Degree(sqf) <? Degree(resid[1]),\n          [\n            If(InVerboseMode(),Tell(\"               sqf helps factor resid\"));\n            sqfGood := True;\n            Local(f1,f2);\n            f1 := sqf;\n            f2 := Simplify(resid[1]/sqf);\n            If( f2 =? f1,\n                 factrsnew := Concat({{f1,2*resid[2]}},factrsnew),\n                 factrsnew := Concat({{f1,resid[2]},{f2,resid[2]}},factrsnew)\n            );\n            //HSO experimental\n            residuals := Difference(residuals,{resid});\n            If(InVerboseMode(),Tell(\"                       new\",residuals));\n            residualList := residuals;\n          ],\n          [\n            If(InVerboseMode(),\n              [\n                 Tell(\"               sqf DOES NOT HELP factor resid\");\n                 sqfGood := False;\n              ]\n            );\n          ]\n        );\n        If(InVerboseMode(),Tell(\"            after sqf \",factrsnew));\n        If(InVerboseMode(),Tell(\"                      \",residuals));\n        If(InVerboseMode(),Tell(\"                      \",residualList));  // hso\n    ];\n    residualList;   //  hso\n];\nUnFence(\"trySQF\",1);\n\n\n\n10 # tryRealRoots(residualList_IsList)_(Length(residualList)>?0) <--\n[\n    //--- See if there are any REAL roots to factor out\n    If(InVerboseMode(),[NewLine(); Tell(\"tryRealRoots\",residualList);]);\n    ForEach(resid,residualList)\n    [\n        Local(nrr,rr,ptry,uptry);\n        nrr := RealRootsCount(resid[1]);\n        If(InVerboseMode(),\n          [ Tell(\"            this \",resid[1]); Tell(\"            \",nrr); ]\n        );\n        If( nrr >? 0, rr := FindRealRoots(resid[1]), rr := {} );\n        processRealRoots(rr);\n        \n        If( nrr =? 2,\n          [\n             If( nrr =? 0,\n               [\n                  //  OhOh - no real solutions -- have to try something else\n                  If(InVerboseMode(),\n                    [\n                       NewLine();\n                       Tell(\"               NO real solutions\");\n                       Tell(\"               try something else\");\n                    ]\n                  );\n                  //  Here go some ad-hoc solutions that can be useful....\n                  Local(u,X);\n                  u := MakeUni(resid[1]);\n                  X := u[1];\n                  If( u[2]=?0 And? u[3]=?{1,0,1,0,1},\n                    [ \n                       DestructiveAppend(residOut,{X^2-X+1,1});\n                       DestructiveAppend(residOut,{X^2+X+1,1});\n                       If(InVerboseMode(),\n                         [\n                            Tell(\"     found \",factrsnew);\n                            Tell(\"           \",resid);\n                            Tell(\"           \",factrs);\n                            Tell(\"           \",residOut);\n                         ]\n                       );\n                    ]\n                  );\n               ],\n               [\n                  //  more than 2 real solutions -- have to do a bit more work\n                  rr := FindRealRoots(resid[1]);\n                  If(InVerboseMode(),Tell(\"    \",rr));\n                  // try them pairwise\n                  goodptry := {};\n                  For(ii:=1,ii<?nrr,ii++)\n                      For(jj:=ii+1,jj<=?nrr,jj++)\n                      [\n                          If(InVerboseMode(),Tell(\"   \",{ii,jj}));\n                          ptry     := Expand((x-rr[ii])*(x-rr[jj]));\n                          uptry    := MakeUni(ptry);\n                          uptry[3] := \"NearRational\" /@ uptry[3];\n                          If(InVerboseMode(),Tell(\"    rat\",uptry[3]));\n                          If(InVerboseMode(),Tell(\"  \",Maximum(Denominator /@ uptry[3])));\n                          If( Maximum(Denominator /@ uptry[3]) <? 100,\n                            [ DestructiveAppend(goodptry,NormalForm(uptry)); ]    );\n                      ];\n                  If(InVerboseMode(),Tell(\"    \",goodptry));\n                  If(Length(goodptry) >? 0,\n                    [\n                       ForEach(pt,goodptry)\n                         [ DestructiveAppend(residOut,{pt,1}); ];\n                    ]\n                  );\n               ]\n             );  //   if nrr=?0\n          ]\n        );  //  if nrr=?2\n     ];  \n];\nUnFence(\"tryRealRoots\",1);\n\n\n10 # processRealRoots( rr_IsNumericList )_(Length(rr) =? 1) <--\n[\n    //  Only one real root, so it will probably be of no help\n    //  in factoring, unless it is integer or small rational\n    If(InVerboseMode(),Tell(\"  Only 1 real root\",rr));\n    Local(root);\n    root := rr[1];\n    rrGood := False;\n    If(IsInteger(root), \n      [\n          If(InVerboseMode(),Tell(\"    integer \",root));\n          rrGood := True;\n      ],\n      [\n          Local(rroot);\n          rroot := NearRational(root);\n          If(InVerboseMode(),Tell(\"    rational \",rroot));\n          If(Denominator(rroot) <? 100, [root := rroot; rrGood:=True;] );\n      ]\n    );\n    \n];\nUnFence(\"processRealRoots\",1);\n\n\n10 # processRealRoots( rr_IsNumericList )_(Length(rr) =? 2) <--\n[\n    // a pair of real solutions -- probably form a quadratic\n    ptry  := Expand((x-rr[1])*(x-rr[2]));\n    If(InVerboseMode(),[Tell(\"    \",rr);Tell(\"    \",ptry);]);\n    uptry    := MakeUni(ptry);\n    uptry[3] := \"NearRational\" /@ uptry[3];\n    ptry     := NormalForm(uptry);\n    If(InVerboseMode(),Tell(\"    \",ptry));\n    If( Abs(Lcm(uptry[3])) <? 100,\n      [\n         //  looks OK -- try to use it\n         Local(f1,f2,new);\n         f1    := ptry;\n         f2    := Simplify(resid[1]/f1);\n         new   := {{f1,resid[2]},{f2,resid[2]}};\n         If(InVerboseMode(),Tell(\"    \",new));\n         resid := new;\n         residOut := new;\n         If(InVerboseMode(),Tell(\"    \",residOut)); \n      ]\n    );\n];\nUnFence(\"processRealRoots\",1);\n\n\n\n10 # processRealRoots( rr_IsNumericList )_(Length(rr) >=? 4) <--\n[\n     //  more than 2 real solutions -- have to do a bit more work\n     If(InVerboseMode(),Tell(\"    \",rr));\n     // try them pairwise\n     goodptry := {};\n     For(ii:=1,ii<?nrr,ii++)\n         For(jj:=ii+1,jj<=?nrr,jj++)\n         [\n             If(InVerboseMode(),Tell(\"   \",{ii,jj}));\n             ptry     := Expand((x-rr[ii])*(x-rr[jj]));\n             uptry    := MakeUni(ptry);\n             uptry[3] := \"NearRational\" /@ uptry[3];\n             If(InVerboseMode(),Tell(\"    rat\",uptry[3]));\n             If(InVerboseMode(),Tell(\"  \",Maximum(Denominator /@ uptry[3])));\n             If( Maximum(Denominator /@ uptry[3]) <? 100,\n               [ DestructiveAppend(goodptry,NormalForm(uptry)); ]    );\n         ];\n         If(InVerboseMode(),Tell(\"    \",goodptry));\n         If(Length(goodptry) >? 0,\n           [\n               ForEach(pt,goodptry)\n               [ DestructiveAppend(residOut,{pt,1}); ];\n           ]\n         );\n     ];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/xFactorsResiduals.mpw";
        scriptMap.put("xFactorsResiduals",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"xPrimitivePart\",*);\n    \n10 # xPrimitivePart(poly_CanBeUni) <-- \n[\n    Local(cont,pp);\n    If(InVerboseMode(),Tell(\"  xPrimitivePart1\",poly));\n    cont := xContent(poly);\n    pp   := poly / cont;\n    //pp   := Simplify(Simplify(pp));\n];\n\n\nMacro(\"xPrimitivePart\",{poly,xcont})\n[\n    Local(pp);\n    If(InVerboseMode(),Tell(\"  xPrimitivePart2\",{poly,xcont}));\n    \n    If( IsBound(@xcont), \n      [\n          pp := Eval(@poly) / Eval(@xcont);\n      ],\n      [\n          Local(xCont);\n          xCont  := xContent(Eval(@poly));\n          @xcont := xCont;\n          pp     := Eval(@poly) / xCont;\n      ]\n    );\n    pp;\n    //pp   := Simplify(Simplify(pp));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/factors/xPrimitivePart.mpw";
        scriptMap.put("xPrimitivePart",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Apply(_applyoper,_applyargs) _ (Or?(IsString(applyoper), IsList(applyoper))) <-- ApplyFast(applyoper,applyargs);\n20 # Apply(applyoper_IsAtom,_applyargs) <-- ApplyFast(ToString(applyoper),applyargs);\n\n30 # Apply(Lambda(_args,_body),_applyargs) <-- `ApplyFast(Hold({@args,@body}),applyargs);\nUnFence(\"Apply\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/Apply.mpw";
        scriptMap.put("Apply",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* NFunction(\"new'func\", \"old'func\" {arg'list}) will define a wrapper function\naround  \"old'func\", called \"new'func\", which will return \"old'func(arg'list)\"\nonly when all arguments are numbers and will return unevaluated\n\"new'func(arg'list)\" otherwise. */\nLocalSymbols(NFunction'Numberize)\n[\nNFunction(new'name_IsString, old'name_IsString, arg'list_IsList) <-- [\n        MacroRulebase(new'name, arg'list);\n        MacroRule(new'name, Length(arg'list), 0,        // check whether all args are numeric\n                ListToFunction({IsNumericList, arg'list})\n        )\n\n                /* this is the rule defined for the new function.\n                // this expression should evaluate to the body of the rule.\n                // the body looks like this:\n                // NFunction'Numberize(old'name(arg'list))\n                */\n                        NFunction'Numberize(ListToFunction({ToAtom(\"@\"), old'name, arg'list}));\n                        // cannot use bare '@' b/c get a syntax error\n\n];\n\n// this function is local to NFunction.\n// special handling for numerical errors: return Undefined unless given a number.\n10 # NFunction'Numberize(x_IsNumber) <-- x;\n20 # NFunction'Numberize(x_IsAtom) <-- Undefined;\n// do nothing unless given an atom\n\n];        // LocalSymbols()\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/NFunction.mpw";
        scriptMap.put("NFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"@\",{func,arg});\nRule(\"@\",2,1,IsList(arg)) Apply(func,arg);\nRule(\"@\",2,2,True       ) Apply(func,{arg});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/atsign_operator.mpw";
        scriptMap.put("@",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Operators for functional programming. todo:tk:move some of this documentation into the proper function's .mpw files.\n * Examples:\n *  a:b:c:{}       ->  {a,b,c}\n *  \"Sin\" @ a      ->   Sin(a)\n *  \"Sin\" @ {a,b}  ->   Sin(a,b)\n *  \"Sin\" /@ {a,b} ->   {Sin(a),Sin(b)}\n *  1 .. 4         ->   {1,2,3,4}\n */\n\n\n/* a : b will now return unevaluated (rather than cause error of invalid argument in Concat) if neither a nor b is a list and if one of them is not a string\n*/\nRulebase(\":\",{head,tail});\nRule(\":\",2,20,IsList(head) And? Not? IsList(tail) ) Concat(head,{tail});\nRule(\":\",2,30,IsList(tail) ) Concat({head},tail);\nRule(\":\",2,10,IsString(tail) And? IsString(head)) ConcatStrings(head,tail);\nUnFence(\":\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/colon_operator.mpw";
        scriptMap.put(":",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n.. operator is implemented with the Table function.\n*/\n10 # (count'from_IsInteger .. count'to_IsInteger)_(count'from <=? count'to)\n   <-- Table(i,i,count'from,count'to,1);\n20 # (count'from_IsInteger .. count'to_IsInteger)\n   <-- Table(i,i,count'from,count'to,-1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/dot_dot_operator.mpw";
        scriptMap.put("..",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"/@\",{func,lst}) Apply(\"MapSingle\",{func,lst});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/functional/slash_atsign_operator.mpw";
        scriptMap.put("/@",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nHtmlNewParagraph\nHtmlAnchor\nHtmlLink\nHtmlTable\nHtmlCaption\nHtmlTitle\nHtmlFrameSetRows\nHtmlFrameSetCols\nHtmlFrame\nHtmlTag\nHtmlForm\nBullets\nBullet\nHtmlTextArea\nHtmlTextField\nHtmlSubmitButton\nSetHtmlDirectory\nHtmlFile\nClearSite\nLoadSite\nSaveSite\nMySQLQuery\n*/\n\n\n/* code to generate html */\n\n\n/* Global defines */\nanchor:={};\nanchor[\"0\"]:=\"a\";\nanchor[\"name\"]:=\"\";\n\nlink:={};\nlink[\"0\"]:=\"a\";\nlink[\"href\"]:=\"\";\n\nframeset:={};\nframeset[\"0\"]:=\"frameset\";\nframeset[\"border\"]:=\"0\";\n\nframe:={};\nframe[\"0\"]:=\"frame\";\n\ncaption:={};\ncaption[\"0\"]:=\"caption\";\n\ntable:={};\ntable[\"0\"]:=\"table\";\n\nform:={};\nform[\"0\"]:=\"form\";\n\ntextarea:={};\ntextarea[\"0\"]:=\"textarea\";\n\ntextfield:={};\ntextfield[\"0\"]:=\"input\";\ntextfield[\"TYPE\"]:=\"text\";\n\nbutton:={};\nbutton[\"0\"]:=\"input\";\nbutton[\"TYPE\"]:=\"submit\";\n\nbullets:={};\nbullets[\"0\"]:=\"ul\";\n\nbullet:={};\nbullet[\"0\"]:=\"li\";\n\nnewline:=\"\n\";\nGt():=\"&gt;\";\nLt():=\"&lt;\";\n\n\n\n\nHtmlNewParagraph():= (newline : \"<p>\" : newline);\n\nHtmlTitle(title):=\n[\n\"<head>\n  <title>\" : title : \"</title>\n  <link rel=\\\"stylesheet\\\" href=\\\"piper.css\\\" TYPE=\\\"text/css\\\" MEDIA=\\\"screen\\\">\n</head>\";\n];\n\nHtmlAnchor(name):=\n[\n  anchor[\"name\"]:=name;\n  HtmlTag(anchor,\"\");\n];\n//Bodied(\"HtmlAnchor\",60000);\n\nHtmlTable(cellpadding,width,body):=\n[\n  table[\"cellpadding\"]:=ToString(cellpadding);\n  table[\"width\"]:=width;\n  HtmlTag(table,body);\n];\n\nBullets(list):=HtmlTag(bullets,list);\nBullet (list):=HtmlTag(bullet ,list);\n\n\nHtmlCaption(title):=\n[\n HtmlTag(caption,title);\n];\n\nHtmlForm(action,body):=\n[\n  form[\"method\"]:=\"get\";\n  form[\"action\"]:=action;\n  HtmlTag(form,body);\n];\n\n\nHtmlTextArea(name,width,height,body) :=\n[\n  textarea[\"name\"]:=name;\n  textarea[\"cols\"]:=ToString(width);\n  textarea[\"rows\"]:=ToString(height);\n  HtmlTag(textarea,body);\n];\n\nHtmlTextField(name,size,value):=\n[\n  textfield[\"name\"]:=name;\n  textfield[\"size\"]:=ToString(size);\n  textfield[\"value\"]:=value;\n  HtmlTag(textfield,\"\");\n];\n\nHtmlSubmitButton(name,value):=\n[\n  button[\"name\"]:=name;\n  button[\"value\"]:=value;\n  HtmlTag(button,\"\");\n];\n\n\nHtmlLink(description,file,tag,target):=\n[\n  If(tag !=? \"\",\n    link[\"href\"]:= file : \"#\" : tag,\n    link[\"href\"]:= file);\n\n  If(target !=? \"\",link[\"target\"] :=target);\n  HtmlTag(link,description);\n];\n\nHtmlFrameSetRows(columns,body):=\n[\n  frameset[\"cols\"]:=\"\";\n  frameset[\"rows\"]:=columns;\n  HtmlTag(frameset,body);\n];\n\nHtmlFrameSetCols(columns,body):=\n[\n  frameset[\"cols\"]:=columns;\n  frameset[\"rows\"]:=\"\";\n  HtmlTag(frameset,body);\n];\n\nHtmlFrame(source,name):=\n[\n  frame[\"src\"]:=source;\n  frame[\"name\"]:=name;\n  HtmlTag(frame,\"\");\n];\n\n\n/* export a html tag type, using the specifications in the\n   tags assoc list.\n   */\nHtmlTag(tags,content):=\n[\n  Local(result,tag,analytics);\n  result:=\"<\" : tags[\"0\"];\n  ForEach(tag,AssocIndices(tags))\n  [\n    If (tag !=? \"0\" And? tags[tag] !=? \"\",\n       result:= result : \" \" : tag : \"=?\" : \"\\\"\" : tags[tag] : \"\\\"\"\n       );\n  ];\n\n  analytics:=\"\";\n  If(tags[\"0\"] =? \"body\",\n    analytics:=\"<script src=\\\"http://www.google-analytics.com/urchin.js\\\" type=\\\"text/javascript\\\">\n</script>\n<script type=\\\"text/javascript\\\">\n_uacct = \\\"UA-2425144-1\\\";\nurchinTracker();\n</script>\n\");\n\n\n  result:= result : \">\" : newline :\n           content : newline :\n           analytics : \"</\" : tags[\"0\"] : \">\" : newline;\n\n  result;\n];\n\n/* output directory management */\nhtmldir:=\"\";\nSetHtmlDirectory(dir):= [htmldir:=dir;];\nHtmlFile(file) := [htmldir : file;];\n\n\n/* loading and saving site info */\nsite:={};\nClearSite() := [site:={};];\nLoadSite():=\n[\n  PipeFromFile(\"siteall\")\n  [\n    site:=Read();\n  ];\n];\n\nSaveSite():=\n[\n  PipeToFile(\"siteall\")\n  [\n    Write(site);\n    WriteString(\";\");\n  ];\n];\n\nMySQLQuery(pidstr,string):=\n[\n  Local(result);\n  PipeToFile(\"sqlin\":pidstr) WriteString(string);\n  SystemCall(\"mysql mysql < \":\"sqlin\":pidstr:\" > sqlout\":pidstr);\n  SystemCall(FindFile(\"tools/mysqlstubs\"):\" sqlout\":pidstr:\" sqlout_\":pidstr);\n  result:= PipeFromFile(\"sqlout_\":pidstr)Read();\n  SystemCall(\"rm -rf sqlin\":pidstr);\n  SystemCall(\"rm -rf sqlout\":pidstr);\n  SystemCall(\"rm -rf sqlout_\":pidstr);\n  result;\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/html/html.mpw";
        scriptMap.put("HtmlNewParagraph",scriptString);
        scriptMap.put("HtmlAnchor",scriptString);
        scriptMap.put("HtmlLink",scriptString);
        scriptMap.put("HtmlTable",scriptString);
        scriptMap.put("HtmlCaption",scriptString);
        scriptMap.put("HtmlTitle",scriptString);
        scriptMap.put("HtmlFrameSetRows",scriptString);
        scriptMap.put("HtmlFrameSetCols",scriptString);
        scriptMap.put("HtmlFrame",scriptString);
        scriptMap.put("HtmlTag",scriptString);
        scriptMap.put("HtmlForm",scriptString);
        scriptMap.put("Bullets",scriptString);
        scriptMap.put("Bullet",scriptString);
        scriptMap.put("HtmlTextArea",scriptString);
        scriptMap.put("HtmlTextField",scriptString);
        scriptMap.put("HtmlSubmitButton",scriptString);
        scriptMap.put("SetHtmlDirectory",scriptString);
        scriptMap.put("HtmlFile",scriptString);
        scriptMap.put("ClearSite",scriptString);
        scriptMap.put("LoadSite",scriptString);
        scriptMap.put("SaveSite",scriptString);
        scriptMap.put("MySQLQuery",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//todo:tk:this file need to be broken down further.\n\n//tk:this code was moved here from Integrate.mpw because it was causing a \n// \"rulebase with this arity already defined\" error.\n//hso:but the Rulebase line causes hang when processing in fold\n//Rulebase(\"IntegrateMultiplicative\",{var,from,a,b});\n\n//Retract(\"AntiDeriv\",*);\n//Retract(\"IntFunc\",*);\n\n\n////////////////////////////////////////////////\n//\n// Anti-derivative of a univariate polynomial\n//\n////////////////////////////////////////////////\n5  # AntiDeriv(_var, poly_CanBeUni(var) )\n     <-- NormalForm(AntiDeriv(var,`MakeUni(@poly,@var)));\n5 # AntiDeriv(_var,UniVariate(_var,_first,_coefs)) <--\n[\n  Local(result,i);\n  result:=FlatCopy(coefs);\n  For(i:=1,i<=?Length(result),i++)\n  [\n    result[i]:= result[i]/(first+i);\n  ];\n  UniVariate(var,first+1,result);\n];\n\n\n////////////////////////////////////////////////\n//\n// Standard additive properties of integration.\n//\n////////////////////////////////////////////////\n10 # AntiDeriv(_var,_x + _y) <-- AntiDeriv(var,x) + AntiDeriv(var,y);\n10 # AntiDeriv(_var,_x - _y) <-- AntiDeriv(var,x) - AntiDeriv(var,y);\n10 # AntiDeriv(_var,   - _y) <--            - AntiDeriv(var,y);\n\n10 # AntiDeriv(_var,_x/c_IsFreeOf(var) )_(HasExpr(x,var)) <-- AntiDeriv(var,x)/c;\n10 # AntiDeriv(_var,c_IsFreeOf(var)/_x )_(HasExpr(x,var) And? c!=? 1)\n        <-- c*AntiDeriv(var,1/x);\n\n\n////////////////////////////////////////////////\n//\n// Multiplying a polynomial with another (integrable)\n// function, Integrate by parts.\n//\n////////////////////////////////////////////////\n1570 # IntegrateMultiplicative(_var,(exy_CanBeUni(var)) * _exx,_dummy1,_dummy2)\n     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));\n1570 # IntegrateMultiplicative(_var,_exx * (exy_CanBeUni(var)),_dummy1,_dummy2)\n     <-- IntByParts(var,exy*exx,AntiDeriv(var,exx));\n10 # IntByParts(_var,_exy * _exx,Integrate(_var)(_something)) <--\n     `Hold(AntiDeriv(@var,((@exy)*(@exx))));\n20 # IntByParts(_var,_exy * _exx,_anti)_(Not? IsFreeOf(anti,exx)) <--\n     `Hold(AntiDeriv(@var,((@exy)*(@exx))));\n30 # IntByParts(_var,_exy * _exx,_anti) <--\n     [\n       Local(cf);\n       cf:=anti*Deriv(var)exy;\n//  Echo({exy*anti,exy*exx,cf});\n       exy*anti - `(AntiDeriv(@var,@cf));\n     ];\n\n////////////////////////////////////////////////\n//\n// Rational functions: f(x)/g(x) where f and g are\n// polynomials.\n//\n////////////////////////////////////////////////\n1570 # IntegrateMultiplicative(_var,(exy_CanBeUni(var)) / (exx_CanBeUni(var)),_dummy1,_dummy2) <--\n     IntRat(var,exy/exx,MakeUni(exy,var),MakeUni(exx,var));\n\n10 # IntRat(_var,_exy / _exx,_exyu,_exxu)_\n     (Degree(exyu) >? Degree(exxu) Or? Degree(Gcd(exyu,exxu)) >? 0) <--\n     [\n     Local(gcd);\n     gcd:=Gcd(exxu,exyu);\n     exyu:=Quotient(exyu,gcd);\n     exxu:=Quotient(exxu,gcd);\n     AntiDeriv(var,NormalForm(Quotient(exyu,exxu))) +\n       AntiDeriv(var,NormalForm(Modulo(exyu,exxu))/NormalForm(exxu));\n     ];\n\n11 # IntRat(_var,_exy / _exx,_exyu,_exxu)_\n        (Degree(exxu,var) >? 1 And? LeadingCoef(exxu)=?1 And?\n         IsNumericList(Coef(exxu,var,0 .. Degree(exxu)))) <--\n[\n  Local(ee);\n  ee:=Apart(exy/exx,var);\n  `AntiDeriv(@var,@ee);\n];\n\n\n20 # IntRat(_var,_exy / _exx,_exyu,_exxu) <--\n     `Hold(AntiDeriv(@var,((@exy)/(@exx))));\n\n\n30 # AntiDeriv(_var,Deriv(_var)(_expr)) <-- expr;\n\n////////////////////////////////////////////////\n//\n// No simple form, try something else\n//\n////////////////////////////////////////////////\n100 # AntiDeriv(_var,_exp) <--\n[\n  IntegrateMultiplicative(var,exp,a,b);\n];\n\n\n////////////////////////////////////////////////\n//\n// Special anti-derivatives can be added here.\n//\n////////////////////////////////////////////////\n\n// integrating expressions containing if:\n10 # IntegrateMultiplicative(_var,if(_cond)(_body),_a,_b)\n     <--\n     [\n       body := AntiDeriv(var,body);\n       `Hold(if(@cond)(@body));\n     ];\n// integrating expressions containing else\n10 # IntegrateMultiplicative(_var,(_left) else (_right),_a,_b)\n     <--\n     [\n       left  := AntiDeriv(var,left);\n       right := AntiDeriv(var,right);\n       `Hold( (@left) else (@right) );\n     ];\n\n\n////////////////////////////////////////////////\n//\n// Could not find anti-derivative, return unsimplified\n//\n////////////////////////////////////////////////\n1600 # IntegrateMultiplicative(_var,_exp,_a,_b) <-- `Hold(Integrate(@var)(@exp));\n\n////////////////////////////////////////////////\n//\n// IntFunc declares the anti-derivative of a function\n// that has one argument.\n// Calling sequence: IntFunc(variable,from,to);\n// Example: IntFunc(x,Cos(_x),Sin(x));\n//\n////////////////////////////////////////////////\nLocalSymbols(intpred)\n[\n  intpred := 50;\n  IntFunc(_vr,_from,_to) <--\n  [\n    `((@intpred) # IntegrateMultiplicative(_var,@from,_dummy1,_dummy2)_MatchLinear(var,@vr) <-- (@to)/Matched'a());\n    intpred++;\n  ];\n];\n\n\nIntPureSquare(_vr,_from,_sign2,_sign0,_to) <--\n[\n  `(50 # IntegrateMultiplicative(_var,@from,_dummy1,_dummy2)_MatchPureSquared(var,@sign2,@sign0,@vr) <-- (@to));\n];\n\n\n\n\n////////////////////////////////////////////////\n//\n// Declaration of the anti-derivatives of a few analytic functions\n//\n////////////////////////////////////////////////\n\n\nIntFunc(x,Sqrt(_x),(2*Sqrt(x)^(3))/3);\nIntFunc(x,1/Sqrt(_x),2*Sqrt(x));\nIntFunc(x,1/_x^(_n),x^(1-n)/(1-n) );\nIntFunc(x,Sin(_x),-Cos(x));\nIntFunc(x,1/Sin(_x), Ln( 1/Sin(x) - Cos(x)/Sin(x) ) );\nIntFunc(x,Cos(_x),Sin(x));\nIntFunc(x,1/Cos(_x),Ln(1/Cos(x)+Tan(x)));\nIntFunc(x,Tan(_x),-Ln(Cos(x)));\nIntFunc(x,1/Tan(_x),Ln(Sin(x)) );\nIntFunc(x,Cos(_x)/Sin(_x),Ln(Sin(x)));\nIntFunc(x,Exp(_x),Exp(x));\nIntFunc(x,(C_IsFreeOf(var))^(_x),C^x/Ln(C));\n// we don't need Ln(Abs(x))\nIntFunc(x,num_IsFreeOf(var) / (_x),num*Ln(x));\nIntFunc(x,Ln(_x),x*Ln(x)-x);\n// where did these 1+1's come from?\nIntFunc(x,(_x)*Ln(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );\nIntFunc(x,Ln(_x)*(_x),(1/(1+1))*x^(1+1)*Ln(x) - (1/(1+1)^2)*x^(1+1) );\n\nIntFunc(x,1/Sin(_x)^2,-Cos(x)/Sin(x) );\nIntFunc(x,1/Cos(_x)^2,Tan(x) );\nIntFunc(x,1/(Sin(_x)*Tan(_x)),-1/Sin(x));\nIntFunc(x,Tan(_x)/Cos(_x),1/Cos(x));\nIntFunc(x,1/Sinh(_x)^2,-1/Tanh(x));\nIntFunc(x,1/Cosh(_x)^2,Tanh(x));\nIntFunc(x,1/(Sinh(_x)*Tan(_x)),-1/Sinh(x));\nIntFunc(x,Tanh(_x)/Cosh(_x),-1/Cosh(x));\n\nIntFunc(x,1/Sqrt(m_IsFreeOf(x)-_x^2),ArcSin(x/Sqrt(m)) );\n\nIntFunc(x,Exp(n_IsNumber*_x)*Sin(m_IsNumber*_x),Exp(n*x)*(n*Sin(m*x)- m*Cos(m*x))/(m^2+n^2) );\n\n// n>0\nIntFunc(x,Ln(_x)*(_x)^n_IsNumber,(1/(n+1))*x^(n+1)*Ln(x) - (1/(n+1)^2)*x^(n+1) );\n\n// n>0\nIntFunc(x,Ln(A_IsNumber*_x)*(_x)^n_IsNumber,(1/(n+1))*x^(n+1)*Ln(A*x) - (1/(n+1)^2)*x^(n+1) );\n\nIntFunc(x,Sin(Ln(_x)),x*Sin(Ln(x))/2 - x*Cos(Ln(x))/2 );\n\n\n//This is a bug fix which was posted on the Yacas list by Alberto González Palomo on 10/5/2009.\n//IntFunc(x,Cos(Ln(_x)),x*Sin(Ln(x))/2 - x*Cos(Ln(x))/2 );\nIntFunc(x,Cos(Ln(_x)),x*Sin(Ln(x))/2 + x*Cos(Ln(x))/2 );\n\nIntFunc(x,1/((_x)*Ln(_x)),Ln(Ln(x)));\n\nIntFunc(x,(_x)^(-1),Ln(x));\n\nIntFunc(x,(_x)^(n_IsFreeOf(x)),x^(n+1)/(n+1));\nIntFunc(x,C_IsFreeOf(x)*(_x)^(n_IsFreeOf(x)),C*x^(n+1)/(n+1));\nIntFunc(x,C_IsFreeOf(x)/(D_IsFreeOf(x)*(_x)^(n_IsFreeOf(x))),(C/D)*x^(1-n)/(1-n));\nIntFunc(x,Sinh(_x),Cosh(x));\nIntFunc(x,Sinh(_x)^2,Sinh(2*x)/4 - x/2);\nIntFunc(x,1/Sinh(_x),Ln(Tanh(x/2)));\nIntFunc(x,Cosh(_x),Sinh(x));\nIntFunc(x,Cosh(_x)^2,Sinh(2*x)/4 + x/2);\nIntFunc(x,1/Cosh(_x),ArcTan(Sinh(x)));\nIntFunc(x,Tanh(_x),Ln(Cosh(x)));\nIntFunc(x,Tanh(_x)/Cosh(_x),-1/Cosh(x));\nIntFunc(x,1/Cosh(_x)^2,Tanh(x));\n//IntFunc(x,1/Sech(_x)*Coth(_x),-1/Sinh(x));\nIntFunc(x,1/Tanh(_x),Ln(Sinh(x)));\n\nIntFunc(x,Abs(_x),Abs(x)*x/2);        // not 2*a\n\nIntFunc(x,ArcTan(_x),x*ArcTan(x) - Ln(x^2 + 1)/2);\n//IntFunc(x,ArcSin(_x),(x*ArcSin(x)) + Sqrt(1-x^2) );\nIntFunc(x,ArcCos(_x),x*ArcCos(x) - Sqrt(1-x^2) );\n\nIntFunc(x,ArcTanh(_x),x*ArcTanh(x) + Ln(1-x^2)/2 );\nIntFunc(x,ArcSinh(_x),x*ArcSinh(x) - Sqrt(x^2 + 1) );\nIntFunc(x,ArcCosh(_x),x*ArcCosh(x) - Sqrt(x-1)*Sqrt(x+1) );\n\n\n// n^2 > x^2\n//IntFunc(x,num_IsFreeOf(var)/(-(_x)^2 + n_IsNumber),num*ArcTanh(x/Sqrt(n))/n);\n\n// x^2 > n^2\n//IntFunc(x,num_IsFreeOf(var)/((_x)^2 - n_IsNumber),num * -ArcCoth(x/Sqrt(n))/Sqrt(n));\n\n// n^2 > x^2\n//IntFunc(x,num_IsFreeOf(var)/Sqrt(n_IsNumber - (_x)^2),num*ArcSin(x/Sqrt(n)));\n\n// previous code is killing this....\nIntFunc(x,num_IsFreeOf(var)/(A_IsNumber + B_IsNumber*(_x))^2,-num/(A*b + B^2*x));\n\n// Code works now?\nIntFunc(x,num_IsFreeOf(var)/(n_IsNumber + m_IsNumber*Exp(p_IsNumber*(_x))),num*x/n - num*Ln(n + m*Exp(p*x))/(n*p));\nIntFunc(x,num_IsFreeOf(var)/(m_IsNumber*Exp(p_IsNumber*(_x)) + n_IsNumber),num*x/n - num*Ln(n + m*Exp(p*x))/(n*p));\n\n// note:hso: removed erroneous \"a\" in denominator of function below\nIntPureSquare(x,num_IsFreeOf(var)/(_x),1,1,(num/(Sqrt(Matched'b()*Matched'a())))*ArcTan(var/Sqrt(Matched'b()/Matched'a())));\n\n///// Integrating Special Functions\nIntFunc(x,Erf(_x), x*Erf(x)+ 1/(Exp(x^2)*Sqrt(Pi)) );\n\nUnFence(\"IntegrateMultiplicative\",4);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/integrate/AntiDeriv.mpw";
        scriptMap.put("AntiDeriv",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//todo:tk:this file need to be broken down further.\n\n\n10# (Integrate(_var)(expr_IsList))\n    <-- Map(\"Integrate\",{FillList(var,Length(expr)),expr});\n20 # (Integrate(_var)(_expr)) <-- IntSub(var,expr,AntiDeriv(var,IntClean(var,expr)));\n\n20 # (Integrate(_var, optionsList_IsList)(_expr)) <--\n[\n    Local(result);\n\n    optionsList := OptionsToAssociativeList(optionsList);\n\n    result := Integrate(var) expr;\n\n    If( optionsList[\"logAbs\"] =? \"True\", result := ( result /: {Ln(_x) <- Ln(Abs(x))}) );\n\n    result;\n];\n\n\n10 # IntSub(_var,_expr,Integrate(_var)(_expr2)) <--\n     `Hold(Integrate(@var)(@expr));\n20 # IntSub(_var,_expr,_result) <-- result;        // + UniqueConstant();\n\n////////////////////////////////////////////////\n//\n// Integrate over a range\n//\n////////////////////////////////////////////////\n10# (Integrate(_var,_from,_to)(expr_IsList))\n    <-- Map(\"Integrate\",{FillList(var,Length(expr)),\n                         FillList(from,Length(expr)),\n                         FillList(to,Length(expr)),\n                         expr});\n\n20 # (Integrate(_var,_from,_to)(_expr))\n    <-- defIntegrate(var,from,to,expr,a,b);\n\n\n20 # (Integrate(_var,_from,_to,optionsList_IsList)(_expr)) <--\n[\n    Local(result);\n\n    optionsList := OptionsToAssociativeList(optionsList);\n\n    result := Integrate(var,from,to) expr;\n\n    If( optionsList[\"logAbs\"] =? \"True\", result := ( result /: {Ln(_x) <- Ln(Abs(x))}) );\n\n    result;\n];\n\n////////////////////////////////////////////////\n//\n// separate rules can be added here for specific integrals\n// to defIntegrate\n//\n////////////////////////////////////////////////\n\n10 # defIntegrate(_var,_from,_to,_expr,_a,_b)_(from =? -to And? IsOddFunction(expr,var)) <-- 0;\n\n// We need to define this case (integrating from 0 to 0 over an even function)\n// explicitly, otherwise the integration ends up going in to infinite recursion.\n// Extended it a little bit more, since if you are integrating from A to A,\n// then the result is obviously zero. There are perhaps situations where\n// this does not work, where we need to simplify (to-from) first. A naive\n// implementation caused a test to fail.\n\n10 # defIntegrate(_var,_from,_from,_expr,_a,_b) <-- 0;\n\n12 # defIntegrate(_var,_from,_to,_expr,_a,_b)_(from =? -to And? IsEvenFunction(expr,var))\n        <-- 2*defIntegrate(var,0,to,expr,a,b);\n\n100 # defIntegrate(_var,_from,_to,_expr,_a,_b)_(Type(AntiDeriv(var,IntClean(var,expr))) !=? \"AntiDeriv\")\n        <-- IntegrateRange(var,expr,from,to,AntiDeriv(var,IntClean(var,expr)));\n\n101 # defIntegrate(_var,_from,_to,_expr,_a,_b)\n    <-- `Hold(Integrate(@var,@from,@to)(@expr));\n//    <-- IntegrateRange(var,expr,from,to,AntiDeriv(var,expr));\n\n\n////////////////////////////////////////////////\n//\n// No anti-derivative found, return unavaluated.\n//\n////////////////////////////////////////////////\n10 # IntegrateRange(_var,_expr,_from,_to,Integrate(_var)_expr2)\n    <-- `Hold(Integrate(@var,@from,@to)@expr);\n\n////////////////////////////////////////////////\n//\n// Anti-derivative found, return result.\n//\n////////////////////////////////////////////////\n20 # IntegrateRange(_var,_expr,_from,_to,_antideriv)\n    <-- `(@antideriv Where @var == @to) - `(@antideriv Where @var == @from);\n\n////////////////////////////////////////////////\n//\n// IntClean cleans up an expression before passing\n// it on to integration. This function normalizes\n// an expression in a way desirable for integration.\n// TrigSimpCombine, for instance, expands expressions\n// containing trigonometric functions so that they are\n// additive as opposed to multiplicative.\n//\n// If the expression doesn't contain the variable,\n// just return it as-is. This fixes:\n// In> Integrate(x) z^100\n//\n// If the expression can be considered to be a sum\n// of terms in var, then avoid premature simplification.\n////////////////////////////////////////////////\n10 # IntClean(_var,_expr) <--\n[\n        if( IsFreeOf(var,expr) Or? IsSumOfTerms(var,expr) )[\n                expr;\n        ] else if ( HasFunc(expr,Sin) Or? HasFunc(expr,Cos) )[\n                Simplify(TrigSimpCombine(expr));\n        ] else [\n                Simplify(expr);\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/integrate/Integrate.mpw";
        scriptMap.put("Integrate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\ntodo:tk:MatchPureSquared() is in this file because it is grouped with MatchLinear in a\nLocalSymbols() block.\n*/\n\n/* Def file definitions\nMatchPureSquared\n*/\n\n/** MatchLinear(variable,expression)\n */\nLocalSymbols(a,b)[\n\n10 # MatchLinear(var_IsAtom,expr_CanBeUni(var)) <--\n[\n  Bind(expr,MakeUni(expr,var));\n  MatchLinear(expr);\n];\n20 # MatchLinear(_var,_expr) <-- False;\n\n10 # MatchLinear(_expr)_(Degree(expr,var)<?2) <--\n[\n  Check(IsUniVar(expr), \"Argument\", PipeToString()Echo({\"Incorrect argument \",expr,\" passed to MatchLinear\"}));\n\n//TODO if I enable these checks, then integration fails (only users of this function any way). Can this be removed? Where are these variables cleared any way?\n//  Check(a = Hold(a), \"Argument\", PipeToString()(Echo({\"Found bound variable a which should have been unbound, in MatchLinear: \", a, \"=?\", Eval(a)})));\n//  Check(b = Hold(b), \"Argument\", PipeToString()(Echo({\"Found bound variable b which should have been unbound, in MatchLinear: \", b, \"=?\", Eval(b)})));\n\n  a := Coef(expr,1);\n  b := Coef(expr,0);\n  True;\n];\n20 # MatchLinear(_expr) <-- False;\nUnFence(\"MatchLinear\",1);\nUnFence(\"MatchLinear\",2);\n\n/** MatchPureSquared(variable,expression) - matches expressions\n *  of the form a*x^2+b.\n */\n10 # MatchPureSquared(var_IsAtom,_sign2,_sign0,expr_CanBeUni(var)) <--\n[\n  Bind(expr,MakeUni(expr,var));\n  MatchPureSquared(expr,sign2,sign0);\n];\n20 # MatchPureSquared(_var,_sign2,_sign0,_expr) <-- False;\n\n10 # MatchPureSquared(_expr,_sign2,_sign0)_(Degree(expr,var)=?2 And?\n                                    Coef(expr,1) =? 0 And?\n                                    IsNumber(Coef(expr,0)) And?\n                                    IsNumber(Coef(expr,2)) And?\n                                    Coef(expr,0)*sign0 >? 0 And?\n                                    Coef(expr,2)*sign2 >? 0\n                                    ) <--\n[\n  Check(IsUniVar(expr), \"Argument\", PipeToString()Echo({\"Incorrect argument \",expr,\" passed to MatchLinear\"}));\n//TODO if I enable these checks, then integration fails (only users of this function any way). Can this be removed? Where are these variables cleared any way?\n//  Check(a = Hold(a), \"Invariant\", \"Found bound variable which should have been unbound, in MatchLinear\");\n//  Check(b = Hold(b), \"Invariant\", \"Found bound variable which should have been unbound, in MatchLinear\");\n  a := Coef(expr,2);\n  b := Coef(expr,0);\n  True;\n];\n20 # MatchPureSquared(_expr,_sign2,_sign0) <-- False;\nUnFence(\"MatchPureSquared\",3);\nUnFence(\"MatchPureSquared\",4);\n\nMatched'a() := a;\nMatched'b() := b;\n\n\n\n]; // LocalSymbols a,b\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/integrate/MatchLinear.mpw";
        scriptMap.put("MatchLinear",scriptString);
        scriptMap.put("MatchPureSquared",scriptString);
        scriptMap.put("Matched'a",scriptString);
        scriptMap.put("Matched'b",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// post an error if assertion fails\n(Assert(_error'class, _error'object) _predicate) <--\n[\n        CheckErrorTableau();\n        If(IsEqual(predicate, True),        // if it does not evaluate to True, it's an error\n                True,\n                [        // error occurred, need to post error'object\n                        DestructiveAppend(GetErrorTableau(), {error'class, error'object});\n                        False;\n                ]\n        );\n];\n\n/// interface\n(Assert(_error'class) _predicate) <-- Assert(error'class, True) predicate;\n\n/// interface\n(Assert() _predicate) <-- Assert(\"generic\", True) predicate;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/Assert.mpw";
        scriptMap.put("Assert",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// The new default pretty-printer: DefaultPrint\nFunction(\"DefaultPrint\", {x})\n[\n        DumpErrors();\n        WriteString(\"Result: \");\n        Write(x);\n        WriteString(\";\n\");\n];\nHoldArgument(\"DefaultPrint\", x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/DefaultPrint.mpw";
        scriptMap.put("DefaultPrint",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// print all errors and clear the tableau\nDumpErrors() <--\n[\n        Local(error'object, error'word);\n        CheckErrorTableau();\n        ForEach(error'object, GetErrorTableau())\n        [        // error'object might be e.g. {\"critical\", {\"bad bad\", -1000}}\n                If(\n                        IsList(error'object),\n                        [\n                                If( // special case: error class \"warning\"\n                                        Length(error'object) >? 0 And? error'object[1] =? \"warning\",\n                                        [\n                                                error'word := \"Warning\";\n                                                error'object[1] := \"\";        // don't print the word \"warning\" again\n                                        ],\n                                        error'word := \"Error: \"        // important hack: insert \": \" here but not after \"Warning\"\n                                );\n\n                                If(        // special case: {\"error'class\", True}\n                                        Length(error'object)=?2 And? error'object[2]=?True,\n                                        Echo(error'word, error'object[1]),\n                                        [\n                                                Echo(error'word, error'object[1], \": \",\n                                                        PrintList(Rest(error'object)));\n                                        ]\n                                );\n                        ],\n                        // error'object is not a list: just print it\n                        Echo(\"Error: \", error'object)\n                );\n        ];\n        ClearErrors();\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/DumpErrors.mpw";
        scriptMap.put("DumpErrors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"EchoInternal\",*);\n\n10 # EchoInternal(string_IsString) <--\n[\n  WriteString(string);\n];\n\n20 # EchoInternal(_item) <--\n[\n  Write(item);Space();\n];\n\n\n\n\n\n\n//Retract(\"Echo\",*);\n\nRulebaseListed(\"Echo\",{firstParameter, parametersList});\n\n//Handle no option call.\n5 # Echo(_firstParameter) <-- Echo(firstParameter, {});\n\n\n//Main routine.  It will automatically accept 1 or more option calls because the\n//options come in a list.\n10 # Echo(_firstParameter, parametersList_IsList) <--\n[\n    EchoInternal(firstParameter);\n    ForEach(item,parametersList) EchoInternal(item);\n    NewLine();\n    \n];\n\n\n//Handle a single option call because the option does not come in a list for some reason.\n20 # Echo(_firstParameter, _secondParameter) <-- Echo(firstParameter, {secondParameter});\n\n\n//No argument Echo simply prints a newline.\nEcho() := NewLine();\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/Echo.mpw";
        scriptMap.put("Echo",scriptString);
        scriptMap.put("EchoInternal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nClearErrors\nGetError\n*/\n\n//////////////////////////////////////////////////\n/// ErrorTableau, Assert, IsError --- global error reporting\n//////////////////////////////////////////////////\n\nLocalSymbols(ErrorTableau) [\n\n  /// global error tableau. Its entries do not have to be lists.\n  Bind(ErrorTableau, {});\n\n  GetErrorTableau() := ErrorTableau;\n\n  ClearErrors() <-- Bind(ErrorTableau, {});\n\n  /// aux function to check for corrupt tableau\n  CheckErrorTableau() <--\n  If(\n    Not? IsList(ErrorTableau),\n    Bind(ErrorTableau, {{\"general\", \"corrupted ErrorTableau\"}})\n  );\n\n]; // LocalSymbols(ErrorTableau)\n\n\n/// obtain error object\nGetError(error'class_IsString) <--\n[\n        Local(error);\n        error := GetErrorTableau()[error'class];\n        If(\n                error !=? Empty,\n                error,\n                False\n        );\n];\n\n\n/// delete error\nClearError(error'class_IsString) <-- AssocDelete(GetErrorTableau(), error'class);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/GetErrorTableau.mpw";
        scriptMap.put("GetErrorTableau",scriptString);
        scriptMap.put("ClearErrors",scriptString);
        scriptMap.put("GetError",scriptString);
        scriptMap.put("CheckErrorTableau",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// check for errors\nIsError() <--\n[\n        CheckErrorTableau();\n        Length(GetErrorTableau())>?0;\n];\n\n/// check for errors of a given kind\nIsError(error'class_IsString) <--\n[\n        CheckErrorTableau();\n        GetErrorTableau()[error'class] !=? Empty;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/IsError.mpw";
        scriptMap.put("IsError",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* A reference print implementation. Expand at own leisure.\n *\n * This file implements Print, a scripted expression printer.\n */\n\n\n/* 60000 is the maximum precedence allowed for operators */\n10 # Print(_x) <--\n[\n  Print(x,60000);\n  NewLine();\n  DumpErrors();\n];\n\n/* Print an argument within an environment of precedence n */\n10 # Print(x_IsAtom,_n) <-- Write(x);\n10 # Print(_x,_n)_(IsInfix(Type(x))And? ArgumentsCount(x) =? 2) <--\n[\n  Local(bracket);\n  bracket:= (PrecedenceGet(Type(x)) >? n);\n  If(bracket,WriteString(\"(\"));\n  Print(x[1],LeftPrecedenceGet(Type(x)));\n  Write(x[0]);\n  Print(x[2],RightPrecedenceGet(Type(x)));\n  If(bracket,WriteString(\")\"));\n];\n\n10 # Print(_x,_n)_(IsPrefix(Type(x)) And? ArgumentsCount(x) =? 1) <--\n[\n  Local(bracket);\n  bracket:= (PrecedenceGet(Type(x)) >? n);\n  Write(x[0]);\n  If(bracket,WriteString(\"(\"));\n  Print(x[1],RightPrecedenceGet(Type(x)));\n  If(bracket,WriteString(\")\"));\n];\n\n10 # Print(_x,_n)_(IsPostfix(Type(x))And? ArgumentsCount(x) =? 1) <--\n[\n  Local(bracket);\n  bracket:= (PrecedenceGet(Type(x)) >? n);\n  If(bracket,WriteString(\"(\"));\n  Print(x[1],LeftPrecedenceGet(Type(x)));\n  Write(x[0]);\n  If(bracket,WriteString(\")\"));\n];\n\n20 # Print(_x,_n)_(Type(x) =? \"List\") <--\n[\n  WriteString(\"{\");\n  PrintArg(x);\n  WriteString(\"}\");\n];\n\n20 # Print(_x,_n)_(Type(x) =? \"Prog\") <--\n[\n  WriteString(\"[\");\n  PrintArgProg(Rest(FunctionToList(x)));\n  WriteString(\"]\");\n];\n20 # Print(_x,_n)_(Type(x) =? \"Nth\") <--\n[\n  Print(x[1],0);\n  WriteString(\"[\");\n  Print(x[2],60000);\n  WriteString(\"]\");\n];\n\n100 # Print(x_IsFunction,_n) <--\n [\n   Write(x[0]);\n   WriteString(\"(\");\n   PrintArg(Rest(FunctionToList(x)));\n   WriteString(\")\");\n ];\n\n\n/* Print the arguments of an ordinary function */\n10 # PrintArg({}) <-- True;\n\n20 # PrintArg(_list) <--\n[\n  Print(First(list),60000);\n  PrintArgComma(Rest(list));\n];\n10 # PrintArgComma({}) <-- True;\n20 # PrintArgComma(_list) <--\n[\n  WriteString(\",\");\n  Print(First(list),60000);\n  PrintArgComma(Rest(list));\n];\n\n\n18 # Print(Complex(0,1),_n)   <-- [WriteString(\"I\");];\n19 # Print(Complex(0,_y),_n)  <-- [WriteString(\"I*\");Print(y,4);];\n19 # Print(Complex(_x,1),_n)  <-- [Print(x,7);WriteString(\"+I\");];\n20 # Print(Complex(_x,_y),_n) <-- [Print(x,7);WriteString(\"+I*\");Print(y,4);];\n\n\n/* Tail-recursive printing the body of a compound statement */\n10 # PrintArgProg({}) <-- True;\n20 # PrintArgProg(_list) <--\n[\n   Print(First(list),60000);\n   WriteString(\";\");\n   PrintArgProg(Rest(list));\n];\n\n\n\n\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/Print.mpw";
        scriptMap.put("Print",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "Macro(\"Show\",{id})    [SysOut(\"<< \",@id,\" >>\");];\nMacro(\"Show\",{id,x})  [SysOut(\"<< \",@id,\" >> \",Hold(@x),\": \",Eval(@x));];\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/Show.mpw";
        scriptMap.put("Show",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"TableForm\",{list})\n[\n  Local(i);\n  ForEach(i,list)\n  [\n    Write(i);\n    NewLine();\n  ];\n  True;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/TableForm.mpw";
        scriptMap.put("TableForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "Macro(\"Tell\",{id})    [Echo(<<,@id,>>);];\nMacro(\"Tell\",{id,x})  [Echo(<<,@id,>>,Hold(@x),\": \",Eval(@x));];\n";
        scriptString[2] = "/org/mathpiper/scripts4/io/Tell.mpw";
        scriptMap.put("Tell",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # IsIrrationalFunction(Sqrt(_expr), _var)_(IsPolynomial(expr, var) And? Degree(expr, var) >? 0 Or? IsIrrationalFunction(expr,var)) <-- True;\n100 # IsIrrationalFunction(_expr^_p, _var)_((IsPolynomial(expr, var) Or? IsIrrationalFunction(expr,var)) And? IsRationalOrNumber(p) And? Not? IsZero(p) And? Not? IsPositiveInteger(p)) <-- True;\n100 # IsIrrationalFunction(_e1 + _e2, _var)_(IsIrrationalFunction(e1, var) And? IsIrrationalFunction(e2, var) Or? IsPolynomial(e1, var) And? IsIrrationalFunction(e2, var) Or? IsIrrationalFunction(e1, var) And? IsPolynomial(e2, var)) <-- True;\n100 # IsIrrationalFunction(_e1 - _e2, _var)_(IsIrrationalFunction(e1, var) And? IsIrrationalFunction(e2, var) Or? IsPolynomial(e1, var) And? IsIrrationalFunction(e2, var) Or? IsIrrationalFunction(e1, var) And? IsPolynomial(e2, var)) <-- True;\n100 # IsIrrationalFunction(_e1 * _e2, _var)_(IsIrrationalFunction(e1, var) And? IsIrrationalFunction(e2, var) Or? IsPolynomial(e1, var) And? IsIrrationalFunction(e2, var) Or? IsIrrationalFunction(e1, var) And? IsPolynomial(e2, var)) <-- True;\n100 # IsIrrationalFunction(_e1 / _e2, _var)_(IsIrrationalFunction(e1, var) And? IsIrrationalFunction(e2, var) Or? IsPolynomial(e1, var) And? IsIrrationalFunction(e2, var) Or? IsIrrationalFunction(e1, var) And? IsPolynomial(e2, var)) <-- True;\n\n500 # IsIrrationalFunction(_expr, _var) <-- False;\n\n100 # IrrationalFunctionDegree(Sqrt(_expr), _var)_(IsPolynomial(expr, var)) <-- Degree(expr, var) / 2;\n105 # IrrationalFunctionDegree(Sqrt(_expr), _var)_(IsIrrationalFunction(expr, var)) <-- IrrationalFunctionDegree(expr, var) / 2;\n110 # IrrationalFunctionDegree(_expr^_p, _var)_(IsPolynomial(expr, var) And? IsRationalOrNumber(p) And? Not? IsZero(p) And? Not? IsPositiveInteger(p)) <-- Degree(expr, var) * p;\n110 # IrrationalFunctionDegree(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- Maximum(IrrationalFunctionDegree(e1,var), IrrationalFunctionDegree(e2,var));\n110 # IrrationalFunctionDegree(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- Maximum(IrrationalFunctionDegree(e1,var), Degree(e2, var));\n110 # IrrationalFunctionDegree(_e1 - _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- Maximum(Degree(e1, var), IrrationalFunctionDegree(e2,var));\n110 # IrrationalFunctionDegree(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- Maximum(IrrationalFunctionDegree(e1,var), IrrationalFunctionDegree(e2,var));\n110 # IrrationalFunctionDegree(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- Maximum(IrrationalFunctionDegree(e1,var), Degree(e2, var));\n110 # IrrationalFunctionDegree(_e1 + _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- Maximum(Degree(e1, var), IrrationalFunctionDegree(e2,var));\n110 # IrrationalFunctionDegree(_e1 * _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- IrrationalFunctionDegree(e1,var) + IrrationalFunctionDegree(e2,var);\n110 # IrrationalFunctionDegree(_e1 * _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- IrrationalFunctionDegree(e1,var) + Degree(e2, var);\n110 # IrrationalFunctionDegree(_e1 * _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- Degree(e1, var) + IrrationalFunctionDegree(e2,var);\n\n110 # IrrationalFunctionDegree(_e1 / _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- IrrationalFunctionDegree(e1,var) - IrrationalFunctionDegree(e2,var);\n110 # IrrationalFunctionDegree(_e1 / _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- IrrationalFunctionDegree(e1,var) - Degree(e2, var);\n110 # IrrationalFunctionDegree(_e1 / _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- Degree(e1, var) - IrrationalFunctionDegree(e2,var);\n\n100 # IrrationalFunctionLeadingCoef(Sqrt(_expr), _var)_(IsPolynomial(expr, var)) <-- Sqrt(LeadingCoef(expr, var));\n105 # IrrationalFunctionLeadingCoef(Sqrt(_expr), _var)_(IsIrrationalFunction(expr, var)) <-- Sqrt(IrrationalFunctionLeadingCoef(expr, var));\n110 # IrrationalFunctionLeadingCoef(_expr^_p, _var)_(IsPolynomial(expr, var) And? IsRationalOrNumber(p) And? Not? IsZero(p) And? Not? IsPositiveInteger(p)) <-- LeadingCoef(expr, var)^p;\n\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) >? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) <? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) =? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) + IrrationalFunctionLeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) >? Degree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) <? Degree(e2,var)) <-- LeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) =? Degree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) + LeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) >? IrrationalFunctionDegree(e2,var)) <-- LeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) <? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 + _e2, _var)_(IsPolynomiaml(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) =? IrrationalFunctionDegree(e2,var)) <-- LeadingCoef(e1,var) + IrrationalFunctionLeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) >? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) <? IrrationalFunctionDegree(e2,var)) <-- -IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var) And? IrrationalFunctionDegree(e1,var) =? IrrationalFunctionDegree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) - IrrationalFunctionLeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) >? Degree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) <? Degree(e2,var)) <-- -LeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var) And? IrrationalFunctionDegree(e1,var) =? Degree(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) - LeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) >? IrrationalFunctionDegree(e2,var)) <-- LeadingCoef(e1,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) <? IrrationalFunctionDegree(e2,var)) <-- -IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 - _e2, _var)_(IsPolynomiaml(e1,var) And? IsIrrationalFunction(e2,var) And? Degree(e1,var) =? IrrationalFunctionDegree(e2,var)) <-- LeadingCoef(e1,var) - IrrationalFunctionLeadingCoef(e2,var);\n\n110 # IrrationalFunctionLeadingCoef(_e1 * _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) * IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 * _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) * LeadingCoef(e2, var);\n110 # IrrationalFunctionLeadingCoef(_e1 * _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- LeadingCoef(e1, var) * IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 / _e2, _var)_(IsIrrationalFunction(e1,var) And? IsIrrationalFunction(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) / IrrationalFunctionLeadingCoef(e2,var);\n110 # IrrationalFunctionLeadingCoef(_e1 / _e2, _var)_(IsIrrationalFunction(e1,var) And? IsPolynomial(e2,var)) <-- IrrationalFunctionLeadingCoef(e1,var) / LeadingCoef(e2, var);\n110 # IrrationalFunctionLeadingCoef(_e1 / _e2, _var)_(IsPolynomial(e1,var) And? IsIrrationalFunction(e2,var)) <-- LeadingCoef(e1, var) / IrrationalFunctionLeadingCoef(e2,var);\n\n\n\n/*                            */\n/*  Limit operator rule base  */\n/*                            */\n\n/* Special case: limits of polynomials as x approaches infinity */\n100 # Lim(_var, _tar, _dir, _p)_(IsPolynomial(p, var) And? Degree(p, var) >? 0 And? IsInfinity(tar))\n    <-- LeadingCoef(p,var) * Sign(tar)^Degree(p,var) * Infinity;\n\n/* Special case: limits of rational function as x approaches infinity */\n110 # Lim(_var, _tar, _dir, _r)_(IsRationalFunction(r, var) And? IsInfinity(tar)) <-- \n[\n    Local(p,q,pd,qd,pc,qc);\n\n    p:=Numerator(r);\n    q:=Denominator(r);\n\n    pd:=Degree(p,var);\n    qd:=Degree(q,var);\n\n    pc:=LeadingCoef(p,var);\n    qc:=LeadingCoef(q,var);\n\n    If(pd>?qd,\n        pc/qc*tar,\n        If(pd=?qd,pc/qc,0)\n    );\n];\n\n/* Special case: limits of irrational function as x approaches infinity */\n110 # Lim(_var, _tar, _dir, _expr)_(IsIrrationalFunction(expr, var) And? IsInfinity(tar)) <-- \n[\n    Local(lc,dg);\n\n    lc:=IrrationalFunctionLeadingCoef(expr, var);\n    dg:=IrrationalFunctionDegree(expr, var);\n\n    If(lc =? 0,\n        0,\n        If(dg >? 0,\n            Sign(tar)^dg * Infinity,\n            If(dg =? 0, lc, 0)\n        )\n    );\n];\n\n\n/* Special case: make use of the logarithm properties */\n120 # Lim(_var, _tar, _dir, Ln(_a) + Ln(_b)) <-- Lim(var, tar, dir, Ln(a*b));\n120 # Lim(_var, _tar, _dir, Ln(_a) - Ln(_b)) <-- Lim(var, tar, dir, Ln(a/b));\n\n/*  Exponentiation rules  */\n\n/*  Special limit #1:  0 ^ 0;  #2:  1 ^ Infinity;  #3:  Infinity ^ 0  */\n200 # Lim(_var, _tar, _dir, _x ^ _y)_\n( [\n    Local(lx,ly); lx := Lim(var, tar, dir, x); ly := Lim(var, tar, dir, y);\n    ((IsZero(lx) And? IsZero(ly)) Or? ((lx =? 1) And? IsInfinity(ly)) Or? (IsInfinity(lx) And? IsZero(ly)));\n] )\n<-- Exp(Lim(var, tar, dir, y * Ln(x)));\n\n/*  Default rule  */\n210 # Lim(_var, _tar, _dir, _x ^ _y)\n<-- Lim(var, tar, dir, x)^Lim(var, tar, dir, y);\n\n\n/*  Division rules  */\n\n/*  Special limit #4:  0 / 0;  #5:  Infinity / Infinity  */\n300 # Lim(_var, _tar, _dir, _x / _y)_\n( [\n    Local(lx,ly,infx,infy);\n     lx := Lim(var, tar, dir, x);\n     ly := Lim(var, tar, dir, y);\n     infx := (IsInfinity(lx) Or? (IsZero(Re(lx)) And? IsInfinity(Im(lx))));\n     infy := (IsInfinity(ly) Or? (IsZero(Re(ly)) And? IsInfinity(Im(ly))));\n    ((IsZero(lx) And? IsZero(ly)) Or?\n     (infx And? infy)\n     );\n] )\n<-- Lim(var, tar, dir, ApplyFast(\"Differentiate\", {var, x})/ApplyFast(\"Differentiate\", {var, y}));\n\n/*  Special limit #6: null denominator  */\n/*  Probably there are still some problems.  */\n\nDir(Right) <-- 1;\nDir(Left) <-- -1;\n\n/*  To get the sign of the denominator on one side:  */\nSign(_var, _tar, _dir, _exp, _n)\n<-- [\n  Local(der, coef); der := ApplyFast(\"Differentiate\", {var, exp});\n  coef := Eval(ApplyFast(\"Subst\", {var, tar, der}));\n  If ( coef =? 0,\n       Sign(var, tar, dir, der, n+1),\n       (Sign(coef)*Dir(dir)) ^ n\n     );\n];\n\n/*  To avoid infinite recursion (with 1/Exp(-x) for instance)  */\n310 # Lim(_var, _tar, _dir, _x / _y)_\n(IsInfinity(tar) And? IsZero(Lim(var, tar, dir, y)))\n<-- Sign(Lim(var, tar, dir, x))*Sign(Lim(var, tar, dir, ApplyFast(\"Differentiate\", {var, y})))*tar;\n\n320 # Lim(_var, _tar, _dir, _x / _y)_IsZero(Lim(var, tar, dir, y))\n<-- Sign(Lim(var, tar, dir, x))*Sign(var, tar, dir, y, 1)*Infinity;\n\n\n/*  Default rule  */\n330 # Lim(_var, _tar, _dir, _x / _y) <-- [\n    Local(u,v,r);\n\n    u := Lim(var, tar, dir, x);\n    v := Lim(var, tar, dir, y);\n\n    r := u / v;\n\n    If (u =? Undefined And? IsInfinity(v), [\n        Local(li, ls);\n\n        li := LimInf(var,tar,dir,x); \n        ls := LimSup(var,tar,dir,x);\n        r := (li * ls) / v;\n    ]);\n\n    r;\n];\n\n\n/*  Multiplication rules  */\n\n/*  To avoid some infinite recursions  */\n400 # Lim(_var, _tar, _dir, _x * Exp(_y))_\n(IsInfinity(Lim(var, tar, dir, x)) And? (Lim(var, tar, dir, y) =? -Infinity))\n<-- Lim(var, tar, dir, x/Exp(-y));\n400 # Lim(_var, _tar, _dir, Exp(_x) * _y)_\n((Lim(var, tar, dir, x) =? -Infinity) And? IsInfinity(Lim(var, tar, dir, y)))\n<-- Lim(var, tar, dir, y/Exp(-x));\n400 # Lim(_var, _tar, _dir, Ln(_x) * _y)_\n(IsZero(Lim(var, tar, dir, x)) And? IsZero(Lim(var, tar, dir, y)))\n<-- Lim(var, tar, dir, y*Ln(x));\n\n/*  Special limit #7:  0 * Infinity  */\n410 # Lim(_var, _tar, _dir, _x * _y)_\n((IsZero(Lim(var, tar, dir, x)) And? IsInfinity(Lim(var, tar, dir, y)))\n  Or? (IsInfinity(Lim(var, tar, dir, x)) And? IsZero(Lim(var, tar, dir, y))))\n<-- Lim(var, tar, dir, Simplify(ApplyFast(\"Differentiate\", {var, y})/ApplyFast(\"Differentiate\",\n{var, 1/x})));\n\n/*  Default rule  */\n420 # Lim(_var, _tar, _dir, _x * _y) <-- [\n    Local(u,v,r);\n\n    u := Lim(var, tar, dir, x);\n    v := Lim(var, tar, dir, y);\n\n    r := u * v;\n\n    If (u =? 0 And? v =? Undefined, [\n        li := LimInf(var,tar,dir,y); \n        ls := LimSup(var,tar,dir,y);\n        r := u * li * ls;\n    ], If (u =? Undefined And? v =? 0, [\n        li := LimInf(var,tar,dir,x); \n        ls := LimSup(var,tar,dir,x);\n        r := v * li * ls;\n    ]));\n\n    r;\n];\n\n/*  Substraction rules  */\n\n/*  Special limit #8:  Infinity - Infinity  */\n500 # Lim(_var, _tar, _dir, _x - _y)_\n( [\n    Local(lx,ly); lx := Lim(var, tar, dir, x); ly := Lim(var, tar, dir, y);\n    ((lx =? Infinity) And? (ly =? Infinity)) Or? ((lx =? -Infinity) And? (ly =? -Infinity));\n] )\n<-- Lim(var, tar, dir, x*(1-y/x));\n\n/*  Default rule  */\n510 # Lim(_var, _tar, _dir, _x - _y)\n<-- Lim(var, tar, dir, x)-Lim(var, tar, dir, y);\n\n/*  Unary minus  */\n520 # Lim(_var, _tar, _dir, - _x)\n<-- - Lim(var, tar, dir, x);\n\n\n/*  Addition rules  */\n\n/*  Special limit #9:  Infinity + (-Infinity)  */\n600 # Lim(_var, _tar, _dir, _x + _y)_\n( [\n    Local(lx,ly); lx := Lim(var, tar, dir, x); ly := Lim(var, tar, dir, y);\n    ((lx =? Infinity) And? (ly =? -Infinity)) Or? ((lx =? -Infinity) And? (ly =? Infinity));\n] )\n<-- Lim(var, tar, dir, x*(1+y/x));\n\n603 # Lim(_var, _tar, _dir, _x + _y)_\n(\n    Lim(var, tar, dir, x) =? Infinity And? Lim(var, tar, dir, y) =? Undefined And? LimInf(var, tar, dir, y) !=? -Infinity\n    Or?\n    Lim(var, tar, dir, x) =? Undefined And? LimInf(var, tar, dir, x) !=? -Infinity And? Lim(var, tar, dir, y) =? Infinity\n\n) <-- Infinity;\n\n/*  Default rule  */\n610 # Lim(_var, _tar, _dir, _x + _y)\n<-- Lim(var, tar, dir, x)+Lim(var, tar, dir, y);\n\n/*  Global default rule : evaluate expression  */\n\n700 # Lim(_var, _tar, _dir, exp_IsFunction)\n<-- Eval(MapArgs(exp,\"LimitArgs\"));\n\nLimitArgs(_arg) <-- Lim(var,tar,dir,arg);\nUnFence(\"LimitArgs\",1); /* Allow LimitArgs to have access to the local variables of the caller. */\n\n701 # Lim(_var, _tar, _dir, _exp)\n<-- Eval(ApplyFast(\"Subst\", {var, tar, exp}));\n\n\n/*  Limit without direction  */\n\n10 # Lim(_var, tar_IsInfinity, _exp) <-- Lim(var, tar, None, exp);\n\n20 # Lim(_var, _tar, _exp)\n<-- [\n  Local(l); l := Lim(var, tar, Left, exp);\n  If ( l =? Lim(var, tar, Right, exp),\n       l,\n       Undefined\n     );\n];\n\n\n100 # LimInf(_var, _tar, _dir, Cos( _exp ))_IsInfinity(Lim(var,tar,dir,exp)) <-- -1;\n100 # LimInf(_var, _tar, _dir, Sin( _exp ))_IsInfinity(Lim(var,tar,dir,exp)) <-- -1;\n\n500 # LimInf(_var, _tar, _dir, _exp) <-- Lim(var,tar,dir,exp);\n\n100 # LimSup(_var, _tar, _dir, Cos( _exp ))_IsInfinity(Lim(var,tar,dir,exp)) <-- 1;\n100 # LimSup(_var, _tar, _dir, Sin( _exp ))_IsInfinity(Lim(var,tar,dir,exp)) <-- 1;\n\n500 # LimSup(_var, _tar, _dir, _exp) <-- Lim(var,tar,dir,exp);\n\n\n/* User-callable function */\n\n(Limit(_var,_lim)(_fie)) <-- Lim(var,lim,fie);\n(Limit(_var,_lim,_direction)(_fie)) <-- Lim(var,lim,direction,fie);\nUnFence(\"Limit\",3);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/limit/Limit.mpw";
        scriptMap.put("Limit",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"BaseVector\",{row,n})\n[\n    Local(i,result);\n    result:=ZeroVector(n);\n    result[row] := 1;\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/BaseVector.mpw";
        scriptMap.put("BaseVector",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"CartesianProduct\",*);\n\nCartesianProduct(xList_IsList, yList_IsList) <--\n[\n    Local(cartesianProduct);\n    \n    cartesianProduct := {};\n    \n    ForEach(x, xList)\n    [\n        ForEach(y, yList)\n        [\n            cartesianProduct := DestructiveAppend(cartesianProduct, {x,y});\n        \n        ];\n    ];\n\n    cartesianProduct;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/CartesianProduct.mpw";
        scriptMap.put("CartesianProduct",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Cholesky Decomposition, adapted from:\n//        Fundamentals Of Matrix Computation (2nd), David S. Watkins, pp38\n// This algorithm performs O(n^3) flops where A is nxn\n// Given the positive definite matrix A, a matrix R is returned such that\n// A = Transpose(R) * R\n\n10 # Cholesky(A_IsMatrix) <--\n[\n        Local(matrix,n,k,j);\n        n:=Length(A);\n        matrix:=ZeroMatrix(n);\n\n        // copy entries of A into matrix\n        ForEach(i,1 .. n)\n                ForEach(j,1 .. n)\n                        matrix[i][j] := A[i][j];\n\n        // in place algorithm for cholesky decomp\n        ForEach(i,1 .. n)[\n                For(k:=1,k<=?(i-1),k++)\n                        matrix[i][i] := matrix[i][i] - matrix[k][i]^2;\n                Check( matrix[i][i] >? 0, \"Math\", \"Cholesky: Matrix is not positive definite\");\n                matrix[i][i] := Sqrt(matrix[i][i]);\n                //Echo({\"matrix[\",i,\"][\",i,\"] = \", matrix[i][i] });\n                For(j:=i+1,j<=?n,j++)[\n                        For(k:=1,k<=?(i-1),k++)\n                                matrix[i][j]:= matrix[i][j] - matrix[k][i]*matrix[k][j];\n                        matrix[i][j] := matrix[i][j]/matrix[i][i];\n                        //Echo({\"matrix[\",i,\"][\",j,\"] = \", matrix[i][j] });\n                ];\n        ];\n        // cholesky factorization is upper triangular\n        ForEach(i,1 .. n)\n                ForEach(j,1 .. n)\n                        If(i>?j,matrix[i][j] := 0);\n        matrix;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Cholesky.mpw";
        scriptMap.put("Cholesky",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"CoFactor\",{matrix,ii,jj})\n[\n  Local(perms,indices,result);\n  indices:=Table(i,i,1,Length(matrix),1);\n  perms:=PermutationsList(indices);\n  result:=0;\n  ForEach(item,perms)\n     If(item[ii] =? jj,\n       result:=result+\n         Product(i,1,Length(matrix),\n         If(ii=?i,1,matrix[i][item[i] ])\n                  )*LeviCivita(item));\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/CoFactor.mpw";
        scriptMap.put("CoFactor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"CrossProduct\",{aLeft,aRight})\n[\n  Local(length);\n  length:=Length(aLeft);\n  Check(length =? 3, \"Argument\", \"OutProduct: error, vectors not of dimension 3\");\n  Check(length =? Length(aRight), \"Argument\", \"OutProduct: error, vectors not of the same dimension\");\n\n  Local(perms);\n  perms := PermutationsList({1,2,3});\n\n  Local(result);\n  result:=ZeroVector(3);\n\n  Local(term);\n  ForEach(term,perms)\n  [\n    result[ term[1] ] := result[ term[1] ] +\n      LeviCivita(term) * aLeft[ term[2] ] * aRight[ term[3] ] ;\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/CrossProduct.mpw";
        scriptMap.put("CrossProduct",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Determinant(_matrix)_(IsUpperTriangular(matrix) Or? IsLowerTriangular(matrix)) <--\n[\n        Local(result);\n        result:=1;\n        ForEach(i, Diagonal(matrix) )\n                result:=result*i;\n        result;\n];\n\n//\n// The fast determinant routine that does the determinant numerically, rule 20,\n// divides things by the elements on the diagonal of the matrix. So if one of these\n// elements happens to be zero, the result is something like Infinity or Undefined.\n// Use the symbolic determinant in that case, as it is slower but much more robust.\n//\n15 # Determinant(_matrix)_(Length(Select(Diagonal(matrix), \"IsZero\")) >? 0) <-- SymbolicDeterminant(matrix);\n\n// Not numeric entries, so lets treat it symbolically.\n16 # Determinant(_matrix)_(VarList(matrix) !=? {}) <-- SymbolicDeterminant(matrix);\n\n20 # Determinant(_matrix) <-- GaussianDeterminant(matrix);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Deteminant.mpw";
        scriptMap.put("Determinant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//\n// Diagonal: return a vector with the diagonal elements of the matrix\n//\nFunction(\"Diagonal\",{A})\n[\n        Local(result,i,n);\n        n:=Length(A);\n        result:=ZeroVector(n);\n        For(i:=1,i<=?n,i++)\n        [\n                result[i] := A[i][i];\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Diagonal.mpw";
        scriptMap.put("Diagonal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"DiagonalMatrix\",{list})\n[\n  Local(result,i,n);\n  n:=Length(list);\n  result:=Identity(n);\n  For(i:=1,i<=?n,i++)\n  [\n    result[i][i] := list[i];\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/DiagonalMatrix.mpw";
        scriptMap.put("DiagonalMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Dimensions\",*);\n\n/* Code that returns the list of the dimensions of a tensor or matrix\n   Code submitted by Dirk Reusch.\n */\n\nLocalSymbols(x,i,n,m,aux,dim,result)\n[\n 1 # Dimensions(x_IsList) <--\n    [\n      Local(i,n,m,aux,dim,result);\n      result:=List(Length(x));\n      If(Length(x)>?0 And? Length(Select(x, IsList))=?Length(x),\n        [\n          n:=Length(x);\n              dim:=MapSingle(Dimensions,x);\n              m:=Minimum(MapSingle(Length,dim));\n              For(i:=1,i<=?m,i++)\n              [\n                aux:=Table(dim[j][i],j,1,n,1);\n                If(Minimum(aux)=?Maximum(aux),\n                   result:=DestructiveAppend(result,dim[1][i]),\n                   i:=m+1\n            );\n          ];\n        ]\n      );\n      result;\n    ];\n\n 2 # Dimensions(_x) <-- List();\n];  // LocalSymbols\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Dimensions.mpw";
        scriptMap.put("Dimensions",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////\n// dot product for vectors and matrices (dr)\n//////\n\nLocalSymbols(Dot0,Dot1)\n[\n// vector . vector\nDot(t1_IsVector,t2_IsVector)_(Length(t1)=?Length(t2)) <--\n   Dot0(t1,t2,Length(t1));\n\n// matrix . vector\nDot(t1_IsMatrix,t2_IsVector)_(Length(t1[1])=?Length(t2)) <--\n[\n   Local(i,n,m,result);\n   n:=Length(t1);\n   m:=Length(t2);\n   result:=List();\n   For(i:=1,i<=?n,i++)\n        DestructiveInsert(result,1,Dot0(t1[i],t2,m));\n   DestructiveReverse(result);\n];\n\n// vector . matrix\nDot(t1_IsVector,t2_IsMatrix)_(Length(t1)=?Length(t2)\n                               And? Length(t2[1])>?0) <--\n   Dot1(t1,t2,Length(t1),Length(t2[1]));\n\n// matrix . matrix\nDot(t1_IsMatrix,t2_IsMatrix)_(Length(t1[1])=?Length(t2)\n                                  And? Length(t2[1])>?0) <--\n[\n   Local(i,n,k,l,result);\n   n:=Length(t1);\n   k:=Length(t2);\n   l:=Length(t2[1]);\n   result:=List();\n   For(i:=1,i<=?n,i++)\n      DestructiveInsert(result,1,Dot1(t1[i],t2,k,l));\n   DestructiveReverse(result);\n];\n\n// vector . vector\nDot0(_t1,_t2,_n) <--\n[\n   Local(i,result);\n   result:=0;\n   For(i:=1,i<=?n,i++)\n      result:=result+t1[i]*t2[i];\n   result;\n];\n\n// vector . matrix\n// m vector length\n// n number of matrix cols\nDot1(_t1,_t2,_m,_n) <--\n[\n   Local(i,j,result);\n   result:=ZeroVector(n);\n   For(i:=1,i<=?n,i++)\n      For(j:=1,j<=?m,j++)\n         result[i]:=result[i]+t1[j]*t2[j][i];\n   result;\n];\n\n]; // LocalSymbols(Dot0,Dot1)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Dot.mpw";
        scriptMap.put("Dot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ExtractSubMatrix\",*);\n\n10 # ExtractSubMatrix( mat_IsMatrix, _row1, _col1, _row2, _col2 )_\n       (And?(IsPositiveInteger(row1),IsPositiveInteger(col1),\n            IsPositiveInteger(row2),IsPositiveInteger(col2))) <--\n[\n    Local(nrows,ncols,r,row,result);\n    {nrows,ncols} := Dimensions( mat );\n    Check(And?(row1>?0,col1>?0,row1<?nrows,col1<?ncols), \"Math\", \"ERROR: UL out of range\");\n    Check(And?(row2>?row1,col2>?col1,row2<=?nrows,col2<=?ncols), \"Math\", \"ERROR: LR out of range\");\n    result := {};\n    For(r:=row1,r<=?row2,r++)\n    [\n        row := Take( MatrixRow(mat,r), {col1,col2} );\n        result := DestructiveAppend( result, row );\n    ];\n    result;\n];\n\n\n10 # ExtractSubMatrix( mat_IsMatrix, _row1, _col1 )_\n              (And?(IsPositiveInteger(row1),IsPositiveInteger(col1))) <--\n[\n    Local(nrows,ncols);\n    {nrows,ncols} := Dimensions( mat );\n    Check(And?(row1>?0,col1>?0,row1<?nrows,col1<?ncols), \"Math\", \"ERROR: UL out of range\");\n    ExtractSubMatrix( mat, row1, col1, nrows, ncols );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/ExtractSubmatrix.mpw";
        scriptMap.put("ExtractSubMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFrobeniusNorm(matrix_IsMatrix) <--\n[\n        Local(i,j,result);\n        result:=0;\n        For(i:=1,i<=?Length(matrix),i++)\n                For(j:=1,j<=?Length(matrix[1]),j++)\n                        result:=result+Abs(matrix[i][j])^2;\n\n        Sqrt(result);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/FrobeniusNorm.mpw";
        scriptMap.put("FrobeniusNorm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nGaussianDeterminant(matrix):=\n[\n  Local(n,s,result);\n  n:=Length(matrix);\n        result:=1;\n\n  [\n    matrix:=FlatCopy(matrix);\n    Local(i);\n    For(i:=1,i<=?n,i++)\n    [\n      matrix[i]:=FlatCopy(matrix[i]);\n    ];\n  ];\n\n  // gaussian elimination\n  ForEach(i, 1 .. (n-1) )\n  [\n    ForEach(k, (i+1) .. n )\n    [\n      s:=matrix[k][i];\n      ForEach(j, i .. n )\n      [\n        matrix[k][j] := matrix[k][j] - (s/matrix[i][i])*matrix[i][j];\n        //Echo({\"matrix[\",k,\"][\",j,\"] =\", aug[k][j],\" - \",\n        //      matrix[k][i],\"/\",matrix[i][i],\"*\",matrix[i][j],\" k i =\", k,i  });\n      ];\n    ];\n  ];\n\n//Echo(\"mat: \",matrix);\n//Echo(\"diagmat: \",Diagonal(matrix));\n        // now upper triangular\n  ForEach(i, Diagonal(matrix) )\n    result:=result*i;\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/GaussianDeterminant.mpw";
        scriptMap.put("GaussianDeterminant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"GenMatrix\",{func,m,n})\n[\n  Local(i,j,result);\n  result:=ZeroMatrix(m,n);\n\n  For(i:=1,i<=?m,i++)\n    For(j:=1,j<=?n,j++)\n          result[i][j]:=ApplyFast(func,{i,j});\n\n  result;\n];\nHoldArgument(\"GenMatrix\",func);\nUnFence(\"GenMatrix\",3);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/GenMatrix.mpw";
        scriptMap.put("GenMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\nHankelMatrix(n):=GenMatrix({{i,j}, If(i+j-1>?n,0,i+j-1) }, n,n );\nHankelMatrix(m,n):=GenMatrix({{i,j}, If(i+j-1>?n,0,i+j-1)}, m,n );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/HankelMatrix.mpw";
        scriptMap.put("HankelMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\n// this takes 1 func in N vars\nHessianMatrix(f,v):=GenMatrix({{i,j}, Deriv(v[i]) Deriv(v[j]) f},Length(v),Length(v));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/HessianMatrix.mpw";
        scriptMap.put("HessianMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nHilbertInverseMatrix(n):=GenMatrix({{i,j},\n        (-1)^(i+j)*(i+j-1)*BinomialCoefficient(n+i-1,n-j)*BinomialCoefficient(n+j-1,n-i)*BinomialCoefficient(i+j-2,i-1)^2},n,n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/HilbertInverseMatrix.mpw";
        scriptMap.put("HilbertInverseMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\n// notoriously hard to manipulate numerically\nHilbertMatrix(n):=GenMatrix({{i,j}, 1/(i+j-1)}, n,n );\nHilbertMatrix(m,n):=GenMatrix({{i,j}, 1/(i+j-1)}, m,n );\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/HilbertMatrix.mpw";
        scriptMap.put("HilbertMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIdentity(n_IsNonNegativeInteger) <--\n[\n    Local(i,result);\n    result:={};\n    For(i:=1,i<=?n,i++)\n    [\n      DestructiveAppend(result,BaseVector(i,n));\n    ];\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Identity.mpw";
        scriptMap.put("Identity",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"InProduct\",{aLeft,aRight})\n[\n  Local(length);\n  length:=Length(aLeft);\n  Check(length =? Length(aRight), \"Argument\", \"InProduct: error, vectors not of the same dimension\");\n\n  Local(result);\n  result:=0;\n  Local(i);\n  For(i:=1,i<=?length,i++)\n  [\n    result := result + aLeft[i] * aRight[i];\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/InProduct.mpw";
        scriptMap.put("InProduct",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"InfinityNorm\",*);\n\n\n10 # InfinityNorm( M_IsMatrix ) <--\n[\n        Local(sumlist,row);\n        sumlist := {};\n    ForEach(row,M)\n        Push(sumlist,Sum(Abs(row)));\n    Maximum(sumlist);\n];\n\n10 # InfinityNorm( M_IsVector ) <-- Maximum(Abs(M));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/InfinityNorm.mpw";
        scriptMap.put("xnfinityNorm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Inverse\",{matrix})\n[\n  Local(perms,indices,inv,det,n);\n  n:=Length(matrix);\n  indices:=Table(i,i,1,n,1);\n  perms:=PermutationsList(indices);\n  inv:=ZeroMatrix(n,n);\n  det:=0;\n  ForEach(item,perms)\n  [\n    Local(i,lc);\n    lc := LeviCivita(item);\n    det:=det+Product(i,1,n,matrix[i][item[i] ])* lc;\n    For(i:=1,i<=?n,i++)\n        [\n         inv[item[i] ][i] := inv[item[i] ][i]+\n           Product(j,1,n,\n             If(j=?i,1,matrix[j][item[j] ]))*lc;\n        ];\n  ];\n  Check(det !=? 0, \"Math\", \"Zero determinant\");\n  (1/det)*inv;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Inverse.mpw";
        scriptMap.put("Inverse",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\n// this takes N funcs in N vars\nJacobianMatrix(f,v):=GenMatrix({{i,j},Deriv(v[j])f[i]},Length(f),Length(f));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/JacobianMatrix.mpw";
        scriptMap.put("JacobianMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// In place LU decomposition\n// Pivotting is not implemented\n// Adapted from Numerical Methods with Matlab\n//        Gerald Recktenwald, Sec 8.4\n10 # LU(A_IsSquareMatrix) <--\n[\n        Local(n,matrix,L,U);\n        n:=Length(A);\n        L:=ZeroMatrix(n,n);\n        U:=ZeroMatrix(n,n);\n        matrix:=ZeroMatrix(n,n);\n\n        ForEach(i,1 .. n)\n                ForEach(j,1 .. n)\n                        matrix[i][j] := A[i][j];\n\n        // loop over pivot rows\n        ForEach(i,1 ..(n-1))[\n                // loop over column below the pivot\n                ForEach(k,i+1 .. n)[\n                        // compute multiplier and store it in L\n                        matrix[k][i] := matrix[k][i] / matrix[i][i];\n                        // loop over elements in row k\n                        ForEach(j,i+1 .. n)[\n                                matrix[k][j] := matrix[k][j] - matrix[k][i]*matrix[i][j];\n                        ];\n                ];\n        ];\n        ForEach(i,1 .. n)[\n                ForEach(j,1 .. n)[\n                        If(i<=?j,U[i][j]:=matrix[i][j],L[i][j]:=matrix[i][j]);\n                ];\n                // diagonal of L is always 1's\n                L[i][i]:=1;\n        ];\n\n        {L,U};\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/LU.mpw";
        scriptMap.put("LU",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Levi-civita symbol */\nFunction(\"LeviCivita\",{indices})\n[\n  Local(i,j,length,left,right,factor);\n  length:=Length(indices);\n  factor:=1;\n\n  For (j:=length,j>?1,j--)\n  [\n    For(i:=1,i<?j,i++)\n    [\n      left:=indices[i];\n      right:=indices[i+1];\n\n      If (IsEqual(left,right),\n      [ factor := 0 ; ],\n      [\n        If(Not?(Apply(\"<?\",{left,right})),\n        [\n/*\n          Swap(indices,i,i+1);\n*/\n          indices:=Insert(Delete(indices,i),i+1,left);\n          factor:= -factor;\n        ]);\n      ]);\n    ];\n  ];\n  factor;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/LeviCivita.mpw";
        scriptMap.put("LeviCivita",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////\n// power of a matrix (dr)\n//////\n\nMatrixPower(x_IsSquareMatrix, n_IsNonNegativeInteger) <--\n[\n   Local(result);\n   result:=Identity(Length(x));\n   While(n !=? 0)\n   [\n      If(IsOdd(n),\n         result:=Dot(result,x));\n      x:=Dot(x,x);\n      n:=n>>1;\n   ];\n   result;\n];\n\nMatrixPower(x_IsSquareMatrix, n_IsNegativeInteger) <--\n   MatrixPower(Inverse(x),-n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/MatrixPower.mpw";
        scriptMap.put("MatrixPower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"MatrixSolve\",*);\n\n10 # MatrixSolve(matrix_IsDiagonal,b_IsVector) <--\n[\n    If(InVerboseMode(),Tell(\"   MatrixSolve_diag\",{matrix,b}));\n        Local(rowsm,rowsb,x);\n    rowsm:=Length(matrix);\n        rowsb:=Length(b);\n        Check(rowsm=?rowsb, \"Argument\", \"MatrixSolve: Matrix and vector must have same number of rows\");\n        x:=ZeroVector(rowsb);\n        ForEach(i,1 .. rowsb)\n                x[i]:=b[i]/matrix[i][i];\n        x;\n];\n\n// Backward Substitution\n15 # MatrixSolve(matrix_IsUpperTriangular,b_IsVector) <--\n[\n    If(InVerboseMode(),Tell(\"   MatrixSolve_ut\",{matrix,b}));\n    Local(rowsm,rowsb,x,s);\n    rowsm:=Length(matrix);\n    rowsb:=Length(b);\n    Check(rowsm=?rowsb, \"Argument\", \"MatrixSolve: Matrix and vector must have same number of rows\");\n    x:=ZeroVector(rowsb);\n\n        x[rowsb]:=b[rowsb]/matrix[rowsb][rowsb];\n        If(InVerboseMode(),Echo({\"set x[\",rowsb,\"] =? \",b[rowsb]/matrix[rowsb][rowsb]}));\n\n        ForEach(i,(rowsb-1) .. 1 )[\n                s:=b[i];\n                ForEach(j,i+1 .. rowsb )[\n                        s:= s - matrix[i][j]*x[j];\n                ];\n                x[i]:= s/matrix[i][i];\n                If(InVerboseMode(),Echo({\"set x[\",i,\"] =? \",s/matrix[i][i]}));\n        ];\n        x;\n];\n\n// Forward Substitution\n15 # MatrixSolve(matrix_IsLowerTriangular,b_IsVector) <--\n[\n    If(InVerboseMode(),Tell(\"   MatrixSolve_lt\",{matrix,b}));\n        Local(rowsm,rowsb,x,s);\n        rowsm:=Length(matrix);\n        rowsb:=Length(b);\n        Check(rowsm=?rowsb, \"Argument\", \"MatrixSolve: Matrix and vector must have same number of rows\");\n        x:=ZeroVector(rowsb);\n\n        x[1]:=b[1]/matrix[1][1];\n        If(InVerboseMode(),Echo({\"set x[1] =? \",b[1]/matrix[1][1]}));\n\n        ForEach(i,2 .. rowsb )[\n                s:=b[i];\n                ForEach(j,1 .. (i-1) )[\n                        s:= s - matrix[i][j]*x[j];\n                ];\n                x[i]:= s/matrix[i][i];\n                If(InVerboseMode(),Echo({\"set x[\",i,\"] =? \",s/matrix[i][i]}));\n        ];\n        x;\n];\n// Gaussian Elimination and Back Substitution\n// pivoting not implemented yet\n20 # MatrixSolve(matrix_IsMatrix,b_IsVector) <--\n[\n    If(InVerboseMode(),Tell(\"   MatrixSolve\",{matrix,b}));\n        Local(aug,rowsm,rowsb,x,s);\n    rowsm:=Length(matrix);\n    rowsb:=Length(b);\n    Check(rowsm=?rowsb, \"Argument\", \"MatrixSolve: Matrix and vector must have same number of rows\");\n    aug:=ZeroMatrix(rowsb,rowsb+1);\n        x:=ZeroVector(rowsb);\n\n        // create augmented matrix\n        ForEach(i, 1 .. rowsb )\n                ForEach(j, 1 .. rowsb )\n                        aug[i][j] := matrix[i][j];\n        ForEach(i, 1 .. rowsb )\n                aug[i][rowsb+1] := b[i];\n\n        // gaussian elimination\n        ForEach(i, 1 .. (rowsb-1) )[\n                // If our pivot element is 0 we need to switch\n                // this row with a row that has a nonzero element\n                If(aug[i][i] =? 0, [\n                        Local(p,tmp);\n                        p:=i+1;\n                        While( aug[p][p] =? 0 )[ p++; ];\n                        If(InVerboseMode(), Echo({\"switching row \",i,\"with \",p}) );\n                        tmp:=aug[i];\n                        aug[i]:=aug[p];\n                        aug[p]:=tmp;\n                ]);\n\n\n                ForEach(k, (i+1) .. rowsb )[\n                        s:=aug[k][i];\n                        ForEach(j, i .. (rowsb+1) )[\n                                aug[k][j] := aug[k][j] - (s/aug[i][i])*aug[i][j];\n                                //Echo({\"aug[\",k,\"][\",j,\"] =\", aug[k][j],\" - \",\n                                //        aug[k][i],\"/\",aug[i][i],\"*\",aug[i][j],\" k i =\", k,i  });\n                        ];\n                ];\n        ];\n        //PrettyForm(aug);\n        x[rowsb]:=aug[rowsb][rowsb+1]/aug[rowsb][rowsb];\n        If(InVerboseMode(),Echo({\"set x[\",rowsb,\"] =? \",x[rowsb] }));\n\n        ForEach(i,(rowsb-1) .. 1 )[\n                s:=aug[i][rowsb+1];\n                ForEach(j,i+1 .. rowsb)[\n                        s := s - aug[i][j]*x[j];\n                ];\n                x[i]:=Simplify(s/aug[i][i]);\n                If(InVerboseMode(),Echo({\"set x[\",i,\"] = \",x[i] }));\n        ];\n        x;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/MatrixSolve.mpw";
        scriptMap.put("MatrixSolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMinor(matrix,i,j) := CoFactor(matrix,i,j)*(-1)^(i+j);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Minor.mpw";
        scriptMap.put("Minor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Norm(_v) <-- PNorm(v,2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Norm.mpw";
        scriptMap.put("Norm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Normalize\",{vector})\n[\n  Local(norm);\n  norm:=0;\n  ForEach(item,vector)\n  [\n    norm:=norm+item*item;\n  ];\n  (1/(norm^(1/2)))*vector;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Normalize.mpw";
        scriptMap.put("Normalize",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// This is the standard textbook definition of the Gram-Schmidt\n// Orthogonalization process, from:\n// Friedberg,Insel,Spence \"Linear Algebra\"  (1997)\n// TODO: This function does not check if the input vectors are LI, it\n// only checks for zero vectors\nFunction(\"OrthogonalBasis\",{W})[\n        Local(V,j,k);\n\n        V:=ZeroMatrix(Length(W),Length(W[1]) );\n\n        V[1]:=W[1];\n        For(k:=2,k<=?Length(W),k++)[\n                Check(Not? IsZero(Norm(W[k])), \"Argument\", \"OrthogonalBasis: Input vectors must be linearly independent\");\n                V[k]:=W[k]-Sum(j,1,k-1,InProduct(W[k],V[j])*V[j]/Norm(V[j])^2);\n        ];\n        V;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/OrthogonalBasis.mpw";
        scriptMap.put("OrthogonalBasis",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Like orthogonalization, only normalize all vectors\nFunction(\"OrthonormalBasis\",{W})[\n        Local(i);\n        W:=OrthogonalBasis(W);\n        For(i:=1,i<=?Length(W),i++)[\n                W[i]:=W[i]/Norm(W[i]);\n        ];\n        W;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/OrthonormalBasis.mpw";
        scriptMap.put("OrthonormalBasis",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// outer product of vectors\nOuter(t1_IsVector, t2_IsVector) <--\n[\n   Local(i,j,n,m,result);\n   n:=Length(t1);\n   m:=Length(t2);\n   result:=ZeroMatrix(n,m);\n   For(i:=1,i<=?n,i++)\n      For(j:=1,j<=?m,j++)\n         result[i][j]:=t1[i]*t2[j];\n   result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Outer.mpw";
        scriptMap.put("Outer",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// p-norm, reduces to euclidean norm when p = 2\nFunction(\"PNorm\",{v,p})\n[\n        Local(result,i);\n        Check(p>=?1, \"Argument\", \"PNorm: p must be >=? 1\");\n\n        result:=0;\n        For(i:=1,i<=?Length(v),i++)[\n                result:=result+Abs(v[i])^p;\n        ];\n\n        // make it look nicer when p = 2\n        If(p=?2,Sqrt(result),(result)^(1/p) );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/PNorm.mpw";
        scriptMap.put("PNorm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RREF\",*);\n\n/*------------------------------------------------------------------------\n * RREF\n *    Takes an Augmented Matrix AM and convert it to Reduced Row Echelon\n * Form (Row Canonical Form).\n *\n *    Algorithm based on Anton & Rorres, Elementary Linear Algebra, p 10ff\n *\n *------------------------------------------------------------------------*/\n\n10 # RREF( AM_IsMatrix ) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If(iDebug,Tell(\"RREF\",AM));\n    Local(mRows,nCols,nVars,varVec,ir,jc,col,am,e,ii,pivot);\n    {mRows,nCols} := Dimensions(AM);\n    am            := FlatCopy(AM); //  so as not to mess with original matrix!\n    \n    Local(cc,cr,col,cnz);  // cc = current column,  cr = current row\n    cc := 1;               // initialize cc and cr to 1, to start with\n    cr := 1;\n    \n    While( cr <=? mRows )  // iterating over successively lower submatrices\n    [\n        Local(ic);\n\n        // STEP 1:  Locate first (sub)column that is NOT all zeros\n        If(iDebug, Tell(\"  STEP 1\"));\n        cnz := 0;   //  column number of first non-zero column in submatrix\n        For(ic:=1,ic<=?nCols,ic++)   \n         [ \n            col := MatrixColumn(am,ic);\n            If( cr >? 1, col := Drop( col, {1,cr-1} ) );\n            //Tell(\"         \",{ic,col});\n            If(Not? IsZeroVector(col), [cnz := ic; Break();]); \n         ];\n        cc := cnz;\n        If( iDebug, Tell(\"     first non-zero column is \",cc));\n        \n        // STEP 2::  Now, find the first row which does not have a zero in column cc,\n        // and bring it to the top if necessary\n        If(iDebug, Tell(\"  STEP 2\"));\n        For( ir:=cr, ir<=?mRows,ir++ )\n         [  \n            If( am[ir][cc] !=? 0 And? ir !=? 1, \n              [\n                {am[ir],am[cr]} := {am[cr],am[ir]};\n                If(iDebug, Tell(\"   swapping rows \",{cr,ir}));\n                Break();\n              ]\n            );\n         ];\n        If(iDebug,[Tell(\"working matrix\");TableForm(am);]);\n        \n        // STEP 3:  If the entry am[cr][cc] = a, then multiply row cr by 1/a\n        // in order to introduce a leading 1.\n        If(iDebug, Tell(\"  STEP 3\"));\n        am[cr] := am[cr]/am[cr][cc];\n        If(iDebug,TableForm(am));\n        \n        // STEP 4:  Add suitable multiples of the top row to the rows below,\n        // so that all entries below the leading 1 become zeros.\n        If(iDebug, Tell(\"  STEP 4\"));\n        For(ir:=cr+1,ir<=?mRows,ir++)\n         [\n           If( am[ir][cc] !=? 0, \n             [\n                am[ir] := am[ir] - am[ir][cc]*am[cr];\n             ]\n           );\n         ];\n        If(iDebug,TableForm(am));\n        \n        // STEP 5:  Now cover the top row and begin again with STEP 1, \n        // applied to the submatrix that remains.  Continue until the\n        // entire matrix is in row-echelon form\n        If(iDebug, Tell(\"  STEP 5\"));\n        cr := cr + 1;\n        If(iDebug And? cr <=? mRows, [NewLine();Tell(\" \",cr);]);\n        //Tell(\"   \",cr);\n        //Tell(\"   \",am[cr]);\n        If( cr=?mRows And? IsZeroVector(am[cr]), Break() );\n    ];   // end while cr <=? mRows\n    \n    // STEP 6:  convert to unique reduced row-echelon form\n    //   Beginning with the last non-zero row, and working upward,\n    //   add suitable multiples of each row to the rows above to \n    //   introduce zeros above the leading 1's.\n    If(iDebug, Tell(\"  STEP 6\"));\n    Local(pc,jr);\n    For(ir:=mRows,ir>?1,ir--)\n     [ \n         \n         If(iDebug,Tell(\"\",{ir,am[ir]}));\n         If(IsZeroVector(am[ir]),\n           [If(iDebug,Tell(\"    trailing row of zeros:  row \",ir)); ir:=ir-1;Continue();],\n           [\n              pc := Find(am[ir],1);  // find leading 1 in row\n              If(pc >? 0, \n                [\n                   For(jr:=ir-1,jr>=?1,jr--)\n                    [\n                       If(am[jr][pc]!=?0, am[jr]:=am[jr]-am[jr][pc]*am[ir]);\n                       If(iDebug,[NewLine();TableForm(am);]);\n                    ];\n                ]\n              );\n           ]\n         );\n     ];\n    am;\n];  \n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/RREF.mpw";
        scriptMap.put("RREF",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Recursive calculation of determinant, provided by Sebastian Ferraro\n */\n20 # RecursiveDeterminant(_matrix) <--\n[\n  /*\n  \n  */\n  Local(result);\n  If(IsEqual(Length(matrix),1),matrix[1][1],[\n    result:=0;\n    ForEach(i,1 .. Length(matrix))\n      //Consider only non-zero entries\n      If(Not?(IsEqual(matrix[1][i],0)),\n        //Transpose and Drop eliminate row 1, column i\n        result:=result+matrix[1][i]*(-1)^(i+1)* RecursiveDeterminant(Transpose(Drop(Transpose(Drop(matrix,{1,1})),{i,i}))));\n    result;\n  ]);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/RecursiveDeterminant.mpw";
        scriptMap.put("RecursiveDeterminant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Sparsity\",{matrix})\n[\n        Local(rows,cols,nonzero);\n        nonzero:=0;\n        rows:=Length(matrix);\n        cols:=Length(matrix[1]);\n        ForEach(i, 1 .. rows )\n                ForEach(j, 1 .. cols )\n                        If(matrix[i][j] !=? 0, nonzero:=nonzero+1 );\n\n        N(1 - nonzero/(rows*cols));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Sparsity.mpw";
        scriptMap.put("Sparsity",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* SylvesterMatrix */\n\nFunction(\"SylvesterMatrix\",{poly1, poly2, var})\n[\n  Local(i,m,p,q,y,z,result);\n  y:=Degree(poly1,var);\n  z:=Degree(poly2,var);\n  m:=y+z;\n  p:={};\n  q:={};\n  result:=ZeroMatrix(m,m);\n\n  For(i:=y,i>=?0,i--)\n    DestructiveAppend(p,Coef(poly1,var,i));\n  For(i:=z,i>=?0,i--)\n    DestructiveAppend(q,Coef(poly2,var,i));\n\n  For(i:=1,i<=?z,i++)\n  [\n    Local(j,k);\n        k:=1;\n    For(j:=i,k<=?Length(p),j++)\n        [\n          result[i][j]:=p[k];\n          k++;\n        ];\n  ];\n\n  For(i:=1,i<=?y,i++)\n  [\n    Local(j,k);\n        k:=1;\n    For(j:=i,k<=?Length(q),j++)\n        [\n          result[i+z][j]:=q[k];\n          k++;\n        ];\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/SylvesterMatrix.mpw";
        scriptMap.put("SylvesterMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n20 # SymbolicDeterminant(_matrix) <--\n[\n  Local(perms,indices,result);\n  Check((IsMatrix(matrix)), \"Argument\", \"Determinant: Argument must be a matrix\");\n  indices:=Table(i,i,1,Length(matrix),1);\n  perms:=PermutationsList(indices);\n  result:=0;\n  ForEach(item,perms)\n     result:=result+Product(i,1,Length(matrix),matrix[i][item[i] ])*\n                    LeviCivita(item);\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/SymbolicDeterminant.mpw";
        scriptMap.put("SymbolicDeterminant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\nToeplitzMatrix(N):=GenMatrix({{i,j},N[Abs(i-j)+1]}, Length(N), Length(N) );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/ToeplitzMatrix.mpw";
        scriptMap.put("ToeplitzMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Trace\",*);\n\nTrace(matrix_IsList) <--\n[\n   Local(i,j,n,d,r,aux,result);\n   \n   d:=Dimensions(matrix);\n   \n   r:=Length(d); // tensor rank.\n   \n   n:=Minimum(d);    // minimal dim.\n   \n   result:=0;\n   \n   For(i:=1,i<=?n,i++)\n   [\n      aux:=matrix[i];\n      For(j:=2,j<=?r,j++)\n         aux:=aux[i];\n      result:=result+aux;\n   ];\n   result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Trace.mpw";
        scriptMap.put("Trace",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nTranspose(matrix_IsList)_(Length(Dimensions(matrix))>?1) <--\n[\n  Local(i,j,result);\n  result:=ZeroMatrix(Length(matrix[1]),Length(matrix));\n  For(i:=1,i<=?Length(matrix),i++)\n    For(j:=1,j<=?Length(matrix[1]),j++)\n      result[j][i]:=matrix[i][j];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/Transpose.mpw";
        scriptMap.put("Transpose",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"VandermondeMatrix\",{vector})[\n        Local(len,i,j,item,matrix);\n        len:=Length(vector);\n        matrix:=ZeroMatrix(len,len);\n\n        For(i:=1,i<=?Length(matrix),i++)[\n                For(j:=1,j<=?Length(matrix[1]),j++)[\n                              matrix[j][i]:=vector[i]^(j-1);\n                ];\n        ];\n\n        matrix;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/VandermondeMatrix.mpw";
        scriptMap.put("VandermondeMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Used to test numerical eigenvalue algorithms, because it\n// has eigenvalues extremely close to each other.\n// WilkinsonMatrix(21) has 2 eigenvalues near 10.7 that agree\n// to 14 decimal places\n// Leto: I am not going to document this until we actually have\n// numerical eigenvalue algorithms\nWilkinsonMatrix(N):=GenMatrix({{i,j},\n                If( Abs(i-j)=?1,1,\n                [ If(i=?j,Abs( (N-1)/2 - i+1 ),0 ); ] )}, N,N );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/WilkinsonMatrix.mpw";
        scriptMap.put("WilkinsonMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The arguments of the following functions should be checked\n// this takes N funcs in 1 var\nWronskianMatrix(f,v):=GenMatrix({{i,j}, Deriv(v,i-1) f[j]}, Length(f), Length(f) );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/WronskianMatrix.mpw";
        scriptMap.put("WronskianMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nx X y := CrossProduct(x,y);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/X_operator.mpw";
        scriptMap.put("X",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # ZeroMatrix(n_IsNonNegativeInteger) <--  ZeroMatrix(n,n);\n\n10 # ZeroMatrix(n_IsNonNegativeInteger,m_IsNonNegativeInteger) <--\n[\n  Local(i,result);\n  result:={};\n  For(i:=1,i<=?n,i++)\n    DestructiveInsert(result,i,ZeroVector(m));\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/ZeroMatrix.mpw";
        scriptMap.put("ZeroMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"ZeroVector\",{n})\n[\n    Local(i,result);\n    result:={};\n    For(i:=1,i<=?n,i++)\n    [\n      DestructiveInsert(result,1,0);\n    ];\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/ZeroVector.mpw";
        scriptMap.put("ZeroVector",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n_x o _y <-- Outer(x,y);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/o_operator.mpw";
        scriptMap.put("o",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"MatrixColumn\",{matrix,col})\n[\n  Local(m);\n  m:=matrix[1];\n\n  Check(col >? 0, \"Argument\", \"MatrixColumn: column index out of range\");\n  Check(col <=? Length(m), \"Argument\", \"MatrixColumn: column index out of range\");\n\n  Local(i,result);\n  result:={};\n  For(i:=1,i<=?Length(matrix),i++)\n    DestructiveAppend(result,matrix[i][col]);\n\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixColumn.mpw";
        scriptMap.put("MatrixColumn",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixColumnAugment( M_IsMatrix, v_IsVector )_(Length(v)=?Dimensions(M)[2]) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixColumnAugment,{M,v}) );\n    Local(mRows,nCols,newMat,ir);\n    Local(MT,MA);\n    MT := Transpose(M);\n    MT := MatrixRowStack(MT,v);\n    MA := Transpose(MT);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixColumnAugment.mpw";
        scriptMap.put("MatrixColumnSwap",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixColumnReplace( M_IsMatrix, jCol_IsPositiveInteger, v_IsVector )_(Length(v)=?Dimensions(M)[2]) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixColumnReplace,{M,jCol,v}) );\n    Local(mRows,nCols,MT);\n    {mRows,nCols} := Dimensions(M);\n    If( jCol <=? nCols,\n       [ MT:=Transpose(M); DestructiveReplace(MT,jCol,v); M:=Transpose(MT); ]\n    );\n    M;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixColumnReplace.mpw";
        scriptMap.put("MatrixColumnReplace",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixColumnSwap( M_IsMatrix, jCol1_IsPositiveInteger, jCol2_IsPositiveInteger )_\n                          (And?(jCol1<=?Dimensions(M)[2],jCol2<=?Dimensions(M)[2])) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixColumnSwap,{M,jCol1,jCol2}) );\n    Local(MT);\n    MT := Transpose(M);\n    MT := MatrixRowSwap(MT,jCol1,jCol2);\n    M  := Transpose(MT);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixColumnSwap.mpw";
        scriptMap.put("MatrixColumnSwap",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"MatrixRow\",{matrix,row})\n[\n  Check(row >? 0, \"Argument\", \"MatrixRow: row index out of range\");\n  Check(row <=? Length(matrix), \"Argument\", \"MatrixRow: row index out of range\");\n\n  Local(result);\n  result:=matrix[row];\n\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixRow.mpw";
        scriptMap.put("MatrixRow",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixRowReplace( M_IsMatrix, iRow_IsPositiveInteger, v_IsVector )_(Length(v)=?Length(M[1])) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixRowReplace,{M,iRow,v}) );\n    Local(mRows,nCols);\n    {mRows,nCols} := Dimensions(M);\n    If( iRow <=? mRows, DestructiveReplace(M,iRow,v) );\n    M;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixRowReplace.mpw";
        scriptMap.put("MatrixRowReplace",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixRowStack( M_IsMatrix, v_IsVector )_(Length(v)=?Dimensions(M)[1]) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixRowStack,{M,v}) );\n    Local(mRows,nCols,newMat,ir);\n    {mRows,nCols} := Dimensions(M);\n    newMat        := ZeroMatrix(mRows+1,nCols);\n    For(ir:=1,ir<?mRows+1,ir++)\n       [  MatrixRowReplace(newMat,ir,MatrixRow(M,ir));  ];\n    MatrixRowReplace(newMat,mRows+1,v);\n    newMat;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixRowStack.mpw";
        scriptMap.put("MatrixRowStack",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMatrixRowSwap( M_IsMatrix, iRow1_IsPositiveInteger, iRow2_IsPositiveInteger )_\n                          (And?(iRow1<=?Dimensions(M)[1],iRow2<=?Dimensions(M)[1])) <--\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If( iDebug, Tell(MatrixRowSwap,{M,iRow1,iRow2}) );\n    Local(row1,row2);\n    If( iRow1 !=? iRow2,\n       [\n         row1 := MatrixRow(M,iRow1);         row2 := MatrixRow(M,iRow2);\n         DestructiveReplace(M,iRow1,row2);   DestructiveReplace(M,iRow2,row1);\n       ]\n    );\n    M;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/linalg/rowandcolumnoperations/MatrixRowSwap.mpw";
        scriptMap.put("MatrixRowSwap",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Append\",{list,element})\n[\n  Check(IsList(list), \"Argument\", \"The first argument must be a list.\");\n\n  Insert(list,Length(list)+1,element);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Append.mpw";
        scriptMap.put("Append",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(max,f,result)\n[\n  BSearch(max,f)  :=\n  [\n    Local(result);\n    Bind(result, FindIsq(max,f));\n    If(Apply(f,{result})!=?0,Bind(result,-1));\n    result;\n  ];\n];\nUnFence(\"BSearch\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/BSearch.mpw";
        scriptMap.put("BSearch",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"BubbleSort\",{list,compare})\n[\n  Local(i,j,length,left,right);\n\n  list:=FlatCopy(list);\n  length:=Length(list);\n\n  For (j:=length,j>?1,j--)\n  [\n    For(i:=1,i<?j,i++)\n    [\n      left:=list[i];\n      right:=list[i+1];\n      If(Not?(Apply(compare,{left,right})),\n        [\n          DestructiveInsert(DestructiveDelete(list,i),i+1,left);\n        ]\n      );\n    ];\n  ];\n  list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/BubbleSort.mpw";
        scriptMap.put("BubbleSort",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Contains\",{list,element})\n[\n  Local(result);\n  Bind(result,False);\n  While(And?(Not?(result), Not?(IsEqual(list, {}))))\n  [\n    If(IsEqual(First(list),element),\n      Bind(result, True),\n      Bind(list, Rest(list))\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Contains.mpw";
        scriptMap.put("Contains",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Count\",{list,element})\n[\n   Local(result);\n   Bind(result,0);\n   ForEach(item,list) If(IsEqual(item, element), Bind(result,AddN(result,1)));\n   result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Count.mpw";
        scriptMap.put("Count",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"DestructiveAppend\",{list,element})\n[\n  DestructiveInsert(list,Length(list)+1,element);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/DestructiveAppend.mpw";
        scriptMap.put("DestructiveAppend",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"DestructiveAppendList\",{list,toadd})\n[\n  Local(i,nr);\n  nr:=Length(toadd);\n  For(i:=1,i<=?nr,i++)\n  [\n    DestructiveAppend(list,toadd[i]);\n  ];\n  True;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/DestructiveAppendList.mpw";
        scriptMap.put("DestructiveAppendList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Difference\",{list1,list2})\n[\n  Local(l2,index,result);\n  l2:=FlatCopy(list2);\n  result:=FlatCopy(list1);\n  ForEach(item,list1)\n  [\n    Bind(index,Find(l2,item));\n    If(index>?0,\n      [\n        DestructiveDelete(l2,index);\n        DestructiveDelete(result,Find(result,item));\n      ]\n      );\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Difference.mpw";
        scriptMap.put("Difference",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* ���� Drop ���� */\n\n/* Needs to check the parameters */\n\n/*\n * Drop( list, n ) gives 'list' with its first n elements dropped\n * Drop( list, -n ) gives 'list' with its last n elements dropped\n * Drop( list, {m,n} ) gives 'list' with elements m through n dropped\n */\n\nRulebase(\"Drop\", {lst, range});\n\nRule(\"Drop\", 2, 1, IsList(range))\n    Concat(Take(lst,range[1]-1), Drop(lst, range[2]));\n\nRule(\"Drop\", 2, 2, range >=? 0)\n    If( range =? 0 Or? lst =? {}, lst, Drop( Rest(lst), range-1 ));\n\nRule(\"Drop\", 2, 2, range <? 0)\n    Take( lst, Length(lst) + range );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Drop.mpw";
        scriptMap.put("Drop",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"FillList\", {aItem, aLength})\n[\n  Local(i, aResult);\n  aResult:={};\n  For(i:=0, i<?aLength, i++)\n    DestructiveInsert(aResult,1,aItem);\n  aResult;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/FillList.mpw";
        scriptMap.put("FillList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Find\",{list,element})\n[\n  Local(result,count);\n  Bind(result, -1);\n  Bind(count, 1);\n  While(And?(result<?0, Not?(IsEqual(list, {}))))\n  [\n    If(IsEqual(First(list), element),\n      Bind(result, count)\n      );\n    Bind(list,Rest(list));\n    Bind(count,AddN(count,1));\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Find.mpw";
        scriptMap.put("Find",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(max,f,low,high,mid,current)\n[\nFindIsq(max,f)  :=\n[\n  Local(low,high,mid,current);\n  low:=1;\n  high:=max+1;\n  Bind(mid,((high+low)>>1));\n  While(high>?low And? mid>?1)\n  [\n    Bind(mid,((high+low)>>1));\n    Bind(current,Apply(f,{mid}));\n//Echo({low,high,current});\n    If(current =? 0,\n       high:=low-1,\n       If(current >? 0,\n          Bind(high,mid),\n          Bind(low,mid+1)\n          )\n       );\n  ];\n  mid;\n];\n];\nUnFence(\"FindIsq\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/FindIsq.mpw";
        scriptMap.put("FindIsq",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Find the first thingy that matches a predicate\nFunction(\"FindPredicate\",{list,predicate})\n[\n  Local(result,count);\n  Bind(result, -1);\n  Bind(count, 1);\n  While(And?(result<?0, Not?(IsEqual(list, {}))))\n  [\n    If(Apply(predicate,{First(list)}),\n      Bind(result, count)\n      );\n    Bind(list,Rest(list));\n    Bind(count,AddN(count,1));\n  ];\n  result;\n]; \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/FindPredicate.mpw";
        scriptMap.put("FindPredicate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// FuncList --- list all function atoms used in an expression\n//////////////////////////////////////////////////\n/// like VarList except collects functions\n\n10 # FuncList(expr_IsAtom) <-- {};\n20 # FuncList(expr_IsFunction) <--\nRemoveDuplicates(\n        Concat(\n                {First(FunctionToList(expr))},\n                Apply(\"Concat\",\n                        MapSingle(\"FuncList\", Rest(FunctionToList(expr)))\n                )\n        )\n);\n\n/*\nThis is like FuncList except only looks at arguments of a given list of functions. All other functions become \"opaque\".\n\n*/\n10 # FuncList(expr_IsAtom, look'list_IsList) <-- {};\n// a function not in the looking list - return its type\n20 # FuncList(expr_IsFunction, look'list_IsList)_(Not? Contains(look'list, ToAtom(Type(expr)))) <-- {ToAtom(Type(expr))};\n// a function in the looking list - traverse its arguments\n30 # FuncList(expr_IsFunction, look'list_IsList) <--\nRemoveDuplicates(\n        Concat(\n                {First(FunctionToList(expr))},\n                [        // gave up trying to do it using Map and MapSingle... so writing a loop now.\n                        // obtain a list of functions, considering only functions in look'list\n                        Local(item, result);\n                        result := {};\n                        ForEach(item, expr) result := Concat(result, FuncList(item, look'list));\n                        result;\n                ]\n        )\n);\n\nHoldArgumentNumber(\"FuncList\", 1, 1);\nHoldArgumentNumber(\"FuncList\", 2, 1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/FuncList.mpw";
        scriptMap.put("FuncList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* FuncListArith() is defined to only look at arithmetic operations +, -, *, /.  */\n\nFuncListArith(expr) := FuncList(expr, {ToAtom(\"+\"), ToAtom(\"-\"), *, /});\n\nHoldArgumentNumber(\"FuncListArith\", 1, 1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/FuncListArith.mpw";
        scriptMap.put("FuncListArith",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nHeapSort(list, compare) := HeapSort(list, ArrayCreate(Length(list), 0), 1, Length(list), compare);\n\n// this will sort \"list\" and mangle \"tmplist\"\n1 # HeapSort(_list, _tmplist, _first, _last, _compare) _ (last - first <=? 2) <-- SmallSort(list, first, last, compare);\n2 # HeapSort(_list, _tmplist, _first, _last, _compare) <--\n[        // See: J. W. J. Williams, Algorithm 232 (Heapsort), Com. of ACM, vol. 7, no. 6, p. 347 (1964)\n        // sort two halves recursively, then merge two halves\n        // cannot merge in-place efficiently, so need a second list\n        Local(mid, ileft, iright, pleft);\n        mid := first+((last-first)>>1);\n        HeapSort(list, tmplist, first, mid, compare);\n        HeapSort(list, tmplist, mid+1, last, compare);\n        // copy the lower part to temporary array\n        For(ileft := first,  ileft <=? mid, ileft++)\n                tmplist[ileft] := list[ileft];\n        For(\n                [ileft := first; pleft := first; iright := mid+1;],\n                ileft <=? mid,        // if the left half is finished, we don't have to do any more work\n                pleft++        // one element is stored at each iteration\n        )        // merge two halves\n                // elements before pleft have been stored\n                // the smallest element of the right half is at iright\n                // the smallest element of the left half is at ileft, access through tmplist\n        If(        // we copy an element from ileft either if it is smaller or if the right half is finished; it is unnecessary to copy the remainder of the right half since the right half stays in the \"list\"\n                iright>?last Or? Apply(compare,{tmplist[ileft],list[iright]}),\n                [        // take element from ileft\n                        list[pleft] := tmplist[ileft];\n                        ileft++;\n                ],\n                [        // take element from iright\n                        list[pleft] := list[iright];\n                        iright++;\n                ]\n        );\n\n        list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/HeapSort.mpw";
        scriptMap.put("HeapSort",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Intersection\",*);\n\n10 # Intersection( LoL_IsList )_(AllSatisfy(\"IsList\",LoL)) <--\n[\n  //If(InVerboseMode(),Tell(\"Intersection_listOfLists\",LoL));\n  Local(nLists,L0,L1,ii,result,LI);\n  nLists := Length(LoL);\n  //Tell(\"  \",nLists);\n  If( nLists =? 1,\n    [\n        result := LoL[1];\n    ],\n    [\n      L0 := FlatCopy(LoL[1]);\n      For( ii:=2,ii<=?nLists,ii++)\n      [\n          L1 := FlatCopy(LoL[ii]);\n          //If(InVerboseMode(),Tell(\"    \",{ii,L0,L1}));\n          LI := Intersection(L0,L1);\n          //If(InVerboseMode(),Tell(\"  -->\",LI));\n          L0 := FlatCopy(LI);\n      ];\n      //If(InVerboseMode(),Tell(\"  result \",L0));\n      result := L0;\n    ]\n  );\n  result;\n];\n  \n\n11 # Intersection(list1_IsList,list2_IsList) <--\n[\n    //If(InVerboseMode(),Tell(\"Intersection_pairOfLists\",{list1,list2}));\n    Local(l2,index,result);\n    l2:=FlatCopy(list2);\n    result:={};\n    ForEach(item,list1)\n    [\n        Bind(index, Find(l2,item));\n        If(index>?0,\n          [\n             DestructiveDelete(l2,index);\n             DestructiveInsert(result,1,item);\n          ]\n        );\n    ];\n    DestructiveReverse(result);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Intersection.mpw";
        scriptMap.put("Intersection",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Another Macro... hack for /: to work. */\nMacro(\"MacroMapArgs\",{expr,oper})\n[\n  Local(ex,tl,op);\n  Bind(op,@oper);\n  Bind(ex,FunctionToList(@expr));\n  Bind(tl,Rest(ex));\n\n   ListToFunction(Concat({ex[1]},\n     `MacroMapSingle(@op,Hold(@tl)))\n   );\n];\n\nUnFence(\"MacroMapArgs\",2);\nHoldArgument(\"MacroMapArgs\",oper);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/MacroMapArgs.mpw";
        scriptMap.put("MacroMapArgs",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Another Macro... hack for /: to work. */\nTemplateFunction(\"MacroMapSingle\",{func,list})\n[\n  Local(mapsingleresult);\n  mapsingleresult:={};\n\n  ForEach(mapsingleitem,list)\n  [\n    DestructiveInsert(mapsingleresult,1,\n      `ApplyFast(func,{Hold(Hold(@mapsingleitem))}));\n  ];\n  DestructiveReverse(mapsingleresult);\n];\nUnFence(\"MacroMapSingle\",2);\nHoldArgument(\"MacroMapSingle\",func);\nHoldArgument(\"MacroMapSingle\",list);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/MacroMapSingle.mpw";
        scriptMap.put("MacroMapSingle",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(func,lists,mapsingleresult,mapsingleitem)\n[\n  TemplateFunction(\"Map\",{func,lists})\n  [\n    Local(mapsingleresult,mapsingleitem);\n    mapsingleresult:={};\n    lists:=Transpose(lists);\n    ForEach(mapsingleitem,lists)\n    [\n      DestructiveInsert(mapsingleresult,1,Apply(func,mapsingleitem));\n    ];\n    DestructiveReverse(mapsingleresult);\n  ];\n  UnFence(\"Map\",2);\n  HoldArgument(\"Map\",func);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Map.mpw";
        scriptMap.put("Map",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nTemplateFunction(\"MapArgs\",{expr,oper})\n[\n  Bind(expr,FunctionToList(expr));\n   ListToFunction(Concat({expr[1]},\n     Apply(\"MapSingle\",{oper,Rest(expr)})\n   ) );\n];\nUnFence(\"MapArgs\",2);\nHoldArgument(\"MapArgs\",oper);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/MapArgs.mpw";
        scriptMap.put("MapArgs",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nTemplateFunction(\"MapSingle\",{func,list})\n[\n  Local(mapsingleresult);\n  mapsingleresult:={};\n\n  ForEach(mapsingleitem,list)\n  [\n    DestructiveInsert(mapsingleresult,1,\n      Apply(func,{mapsingleitem}));\n  ];\n  DestructiveReverse(mapsingleresult);\n];\nUnFence(\"MapSingle\",2);\nHoldArgument(\"MapSingle\",func);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/MapSingle.mpw";
        scriptMap.put("MapSingle",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* ���� Partition ���� */\n\n/* Partition( list, n ) partitions 'list' into non-overlapping sublists of length n */\n\nPartition(lst, len):=\n        If( Length(lst) <? len Or? len =? 0, {},\n                Concat( {Take(lst,len)}, Partition(Drop(lst,len), len) ));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Partition.mpw";
        scriptMap.put("Partition",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Pop\",{stack,index})\n[\n  Local(result);\n  result:=stack[index];\n  DestructiveDelete(stack,index);\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Pop.mpw";
        scriptMap.put("Pop",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"PopBack\",{stack})  Pop(stack,Length(stack));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/PopBack.mpw";
        scriptMap.put("PopBack",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"PopFront\",{stack}) Pop(stack,1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/PopFront.mpw";
        scriptMap.put("PopFront",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// Print a list using a padding string\n//////////////////////////////////////////////////\n\n10 # PrintList(list_IsList) <-- PrintList(list, \", \");\n10 # PrintList({}, padding_IsString) <-- \"\";\n20 # PrintList(list_IsList, padding_IsString) <-- PipeToString() [\n        Local(i);\n        ForEach(i, list) [\n                If(Not?(IsEqual(i, First(list))), WriteString(padding));\n                If (IsString(i), WriteString(i), If(IsList(i), WriteString(\"{\" : PrintList(i, padding) : \"}\"), Write(i)));\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/PrintList.mpw";
        scriptMap.put("PrintList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Push\",{stack,element})\n[\n  DestructiveInsert(stack,1,element);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Push.mpw";
        scriptMap.put("Push",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRemove(list, expression) :=\n[\n   Local(result);\n   Bind(result,{});\n   ForEach(item,list)\n   If(item !=? expression, DestructiveAppend(result,item));\n   result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Remove.mpw";
        scriptMap.put("Remove",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"RemoveDuplicates\",{list})\n[\n   Local(result);\n   Bind(result,{});\n   ForEach(item,list)\n     If(Not?(Contains(result,item)),DestructiveAppend(result,item));\n   result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/RemoveDuplicates.mpw";
        scriptMap.put("RemoveDuplicates",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Non-destructive Reverse operation\nReverse(list):=DestructiveReverse(FlatCopy(list));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Reverse.mpw";
        scriptMap.put("Reverse",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(predicate,list,result,item)\n[\n  Function(\"Select\",{list,predicate})\n  [\n    Local(result);\n    result:={};\n    ForEach(item,list)\n    [\n      If(Apply(predicate,{item}),DestructiveAppend(result,item));\n    ];\n    result;\n  ];\n  HoldArgument(\"Select\",predicate);\n  UnFence(\"Select\",2);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Select.mpw";
        scriptMap.put("Select",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// fast in-place sorting of a list (or array!)\n/// SmallSort sorts up to 3 elements, HeapSort sorts 4 and more elements\nSmallSort(_list, _first, _last, _compare) _ (last=?first) <-- list;\nSmallSort(_list, _first, _last, _compare) _ (last=?first+1) <--\n[\n        Local(temp);\n        temp := list[first];\n        If(\n                Apply(compare,{temp,list[last]}),\n                list,\n                [\n                        list[first] := list[last];\n                        list[last] := temp;\n                ]        //Swap(list, first, last)\n        );\n        list;\n];\nSmallSort(_list, _first, _last, _compare) _ (last=?first+2) <--\n[\n        Local(temp);\n        temp := list[first];\n        If(\n                Apply(compare,{list[first+1],temp}),\n                [\n                        list[first] := list[first+1];\n                        list[first+1] := temp;\n                ]        //Swap(list, first, first+1)        // x>y, z\n        );\n        // x<y, z\n        temp := list[last];\n        If(\n                Apply(compare,{list[first],temp}),\n                If(        // z>x<y\n                        Apply(compare,{list[first+1],temp}),\n                        list,\n                        [\n                                list[last] := list[first+1];\n                                list[first+1] := temp;\n                        ]        //Swap(list, first+1, last)        // 1, 3, 2\n                ),\n                [        // 2, 3, 1 -> 1, 2, 3\n                        list[last] := list[first+1];\n                        list[first+1] := list[first];\n                        list[first] := temp;\n                ]\n        );\n        list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/SmallSort.mpw";
        scriptMap.put("SmallSort",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Swap\",{list,index1,index2})\n[\n  Local(item1,item2);\n  item1:=list[index1];\n  item2:=list[index2];\n  list[index1] := item2;\n  list[index2] := item1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Swap.mpw";
        scriptMap.put("Swap",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Juan: TemplateFunction (as defined in the file \"deffunc\")\n * also makes the arguments to the function local symbols.\n * Use HoldArgumentNumber to specify the index of a variable to hold\n * (since they are defined as local symbols).\n */\n\nTemplateFunction(\"Table\",{body,var,count'from,count'to,step})\n  [\n    MacroLocal(var);\n    Local(result,nr,ii);\n    result:={};\n    nr := (count'to - count'from) / step;\n    ii := 0;\n    While( ii <=? nr )\n      [\n       MacroBind( var, count'from + ii * step );\n       DestructiveInsert( result,1,Eval(body) );\n       Bind(ii,AddN(ii,1));\n      ];\n    DestructiveReverse(result);\n  ];\nHoldArgumentNumber(\"Table\",5,1); /* body */\nHoldArgumentNumber(\"Table\",5,2); /* var */\nUnFence(\"Table\",5);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Table.mpw";
        scriptMap.put("Table",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* ���� Take ���� */\n\n/* Needs to check the parameters */\n\n/*\n * Take( list, n ) gives the first n elements of 'list'\n * Take( list, -n ) gives the last n elements of 'list'\n * Take( list, {m,n} ) elements m through n of 'list'\n */\n\nRulebase(\"Take\", {lst, range});\n\nRule(\"Take\", 2, 1, IsList(range))\n    Take( Drop(lst, range[1] -1), range[2] - range[1] + 1);\n\nRule(\"Take\", 2, 2, range >=? 0)\n    If( Length(lst)=?0 Or? range=?0, {},\n        Concat({First(lst)}, Take(Rest(lst), range-1)));\n\nRule(\"Take\", 2, 2, range <? 0)\n    Drop( lst, Length(lst) + range );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Take.mpw";
        scriptMap.put("Take",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Union\",{list1,list2})\n[\n  RemoveDuplicates(Concat(list1,list2));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/Union.mpw";
        scriptMap.put("Union",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* VarList: return the variables this expression depends on. */\nVarList(_expr) <-- VarList(expr,\"IsVariable\");\n\nFunction(\"VarList\",{expr,filter})\n[\n  RemoveDuplicates(VarListAll(expr,filter));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/VarList.mpw";
        scriptMap.put("VarList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n * Rulebase for VarListAll: recursively traverse an expression looking\n * up all variables the expression depends on.\n */\n/* Accept any variable. */\n\nVarListAll(_expr) <-- VarListAll(expr,\"IsVariable\");\n\n10 # VarListAll(_expr,_filter)_(Apply(filter,{expr}) =? True) <--\n     {expr};\n\n/* Otherwise check all leafs of a function. */\n20 # VarListAll(expr_IsFunction,_filter) <--\n[\n  Local(item,result, flatlist);\n  Bind(flatlist,Rest(FunctionToList(expr)));\n  Bind(result,{});\n  ForEach(item,flatlist)\n    Bind(result,Concat(result,VarListAll(item,filter)));\n  result;\n];\n\n/* Else it doesn't depend on any variable. */\n30 # VarListAll(_expr,_filter) <-- {};\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/VarListAll.mpw";
        scriptMap.put("VarListAll",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// VarListArith --- obtain arithmetic variables\n// currently the VarList(x,y) semantic is convoluted so let's introduce a new name; but in principle this needs to be cleaned up\nVarListArith(expr) := VarListSome(expr, {ToAtom(\"+\"), ToAtom(\"-\"), *, /});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/VarListArith.mpw";
        scriptMap.put("VarListArith",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// VarListSome is just like FuncList(x,y)\n\n10 # VarListSome({}, _look'list) <-- {};\n// an atom should be a variable to qualify\n10 # VarListSome(expr_IsVariable, _look'list) <-- {expr};\n15 # VarListSome(expr_IsAtom, _look'list) <-- {};\n// a function not in the looking list - return it whole\n20 # VarListSome(expr_IsFunction, look'list_IsList)_(Not? Contains(look'list, ToAtom(Type(expr)))) <-- {expr};\n// a function in the looking list - traverse its arguments\n30 # VarListSome(expr_IsFunction, look'list_IsList) <--\nRemoveDuplicates(\n                [        // obtain a list of functions, considering only functions in look'list\n                        Local(item, result);\n                        result := {};\n                        ForEach(item, expr) result := Concat(result, VarListSome(item, look'list));\n                        result;\n                ]\n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/VarListSome.mpw";
        scriptMap.put("VarListSome",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// Global stack operations on variables\n//////////////////////////////////////////////////\n\n\nLocalSymbols(GlobalStack, x)\n[\n  GlobalStack := {};\n\n        GlobalPop(x_IsAtom) <--\n        [\n                Check(Length(GlobalStack)>?0, \"Invariant\", \"GlobalPop: Error: empty GlobalStack\");\n                MacroBind(x, PopFront(GlobalStack));\n                Eval(x);\n        ];\n\n        HoldArgumentNumber(\"GlobalPop\", 1, 1);\n\n        GlobalPop() <--\n        [\n                Check(Length(GlobalStack)>?0, \"Invariant\", \"GlobalPop: Error: empty GlobalStack\");\n                PopFront(GlobalStack);\n        ];\n\n        GlobalPush(_x) <--\n        [\n                Push(GlobalStack, x);\n                x;\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/global_stack.mpw";
        scriptMap.put("GlobalPush",scriptString);
        scriptMap.put("GlobalPop",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file list\nNewStack\nPushStackFrame\nPopStackFrame\nStackDepth\nAddToStack\nIsOnStack\nFindOnStack\n\n*/\n\n\n/*\n   Stack simulator. Api:\n\n   NewStack() - creates a stack simulation\n   PushStackFrame(stack,unfenced) - push frame on stack, (un)fenced\n   PushStackFrame(stack,fenced)\n   PopStackFrame(stack)   - pop stack frame\n   StackDepth(_stack) - return stack depth\n   AddToStack(stack,element) - add element to top stack frame\n\n   IsOnStack(stack,element) - returns True if element is accessible\n       on current stack, False otherwise\n   FindOnStack(stack,element) - return assoc list for element.\n       Check first with IsOnStack that it is available!\n\n*/\n\nNewStack() := {{},{}};\n\n10 # PushStackFrame(_stack,unfenced)\n   <--\n   [\n     DestructiveInsert(stack[1],1,{});\n     DestructiveInsert(stack[2],1,True);\n   ];\n10 # PushStackFrame(_stack,fenced)\n   <--\n   [\n     DestructiveInsert(stack[1],1,{});\n     DestructiveInsert(stack[2],1,False);\n   ];\nPopStackFrame(stack):=\n[\n  DestructiveDelete(stack[1],1);\n  DestructiveDelete(stack[2],1);\n];\nStackDepth(_stack) <-- Length(stack[1]);\n\nAddToStack(stack,element)  :=\n[\n  DestructiveInsert(stack[1][1],1,{element,{}});\n];\n\nDropOneFrame(_stack) <-- {Rest(stack[1]),Rest(stack[2])};\n\n10 # IsOnStack({{},{}},_element) <-- False;\n11 # IsOnStack(_stack,_element)_(stack[1][1][element] !=? Empty) <-- True;\n20 # IsOnStack(_stack,_element)_(StackDepth(stack)>?0 And? stack[2][1] =? True)\n   <-- IsOnStack(DropOneFrame(stack),element);\n30 # IsOnStack(_stack,_element) <--\n[\n//Echo(\"stack depth = \",StackDepth(stack));\n//Echo(stack[2][1]);\nFalse;\n];\n10 # FindOnStack(_stack,_element)_(stack[1][1][element] !=? Empty)\n   <-- stack[1][1][element];\n20 # FindOnStack(_stack,_element)_(StackDepth(stack)>?0 And? stack[2][1] =? True)\n   <-- FindOnStack(DropOneFrame(stack),element);\n30 # FindOnStack(_stack,_element) <-- Check(False, \"Argument\", \"Illegal stack access! Use IsOnStack.\");\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/lists/scopestack/scopestack.mpw";
        scriptMap.put("NewStack",scriptString);
        scriptMap.put("PushStackFrame",scriptString);
        scriptMap.put("PopStackFrame",scriptString);
        scriptMap.put("StackDepth",scriptString);
        scriptMap.put("AddToStack",scriptString);
        scriptMap.put("IsOnStack",scriptString);
        scriptMap.put("FindOnStack",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// (a or b) and (c or d) -> (a and c) or (a and d) or (b and c) or (b and d)\n20 # (list_IsList AddTo _rest) <--\n[\n  Local(res);\n  res:={};\n  ForEach(item,list)\n  [\n    res := Concat(res,item AddTo rest);\n  ];\n  res;\n];\n30 # (_a'item AddTo list_IsList) <--\n[\n  MapSingle({{orig},a'item And? orig},list);\n];\n40 # (_a'item AddTo _b) <-- a'item And? b;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/AddTo.mpw";
        scriptMap.put("AddTo",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(LocResult) [\n\n  Bind(LocResult,True);\n  10 # LocPredicate(exp_IsAtom) <--\n  [\n    Local(tr,result);\n    tr:=patterns;\n    result:=False;\n    While (tr !=? {})\n    [\n      If (First(First(tr)) =? exp,\n      [\n        Bind(LocResult,Eval(First(Rest(First(tr)))));\n        result := True;\n        tr:={};\n      ],\n      [\n        tr := Rest(tr);\n      ]);\n    ];\n    result;\n  ];\n\n  10 # LocPredicate(exp_IsFunction) <--\n  [\n    Local(tr,result,head);\n    tr:=patterns;\n    result:=False;\n    While (tr !=? {})\n    [\n      Bind(head, First(First(tr)));\n      If (Not?(IsAtom(head)) And? exp[0]=?head[1] And? PatternMatches(head[2], exp),\n      [\n        Bind(LocResult,Eval(First(Rest(First(tr)))));\n        Bind(result, True);\n        Bind(tr,{});\n      ],\n      [\n        Bind(tr, Rest(tr));\n      ]);\n    ];\n    result;\n  ];\n  20 # LocPredicate(_exp) <-- False;\n\n  LocChange(_exp) <-- LocResult;\n]; // LocalSymbols(LocResult)\n\nUnFence(\"LocPredicate\",1);\nUnFence(\"LocChange\",1);\n\n10 # LocProcessSingle({_pat,_post,_exp}) <-- { {pat[0],PatternCreate(pat,post)},exp };\n\n20 # LocProcessSingle({pat_IsFunction,_exp}) <-- { {pat[0],PatternCreate(pat,True)},exp };\n\n30 # LocProcessSingle({pat_IsAtom,_exp}) <-- { pat,exp };\n\n/*\n    40 # LocProcessSingle(pat_IsFunction <- _exp) <-- { {pat[0],PatternCreate(pat,True)},exp };\n    todo:tk:this rule was not handling post predicates so I replaced it with a new version that does.\n    I suspect that the other rules for this Rulebase have problems too. \n*/\n40 # LocProcessSingle(pat_IsFunction <- _exp) <-- \n[\n    Local(justPattern, postPredicate);\n    \n    If(Type(pat) =? \"_\",\n        [\n            //A post predicate was submitted.\n            justPattern := pat[1];\n            postPredicate := pat[2];\n        ],\n        [\n            //No post predicate was submitted.\n            justPattern := pat;\n            postPredicate := True;\n        ]\n    );\n    \n    { {justPattern[0],PatternCreate(justPattern,postPredicate)},exp };\n];\n\n50 # LocProcessSingle(pat_IsAtom <- _exp) <-- { pat,exp };\n\nLocProcess(patterns) :=\n[\n  MapSingle(\"LocProcessSingle\",patterns);\n];\n\nCompilePatterns(patterns) := LocPatterns(LocProcess(patterns));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/CompilePatterns.mpw";
        scriptMap.put("CompilePatterns",scriptString);
        scriptMap.put("LocProcess",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Where\",{left,right});\n//HoldArgument(\"Where\",left);\n//HoldArgument(\"Where\",right);\nUnFence(\"Where\",2);\n10 # (_body Where var_IsAtom == _value)\n     <-- `[Local(@var);@var := @value;@body;];\n20 # (_body Where (_a And? _b))\n     <--\n[\n  Bind(body,`(@body Where @a));\n  `(@body Where @b);\n];\n\n30 # (_body Where {}) <-- {};\n40 # (_body Where list_IsList)_IsList(list[1])\n     <--\n     [\n       Local(head,rest);\n       head:=First(list);\n       rest:=Rest(list);\n       rest:= `(@body Where @rest);\n       `(@body Where @head) : rest;\n     ];\n\n50 # (_body Where list_IsList)\n     <--\n     [\n       Local(head,rest);\n       While (list !=? {})\n       [\n          head:=First(list);\n          body := `(@body Where @head);\n          list:=Rest(list);\n        ];\n        body;\n     ];\n\n\n60 # (_body Where _var == _value) <-- Subst(var,value)body;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/Where.mpw";
        scriptMap.put("Where",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"<-\",{left,right});\nHoldArgument(\"<-\",left);\nHoldArgument(\"<-\",right);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/lessthan_minus_operator.mpw";
        scriptMap.put("<-",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # (_expression /:: LocPatterns(_patterns)) <--\n[\n  MacroSubstitute(expression,\"LocPredicate\",\"LocChange\");\n];\n10 # (_expression /:: _patterns) <--\n[\n  Local(old);\n  Bind(patterns, LocProcess(patterns));\n  Bind(old, expression);\n  Bind(expression, MacroSubstitute(expression,\"LocPredicate\",\"LocChange\"));\n  While (expression !=? old)\n  [\n    Bind(old, expression);\n    Bind(expression, MacroSubstitute(expression,\"LocPredicate\",\"LocChange\"));\n  ];\n  expression;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/slash_colon_colon_operator.mpw";
        scriptMap.put("/::",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # (_expression /: LocPatterns(_patterns)) <--\n[\n  MacroSubstitute(expression,\"LocPredicate\",\"LocChange\");\n];\n\n\n10 # (_expression /: _patterns) <--\n[\n  Bind(patterns, LocProcess(patterns));\n  MacroSubstitute(expression,\"LocPredicate\",\"LocChange\");\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/localrules/slash_colon_operator.mpw";
        scriptMap.put("/:",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n // former LogicSimplify\n\n/*\n   Simplify a boolean expression. CNF is responsible\n   for converting an expression to the following form:\n        (p1  Or?  p2  Or?  ...)  And?  (q1  Or?  q2  Or?  ...)  And? ...\n   That is, a conjunction of disjunctions.\n*/\n\n\n// Trivial simplifications\n10  # CNF( Not?  True)                  <-- False;\n11  # CNF( Not?  False)                 <-- True;\n12  # CNF(True   And?  (_x))            <-- CNF(x);\n13  # CNF(False  And?  (_x))            <-- False;\n14  # CNF(_x   And?  True)              <-- CNF(x);\n15  # CNF(_x  And?  False)              <-- False;\n16  # CNF(True   Or?  (_x))             <-- True;\n17  # CNF(False  Or?  (_x))             <-- CNF(x);\n18  # CNF((_x)  Or?  True )             <-- True;\n19  # CNF((_x)  Or?  False)             <-- CNF(x);\n\n// A bit more complext\n21  # CNF(_x  Or?  _x)                  <-- CNF(x);\n22  # CNF(_x  And?  _x)                 <-- CNF(x);\n23  # CNF(_x  Or? Not? (_x))             <-- True;\n14  # CNF(Not? (_x)  Or? _x)             <-- True;\n25  # CNF(_x  And? Not? (_x))            <-- False;\n26  # CNF(Not? (_x)  And? _x)            <-- False;\n\n// Simplifications that deal with (in)equalities\n25  # CNF(((_x) == (_y))   Or?  ((_x) !== (_y)))   <-- True;\n25  # CNF(((_x) !== (_y))  Or?  ((_x) == (_y)))    <-- True;\n26  # CNF(((_x) == (_y))   And? ((_x) !== (_y)))   <-- False;\n26  # CNF(((_x) !== (_y))  And? ((_x) == (_y)))    <-- False;\n\n27  # CNF(((_x) >=? (_y))   And? ((_x) <? (_y)))     <-- False;\n27  # CNF(((_x) <? (_y))    And? ((_x) >=? (_y)))    <-- False;\n28  # CNF(((_x) >=? (_y))   Or?  ((_x) <? (_y)))     <-- True;\n28  # CNF(((_x) <? (_y))    Or?  ((_x) >=? (_y)))    <-- True;\n\n\n// some things that are more complex\n120  # CNF((_x)  Or?  (_y))            <-- LogOr(x, y, CNF(x), CNF(y));\n10 # LogOr(_x,_y,_x,_y)               <-- x Or? y;\n20 # LogOr(_x,_y,_u,_v)               <-- CNF(u Or? v);\n\n130  # CNF( Not?  (_x))                <-- LogNot(x, CNF(x));\n10 # LogNot(_x, _x)                   <-- Not? (x);\n20 # LogNot(_x, _y)                   <-- CNF(Not? (y));\n\n40 # CNF( Not? ( Not?  (_x)))           <-- CNF(x);                           // eliminate double negation\n45 # CNF((_x)=>(_y))                  <-- CNF((Not? (x))  Or?  (y));              // eliminate implication\n\n50 # CNF( Not? ((_x)  And?  (_y)))      <-- CNF((Not? x) Or? (Not? y));          // De Morgan's law\n60 # CNF( Not? ((_x)  Or?  (_y)))       <-- CNF(Not? (x)) And? CNF(Not? (y));        // De Morgan's law\n\n/*\n70 # CNF((_x) And? ((_y)  Or?  (_z)))   <-- CNF(x And? y) Or? CNF(x And? z);\n70 # CNF(((_x) Or? (_y)) And? (_z))     <-- CNF(x And? z) Or? CNF(y And? z);\n\n80 # CNF((_x)  Or?  ((_y)  And?  (_z))) <-- CNF(x Or? y) And? CNF(x Or? z);\n80 # CNF(((_x)  And?  (_y)) Or? (_z))   <-- CNF(x Or? z) And? CNF(y Or? z);\n*/\n\n70 # CNF(((_x)  And?  (_y))  Or?  (_z)) <-- CNF(x Or? z) And? CNF(y Or? z);      // Distributing Or? over And?\n80 # CNF((_x)  Or?  ((_y)  And?  (_z))) <-- CNF(x Or? y) And? CNF(x Or? z);\n\n90 # CNF((_x)  And?  (_y))             <-- CNF(x) And? CNF(y);                // Transform subexpression\n\n101 # CNF( (_x) <? (_y) )              <-- Not? CNFInEq(x >=?  y);\n102 # CNF( (_x) >? (_y) )              <-- CNFInEq(x >?   y);\n103 # CNF( (_x) >=? (_y) )             <-- CNFInEq(x >=?  y);\n104 # CNF( (_x) <=? (_y) )             <-- Not? CNFInEq(x >?  y);\n105 # CNF( (_x) == (_y) )             <-- CNFInEq(x ==  y);\n106 # CNF( (_x) !== (_y) )            <-- Not? CNFInEq(x == y);\n\n111 # CNF( Not?((_x) <?  (_y)) )        <-- CNFInEq( x >=? y );\n113 # CNF( Not?((_x) <=? (_y)) )        <-- CNFInEq( x >? y );\n116 # CNF( Not?((_x) !== (_y)) )       <-- CNFInEq( x == y );\n\n/* Accept as fully simplified, fallthrough case */\n200 # CNF(_x)                         <-- x;\n\n20 # CNFInEq((_xex) == (_yex))        <-- (CNFInEqSimplify(xex-yex) ==  0);\n20 # CNFInEq((_xex) >? (_yex))         <-- (CNFInEqSimplify(xex-yex) >?   0);\n20 # CNFInEq((_xex) >=? (_yex))        <-- (CNFInEqSimplify(xex-yex) >=?  0);\n30 # CNFInEq(_exp)                    <-- (CNFInEqSimplify(exp));\n\n10 # CNFInEqSimplify((_x) - (_x))     <-- 0;        // strictly speaking, this is not always valid, i.e. 1/0 - 1/0 != 0...\n100# CNFInEqSimplify(_x)              <-- [/*Echo({\"Hit the bottom of CNFInEqSimplify with \", x, Nl()});*/ x;];\n                                                    // former \"Simplify\";\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/CNF.mpw";
        scriptMap.put("CNF",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Small theorem prover for propositional logic, based on the\n * resolution principle.\n * Written by Ayal Pinkus, based on the simple theorem prover from \"Prolog, Ivan Bratko, chapter 20\"\n * Version 0.1 initial implementation.\n *\n *\n * Examples:\nCanProve(( (a=>b) And? (b=>c)=>(a=>c) ))  <-- True\nCanProve(a  Or?   Not? a)                  <-- True\nCanProve(True  Or?  a)                    <-- True\nCanProve(False  Or?  a)                   <-- a\nCanProve(a  And?   Not? a)                 <-- False\nCanProve(a  Or? b Or? (a And? b))           <-- a Or? b\n */\n\n // <=?=> LogicSimplify(expr, 3)\n\n/* CanProve tries to prove that the negation of the negation of\n   the proposition is true. Negating twice is just a trick to\n   allow all the simplification rules a la De Morgan to operate\n */\n/*CanProve(_proposition)    <-- CanProveAux( Not? CanProveAux( Not? proposition));*/\n\nCanProveAux(_proposition)    <-- LogicSimplify(proposition, 3);\n\nCanProve(_proposition)      <-- CanProveAux( proposition );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/CanProve.mpw";
        scriptMap.put("CanProve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Contradict((_x) - (_y) == 0, (_x) - (_z) == 0)_(y !=? z)     <-- True;\n12 # Contradict((_x) == (_y), (_x) == (_z))_(y !=? z)             <-- True;\n13 # Contradict((_x) - (_y) == 0, (_x) - (_z) >=? 0)_(z >? y)      <-- True;\n14 # Contradict((_x) - (_y) == 0, (_x) - (_z) >?  0)_(z >? y)      <-- True;\n14 # Contradict(Not? (_x) - (_y) >=? 0, (_x) - (_z) >?  0)_(z >? y)  <-- True;\n15 # Contradict(_a, _b)                                          <-- IsEqual(SimpleNegate(a), b);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/Contradict.mpw";
        scriptMap.put("Contradict",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// perform unit subsumption and resolutiuon for a unit clause # i\n// a boolean indicated whether there was a change is returned\nDoUnitSubsumptionAndResolution(_list) <--\n[\n    Local(i, j, k, isFalse, isTrue, changed);\n    Bind(isFalse, False);\n    Bind(isTrue,  False);\n    Bind(changed, True);\n\n    //Echo({\"In DoUnitSubsumptionAndResolution\", Nl()});\n\n    While(changed) [\n      Bind(changed, False);\n\n      For(i:=1, (Not? isFalse And? Not? isTrue) And? i <=? Length(list), i++)\n      [\n        If(Length(list[i]) =? 1, [\n          Local(x); Bind(x, list[i][1]); //n := SimpleNegate(x);\n          //Echo({\"Unit clause \", x, Nl()});\n\n          // found a unit clause, {x}, not use it to modify other clauses\n          For(j:=1, (Not? isFalse And? Not? isTrue) And? j <=? Length(list), j++)\n          [\n              If(i !=?j, [\n                Local(deletedClause); Bind(deletedClause, False);\n                For(k:=1, (Not? isFalse And? Not? isTrue And? Not? deletedClause) And? k <=? Length(list[j]),  k++)\n                [\n                    // In both of these, if a clause becomes empty, the whole thing is False\n\n                    //Echo({\"   \", x, \" subsumes \", list[j][k], i,j, Subsumes(x, list[j][k]), Nl()});\n\n                    // unit subsumption -- this kills clause j\n                    If(Subsumes(x, list[j][k]), [\n                        // delete this clause\n                        DestructiveDelete(list, j);\n                        j--;\n                        If(i>?j, i--);   // i also needs to be decremented\n                        Bind(deletedClause, True);\n                        Bind(changed, True);\n                        If(Length(list) =? 0, [Bind(isTrue, True);]);\n                    ],\n                      // else, try unit resolution\n                    If(Contradict(x, list[j][k]), [\n                        //Echo({x, \" contradicts\", list[j][k], Nl()});\n                        DestructiveDelete(list[j], k);\n                        k--;\n                        Bind(changed, True);\n                        If(Length(list[j]) =? 0, [Bind(isFalse, True);]);\n                    ])\n                    );\n                ];\n              ]);\n          ];\n        ]);\n      ];\n    ];\n\n    list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/DoUnitSubsumptionAndResolution.mpw";
        scriptMap.put("DoUnitSubsumptionAndResolution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* LogicCombine is responsible for scanning a list of lists, which represent\n   a form (p1  Or?  p2  Or?  ...)  And  (q1  Or?  q2  Or?  ...)  And ... by scanning the lists\n   for combinations x Or? Y  And   Not? x Or? Z <-- Y Or? Z . If Y Or? Z is empty then this clause\n   is false, and thus the entire proposition is false.\n*/\nLogicCombine(_list) <--\n[\n  Local(i, j);\n  For(Bind(i,1), i<=?Length(list), Bind(i,AddN(i,1)))\n  [\n    //Echo({\"list[\", i, \"/\", Length(list), \"]: \", list[i], Nl()});\n\n    For(j := 1, (j<=?Length(list[i])), j++)\n    [\n      Local(tocombine, n, k);\n      Bind(n, list[i][j]);\n\n      {tocombine, k} := LogicFindWith(list, i, n);// search forward for n, tocombine is the list we\n                                                  // will combine the current one with\n      If(tocombine !=? -1,\n      [\n        Local(combination);\n        Check(k !=? -1, \"Math\", \"k is -1\");\n\n        Bind(combination, LogicRemoveTautologies(Concat(list[i], list[tocombine])));\n        If(combination =? {},                      // the combined clause is false, so the whole thing is false\n          [Bind(list, {{}}); Bind(i, Length(list)+1);], [/*Bind(i, 0);*/]);\n      ]);\n    ];\n  ];\n  list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/LogicCombine.mpw";
        scriptMap.put("LogicCombine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* find the number of the list that contains n in it, a pointer to a list of lists in passed */\nLogicFindWith(_list, _i, _n) <--\n[\n  Local(result, index, j);\n  Bind(result, -1); Bind(index, -1);\n\n  For(j := i+1, (result<?0) And? (j <=? Length(list)), j++)\n  [\n    Local(k, len); Bind(len, Length(list[j]));\n    For(k := 1, (result<?0) And? (k<=?len), k++)\n    [\n      Local(el); Bind(el, list[j][k]);\n\n      If(Contradict(n, el),\n        [Bind(result, j); Bind(index, k);]);\n    ];\n  ];\n  {result, index};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/LogicFindWith.mpw";
        scriptMap.put("LogicFindWith",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n // not clear is this will stay, but it is eq. to LogicSimplify(expr, 2)\n\n1 # SimpleNegate(Not? (_x))  <-- x;\n2 # SimpleNegate(_x)        <-- Not?(x);\n\n/* LogicRemoveTautologies scans a list representing e1 Or? e2 Or? ... to find\n   if there are elements p and  Not? p in the list. This signifies p Or? Not? p,\n   which is always True. These pairs are removed. Another function that is used\n   is RemoveDuplicates, which converts p Or? p into p.\n*/\n\n/* this can be optimized to walk through the lists a bit more efficiently and also take\ncare of duplicates in one pass */\nLocalCmp(_e1, _e2)                  <-- IsLessThan(PipeToString() Write(e1), PipeToString() Write(e2));\n\n// we may want to add other expression simplifers for new expression types\n100 # SimplifyExpression(_x)        <-- x;\n\n// Return values:\n//  {True} means True\n//  {} means False\nLogicRemoveTautologies(_e) <--\n[\n  Local(i, len, negationfound); Bind(len, Length(e));\n  Bind(negationfound, False);\n\n  //Echo(e);\n  e := BubbleSort(e, \"LocalCmp\");\n\n  For(Bind(i, 1), (i <=? len) And? (Not? negationfound), i++)\n  [\n    Local(x, n, j);\n    // we can register other simplification rules for expressions\n    //e[i] := MathNth(e,i) /:: {gamma(_y) <- SimplifyExpression(gamma(y))};\n    Bind(x, MathNth(e,i));\n    Bind(n, SimpleNegate(x));                    /* this is all we have to do because of\n                                                the kind of expressions we can have coming in */\n\n    For(Bind(j, i+1), (j <=? len) And? (Not? negationfound), j++) [\n        Local(y);\n        Bind(y, MathNth(e,j));\n\n        If(IsEqual(y, n),\n            [\n                //Echo({\"Deleting from \", e, \" i=\", i, \", j=\", j, Nl()});\n\n                Bind(negationfound, True);\n                //Echo({\"Removing clause \", i, Nl()});\n            ],\n        If(IsEqual(y, x),\n            [\n                //Echo({\"Deleting from \", e, \" j=\", j, Nl()});\n                DestructiveDelete(e, j);\n                Bind(len,SubtractN(len,1));\n            ])\n        );\n    ];\n    Check(len =? Length(e), \"Math\", \"The length computation is incorrect\");\n  ];\n\n  If(negationfound, {True}, e);            /* note that a list is returned */\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/LogicRemoveTautologies.mpw";
        scriptMap.put("LogicRemoveTautologies",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n // (expression, level=1..3\n\n// Some shortcuts to match prev interface\n\n10 # LogicSimplify(_proposition, _level)_(level<?2)  <-- CNF(proposition);\n\n20 # LogicSimplify(_proposition, _level) <--\n[\n  Local(cnf, list, clauses);\n  Check(level >? 1, \"Argument\", \"Wrong level\");\n  // First get the CNF version of the proposition\n  Bind(cnf, CNF(proposition));\n\n  If(level <=? 1, cnf, [\n    Bind(list, Flatten(cnf, \"And?\"));\n    Bind(clauses, {});\n    ForEach(clause, list)\n    [\n      Local(newclause);\n      //newclause := BubbleSort(LogicRemoveTautologies(Flatten(clause, \"Or?\")), LessThan);\n      Bind(newclause, LogicRemoveTautologies(Flatten(clause, \"Or?\")));\n      If(newclause !=? {True}, DestructiveAppend(clauses, newclause));\n    ];\n\n    /*\n        Note that we sort each of the clauses so that they look the same,\n        i.e. if we have (A And? B) And? ( B And? A), only the first one will\n        persist.\n    */\n    Bind(clauses, RemoveDuplicates(clauses));\n\n    If(IsEqual(level, 3) And? (Length(clauses) !=? 0), [\n        Bind(clauses, DoUnitSubsumptionAndResolution(clauses));\n        Bind(clauses, LogicCombine(clauses));\n    ]);\n\n    Bind(clauses, RemoveDuplicates(clauses));\n\n    If(IsEqual(Length(clauses), 0), True, [\n        /* assemble the result back into a boolean expression */\n        Local(result);\n        Bind(result, True);\n        ForEach(item,clauses)\n        [\n            Bind(result, result And? UnFlatten(item, \"Or?\", False));\n        ];\n\n        result;\n    ]);\n  ]);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/LogicSimplify.mpw";
        scriptMap.put("LogicSimplify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Subsumes((_x) - (_y) == 0, Not? ((_x) - (_z)==0))_(y!=?z)    <-- True;\n// suif_tmp0_127_1-72==0 And? 78-suif_tmp0_127_1>=?0\n20 # Subsumes((_x) - (_y) == 0, (_z) - (_x) >=? 0)_(z>=?y)        <-- True;\n20 # Subsumes((_x) - (_y) == 0, (_z) - (_x) >?  0)_(z>?y)         <-- True;\n// suif_tmp0_127_1-72==0 And? suif_tmp0_127_1-63>=?0\n30 # Subsumes((_x) - (_y) == 0, (_x) - (_z) >=? 0)_(y>=?z)        <-- True;\n30 # Subsumes((_x) - (_y) == 0, (_x) - (_z) >? 0)_(y>?z)          <-- True;\n\n90 # Subsumes((_x), (_x))                                       <-- True;\n\n100# Subsumes((_x), (_y))                                       <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/Subsumes.mpw";
        scriptMap.put("Subsumes",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"=>\",{a,b});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/logic/equals_greaterthan_operator.mpw";
        scriptMap.put("=>",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"DisassembleExpression\",*);\n\n10 # DisassembleExpression( _expr ) <--\n[\n    Local(vars);\n    vars := MultiExpressionList( expr );\n    DisassembleExpression( expr, vars );\n];\n\n10 # DisassembleExpression( _expr, vars_IsList ) <--\n[\n    Local(mexpr,func,termList,result,powers,coeffs);\n    mexpr    := MakeMultiNomial(expr,vars);\n    func     := Lambda({x,y},If(y!=?0,DestructiveAppend(termList,{x,y})));\n    termList := {};\n    ScanMultiNomial(func,mexpr);\n    result   := Concat({vars},Transpose(termList));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/DisassembleExpression.mpw";
        scriptMap.put("DisassembleExpression",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n  Groebner : Calculate the Groebner basis of a set of polynomials.\n  Nice example of its power is\n\nIn> TableForm(Groebner({x*(y-1),y*(x-1)}))\n x*y-x\n x*y-y\n y-x\n y^2-y\nIn> Factor(y^2-y)\nResult: y*(y-1);\n\nFrom which you can see that x = y, and x^2 = x so x is 0 or 1.\n\n*/\n\nGroebner(f_IsList) <--\n[\n  Local(vars,i,j,S,nr,r);\n  nr:=Length(f);\n  vars:=VarList(f);\n  For(i:=1,i<=?nr,i++)\n  [\n    f[i] := MakeMultiNomial(f[i],vars);\n  ];\n  S:={};\n  For(i:=1,i<?nr,i++)\n  For(j:=i+1,j<=?nr,j++)\n  [\n    r := (MultiDivide(MultiS(f[i],f[j],f[i]),f)[2]);\n    If(NormalForm(r) !=? 0, S:= r:S);\n    f:=Concat(f,S);\n    S:={};\n    nr:=Length(f);\n  ];\n  MapSingle(\"NormalForm\",Concat(f));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/Groebner.mpw";
        scriptMap.put("Groebner",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//From 0Solve5/ListTerms5.mpw, 7 Nov 2010\n\n//Retract(\"ListTerms\",*);\n//Retract(\"terms\",*);\n\n10 # ListTerms(_expr) <--\n[\n    If(InVerboseMode(),Tell(\"ListTerms\",expr));\n    Local(termList);\n    Local(op,x2,x3);\n    termList := {};\n    If(IsFunction(expr),\n      [\n         {op,x2,x3} := FunctionToList(expr);\n         If(InVerboseMode(),Tell(\"          \",{op,x2,x3})); \n         terms(op,x2,x3);\n      ],\n      [\n         Push(termList,expr);\n      ]\n    );\n    termList;\n];\n\n\n10 # terms(_op,_x2,_x3)_(op=?ToAtom(\"+\") Or? op=?ToAtom(\"-\")) <--\n[\n    If(InVerboseMode(),[Tell(\"   terms10\",op);Tell(\"         \",{x2,x3});]);\n    Local(sgn);\n    If(op=?ToAtom(\"+\"),sgn:=1,sgn:=-1);\n    Push(termList,sgn*x3);\n    If(InVerboseMode(),Tell(\"         \",termList));\n    If(IsFunction(x2),\n      [\n         Local(L);\n         L := FunctionToList(x2);\n         If(InVerboseMode(),Tell(\"               \",L));\n         If(Length(L)=?3,terms(L[1],L[2],L[3]),Push(termList,x2));\n      ],\n      [\n         Push(termList,x2);\n      ]\n    );\n];\nUnFence(\"terms\",3);\n\n\n20 # terms(_op,_x2,_x3) <--\n[\n    If(InVerboseMode(),[Tell(\"   terms20\",op);Tell(\"         \",{x2,x3});]);\n    Local(F);\n    F := ListToFunction({op,x2,x3});\n    Push(termList,F);\n    If(InVerboseMode(),Tell(\"         \",termList));\n    termList;\n];\nUnFence(\"terms\",3);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/ListTerms.mpw";
        scriptMap.put("ListTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMM(_expr) <--  MM(expr,MultiExpressionList(expr));\nMM(_expr,_vars) <--  MakeMultiNomial(expr,vars);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MM.mpw";
        scriptMap.put("MM",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMultiDivTerm(MultiNomial(_vars,_term1),MultiNomial(_vars,_term2)) <--\n[\n  Local(lm1,lm2);\n  Bind(lm1,MultiLeadingTerm(MultiNomial(vars,term1)) );\n  Bind(lm2,MultiLeadingTerm(MultiNomial(vars,term2)) );\n  CreateTerm(vars,{lm1[1]-lm2[1],lm1[2] / lm2[2]});\n];\nMultiS(_g,_h,MultiNomial(_vars,_terms)) <--\n[\n  Local(gamma);\n\n  gamma :=Maximum(MultiDegree(g),MultiDegree(h));\n  Local(result,topterm);\n  topterm := MM(Product(vars^gamma));\n\n  result :=\n    MultiDivTerm(topterm,MultiLT(g))*g -\n    MultiDivTerm(topterm,MultiLT(h))*h;\n\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MultiDivTerm.mpw";
        scriptMap.put("MultiDivTerm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"MultiDivide\",*);\n\n/*************************************************************\n  MultiDivide :\n  input\n    f - a multivariate polynomial\n    g[1 .. n] - a list of polynomials to divide by\n  output\n    {q[1 .. n],r} such that f = q[1]*g[1] + ... + q[n]*g[n] + r\n\n  Basically quotient and remainder after division by a group of\n  polynomials.\n\n  110709    Corrected error in if-Select statement  (hao)\n**************************************************************/\n\n20 # MultiDivide(_f,g_IsList) <--\n[\n  If(InVerboseMode(),Tell(\"MultiDivide_1\",{f,g}));\n  Local(i,v,q,r,nr);\n  v  := MultiExpressionList(f+Sum(g));\n  f  := MakeMultiNomial(f,v);\n  nr := Length(g);\n  For(i:=1,i<=?nr,i++)\n  [\n    g[i] := MakeMultiNomial(g[i],v);\n  ];\n  If(Not? IsMulti(f),Break());\n  {q,r} := MultiDivide(f,g);\n  q     := MapSingle(\"NormalForm\",q);\n  r     := NormalForm(r);\n  {q,r};\n];\n\n\n10 # MultiDivide(f_IsMulti,g_IsList) <--\n[\n  If(InVerboseMode(),Tell(\"MultiDivide_2\",{f,g}));\n  Local(i,nr,q,r,p,v,finished);\n  nr := Length(g);\n  v  := MultiVars(f);\n  q  := FillList(0,nr);\n  r  := 0;\n  p  := f;\n  finished := MultiZero(p);\n  Local(plt,glt);\n  While (Not? finished)\n  [\n    plt := MultiLT(p);  //  MultiLT computes the multi-LeadingTerm\n    For(i:=1,i<=?nr,i++)\n    [\n      glt := MultiLT(g[i]);\n\n      if (MultiLM(glt) =? MultiLM(plt) Or? MultiTermLess({MultiLM(glt),1}, {MultiLM(plt),1}))\n      [\n        //   corrected if-select statement  110708    hso\n        if (Select(MultiLM(plt)-MultiLM(glt),{{n},n<?0}) =? {} )\n        [\n          Local(ff,ltbefore,ltafter);\n          ff := CreateTerm(v,{MultiLM(plt)-MultiLM(glt),MultiLC(plt)/MultiLC(glt)});\n          If(InVerboseMode(),Tell(\"      \",NormalForm(ff)));\n          q[i] := q[i] + ff;\n          ltbefore := MultiLeadingTerm(p);\n          p := p - ff*g[i];\n          ltafter := MultiLeadingTerm(p);\n          if (ltbefore[1] =? ltafter[1])\n          [\n            ltafter := MultiLT(p);\n            p       := p-ltafter;\n          ];\n//          Echo(ltbefore,MultiLeadingTerm(p));\n          i := nr + 2;\n        ];\n      ];\n    ];\n\n    If (i =? nr + 1,\n      [\n        r := r + LocalSymbols(a,b)(Subst(a,b)plt);\n        p := p - LocalSymbols(a,b)(Subst(a,b)plt);\n      ]\n    );\n    finished := MultiZero(p);\n  ];\n  {q,r};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MultiDivide.mpw";
        scriptMap.put("MultiDivide",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//TODO optimize this! keeps on converting to and from internal format!\n\n10 # MultiGcd( 0,_g) <-- g;\n10 # MultiGcd(_f, 0) <-- f;\n\n20 # MultiGcd(_f,_g) <--\n[\n  Local(v);\n  v:=MultiExpressionList(f+g);  //hier\n  NormalForm(MultiGcd(MakeMultiNomial(f,v),MakeMultiNomial(g,v)));\n];\n\n\n5 # MultiGcd(f_IsMulti,g_IsMulti)_(MultiTermLess({MultiLM(f),1},{MultiLM(g),1})) <--\n[\n//Echo(\"lesser\");\n  MultiGcd(g,f);\n];\n\n5  # MultiGcd(MultiNomial(_vars,_terms),g_IsMulti)_(MultiLM(MultiNomial(vars,terms)) =? MultiLM(g))\n     <-- CreateTerm(vars,{FillList(0,Length(vars)),1});\n\n5  # MultiGcd(MultiNomial(_vars,_terms),g_IsMulti)_( Select(MultiLM(MultiNomial(vars,terms))-MultiLM(g), {{n},n<?0} ) !=? {})\n     <-- CreateTerm(vars,{FillList(0,Length(vars)),1});\n\n5  # MultiGcd(MultiNomial(_vars,_terms),g_IsMulti)_(NormalForm(g) =? 0)\n     <-- CreateTerm(vars,{FillList(0,Length(vars)),1});\n10 # MultiGcd(f_IsMulti,g_IsMulti) <--\n[\n  LocalSymbols(a)\n  [\n    Bind(f,Subst(a,a)f);\n    Bind(g,Subst(a,a)g);\n  ];\n  Local(new);\n  While(g !=? 0)\n  [\n//Echo(\"before f\",f,NormalForm(f));\n//Echo(\"before g\",g,NormalForm(g));\n    Bind(new, MultiDivide(f,{g}));\n//Echo(\"new g\",NormalForm(new[1][1]),NormalForm(new[2]));\nIf(new[1][1]=?0,\n[\n  g:=MakeMultiNomial(1,MultiVars(f));\n//Echo(\"PRIM \",MultiPrimitivePart(g));\n  new[2]:=0;\n]);\n    Bind(new, new[2]);\n    Bind(f,g);\n    Bind(g,new);\n\n//Echo(\"after f\",f,NormalForm(f));\n//Echo(\"after g\",g,NormalForm(g));\n  ];\n  MultiPrimitivePart(f);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MultiGcd.mpw";
        scriptMap.put("MultiGcd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// The basic container for multivariates\nRulebase(\"MultiNomial\",{vars,terms});\n\n// using the sparse tree driver for multivariate polynomials\n//LoadScriptOnce(\"multivar.rep/sparsenomial.mpi\");\n//LoadScriptOnce(\"multivar.rep/partialdensenomial.mpi\");\n\n/*If(IsBound(MultiNomialDriver),\n  `LoadScriptOnce(@MultiNomialDriver),\n  LoadScriptOnce(\"multivar.rep/sparsenomial.mpi\"));\n*/\n\n// Code that can build the internal representation of a multivariate polynomial\n//LoadScriptOnce(\"multivar.rep/makemulti.mpi\");\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MultiNomial.mpw";
        scriptMap.put("MultiNomial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMultiSimp(_expr) <--\n[\n  Local(vars);\n  vars:=MultiExpressionList(expr);\n//Echo({\"step1 \",MM(expr,vars)});\n  MultiSimp2(MM(expr,vars));\n];\n\n10 # MultiSimp2(_a / _b) <--\n[\n  Local(c1,c2,gcd,cmn,vars);\n\n\n  c1 := MultiContentTerm(a);\n  c2 := MultiContentTerm(b);\n  gcd:=Gcd(c1[2],c2[2]);\n  c1[2] := c1[2]/gcd;\n  c2[2] := c2[2]/gcd;\n\n  cmn:=Minimum(c1[1],c2[1]);\n  c1[1] := c1[1] - cmn;\n  c2[1] := c2[1] - cmn;\n\n  vars:=MultiVars(a);\n  Check(vars =? MultiVars(b), \"Argument\", \"incompatible Multivars to simplify\");\n\n  (NormalForm(CreateTerm(vars,c1))/NormalForm(CreateTerm(vars,c2)))\n    *(NormalForm(MultiPrimitivePart(a))/NormalForm(MultiPrimitivePart(b)));\n];\n\n20 # MultiSimp2(expr_IsMulti) <--\n[\n  NormalForm(MultiContent(expr))*NormalForm(MultiPrimitivePart(expr));\n];\n30 # MultiSimp2(_expr) <-- expr;\n\nMultiContent(multi_IsMulti)\n<--\n[\n  Local(least,gcd);\n  Bind(least, MultiDegree(multi));\n  Bind(gcd,MultiLeadingCoef(multi));\n  ScanMultiNomial(\"MultiContentScan\",multi);\n  CreateTerm(MultiVars(multi),MultiContentTerm(multi));\n];\n\nMultiContentTerm(multi_IsMulti)\n<--\n[\n  Local(least,gcd);\n  Bind(least, MultiDegree(multi));\n  Bind(gcd,MultiLeadingCoef(multi));\n  ScanMultiNomial(\"MultiContentScan\",multi);\n  {least,gcd};\n];\n\nMultiContentScan(_coefs,_fact) <--\n[\n  Bind(least,Minimum({least,coefs}));\n  Bind(gcd,Gcd(gcd,fact));\n];\nUnFence(\"MultiContentScan\",2);\n\nMultiPrimitivePart(MultiNomial(vars_IsList,_terms))\n<--\n[\n  Local(cont);\n  Bind(cont,MultiContentTerm(MultiNomial(vars,terms)));\n  Bind(cont,CreateTerm(vars,{-cont[1],1/Rationalize(cont[2])}));\n  MultiNomialMultiply(MultiNomial(vars,terms), cont);\n];\n\n10 # MultiRemoveGcd(x_IsMulti/y_IsMulti) <--\n[\n  Local(gcd);\n  Bind(gcd,MultiGcd(x,y));\n  Bind(x,MultiDivide(x,{gcd})[1][1]);\n  Bind(y,MultiDivide(y,{gcd})[1][1]);\n  x/y;\n];\n20 # MultiRemoveGcd(_x) <-- x;\n\n\n\n5 # MultiDegree(MultiNomial(_vars,_term))_(Not?(IsList(term))) <-- {};\n10 # MultiDegree(MultiNomial(_vars,{})) <-- FillList(-Infinity,Length(vars));\n20 # MultiDegree(MultiNomial(_vars,_terms))\n   <-- (MultiLeadingTerm(MultiNomial(vars,terms))[1]);\n\n\n10 # MultiLeadingCoef(MultiNomial(_vars,_terms))\n   <-- (MultiLeadingTerm(MultiNomial(vars,terms))[2]);\n\n10 # MultiLeadingMono(MultiNomial(_vars,{})) <-- 0;\n20 # MultiLeadingMono(MultiNomial(_vars,_terms))\n   <-- Product(vars^(MultiDegree(MultiNomial(vars,terms))));\n\n20 # MultiLeadingTerm(_m) <-- MultiLeadingCoef(m) * MultiLeadingMono(m);\n\nMultiVars(MultiNomial(_vars,_terms)) <-- vars;\n\n20 # MultiLT(multi_IsMulti)\n   <-- CreateTerm(MultiVars(multi),MultiLeadingTerm(multi));\n\n10 # MultiLM(multi_IsMulti) <-- MultiDegree(multi);\n\n10 # MultiLC(MultiNomial(_vars,{})) <-- 0;\n20 # MultiLC(multi_IsMulti) <-- MultiLeadingCoef(multi);\n\nDropZeroLC(multi_IsMulti) <-- MultiDropLeadingZeroes(multi);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/MultiSimp.mpw";
        scriptMap.put("MultiSimp",scriptString);
        scriptMap.put("MultiSimp2",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ReassembleListTerms\",*);\n\n10 # ReassembleListTerms( disassembly_IsList ) <--\n[\n    Local(vars,lst,powers,coeffs,ii,pows,coef,term);\n    vars   := disassembly[1];\n    powers := disassembly[2];\n    coeffs := disassembly[3];\n    lst    := {};\n    For(ii:=1,ii<=?Length(powers),ii++)\n    [\n        pows := powers[ii];\n        coef := coeffs[ii];\n        //Tell(\"     \",{pows,coef});\n        term  := coef*Product(vars^pows);\n        //Tell(\"          \",term);\n        DestructiveAppend(lst,term);\n    ];\n    lst;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/ReassembleListTerms.mpw";
        scriptMap.put("ReassembleListTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* code pertaining to creating the internal format for multivariate\n   polynomials (the inverse of NormalForm\n\n- MultiExpressionList(x)\n  extract all variable-like sub-expressions from the main expression,\n  including functions, which can then get treated as if they were\n  a variable.\n- IsMultiExpression(x)\n  determing whether 'x' can be a 'variable' for a multiNomial\n- IsMulti(x)\n  returns True if 'x' is a multivariate expression in internal format.\n  Useful for transformation rules.\n */\n\nMultiExpressionList(_expr) <-- VarList(expr,\"IsMultiExpression\");\n10 # IsMultiExpression(_x + _y) <-- False;\n10 # IsMultiExpression(_x - _y) <-- False;\n10 # IsMultiExpression(   - _y) <-- False;\n10 # IsMultiExpression(_x * _y) <-- False;\n10 # IsMultiExpression(_x / _y) <-- False;\n10 # IsMultiExpression(_x ^ y_IsPositiveInteger) <-- False;\n11 # IsMultiExpression(_x ^ _y)_(IsPositiveInteger(Simplify(y))) <-- False;\n//10 # IsMultiExpression(x_IsConstant) <-- False;\n10 # IsMultiExpression(x_IsMultiConstant) <-- False;\n\n//TODO: shouldn't this be more global? The problem right now is\n// that IsConstant/IsVariable take Pi to be a constant...\nIsMultiConstant(_n) <-- (VarList(n,\"IsVr\")=?{});\n10 # IsVr(n_IsNumber) <-- False;\n10 # IsVr(n_IsFunction) <-- False;\n10 # IsVr(n_IsString) <-- False;\n20 # IsVr(_n) <-- True;\n100 # IsMultiExpression(_x) <-- True;\n\n10 # IsMulti(MultiNomial(vars_IsList,_terms)) <-- True;\n20 # IsMulti(_anything) <-- False;\n\n\n\nLocalSymbols(a,vars,pow)  [\n  20 #  MultiSingleFactor(_vars,_a,_pow) <--\n    [\n      Local(term);\n      term:={FillList(0,Length(vars)),1};\n      term[1][Find(vars,a)] := pow;\n      CreateTerm(vars,term);\n    ];\n];\nLocalSymbols(x,y,vars)  [\n10 #  MakeMultiNomial(x_IsMultiConstant,vars_IsList) <--\n      CreateTerm(vars,{FillList(0,Length(vars)),x});\n20 #  MakeMultiNomial(_x,vars_IsList)_(Contains(vars,x)) <-- MultiSingleFactor(vars,x,1);\n30 #  MakeMultiNomial(_x + _y,vars_IsList) <--\n      MakeMultiNomial(x,vars) + MakeMultiNomial(y,vars);\n30 #  MakeMultiNomial(_x * _y,vars_IsList) <--\n      MakeMultiNomial(x,vars) * MakeMultiNomial(y,vars);\n30 #  MakeMultiNomial(- _x,vars_IsList) <-- -MakeMultiNomial(x,vars);\n30 #  MakeMultiNomial(_x - _y,vars_IsList) <--\n      MakeMultiNomial(x,vars) - MakeMultiNomial(y,vars);\n30 #  MakeMultiNomial(MultiNomial(_vars,_terms),vars_IsList)\n      <-- MultiNomial(vars,terms);\n\n// This rule would accept almost all terms, assuming them to be const.\n100 #  MakeMultiNomial(_x,vars_IsList) <--\n      [\n      CreateTerm(vars,{FillList(0,Length(vars)),x});\n      ];\n\n];\n\nLocalSymbols(x,y,z,vars,gcd,a,a)  [\n  20 #  MakeMultiNomial(_x / (_y / _z),vars_IsList)\n     <-- MakeMultiNomial((x*z) / y,vars_IsList);\n  20 #  MakeMultiNomial((_x / _y) / _z,vars_IsList)\n     <-- MakeMultiNomial((x*z) / y,vars_IsList);\n  25 #  MakeMultiNomial(_x / y_IsConstant,vars_IsList)\n     <-- MakeMultiNomial(1/y,vars)*MakeMultiNomial(x,vars);\n  30 #  MakeMultiNomial(_x / _y,vars_IsList) <--\n        [\n          Local(result);\n//Echo(\"1...\",x);\n//Echo(\"2...\",y);\n          Bind(result,MultiRemoveGcd(MakeMultiNomial(x,vars)/MakeMultiNomial(y,vars)));\n//Echo(\"3...\",result);\n          result;\n        ];\n  ];\n\n\nMultiNomial(_vars,_x) + MultiNomial(_vars,_y) <--\n           MultiNomialAdd(MultiNomial(vars,x), MultiNomial(vars,y));\nMultiNomial(_vars,_x) * MultiNomial(_vars,_y) <--\n           MultiNomialMultiply(MultiNomial(vars,x), MultiNomial(vars,y));\nMultiNomial(_vars,_x) - MultiNomial(_vars,_y) <--\n        MultiNomialAdd(MultiNomial(vars,x), MultiNomialNegate(MultiNomial(vars,y)));\n                      - MultiNomial(_vars,_y) <--\n        MultiNomialNegate(MultiNomial(vars,y));\nMultiNomial(_vars,_x) / MultiNomial(_vars,_x) <-- MakeMultiNomial(1, vars);\n\n\nLocalSymbols(x,n,vars)  [\n30 #  MakeMultiNomial(_x ^ n_IsInteger,vars_IsList)_(Contains(vars,x)) <--\n      MultiSingleFactor(vars,x,n);\n40 #  MakeMultiNomial(_x ^ n_IsPositiveInteger,vars_IsList) <--\n      [\n        Local(mult,result);\n        Bind(mult,MakeMultiNomial(x,vars));\n        Bind(result,MakeMultiNomial(1,vars));\n        While(n>?0)\n        [\n          If(n&1 !=? 0, Bind(result, MultiNomialMultiply(result,mult)));\n          Bind(n,n>>1);\n          If(n!=?0,Bind(mult,MultiNomialMultiply(mult,mult)));\n        ];\n        result;\n      ];\n\n  15 #  MakeMultiNomial(_x ^ _n,vars_IsList)_(Not?(IsInteger(n)) And? IsInteger(Simplify(n))) <--\n        MakeMultiNomial( x ^  Simplify(n),vars);\n\n  50 #  MakeMultiNomial(_x ^ (_n),vars_IsList)_(Contains(vars,x)) <--\n        [\n          Bind(n,Simplify(n));\n          If(IsInteger(n),\n            MultiSingleFactor(vars,x,n),\n            MultiSingleFactor(vars,x^n,1)\n              );\n        ];\n];\n\n\nx_IsMulti + (y_IsMulti/z_IsMulti) <-- ((x*z+y)/z);\n(y_IsMulti/z_IsMulti) + x_IsMulti <-- ((x*z+y)/z);\n(y_IsMulti/z_IsMulti) + (x_IsMulti/w_IsMulti) <-- ((y*w+x*z)/(z*w));\n(y_IsMulti/z_IsMulti) - (x_IsMulti/w_IsMulti) <-- ((y*w-x*z)/(z*w));\n(y_IsMulti/z_IsMulti) * (x_IsMulti/w_IsMulti) <-- ((y*x)/(z*w));\n(y_IsMulti/z_IsMulti) / (x_IsMulti/w_IsMulti) <-- ((y*w)/(z*x));\nx_IsMulti - (y_IsMulti/z_IsMulti) <-- ((x*z-y)/z);\n(y_IsMulti/z_IsMulti) - x_IsMulti <-- ((y-x*z)/z);\n(a_IsMulti/(c_IsMulti/b_IsMulti))    <-- ((a*b)/c);\n((a_IsMulti/c_IsMulti)/b_IsMulti)    <-- (a/(b*c));\n((a_IsMulti/b_IsMulti) * c_IsMulti)  <-- ((a*c)/b);\n(a_IsMulti * (c_IsMulti/b_IsMulti))  <-- ((a*c)/b);\n- ((a_IsMulti)/(b_IsMulti))         <-- (-a)/b;\n\n\nMultiNomialMultiply(\n     MultiNomial(_vars,_terms1)/MultiNomial(_vars,_terms2),\n     MultiNomial(_vars,_terms3)/MultiNomial(_vars,_terms4)) <--\n[\n  MultiNomialMultiply(MultiNomial(vars,terms1),MultiNomial(vars,terms3))/\n  MultiNomialMultiply(MultiNomial(vars,terms2),MultiNomial(vars,terms4));\n];\nMultiNomialMultiply(\n     MultiNomial(_vars,_terms1)/MultiNomial(_vars,_terms2),\n     MultiNomial(_vars,_terms3)) <--\n[\n  MultiNomialMultiply(MultiNomial(vars,terms1),MultiNomial(vars,terms3))/\n  MultiNomial(vars,terms2);\n];\nMultiNomialMultiply(\n     MultiNomial(_vars,_terms3),\n     MultiNomial(_vars,_terms1)/MultiNomial(_vars,_terms2)) <--\n[\n  MultiNomialMultiply(MultiNomial(vars,terms1),MultiNomial(vars,terms3))/\n  MultiNomial(vars,terms2);\n];\n\n10 # MultiNomialMultiply(_a,_b) <--\n[\n  Echo({\"ERROR!\",a,b});\n  Echo({\"ERROR!\",Type(a),Type(b)});\n];\n\n\n\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/makemulti/MakeMultiNomial.mpw";
        scriptMap.put("MakeMultiNomial",scriptString);
        scriptMap.put("MultiExpressionList",scriptString);
        scriptMap.put("IsMultiExpression",scriptString);
        scriptMap.put("IsMultiConstant",scriptString);
        scriptMap.put("IsVr",scriptString);
        scriptMap.put("MultiSingleFactor",scriptString);
        scriptMap.put("IsMulti",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* Implementation of MultiNomials based on sparse representation\n   in the sparsetree.mpi code. This is the real driver, using\n   the sparse trees just for representation.\n */\n//LoadScriptOnce(\"multivar.rep/sparsetree.mpi\");\n\nLocalSymbols(NormalMultiNomial) [\n\nCreateTerm(_vars,{_coefs,_fact})\n  <-- MultiNomial(vars,CreateSparseTree(coefs,fact));\n\n/************************************************************\n\nAdding and multiplying multivariate polynomials\n\n************************************************************/\nMultiNomialAdd(MultiNomial(_vars,_x), MultiNomial(_vars,_y))\n    <-- MultiNomial(vars,AddSparseTrees(Length(vars),x,y));\nMultiNomialMultiplyAdd(MultiNomial(_vars,_x), MultiNomial(_vars,_y),_coefs,_fact)\n    <-- MultiNomial(vars,MultiplyAddSparseTrees(Length(vars),x,y,coefs,fact));\nMultiNomialNegate(MultiNomial(_vars,_terms))\n    <--\n    [\n      SparseTreeMap(Hold({{coefs,list},-list}),Length(vars),terms);\n      MultiNomial(vars,terms);\n    ];\nMultiNomialMultiply(MultiNomial(_vars,_x),_multi2)\n    <--\n    [\n      Local(result);\n      Bind(result,MakeMultiNomial(0,vars));\n      SparseTreeScan(\"muadm\",Length(vars),x);\n      result;\n    ];\nmuadm(_coefs,_fact) <--\n[\n  Bind(result,MultiNomialMultiplyAdd(result, multi2,coefs,fact));\n];\nUnFence(\"muadm\",2);\n\n\n/* NormalForm: done as an explicit loop in stead of using SparseTreeScan\n   for speed. This routine is a lot faster!\n */\n\nRulebase(\"NormalForm\",{expression});\nRule(\"NormalForm\",1,1000,True) expression;\n0 # NormalForm(UniVariate(_var,_first,_coefs)) <--\n    ExpandUniVariate(var,first,coefs);\n10 # NormalForm(x_IsMulti/y_IsMulti) <-- NormalForm(x)/NormalForm(y);\n20 # NormalForm(MultiNomial(_vars,_list) )\n    <-- NormalMultiNomial(vars,list,1);\n\n\n\n\n10 # NormalMultiNomial({},_term,_prefact) <-- prefact*term;\n20 # NormalMultiNomial(_vars,_list,_prefact)\n    <--\n    [\n      Local(first,rest,result);\n      Bind(first,First(vars));\n      Bind(rest,Rest(vars));\n      Bind(result,0);\n      ForEach(item,list)\n      [\n        Bind(result,result+NormalMultiNomial(rest,item[2],prefact*first^(item[1])));\n      ];\n      result;\n    ];\n\n]; // LocalSymbols\n\nMultiLeadingTerm(MultiNomial(_vars,_terms))\n    <--\n    [\n      Local(coefs,fact);\n      Bind(coefs,MultiDegreeScanHead(terms,Length(vars)));\n      {coefs,fact};\n    ];\n10 # MultiDegreeScanHead(_tree,0)\n   <--\n   [\n     Bind(fact,tree);\n     {};\n   ];\n10 # MultiDegreeScanHead(_tree,1)\n   <--\n   [\n     Bind(fact,tree[1][2]);\n     {tree[1][1]};\n   ];\n20 # MultiDegreeScanHead(_tree,_depth)\n   <--\n   [\n     (tree[1][1]):MultiDegreeScanHead(tree[1][2],depth-1);\n   ];\nUnFence(\"MultiDegreeScanHead\",2);\n\nScanMultiNomial(_op,MultiNomial(vars_IsList,_terms))\n    <-- SparseTreeScan(op,Length(vars),terms);\nUnFence(\"ScanMultiNomial\",2);\n\n\nMultiDropLeadingZeroes(MultiNomial(_vars,_terms))\n    <--\n    [\n      MultiDropScan(terms,Length(vars));\n      MultiNomial(vars,terms);\n    ];\n10 # MultiDropScan(0,0) <-- True;\n10 # MultiDropScan({_n,0},0) <-- True;\n20 # MultiDropScan(_n,0)\n   <--\n   [\n     False;\n   ];\n30 # MultiDropScan(_tree,_depth)\n   <--\n   [\n     Local(i);\n     For(i:=1,i<=?Length(tree),i++)\n     [\n       if (MultiDropScan(tree[i][2],depth-1))\n       [\n         DestructiveDelete(tree,i);\n         i--;\n       ]\n       else\n       [\n         i:=Length(tree);\n       ];\n     ];\n     (tree =? {});\n   ];\nUnFence(\"MultiDropScan\",2);\n\n\nMultiTermLess({_deg1,_fact1},{_deg2,_fact2}) <--\n  [\n    Local(deg);\n    Bind(deg, deg1-deg2);\n    While(deg !=? {} And? First(deg) =? 0) [ Bind(deg, Rest(deg));];\n\n    ((deg =? {}) And? (fact1-fact2 <? 0)) Or?\n    ((deg !=? {}) And? (deg[1] <? 0));\n  ];\n\n20 # MultiZero(multi_IsMulti) <--\n[\n  CheckMultiZero(DropZeroLC(multi));\n];\n10 # CheckMultiZero(MultiNomial(_vars,{})) <-- True;\n20 # CheckMultiZero(MultiNomial(_vars,_terms)) <-- False;\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/sparsenomial/sparsenomial.mpw";
        scriptMap.put("CreateTerm",scriptString);
        scriptMap.put("MultiNomialAdd",scriptString);
        scriptMap.put("MultiNomialNegate",scriptString);
        scriptMap.put("MultiNomialMultiply",scriptString);
        scriptMap.put("NormalForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nCreateSparseTree\nSparseTreeMap\nSparseTreeScan\nAddSparseTrees\nMultiplyAddSparseTrees\nSparseTreeGet\n*/\n\n/* Implementation of a sparse tree of Multidimensional matrix elements.\n*/\n\n10 # SparseTreeGet({},_tree) <-- tree;\n20 # SparseTreeGet(_key,_tree) <--\n[\n  SparseTreeGet2(Rest(key),Assoc(First(key),tree));\n];\n10 # SparseTreeGet2(_key,Empty) <-- 0;\n20 # SparseTreeGet2(_key,_item) <-- SparseTreeGet(key,First(Rest(item)));\n\n10 # SparseTreeSet({_i},_tree,_newvalue)\n   <--\n[\n  Local(Current,assoc,result);\n  Bind(assoc,Assoc(i,tree));\n  if(assoc=?Empty)\n  [\n    Bind(Current,0);\n    Bind(result,Eval(newvalue));\n    AddSparseTrees(1,tree,CreateSparseTree({i},result));\n  ]\n  else\n  [\n    Bind(Current,assoc[2]);\n    Bind(result,Eval(newvalue));\n    assoc[2] := result;\n  ];\n  result;\n];\n20 # SparseTreeSet(_key,_tree,_newvalue) <--\n[\n  SparseTreeSet2(Rest(key),Assoc(First(key),tree));\n];\n10 # SparseTreeSet2(_key,Empty) <-- 0;\n20 # SparseTreeSet2(_key,_item)\n   <-- SparseTreeSet(key,First(Rest(item)),newvalue);\nUnFence(\"SparseTreeSet\",3);\nUnFence(\"SparseTreeSet2\",2);\n\n\nLocalSymbols(SparseTreeMap2,SparseTreeScan2,Muaddterm,MuMuaddterm,\n              meradd,meraddmap) [\n\n10 # CreateSparseTree({},_fact) <-- fact;\n\n20 # CreateSparseTree(_coefs,_fact)\n    <-- CreateSparseTree(First(coefs),Rest(coefs),fact);\n10 # CreateSparseTree(_first,{},_fact) <-- {{first,fact}};\n20 # CreateSparseTree(_first,_coefs,_fact)\n    <-- {{first,CreateSparseTree(First(coefs),Rest(coefs),fact)}};\n\n10 # SparseTreeMap(_op,_depth,_list) <-- SparseTreeMap2(list,depth,{});\n10 # SparseTreeMap2(_list,1,_coefs)\n   <--\n   ForEach(item,list)\n   [\n     item[2] := ApplyFast(op,{Concat(coefs,{item[1]}),item[2]});\n   ];\n20 # SparseTreeMap2(_list,_depth,_coefs)\n   <--\n   ForEach(item,list)\n   [\n     SparseTreeMap2(item[2],AddN(depth,-1),Concat(coefs,{item[1]}));\n   ];\nUnFence(\"SparseTreeMap\", 3);\n[Local(fn);fn:=ToString(SparseTreeMap2);`UnFence(@fn,3);];\n\n10 # SparseTreeScan(_op,_depth,_list) <-- SparseTreeScan2(list,depth,{});\n10 # SparseTreeScan2(_list,0,_coefs)  <-- ApplyFast(op,{coefs,list});\n20 # SparseTreeScan2(_list,_depth,_coefs)\n   <--\n   ForEach(item,list)\n   [\n     SparseTreeScan2(item[2],AddN(depth,-1),Concat(coefs,{item[1]}));\n   ];\nUnFence(\"SparseTreeScan\", 3);\n[Local(fn);fn:=ToString(SparseTreeScan2);`UnFence(@fn,3);];\n\n\n\n5  # AddSparseTrees(0,_x,_y) <-- x+y;\n10 # AddSparseTrees(_depth,_x,_y) <--\n[\n  Local(i,t1,t2,inspt);\n  Bind(t1,x);\n  Bind(i,1);\n  Bind(t2,y);\n  Bind(inspt,{});\n  While(t1 !=? {} And? t2 !=? {})\n  [\n    Muaddterm(First(t1),First(t2));\n  ];\n  While(t2 !=? {})\n  [\n    Bind(x,DestructiveAppend(x,First(t2)));\n    Bind(t2,Rest(t2));\n  ];\n  While(inspt !=? {})\n  [\n    Bind(i,First(inspt));\n    Bind(x,DestructiveInsert(x,i[2],i[1]));\n    Bind(inspt,Rest(inspt));\n  ];\n  x;\n];\n\n10 # Muaddterm({_pow,_list1},{_pow,_list2}) <--\n[\n  if(depth=?1)\n    [ t1[1][2] := list1+list2; ]\n  else\n    [ t1[1][2] := AddSparseTrees(AddN(depth,-1),list1,list2);];\n  Bind(t2,Rest(t2));\n];\n20 # Muaddterm(_h1,_h2)_(h1[1]<?h2[1]) <--\n[\n  Bind(inspt,{h2,i}:inspt);\n  Bind(t2,Rest(t2));\n];\n30 # Muaddterm(_h1,_h2)<--\n[\n  Bind(t1,Rest(t1));\n  Bind(i,AddN(i,1));\n];\n[Local(fn);fn:=ToString(Muaddterm);`UnFence(@fn,2);];\n\n5  # MultiplyAddSparseTrees(0,_x,_y,{},_fact) <-- x+fact*y;\n10 # MultiplyAddSparseTrees(_depth,_x,_y,_coefs,_fact)\n    <--\n[\n  Local(i,t1,t2,inspt,term);\n  Bind(t1,x);\n  Bind(i,1);\n  Bind(t2,y);\n  Bind(inspt,{});\n  While(t1 !=? {} And? t2 !=? {})\n  [\n    MuMuaddterm(First(t1),First(t2),coefs);\n  ];\n\n  While(t2 !=? {})\n  [\n    Bind(term,First(t2));\n    Bind(x,DestructiveAppend(x,meradd(First(t2),coefs)));\n    Bind(t2,Rest(t2));\n  ];\n  While(inspt !=? {})\n  [\n    Bind(i,First(inspt));\n    Bind(x,DestructiveInsert(x,i[2],i[1]));\n    Bind(inspt,Rest(inspt));\n  ];\n  x;\n];\n\n10 # meradd({_ord,rest_IsList},_coefs) <--\n[\n  Local(head);\n  Bind(head,First(coefs));\n  Bind(coefs,Rest(coefs));\n  {ord+head,meraddmap(rest,coefs)};\n];\n20 # meradd({_ord,_rest},_coefs) <--\n[\n   {ord+First(coefs),rest*fact};\n];\n\n10 # meraddmap(list_IsList,_coefs) <--\n[\n  Local(result);\n  Bind(result,{});\n  ForEach(item,list)\n  [\n    DestructiveAppend(result,meradd(item,coefs));\n  ];\n  result;\n];\n[Local(fn);fn:=ToString(meradd);`UnFence(@fn,2);];\n[Local(fn);fn:=ToString(meraddmap);`UnFence(@fn,2);];\n\n10 # MuMuaddterm({_pow1,_list1},{_pow2,_list2},_coefs)_(pow1=?pow2+coefs[1]) <--\n[\n  if(depth=?1)\n    [ t1[1][2] := list1+fact*list2; ]\n  else\n    [\n      t1[1] := {pow1,MultiplyAddSparseTrees(AddN(depth,-1),list1,list2,Rest(coefs),fact)};\n    ];\n  Bind(t2,Rest(t2));\n];\n20 # MuMuaddterm(_h1,_h2,_coefs)_(h1[1]<?h2[1]+coefs[1]) <--\n[\n//Echo({\"inspt \",h1,h2,coefs});\n  Bind(inspt,{meradd(First(t2),coefs),i}:inspt);\n  Bind(t2,Rest(t2));\n];\n30 # MuMuaddterm(_h1,_h2,_coefs)<--\n[\n  Bind(t1,Rest(t1));\n  Bind(i,AddN(i,1));\n];\n[Local(fn);fn:=ToString(MuMuaddterm);`UnFence(@fn,3);];\n\n\n]; // LocalSymbols\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/multivar/sparsetree/sparsetree.mpw";
        scriptMap.put("CreateSparseTree",scriptString);
        scriptMap.put("SparseTreeMap",scriptString);
        scriptMap.put("SparseTreeScan",scriptString);
        scriptMap.put("AddSparseTrees",scriptString);
        scriptMap.put("MultiplyAddSparseTrees",scriptString);
        scriptMap.put("SparseTreeGet",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// BracketRational: find two rational approximations\n//////////////////////////////////////////////////\n\n/// Return a list of two rational numbers r1, r2 such that r1<r<r2 and |r2-r1| < eps*|r|\nBracketRational(r,eps):=\n[\n        Local(n,cflist, r1, r2);\n        cflist := ContFracList(r);\n        n:=2;\n        r1 := ContFracEval(Take(cflist,n));\n        r2 := -r1;\n        // find two successive approximations and check that they differ by less than |eps*r|\n        While (n<?Length(cflist) And? ( Abs(N(Eval(r2-r1))) >? Abs(N(Eval(eps*r)) ) ) )\n        [\n                r2 := r1;\n                n++;\n                r1 := ContFracEval(Take(cflist,n));\n        ];\n        // now r1 and r2 are some rational numbers.\n        // decide whether the search was successful.\n        If(\n                n=?Length(cflist),\n                {},        // return empty list if not enough precision\n                If(N(Eval(r-r1))>?0,\n                        {r1, r2},        // successive approximations are always bracketing, we only need to decide their order\n                        {r2, r1}\n                )\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/BracketRational.mpw";
        scriptMap.put("BracketRational",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"CharacteristicEquation\",{matrix,var})\n   SymbolicDeterminant(matrix-var*Identity(Length(matrix)));\nHoldArgument(\"CharacteristicEquation\",var);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/CharacteristicEquation.mpw";
        scriptMap.put("CharacteristicEquation",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// continued fractions for polynomials\n//////////////////////////////////////////////////\n\n/// main interface\n10 # ContFrac(_n) <-- ContFrac(n, 6);\n50 # ContFrac(_n,_depth) <-- ContFracEval(ContFracList(n, depth), rest);\n\n40 # ContFrac(n_CanBeUni,_depth)_(Length(VarList(n)) =? 1) <--\n[\n  ContFracDoPoly(n,depth,VarList(n)[1]);\n];\n\n5  # ContFracDoPoly(_exp,0,_var) <-- rest;\n5  # ContFracDoPoly(0,0,_var) <-- rest;\n10 # ContFracDoPoly(_exp,_depth,_var) <--\n[\n  Local(content,exp2,first,second);\n  first:=Coef(exp,var,0);\n  exp:=exp-first;\n  content:=Content(exp);\n  exp2:=DivPoly(1,PrimitivePart(exp),var,5+3*depth)-1;\n  second:=Coef(exp2,0);\n  exp2 := exp2 - second;\n  first+content/((1+second)+ContFracDoPoly(exp2,depth-1,var));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/ContFrac.mpw";
        scriptMap.put("ContFrac",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// ContFracEval: evaluate continued fraction from the list of coefficients\n//////////////////////////////////////////////////\n/// Each coefficient is either a single expression or a list of 2 expressions, giving the term and the numerator of the current level in the fraction.\n/// ContFracEval({{a0, b0}, {a1, b1}, ...}) = a0+b0/(a1+b1/(...))\n/// ContFracEval({a0, a1, ...}) = a0+1/(a1+1/(...))\n\n10 # ContFracEval({}, _rest) <-- rest;\n// finish recursion here\n10 # ContFracEval({{_n, _m}}, _rest) <-- n+m+rest;\n15 # ContFracEval({_n}, _rest) <-- n+rest;\n/// Continued fractions with nontrivial numerators\n20 # ContFracEval(list_IsList, _rest)_(IsList(First(list))) <-- First(First(list)) + Rest(First(list)) / ContFracEval(Rest(list), rest);\n/// Continued fractions with unit numerators\n30 # ContFracEval(list_IsList, _rest) <-- First(list) + 1 / ContFracEval(Rest(list), rest);\n\n/// evaluate continued fraction: main interface\nContFracEval(list_IsList) <-- ContFracEval(list, 0);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/ContFracEval.mpw";
        scriptMap.put("ContFracEval",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/////////////////////////////////////////////////\n/// Continued fractions stuff\n/////////////////////////////////////////////////\n\n/// compute the list of continued fraction coefficients for a given number\n/// if order is not given, computes to the end\n10 # ContFracList(_n) <-- ContFracList(n, Infinity);\n/// compute list of given length\n10 # ContFracList(_n, _depth)_(depth <=? 0) <-- {};\n20 # ContFracList(n_IsInteger, _depth) <-- {n};\n// prevent infinite loop when in numeric mode\n30 # ContFracList(n_IsNumber, _depth) _InNumericMode() <-- NonN(ContFracList(Rationalize(n), depth));\n\n40 # ContFracList(n_IsNumber, _depth) <-- ContFracList(Rationalize(n), depth);\n\n/* n/m = Quotient(n,m) + 1/( m/Modulo(n,m) ) */\n35 # ContFracList((n_IsNegativeInteger) / (m_IsInteger), _depth) <-- Push( ContFracList(m/Modulo(n,m), depth-1) , Quotient(n,m)-1);\n\n40 # ContFracList((n_IsInteger) / (m_IsInteger), _depth) <-- Push( ContFracList(m/Modulo(n,m), depth-1) , Quotient(n,m));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/ContFracList.mpw";
        scriptMap.put("ContFracList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Decimal( n_IsInteger ) <-- {n,{0}};\n10 # Decimal( (n_IsPositiveInteger) / (d_IsPositiveInteger) ) <--\n[\n  Local(result,rev,first,period,repeat,static);\n  result:={Quotient(n,d)};\n  Decimal(result,Modulo(n,d),d,350);\n  rev:=DecimalFindPeriod(result);\n  first:=rev[1];\n  period:=rev[2];\n  repeat:=result[first .. (first+period-1)];\n  static:=result[1 .. (first-1)];\n  DestructiveAppend(static,repeat);\n];\n20 # Decimal(_n/_m)_((n/m)<?0) <-- \"-\":Decimal(-n/m);\n\n10 # Decimal(_result , _n , _d,_count ) <--\n[\n  While(count>?0)\n  [\n    DestructiveAppend(result,Quotient(10*n,d));\n    n:=Modulo(10*n,d);\n    count--;\n  ];\n];\n\nDecimalFindPeriod(_list) <--\n[\n  Local(period,nr,reversed,first,i);\n  reversed:=Rest(DestructiveReverse(FlatCopy(Rest(list))));\n  nr:=Length(reversed)>>1;\n  period:=1;\n  first:=reversed[1];\n\n  For(i:=1,i<?nr,i++)\n  [\n    If(reversed[i+1] =? first And? DecimalMatches(reversed,i),\n      [\n        period:=i;\n        i:=nr;\n      ]\n      );\n  ];\n\n  first:=Length(list)-period;\n  While(first>?1 And? list[first] =? list[first+period]) first--;\n  first++;\n\n  {first,period};\n];\n\nDecimalMatches(_reversed,_period) <--\n[\n  Local(nr,matches,first);\n  nr:=0;\n  matches:=True;\n  first:=1;\n  While((nr<?100) And? matches)\n  [\n    matches := (matches And?\n       (reversed[first .. (first+period-1)] =? reversed[(first+period) .. (first+2*period-1)]));\n    first:=first+period;\n    nr:=nr+period;\n  ];\n  matches;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/Decimal.mpw";
        scriptMap.put("Decimal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// diagonal matrices will be caught by IsUpperTriangular\n10 # EigenValues(matrix_IsUpperTriangular) <-- Diagonal(matrix);\n10 # EigenValues(matrix_IsLowerTriangular) <-- Diagonal(matrix);\n\n20 # EigenValues(matrix_IsMatrix) <-- Roots(CharacteristicEquation(matrix,xx));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/EigenValues.mpw";
        scriptMap.put("EigenValues",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nEigenVectors(_matrix,_eigenvalues) <--\n[\n  Local(result,n);\n/*  eigenvalues:=N(Eval(eigenvalues));  */\n  n:=Length(eigenvalues);\n  result:={};\n  ForEach(e,eigenvalues)\n  [\n    Local(possible);\n/* Echo({\"1...\",result}); */\n    possible:=OldSolve(matrix*MakeVector(k,n)==e*MakeVector(k,n),MakeVector(k,n))[1];\n/* Echo({\"2...\"}); */\n/* Echo({\"2...\"}); */\n\n    If(Not?(IsZeroVector(possible)),\n      DestructiveAppend(result,possible)\n      );\n/* Echo({\"3...\"}); */\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/EigenVectors.mpw";
        scriptMap.put("EigenVectors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// guess the rational number behind an imprecise number\n/// prec parameter is the max number of digits you can have in the denominator\nGuessRational(_x) <-- GuessRational(x, Floor(1/2*BuiltinPrecisionGet()));\nGuessRational(x_IsRationalOrNumber, prec_IsInteger) <-- [\n        Local(denom'estimate, cf, i);\n        denom'estimate := 1;\n        cf := ContFracList(x);\n        For(i:=2, i<=?Length(cf) And? denom'estimate <? 10^prec, i++)\n                [        // estimate the denominator\n                        denom'estimate := denom'estimate * If(\n                                cf[i] =? 1,\n                                If(\n                                        i+2<=?Length(cf),        // have at least two more terms, do a full estimate\n                                        RoundTo(N(Eval(cf[i]+1/(cf[i+1]+1/cf[i+2]))), 3),\n                                        // have only one more term\n                                        RoundTo(N(Eval(cf[i]+1/cf[i+1])), 3)\n                                ),\n                                // term is not 1, use the simple estimate\n                                cf[i]\n                        );\n                ];\n        If (denom'estimate <? 10^prec,\n                //If(InVerboseMode(), Echo({\"GuessRational: all \", i, \"terms are within limits\"})),\n                i--        // do not use the last term\n        );\n        i--;        // loop returns one more number\n        //If(InVerboseMode(), Echo({\"GuessRational: using \", i, \"terms of the continued fraction\"}));\n        ContFracEval(Take(cf, i));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/GuessRational.mpw";
        scriptMap.put("GuessRational",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* InverseTaylor : given a function y=f(x), determine the Taylor series\n * expansion of the inverse f^-1(y)=x this function around y0=f(x0).\n *\n */\nFunction(\"InverseTaylor\",{var,val,degree,func})\n[\n  Local(l1);\n  l1:=UniTaylor(func,var,val,degree);\n  val+ReversePoly(l1,var,var,var,degree+1);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/InverseTaylor.mpw";
        scriptMap.put("InverseTaylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n1 # IsFreeOf({},_expr) <-- True;\n2 # IsFreeOf(var_IsList, _expr) <-- And?(IsFreeOf(First(var),expr), IsFreeOf(Rest(var),expr));\n\n4 # IsFreeOf(_var,{}) <-- True;\n5 # IsFreeOf(_var,expr_IsList) <-- And?(IsFreeOf(var,First(expr)), IsFreeOf(var,Rest(expr)));\n\n/* Accept any variable. */\n10 # IsFreeOf(_expr,_expr) <-- False;\n\n/* Otherwise check all leafs of a function. */\n11 # IsFreeOf(_var,expr_IsFunction) <-- IsFreeOf(var,Rest(FunctionToList(expr)));\n\n/* Else it doesn't depend on any variable. */\n12 # IsFreeOf(_var,_expr) <-- True;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/IsFreeOf.mpw";
        scriptMap.put("IsFreeOf",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"IsZeroVector\",{aList}) aList =? ZeroVector(Length(aList));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/IsZeroVector.mpw";
        scriptMap.put("IsZeroVector",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLagrangeInt(_var,_list) <--\n[\n  Local(nr);\n  nr:=Length(list);\n  Product(FillList(var,nr)-list);\n];\n\nLagrangeInterpolant(list_IsList,_values,_var) <--\n[\n  Local(i,nr,sublist);\n  nr:=Length(list);\n  result:=0;\n  For(i:=1,i<=?nr,i++)\n  [\n    sublist:=FlatCopy(list);\n    DestructiveDelete(sublist,i);\n    result:=result + values[i]*LagrangeInt(var,sublist)/LagrangeInt(list[i],sublist);\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/LagrangeInterpolant.mpw";
        scriptMap.put("LagrangeInterpolant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"NearRational\",*);\n\n//////////////////////////////////////////////////\n/// NearRational, GuessRational\n//////////////////////////////////////////////////\n\n/// find rational number with smallest num./denom. near a given number x\n/// See: HAKMEM, MIT AI Memo 239, 02/29/1972, Item 101C\n\n10 # NearRational(_x) <-- NearRational(x, Floor(1/2*BuiltinPrecisionGet()));\n\n15 # NearRational(x_IsRationalOrNumber, prec_IsInteger) <-- \n[\n        Local(x1, x2, i,  old'prec);\n        old'prec := BuiltinPrecisionGet();\n    BuiltinPrecisionSet(prec + 8);        // 8 guard digits (?)\n        x1 := ContFracList(N(Eval(x+10^(-prec))));\n        x2 := ContFracList(N(Eval(x-10^(-prec))));\n\n    /*\n    If(InVerboseMode(),\n      [\n         Echo(\"NearRational: x      = \", N(Eval(x           ))));\n         Echo(\"NearRational: xplus  = \", N(Eval(x+10^(-prec)))));\n         Echo(\"NearRational: xmin   = \", N(Eval(x-10^(-prec)))));\n         Echo(\"NearRational: Length(x1) = \", Length(x1),\" \",x1));\n         Echo(\"NearRational: Length(x2) = \", Length(x2),\" \",x1));\n      ]\n    );\n    */\n    \n        // find where the continued fractions for \"x1\" and \"x2\" differ\n        // prepare result in \"x1\" and length of result in \"i\"\n        For (i:=1, i<=?Length(x1) And? i<=?Length(x2) And? x1[i]=?x2[i], i++ ) True;\n        If(\n                i>?Length(x1),\n                // \"x1\" ended but matched, so use \"x2\" as \"x1\"\n                x1:=x2,\n                If(\n                        i>?Length(x2),\n                // \"x2\" ended but matched, so use \"x1\"\n                        True,\n                // neither \"x1\" nor \"x2\" ended and there is a mismatch at \"i\"\n                // apply recipe: select the smalest of the differing terms\n                        x1[i]:=Minimum(x1[i],x2[i])\n                )\n        );\n        // recipe: x1dd 1 to the lx1st term unless it's the lx1st in the originx1l sequence\n        //Ayal added this line, i could become bigger than Length(x1)!\n        //If(InVerboseMode(), Echo({\"NearRational: using \", i, \"terms of the continued fraction\"}));\n        If(i>?Length(x1),i:=Length(x1));\n        x1[i] := x1[i] + If(i=?Length(x1), 0, 1);\n        BuiltinPrecisionSet(old'prec);\n        ContFracEval(Take(x1, i));\n];\n\n\n20 # NearRational(_z, prec_IsInteger)_\n      (And?(Im(z)!=?0,IsRationalOrNumber(Im(z)),IsRationalOrNumber(Re(z)))) <--\n[\n    Local(rr,ii);\n    rr := Re(z);\n    ii := Im(z);\n    Complex( NearRational(rr,prec), NearRational(ii,prec) );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/NearRational.mpw";
        scriptMap.put("NearRational",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"NewLine\",*);\n\n10 # NewLine()  <-- WriteN(Nl(),1);\n20 # NewLine(n_IsPositiveInteger) <--  WriteN(Nl(),n);\n30 # NewLine(_n) <-- Check(False, \"Argument\", \"The argument must be a positive integer  \");\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/NewLine.mpw";
        scriptMap.put("NewLine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nNl():= UnicodeToString(10);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/Nl.mpw";
        scriptMap.put("Nl",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Lagrangian power series reversion. Copied\n   from Knuth seminumerical algorithms */\n\nReversePoly(_f,_g,_var,_newvar,_degree) <--\n[\n  Local(orig,origg,G,V,W,U,n,initval,firstder,j,k,newsum);\n  orig:=MakeUni(f,var);\n  origg:=MakeUni(g,var);\n  initval:=Coef(orig,0);\n  firstder:=Coef(orig,1);\n  V:=Coef(orig,1 .. Degree(orig));\n  V:=Concat(V,FillList(0,degree));\n  G:=Coef(origg,1 .. Degree(origg));\n  G:=Concat(G,FillList(0,degree));\n  W:=FillList(0,Length(V)+2);\n  W[1]:=G[1]/firstder;\n  U:=FillList(0,Length(V)+2);\n  U[1]:=1/firstder;\n  n:=1;\n  While(n<?degree-1)\n  [\n    n++;\n    For(k:=0,k<?n-1,k++)\n    [\n      newsum:=U[k+1];\n      For(j:=2,j<=?k+1,j++)\n      [\n        newsum:=newsum-U[k+2-j]*V[j];\n      ];\n      U[k+1]:=newsum/firstder;\n    ];\n    newsum:=0;\n    For(k:=2,k<=?n,k++)\n    [\n      newsum:=newsum - k*U[n+1-k]*V[k];\n    ];\n    U[n]:=newsum/firstder;\n    newsum:=0;\n    For(k:=1,k<=?n,k++)\n    [\n      newsum:=newsum + k*U[n+1-k]*G[k]/n;\n    ];\n    W[n]:=newsum;\n  ];\n  DestructiveInsert(W,1,Coef(origg,0));\n  Subst(newvar,newvar-initval)\n    NormalForm(UniVariate(newvar,0,W));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/ReversePoly.mpw";
        scriptMap.put("ReversePoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nSpace() := WriteN(\" \",1);\nSpace(n):= WriteN(\" \",n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/Space.mpw";
        scriptMap.put("Space",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nUniqueConstant() <--\n[\n  Local(result);\n  result := ToString(LocalSymbols(C)(C));\n  ToAtom(StringMidGet(2,Length(result)-1,result));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/UniqueConstant.mpw";
        scriptMap.put("UniqueConstant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nTemplateFunction(\"WithValue\",{var,val,expr})\n[\n  If(IsList(var),\n     ApplyFast(\"MacroLocal\",var),\n     MacroLocal(var)\n    );\n  ApplyFast(\":=\",{var,val});\n  Eval(expr);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/WithValue.mpw";
        scriptMap.put("WithValue",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nWriteN(string,n) :=\n[\n  Local(i);\n  For(i:=1,i<=?n,i++) WriteString(string);\n  True;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/newly/WriteN.mpw";
        scriptMap.put("WriteN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # BellNumber(n_IsInteger)                <-- Sum(k,1,n,StirlingNumber2(n,k));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/BellNumber.mpw";
        scriptMap.put("BellNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nCatalanNumber(_n) <--\n[\n        Check( IsPositiveInteger(n), \"Argument\", \"CatalanNumber: Error: argument must be positive\" );\n        BinomialCoefficient(2*n,n)/(n+1);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/CatalanNumber.mpw";
        scriptMap.put("CatalanNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Check whether n is a power of some integer, assuming that it has no prime factors <=? limit.\n/// This routine uses only integer arithmetic.\n/// Returns {p, s} where s is the smallest prime integer such that n=p^s. (p is not necessarily a prime!)\n/// If no powers found, returns {n, 1}. Primality testing of n is not done.\nCheckIntPower(n, limit) :=\n[\n        Local(s0, s, root);\n        If(limit<=?1, limit:=2);        // guard against too low value of limit\n        // compute the bound on power s\n        s0 := IntLog(n, limit);\n        // loop: check whether n^(1/s) is integer for all prime s up to s0\n        root := 0;\n        s := 0;\n        While(root =? 0 And? NextPseudoPrime(s)<=?s0)        // root=0 while no root is found\n        [\n                s := NextPseudoPrime(s);\n                root := IntNthRoot(n, s);\n                If(\n                        root^s =? n,        // found root\n                        True,\n                        root := 0\n                );\n        ];\n        // return result\n        If(\n                root=?0,\n                {n, 1},\n                {root, s}\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/CheckIntPower.mpw";
        scriptMap.put("CheckIntPower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Digital root of n (repeatedly add digits until reach a single digit).\n10 # DigitalRoot(n_IsPositiveInteger) <-- If(n%9=?0,9,n%9);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/DigitalRoot.mpw";
        scriptMap.put("DigitalRoot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Theorem 6.2 p112\n5  # Divisors(0)        <-- 0;\n5  # Divisors(1)        <-- 1;\n// Unsure about if there should also be a function that returns\n// n's divisors, may have to change name in future\n10 # Divisors(_n)        <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"Divisors: argument must be positive integer\");\n        Local(len,sum,factors,i);\n        sum:=1;\n        factors:=Factors(n);\n        len:=Length(factors);\n        For(i:=1,i<=?len,i++)[\n                sum:=sum*(factors[i][2]+1);\n        ];\n        sum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Divisors.mpw";
        scriptMap.put("Divisors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Theorem 6.2 p112\n5  # DivisorsSum(0)        <-- 0;\n5  # DivisorsSum(1)        <-- 1;\n10 # DivisorsSum(_n)         <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"DivisorsSum: argument must be positive integer\");\n        Local(factors,i,sum,len,p,k);\n        p:=0;k:=0;\n        factors:={};\n        factors:=Factors(n);\n        len:=Length(factors);\n        sum:=1;\n        For(i:=1,i<=?len,i++)[\n                p:=factors[i][1];\n                k:=factors[i][2];\n                sum:=sum*(p^(k+1)-1)/(p-1);\n        ];\n        sum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/DivisorsSum.mpw";
        scriptMap.put("DivisorsSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # Euler(0)                <-- 1;\n10 # Euler(n_IsOdd)        <-- 0;\n10 # Euler(n_IsEven)        <-- - Sum(r,0,n/2-1,BinomialCoefficient(n,2*r)*Euler(2*r));\n10 # Euler(n_IsNonNegativeInteger,_x)        <-- Sum(i,0,Round(n/2),BinomialCoefficient(n,2*i)*Euler(2*i)*(x-1/2)^(n-2*i)/2^(2*i));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Euler.mpw";
        scriptMap.put("Euler",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** Compute an array of Euler numbers using recurrence relations.\n*/\n10 # EulerArray(n_IsInteger) <--\n[\n        Local(E,i,sum,r);\n        E:=ZeroVector(n+1);\n        E[1]:=1;\n        For(i:=1,2*i<=?n,i++)[\n                sum:=0;\n                For(r:=0,r<=?i-1,r++)[\n                        sum:=sum+BinomialCoefficient(2*i,2*r)*E[2*r+1];\n                ];\n                E[2*i+1] := -sum;\n        ];\n        E;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/EulerArray.mpw";
        scriptMap.put("EulerArray",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nEulerian(n_IsInteger,k_IsInteger) <-- Sum(j,0,k+1,(-1)^j*BinomialCoefficient(n+1,j)*(k-j+1)^n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Eulerian.mpw";
        scriptMap.put("Eulerian",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"FermatNumber\",{n})[\n        Check(IsPositiveInteger(n), \"Argument\", \"FermatNumber: argument must be a positive integer\");\n        2^(2^n)+1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/FermatNumber.mpw";
        scriptMap.put("FermatNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Check whether n is a power of some prime integer and return that integer and the power.\n/// This routine uses only integer arithmetic.\n/// Returns {p, s} where p is a prime and n=p^s.\n/// If no powers found, returns {n, 1}. Primality testing of n is not done.\n20 # GetPrimePower(n_IsPositiveInteger) <--\n[\n        Local(s, factors, new'factors);\n        // first, separate any small prime factors\n        factors := TrialFactorize(n, 257);        // \"factors\" = {n1, {p1,s1},{p2,s2},...} or just {n} if no factors found\n        If(\n                Length(factors) >? 1,        // factorized into something\n                // now we return {n, 1} either if we haven't completely factorized, or if we factorized into more than one prime factor; otherwise we return the information about prime factors\n                If(\n                        factors[1] =? 1 And? Length(factors) =? 2,        // factors = {1, {p, s}}, so we have a prime power n=p^s\n                        factors[2],\n                        {n, 1}\n                ),\n                // not factorizable into small prime factors -- use main algorithm\n                [\n                        factors := CheckIntPower(n, 257);        // now factors = {p, s} with n=p^s\n                        If(\n                                factors[2] >? 1,        // factorized into something\n                                // now need to check whether p is a prime or a prime power and recalculate \"s\"\n                                If(\n                                        IsPrime(factors[1]),\n                                        factors,        // ok, prime power, return information\n                                        [        // not prime, need to check if it's a prime power\n                                                new'factors := GetPrimePower(factors[1]);        // recursive call; now new'factors = {p1, s1} where n = (p1^s1)^s; we need to check that s1>?1\n                                                If(\n                                                        new'factors[2] >? 1,\n                                                        {new'factors[1], new'factors[2]*factors[2]},        // recalculate and return prime power information\n                                                        {n, 1}        // not a prime power\n                                                );\n                                        ]\n                                ),\n                                // not factorizable -- return {n, 1}\n                                {n, 1}\n                        );\n                ]\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/GetPrimePower.mpw";
        scriptMap.put("GetPrimePower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 #         HarmonicNumber(n_IsInteger)        <-- HarmonicNumber(n,1);\nHarmonicNumber(n_IsInteger,r_IsPositiveInteger) <--\n[\n        // small speed up\n        if( r=?1 )[\n                Sum(k,1,n,1/k);\n        ] else [\n                Sum(k,1,n,1/k^r);\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/HarmonicNumber.mpw";
        scriptMap.put("HarmonicNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Return integer part of the logarithm of x in given base. Use only integer arithmetic.\n10 # IntLog(_x, _base) _ (base<=?1) <-- Undefined;\n/// Use variable steps to speed up operation for large numbers x\n20 # IntLog(_x, _base) <--\n[\n        Local(result, step, old'step, factor, old'factor);\n        result := 0;\n        old'step := step := 1;\n        old'factor := factor := base;\n        // first loop: increase step\n        While (x >=? factor)\n        [\n                old'factor := factor;\n                factor := factor*factor;\n                old'step := step;\n                step := step*2;\n        ];\n        If(x >=? base,\n          [\n                step := old'step;\n                result := step;\n                x := Quotient(x, old'factor);\n          ],\n          step := 0\n        );\n        // second loop: decrease step\n        While (step >? 0 And? x !=? 1)\n        [\n                step := Quotient(step,2);        // for each step size down to 1, divide by factor if x is up to it\n                factor := base^step;\n                If(\n                        x >=? factor,\n                        [\n                                x:=Quotient(x, factor);\n                                result := result + step;\n                        ]\n                );\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IntLog.mpw";
        scriptMap.put("IntLog",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Compute integer part of s-th root of (positive) integer n.\n// algorithm using floating-point math\n10 # IntNthRoot(_n, 2) <-- Floor(SqrtN(n));\n20 # IntNthRoot(_n, s_IsInteger) <--\n[\n        Local(result, k);\n        GlobalPush(BuiltinPrecisionGet());\n        // find integer k such that 2^k <=? n^(1/s) < 2^(k+1)\n        k := Quotient(IntLog(n, 2), s);\n        // therefore we need k*Ln(2)/Ln(10) digits for the floating-point calculation\n        BuiltinPrecisionSet(2+Quotient(k*3361, 11165));        // 643/2136 < Ln(2)/Ln(10) < 3361/11165\n        result := Round(ExpN(DivideN(Internal'LnNum(DivideN(n, 2^(k*s))), s))*2^k);\n        BuiltinPrecisionSet(GlobalPop());\n        // result is rounded and so it may overshoot (we do not use Floor above because numerical calculations may undershoot)\n        If(result^s>?n, result-1, result);\n];\n\n/* algorithm using only integer arithmetic.\n(this is slower than the floating-point algorithm for large numbers because all calculations are with long integers)\nIntNthRoot1(_n, s_IsInteger) <--\n[\n        Local(x1, x2, x'new, y1);\n        // initial guess should always undershoot\n        //        x1:= 2 ^ Quotient(IntLog(n, 2), s);         // this is worse than we can make it\n        x1 := IntLog(n,2);\n        // select initial interval using (the number of bits in n) mod s\n        // note that if the answer is 1, the initial guess must also be 1 (not 0)\n        x2 := Quotient(x1, s);        // save these values for the next If()\n        x1 := Modulo(x1, s)/s;        // this is kept as a fraction\n        // now assign the initial interval, x1 <=? root <=? x2\n        {x1, x2} := If(\n                x1 >=? 263/290,        // > Ln(15/8)/Ln(2)\n                Quotient({15,16}*2^x2, 8),\n                If(\n                x1 >=? 373/462,        // > Ln(7/4)/Ln(2)\n                Quotient({7,8}*2^x2, 4),\n                If(\n                x1 >=? 179/306,        // > Ln(3/2)/Ln(2)\n                Quotient({6,7}*2^x2, 4),\n                If(\n                x1 >=? 113/351,        // > Ln(5/4)/Ln(2)\n                Quotient({5,6}*2^x2, 4),\n                Quotient({4,5}*2^x2, 4)        // between x1 and (5/4)*x1\n        ))));\n        // check whether x2 is the root\n        y1 := x2^s;\n        If(\n                y1=n,\n                x1 := x2,\n                // x2 is not a root, so continue as before with x1\n                y1 := x1^s        // henceforth, y1 is always x1^s\n        );\n        // Newton iteration combined with bisection\n        While(y1 <? n)\n        [\n//        Echo({x1, x2});\n                x'new := Quotient(x1*((s-1)*y1+(s+1)*n), (s+1)*y1+(s-1)*n) + 1;        // add 1 because the floating-point value undershoots\n                If(\n                        x'new <? Quotient(x1+x2, 2),\n                        // x'new did not reach the midpoint, need to check progress\n                        If(\n                                Quotient(x1+x2, 2)^s <=? n,\n                                // Newton's iteration is not making good progress, so leave x2 in place and update x1 by bisection\n                                x'new := Quotient(x1+x2, 2),\n                                // Newton's iteration knows what it is doing. Update x2 by bisection\n                                x2 := Quotient(x1+x2, 2)\n                        )\n                        // else, x'new reached the midpoint, good progress, continue\n                );\n                x1 := x'new;\n                y1 := x1^s;\n        ];\n        If(y1=n, x1, x1-1);        // subtract 1 if we overshot\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IntNthRoot.mpw";
        scriptMap.put("IntNthRoot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsAmicablePair(m_IsPositiveInteger,n_IsPositiveInteger) <-- ( ProperDivisorsSum(m)=?n And? ProperDivisorsSum(n)=?m );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsAmicablePair.mpw";
        scriptMap.put("IsAmicablePair",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Carmichael numbers are odd,squarefree and have at least 3 prime factors\n5  # IsCarmichaelNumber(n_IsEven)                <-- False;\n5  # IsCarmichaelNumber(_n)_(n<?561)                <-- False;\n10 # IsCarmichaelNumber(n_IsPositiveInteger)        <--\n[\n        Local(i,factors,length,carmichael);\n\n        factors:=Factors(n);\n        carmichael:=True;\n        length:=Length(factors);\n        if( length <? 3)[\n                 carmichael:=False;\n        ] else [\n                For(i:=1,i<=?length And? carmichael,i++)[\n                        //Echo( n-1,\"%\",factors[i][1]-1,\"=?\", Modulo(n-1,factors[i][1]-1) );\n                        If( Modulo(n-1,factors[i][1]-1) !=? 0, carmichael:=False );\n                        If(factors[i][2]>?1,carmichael:=False);        // squarefree\n                ];\n        ];\n        carmichael;\n];\n\nIsCarmichaelNumber(n_IsList) <-- MapSingle(\"IsCarmichaelNumber\",n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsCarmichaelNumber.mpw";
        scriptMap.put("IsCarmichaelNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # IsComposite(1)                        <-- False;\n10 # IsComposite(n_IsPositiveInteger)         <-- (Not? IsPrime(n));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsComposite.mpw";
        scriptMap.put("IsComposite",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # IsCoprime(list_IsList)                     <-- (Lcm(list) =? Product(list));\n10 # IsCoprime(n_IsInteger,m_IsInteger)        <-- (Gcd(n,m) =? 1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsCoprime.mpw";
        scriptMap.put("IsCoprime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # IsIrregularPrime(p_IsComposite)        <-- False;\n// First irregular prime is 37\n5  # IsIrregularPrime(_p)_(p<?37)        <-- False;\n\n// an odd prime p is irregular iff p divides the numerator of a Bernoulli number B(2*n) with\n// 2*n+1<p\n10 # IsIrregularPrime(p_IsPositiveInteger) <--\n[\n        Local(i,irregular);\n\n        i:=1;\n        irregular:=False;\n\n        While( 2*i + 1 <? p And? (irregular =? False) )[\n                If( Abs(Numerator(Bernoulli(2*i))) % p =? 0, irregular:=True );\n                i++;\n        ];\n        irregular;\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsIrregularPrime.mpw";
        scriptMap.put("IsIrregularPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsPerfect(n_IsPositiveInteger) <-- ProperDivisorsSum(n)=?n;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsPerfect.mpw";
        scriptMap.put("IsPerfect",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # IsPrime(_n)_(Not? IsInteger(n) Or? n<=?1) <-- False;\n3 # IsPrime(n_IsInteger)_(n<=?FastIsPrime(0)) <-- IsSmallPrime(n);\n\n/* Fast pseudoprime testing: if n is a prime, then 24 divides (n^2-1) */\n5 # IsPrime(n_IsPositiveInteger)_(n >? 4 And? Modulo(n^2-1,24)!=?0) <-- False;\n\n/* Determine if a number is prime, using Rabin-Miller primality\n   testing. Code submitted by Christian Obrecht\n */\n10 # IsPrime(n_IsPositiveInteger) <-- RabinMiller(n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsPrime.mpw";
        scriptMap.put("IsPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Returns whether n is a prime^m. */\n10 # IsPrimePower(n_IsPrime) <-- True;\n10 # IsPrimePower(0) <-- False;\n10 # IsPrimePower(1) <-- False;\n20 # IsPrimePower(n_IsPositiveInteger) <-- (GetPrimePower(n)[2] >? 1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsPrimePower.mpw";
        scriptMap.put("IsPrimePower",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Theorem 9.1 p187\n10 # IsQuadraticResidue(_a,_p) <--\n[\n        Check( IsInteger(a) And? IsInteger(p) And? p>?2 And? IsCoprime(a,p) And? IsPrime(p),\n                \"Argument\", \"IsQuadraticResidue: Invalid arguments\");\n        If(a^((p-1)/2) % p =? 1, True, False);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsQuadraticResidue.mpw";
        scriptMap.put("IsQuadraticResidue",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Returns whether n is a small by a lookup table, very fast.\nThe largest prime number in the table is returned by FastIsPrime(0). */\n\n2 # IsSmallPrime(0) <-- False;\n3 # IsSmallPrime(n_IsInteger) <-- (FastIsPrime(n)>?0);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsSmallPrime.mpw";
        scriptMap.put("IsSmallPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsSquareFree(n_IsInteger)        <-- ( Moebius(n) !=? 0 );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsSquareFree.mpw";
        scriptMap.put("IsSquareFree",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsTwinPrime(n_IsPositiveInteger)        <-- (IsPrime(n) And? IsPrime(n+2));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/IsTwinPrime.mpw";
        scriptMap.put("IsTwinPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Definition 9.2 p191\n\n10 # LegendreSymbol(_a,_p)        <--\n[\n        Check( IsInteger(a) And? IsInteger(p) And? p>?2 And? IsCoprime(a,p) And? IsPrime(p),\n                \"Argument\", \"LegendreSymbol: Invalid arguments\");\n        If(IsQuadraticResidue(a,p), 1, -1 );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/LegendreSymbol.mpw";
        scriptMap.put("LegendreSymbol",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Definition 6.3 p120\n\n5  # Moebius(1)        <-- 1;\n\n10 # Moebius(_n)        <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"Moebius: argument must be positive integer\");\n        Local(factors,i,repeat);\n        repeat:=0;\n        factors:=Factors(n);\n        len:=Length(factors);\n        For(i:=1,i<=?len,i++)[\n                If(factors[i][2]>?1,repeat:=1);\n        ];\n        If(repeat=?0,(-1)^len,0);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Moebius.mpw";
        scriptMap.put("Moebius",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// obtain the real next prime number -- use primality testing\n1# NextPrime(_i) <--\n[\n        Until(IsPrime(i)) i := NextPseudoPrime(i);\n        i;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/NextPrime.mpw";
        scriptMap.put("NextPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// obtain next number that has good chances of being prime (not divisible by 2,3)\n1# NextPseudoPrime(i_IsInteger)_(i<=?1) <-- 2;\n2# NextPseudoPrime(2) <-- 3;\n//2# NextPseudoPrime(3) <-- 5;\n3# NextPseudoPrime(i_IsOdd) <--\n[\n        // this sequence generates numbers not divisible by 2 or 3\n        i := i+2;\n        If(Modulo(i,3)=?0, i:=i+2, i);\n/* commented out because it slows things down without a real advantage\n// this works only for odd i>=5\n        i := If(\n                Modulo(-i,3)=0,\n                i + 2,\n                i + 2*Modulo(-i, 3)\n        );\n        // now check if divisible by 5\n        If(\n                Modulo(i,5)=0,\n                NextPseudoPrime(i),\n                i\n        );\n*/\n];\n// this works only for even i>=4\n4# NextPseudoPrime(i_IsEven) <-- NextPseudoPrime(i-1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/NextPseudoPrime.mpw";
        scriptMap.put("NextPseudoPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nNthRoot\nNthRoot'Calc\nNthRoot'List\nNthRoot'Save\nNthRoot'Restore\nNthRoot'Clear\n\n*/\n\n//////\n// $Id: nthroot.mpi,v 1.5 2007/05/17 11:56:45 ayalpinkus Exp $\n// calculation/simplifaction of nth roots of nonnegative integers\n// NthRoot         - interface function\n// NthRoot'Calc    - actually calculate/simplifies\n// NthRoot'List    - list table entries for a given n\n// NthRoot'Restore - get a root from lookup table\n// NthRoot'Save    - save a root in lookup table\n// NthRoot'Clear   - clear lookup table\n//////\n\n// LocalSymbols(m,n,r,\n//                NthRoot'Table,\n//                NthRoot'Calc,\n//                NthRoot'List,\n//                NthRoot'Restore,\n//                NthRoot'Save,\n//                NthRoot'Clear)\nLocalSymbols(m,n,r,\n             NthRoot'Table)\n[\n\n// interface function for nth root of m\n// m>=0, n>1, integers\n// m^(1/n) --> f*(r^(1/n))\nNthRoot(m_IsNonNegativeInteger,n_IsInteger)_(n>?1) <--\n[\n   Local(r);\n   r:=NthRoot'Restore(m,n);\n   If(Length(r)=?0,\n   [\n      r:=NthRoot'Calc(m,n);\n      NthRoot'Save(m,n,r);\n   ]);\n   r;\n];\n\n// internal functions\nFunction(\"NthRoot'Calc\",{m,n})\n[\n   Local(i,j,f,r,in);\n   Bind(i,2);\n   Bind(j,Ceil(FastPower(m,N(1.0/n))+1));\n   Bind(f,1);\n   Bind(r,m);\n   // for large j (approx >4000)\n   // using Factors instead of the\n   // following.  would this be\n   // faster in general?\n//Echo(\"i j \",i,\" \",j);\n   While(IsLessThan(i,j))\n   [\n      Bind(in,PowerN(i,n));\n//Echo(\"r in mod \",r, \" \",in,\" \",ModuloN(r,in));\n      While(IsEqual(ModuloN(r,in),0))\n      [\n         Bind(f,MultiplyN(f,i));\n         Bind(r,QuotientN(r,in));\n      ];\n      While(IsEqual(ModuloN(r,i),0))   //\n         Bind(r,QuotientN(r,i));         //\n      //Bind(i,NextPrime(i));\n      Bind(i,NextPseudoPrime(i));\n      Bind(j,Ceil(FastPower(r,N(1.0/n))+1));\n   ];\n   //List(f,r);\n   List(f,QuotientN(m,PowerN(f,n))); //\n];\n\n// lookup table utilities\nFunction(\"NthRoot'List\",{n})\n[\n   If(Length(NthRoot'Table)>?0,\n   [\n      Local(p,xx);\n      p:=Select(NthRoot'Table, {{xx},First(xx)=?n});\n      If(Length(p)=?1,Rest(p[1]),List());\n   ],\n   List());\n];\n\nFunction(\"NthRoot'Restore\",{m,n})\n[\n   Local(p);\n   p:=NthRoot'List(n);\n   If(Length(p)>?0,\n   [\n      Local(r,xx);\n      r:=Select(p, {{xx},First(xx)=?m});\n      If(Length(r)=?1,First(Rest(r[1])),List());\n   ],\n   List());\n];\n\nFunction(\"NthRoot'Save\",{m,n,r})\n[\n   Local(p);\n   p:=NthRoot'List(n);\n   If(Length(p)=?0,\n   // create power list and save root\n   DestructiveInsert(NthRoot'Table,1,List(n,List(m,r))),\n   [\n      Local(rr,xx);\n      rr:=Select(p, {{xx},First(xx)=?m});\n      If(Length(rr)=?0,\n      [\n         // save root only\n         DestructiveAppend(p,List(m,r));\n      ],\n      // already saved\n      False);\n   ]);\n];\n\n//TODO why is NthRoot'Table both lazy global and protected with LocalSymbols?\nFunction(\"NthRoot'Clear\",{}) SetGlobalLazyVariable(NthRoot'Table,List());\n\n// create empty table\nNthRoot'Clear();\n\n]; // LocalSymbols(m,n,r,NthRoot'Table);\n\n//////\n//////\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/NthRoot.mpw";
        scriptMap.put("NthRoot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"NumberToRep\",*);\n\n\n10 # NumberToRep( N_IsNumber ) <--\n[\n    //If(InVerboseMode(),Tell(NumberToRep,N));\n    Local(oldPrec,sgn,assoc,typ,val,prec,rep);\n    oldPrec  := BuiltinPrecisionGet();\n    BuiltinPrecisionSet(300);\n    /*   NOTE: the above arbitrary 'magic number' is used because it is \n     *   currently necessary to set BuiltinPrecision to a value large \n     *   enough to handle any forseeable input.  Of course, even 300\n     *   might not be enough!  I am looking for a way to base the \n     *   setting directly on the input number itself.                   */\n     \n    sgn      := Sign(N); \n    assoc    := DumpNumber(Abs(N));\n    //If(InVerboseMode(),[ Tell(\"   \",assoc); Tell(\"   \",sgn); ]);\n    typ := Assoc(\"type\",assoc)[2];\n    //If(InVerboseMode(),Tell(\"   \",typ));\n    If( typ =? \"BigDecimal\",\n       [\n          rep := { sgn*Assoc(\"unscaledValue\",assoc)[2],\n                   Assoc(\"precision\",    assoc)[2],\n                   Assoc(\"scale\",        assoc)[2] \n                 };\n       ],\n       [\n          Local(val,prec);\n          val  := Assoc(\"value\",assoc)[2];\n          prec := Length(ExpressionToString(val));\n          rep := { sgn*val, prec };\n       ]\n    );\n    //If(InVerboseMode(),Tell(\"   \",rep));\n    BuiltinPrecisionSet(oldPrec);\n    rep;\n];\n\n\n\n12 # NumberToRep( N_IsComplex ) <-- \n[\n    If(IsZero(Re(N)),\n        {NumberToRep(0.0),NumberToRep(Im(N))},\n        {NumberToRep(Re(N)),NumberToRep(Im(N))}\n    );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/NumberToRep.mpw";
        scriptMap.put("NumberToRep",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// the restricted partition function\n/// partitions of length k\n\n5  # PartitionsP(n_IsInteger,0)                          <-- 0;\n5  # PartitionsP(n_IsInteger,n_IsInteger)        <-- 1;\n5  # PartitionsP(n_IsInteger,1)                        <-- 1;\n5  # PartitionsP(n_IsInteger,2)                        <-- Floor(n/2);\n5  # PartitionsP(n_IsInteger,3)                        <-- Round(n^2/12);\n6  # PartitionsP(n_IsInteger,k_IsInteger)_(k>?n) <-- 0;\n10 # PartitionsP(n_IsInteger,k_IsInteger)        <-- PartitionsP(n-1,k-1)+PartitionsP(n-k,k);\n\n/// the number of additive partitions of an integer\n5  # PartitionsP(0)        <-- 1;\n5  # PartitionsP(1)        <-- 1;\n// decide which algorithm to use\n10 # PartitionsP(n_IsInteger)_(n<?250) <-- PartitionsP'recur(n);\n20 # PartitionsP(n_IsInteger) <-- PartitionsP'HR(n);\n\n/// Calculation using the Hardy-Ramanujan series.\n10 # PartitionsP'HR(n_IsPositiveInteger) <--\n[\n        Local(P0, A, lambda, mu, mu'k, result, term, j, k, l, prec, epsilon);\n        result:=0;\n        term:=1;        // initial value must be nonzero\n        GlobalPush(BuiltinPrecisionGet());\n        // precision must be at least Pi/Ln(10)*Sqrt(2*n/3)-Ln(4*n*Sqrt(3))/Ln(10)\n        // here Pi/Ln(10) < 161/118, and Ln(4*Sqrt(3))/Ln(10) <1 so it is disregarded. Add 2 guard digits and compensate for round-off errors by not subtracting Ln(n)/Ln(10) now\n        prec := 2+Quotient(IntNthRoot(Quotient(2*n+2,3),2)*161+117,118);\n        BuiltinPrecisionSet(prec);        // compensate for round-off errors\n        epsilon := PowerN(10,-prec)*n*10;        // stop when term < epsilon\n\n        // get the leading term approximation P0 - compute once at high precision\n        lambda := N(Sqrt(n - 1/24));\n        mu := N(Pi*lambda*Sqrt(2/3));\n        // the hoops with DivideN are needed to avoid roundoff error at large n due to fixed precision:\n        // Exp(mu)/(n) must be computed by dividing by n, not by multiplying by 1/n\n        P0 := N(1-1/mu)*DivideN(ExpN(mu),(n-DivideN(1,24))*4*SqrtN(3));\n        /*\n        the series is now equal to\n        P0*Sum(k,1,Infinity,\n          (\n                Exp(mu*(1/k-1))*(1/k-1/mu) + Exp(-mu*(1/k+1))*(1/k+1/mu)\n          ) * A(k,n) * Sqrt(k)\n        )\n        */\n\n        A := 0;        // this is also used as a flag\n        // this is a heuristic, because the next term error is expensive\n        // to calculate and the theoretic bounds have arbitrary constants\n        // use at most 5+Sqrt(n)/2 terms, stop when the term is nonzero and result stops to change at precision prec\n        For(k:=1, k<=?5+Quotient(IntNthRoot(n,2),2) And? (A=?0 Or? Abs(term)>?epsilon), k++)\n        [\n                // compute A(k,n)\n                A:=0;\n                For(l:=1,l<=?k,l++)\n                [\n                        If(\n                                Gcd(l,k)=?1,\n                                A := A + Cos(Pi*\n                                  (        // replace Exp(I*Pi*...) by Cos(Pi*...) since the imaginary part always cancels\n                                        Sum(j,1,k-1, j*(Modulo(l*j,k)/k-1/2)) - 2*l*n\n                                        // replace (x/y - Floor(x/y)) by Modulo(x,y)/y for integer x,y\n                                  )/k)\n                        );\n                        A:=N(A);        // avoid accumulating symbolic Cos() expressions\n                ];\n\n                term := If(\n                        A=?0,        // avoid long calculations if the term is 0\n                        0,\n                        N( A*Sqrt(k)*(\n                          [\n                                  mu'k := mu/k;        // save time, compute mu/k once\n                            Exp(mu'k-mu)*(mu'k-1) + Exp(-mu'k-mu)*(mu'k+1);\n                          ]\n                        )/(mu-1) )\n                );\n//                Echo(\"k=\", k, \"term=\", term);\n                result := result + term;\n//                Echo(\"result\", new'result* P0);\n        ];\n        result := result * P0;\n        BuiltinPrecisionSet(GlobalPop());\n        Round(result);\n];\n\n// old code for comparison\n\n10 # PartitionsP1(n_IsPositiveInteger) <--\n [\n                 Local(C,A,lambda,m,pa,k,h,term);\n           GlobalPush(BuiltinPrecisionGet());\n           // this is an overshoot, but seems to work up to at least n=4096\n           BuiltinPrecisionSet(10 + Floor(N(Sqrt(n))) );\n           pa:=0;\n                 C:=Pi*Sqrt(2/3)/k;\n                 lambda:=Sqrt(m - 1/24);\n           term:=1;\n           // this is a heuristic, because the next term error is expensive\n           // to calculate and the theoretic bounds have arbitrary constants\n           For(k:=1,k<=?5+Floor(SqrtN(n)*0.5) And? ( term=?0 Or? Abs(term)>?0.1) ,k++)[\n                           A:=0;\n                           For(h:=1,h<=?k,h++)[\n                                           if( Gcd(h,k)=?1 )[\n                                                           A:=A+Exp(I*Pi*Sum(j,1,k-1,(j/k)*((h*j)/k - Floor((h*j)/k) -1/2))\n- 2*Pi*I*h*n/k );\n                                           ];\n                           ];\n                           If(A!=?0, term:= N(A*Sqrt(k)*(Deriv(m) Sinh(C*lambda)/lambda) Where m==n ),term:=0 );\n//                           Echo(\"Term \",k,\"is \",N(term/(Pi*Sqrt(2))));\n                           pa:=pa+term;\n//                           Echo(\"result\", N(pa/(Pi*Sqrt(2))));\n           ];\n           pa:=N(pa/(Pi*Sqrt(2)));\n           BuiltinPrecisionSet(GlobalPop());\n           Round(pa);\n ];\n\n/// integer partitions by recurrence relation P(n) = Sum(k,1,n, (-1)^(k+1)*( P(n-k*(3*k-1)/2)+P(n-k*(3*k+1)/2) ) ) = P(n-1)+P(n-2)-P(n-5)-P(n-7)+...\n/// where 1, 2, 5, 7, ... is the \"generalized pentagonal sequence\"\n/// this method is faster with internal math for number<300 or so.\nPartitionsP'recur(number_IsPositiveInteger) <--\n[\n        // need storage of n values PartitionsP(k) for k=1,...,n\n        Local(sign, cache, n, k, pentagonal, P);\n        cache:=ArrayCreate(number+1,1);        // cache[n] = PartitionsP(n-1)\n        n := 1;\n        While(n<?number)        // this will never execute if number=1\n        [\n                n++;\n                // compute PartitionsP(n) now\n                P := 0;\n                k := 1;\n                pentagonal := 1;        // pentagonal is always equal to the first element in the k-th pair of the \"pentagonal sequence\" of pairs {k*(3*k-1)/2, k*(3*k+1)/2}\n                sign := 1;\n                While(pentagonal<=?n)\n                [\n                        P := P + (cache[n-pentagonal+1]+If(pentagonal+k<=?n, cache[n-pentagonal-k+1], 0))*sign;\n                        pentagonal := pentagonal + 3*k+1;\n                        k++;\n                        sign := -sign;\n                ];\n                cache[n+1] := P;        // P(n) computed, store result\n        ];\n        cache[number+1];\n];\nPartitionsP'recur(0) <-- 1;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/PartitionsP.mpw";
        scriptMap.put("PartitionsP",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Product of small primes <= 257. Computed only once.\nLocalSymbols(p, q)\n[\n        // p:= 1;\n        ProductPrimesTo257() := 2*3*[\n                If(\n                        IsInteger(p),\n                        p,\n                p := Product(Select( 5 .. 257, {{q}, Modulo(q^2,24)=?1 And? IsSmallPrime(q)}))\n                );\n//                p;\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/ProductPrimesTo257.mpw";
        scriptMap.put("ProductPrimesTo257",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ProperDivisors(_n) <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"ProperDivisors: argument must be positive integer\");\n        Divisors(n)-1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/ProperDivisors.mpw";
        scriptMap.put("ProperDivisors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ProperDivisorsSum(_n) <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"ProperDivisorsSum: argument must be positive integer\");\n        DivisorsSum(n)-n;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/ProperDivisorsSum.mpw";
        scriptMap.put("ProperDivisorsSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Rationalize\",*);\n\n10 # Rationalize(aNumber_IsList) <-- Rationalize /@ aNumber;\n\n20 # Rationalize( _aNumber ) <--\n[\n    Local(result,n,d);\n    result:=Substitute(aNumber,{{x},IsNumber(x) And? Not?(IsInteger(x))},\"RationalizeNumber\");\n    If(InVerboseMode(),Tell(\"\",result));\n    If(Length(VarList(aNumber))=?0,\n      [\n        n:=Numerator(result);\n        If(Type(n)=?\"Numerator\",n:=result);\n        d:=Denominator(result);\n        If(Type(d)=?\"Denominator\",d:=1);\n        result := n*(1/d);\n      ]\n    );\n    result;\n];\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Rationalize.mpw";
        scriptMap.put("Rationalize",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"RationalizeNumber\",{x})\n[\n  Check(IsNumber(x), \"Argument\", \"RationalizeNumber: Error: \" : (PipeToString()Write(x)) :\" is not a number\");\n  Local(n,i,bip,m);\n  n   := 1;\n  i   := 0;\n  bip := BuiltinPrecisionGet();\n  // We can not take for granted that the internal representation is rounded properly...\n  While(i<=?bip And? Not?(FloatIsInt(x)))\n  [\n    n := n*10; \n    x := x*10;\n    i := i+1;\n  ];\n  m := Floor(x+0.5);\n  (m/n);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/RationalizeNumber.mpw";
        scriptMap.put("RationalizeNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RepToNumber\",*);\n\n\n10 # RepToNumber( rep_IsListOfLists ) <--\n[\n    //If(InVerboseMode(),[Tell(RepToNumberZ,rep); Tell(\"     complex\");]);\n    RepToNumber(rep[1])+I*RepToNumber(rep[2]);\n];\n\n\n12 # RepToNumber( rep_IsList ) <--\n[\n    //If(InVerboseMode(),Tell(RepToNumber,rep));\n    Local(bigInt,precision,scale,strBI,sgn,index,ans);\n    Local(first,secnd,third,LS,numStr);\n    precision := rep[2];\n    scale     := 0;\n    bigInt    := rep[1];\n    precision := rep[2];\n    sgn       := Sign(bigInt);\n    If( Length(rep) >? 2, scale := rep[3] );\n    strBI     := ExpressionToString(Abs(bigInt));\n    LS        := Length(strBI);\n    //If(InVerboseMode(),[Tell(\"   \",{bigInt,precision,scale,sgn});Tell(\"   \",strBI);]);\n    If( Length(rep)=?2,\n       [ numStr := strBI; ],\n       [\n           index := precision-scale;\n           first := strBI[1];\n           secnd := StringMidGet(2,LS-1,strBI);   \n           third := ExpressionToString(index-1);\n           //If(InVerboseMode(),Tell(\"     \",{index,first,secnd,third}));\n           if ( index >? 0 )\n               [\n                   if ( index <? precision )\n                       [\n                           //If(InVerboseMode(),Tell(\"   index < precision \"));\n                           numStr := ConcatStrings(first,\".\",secnd,\"E\",third);\n                       ]\n                   else if ( index >=? precision )\n                       [\n                           //If(InVerboseMode(),Tell(\"   index >=? precision \"));\n                           numStr := ConcatStrings(first,\".\",secnd,\"E+\",third);\n                       ];\n               ]\n           else if ( index <? 0 )\n               [\n                   //If(InVerboseMode(),Tell(\"   index < 0 \"));\n                   numStr := ConcatStrings(first,\".\",secnd,\"E\",third);\n               ]\n           else\n               [\n                   //If(InVerboseMode(),Tell(\"   index = 0 \"));\n                   first  := \"0.\" ; \n                   secnd  := strBI;\n                   numStr := ConcatStrings(first,secnd);\n               ];\n        ]\n     );\n     ans := sgn * ToAtom(numStr);\n     //If(InVerboseMode(),Tell(\"     \",ans));\n     ans;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/RepToNumber.mpw";
        scriptMap.put("RepToNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 #         Repunit(0)        <-- 0;\n// Number consisting of n 1's\nRepunit(n_IsPositiveInteger) <--\n[\n        (10^n-1)/9;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Repunit.mpw";
        scriptMap.put("Repunit",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RoundToPlace\",*);\n\n10 # RoundToPlace( N_IsDecimal, place_IsInteger ) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPlace_D\",{N,place}));\n    Local(rep,sgn,oldInt,oldPrec,oldScale,oldPlaces,strOInt,LS);\n    Local(newInt,newScale,newRep,ans);\n    sgn      := Sign(N);\n    rep      := NumberToRep( Abs(N) );\n    oldInt   := rep[1];\n    oldPrec  := rep[2];\n    oldScale := rep[3];\n    oldPlaces:= oldPrec - oldScale;\n    strOInt  := ExpressionToString(oldInt);\n    LS       := Length(strOInt);\n    //If(InVerboseMode(),\n    //   [\n    //    Tell(\"   \",rep);\n    //    Tell(\"         \",oldInt);\n    //    Tell(\"         \",strOInt);\n    //    Tell(\"         \",LS);\n    //    Tell(\"         \",{place,oldPrec});\n    //    Tell(\"         \",oldPlaces);\n    //   ]\n    //);\n    If(oldPlaces+place>?0,\n        ans := RoundToPrecision(N,oldPlaces+place),\n        ans := 0.\n    );\n    ans;\n];\n\n\n15 # RoundToPlace( N_IsInteger, place_IsInteger )_(place <=? 0) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPlace_I\",{N,place}));\n    Local(oldRep,oldPrec,decN,newDecN,ans);\n    oldRep   := NumberToRep(N);\n    oldPrec  := oldRep[2];\n    decN     := N*1.0;\n    newDecN  := RoundToPlace( decN, place );\n    //If(InVerboseMode(),Tell(\"    \",oldRep));\n    //If(InVerboseMode(),Tell(\"   \",oldPrec));\n    //If(InVerboseMode(),Tell(\"   \",place));\n    //If(InVerboseMode(),Tell(\"   \",newDecN));\n    If( place <=? oldPrec, \n        ans := Round(newDecN),\n        ans := Round(newDecN*10^(place-oldPrec))\n    );\n    ans;\n];\n\n\n\n20 # RoundToPlace( N_IsComplex, place_IsInteger )_(Not? IsInteger(N)) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPlace_C\",{N,place}));\n    Local(rr,ii);\n    rr := Re(N);\n    ii := Im(N);\n    Complex(RoundToPlace(rr,place),RoundToPlace(ii,place));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/RoundToPlace.mpw";
        scriptMap.put("RoundToPlace",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RoundToPrecision\",*);\n\n10 # RoundToPrecision( N_IsDecimal, newPrec_IsPositiveInteger ) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPrecision_D\",{N,newPrec}));\n    Local(rep,sgn,oldInt,oldPrec,oldScale,strOInt,LS,BIP0);\n    Local(newInt,newScale,newRep,ans);\n    BIP0     := BuiltinPrecisionGet();\n    sgn      := Sign(N);\n    rep      := NumberToRep( If(sgn<?0,-N,N) );\n    oldInt   := rep[1];\n    oldPrec  := rep[2];\n    oldScale := rep[3];\n    If( newPrec >? oldPrec, BuiltinPrecisionSet(newPrec) );\n    strOInt  := ExpressionToString(oldInt);\n    LS       := Length(strOInt);\n    //If(InVerboseMode(),\n    //   [\n    //      Tell(\"   \",rep);\n    //      Tell(\"         \",oldInt);\n    //      Tell(\"         \",strOInt);\n    //      Tell(\"         \",LS);\n    //      Tell(\"         \",{newPrec,oldPrec});\n    //   ]\n    //);\n    \n    Local(first,secnd,rem,ad);\n    if ( newPrec =? oldPrec )\n        [ ans := N; ]\n    else if ( newPrec <? oldPrec )\n        [\n            first    := StringMidGet(1, newPrec, strOInt); \n            secnd    := StringMidGet(newPrec+1, LS-newPrec, strOInt);\n            rem      := ToAtom(ConcatStrings(\".\",secnd));\n            ad       := If(rem>=?0.5, 1, 0 );\n            newInt   := sgn * ( ToAtom(first) + ad );\n            newScale := oldScale - ( oldPrec - newPrec ); \n            newRep   := {newInt,newPrec,newScale};\n            ans      := RepToNumber(newRep);\n            //If(InVerboseMode(),\n            //   [\n            //      Tell(\"         \",{first,secnd});\n            //      Tell(\"         \",{rem,ad});\n            //      Tell(\"         \",newRep);\n            //      Tell(\"         \",ans);\n            //   ]\n            //);\n        ]\n    else\n        [\n            //If(InVerboseMode(),Tell(\"   newPrec >? oldPrec \"));\n            Local(diffPrec);\n            diffPrec := oldPrec - newPrec;\n            newInt   := sgn * ToAtom(strOInt) * 10^(-diffPrec) ;\n            newScale := oldScale - diffPrec;\n            newRep   := {newInt,newPrec,newScale};\n            //If(InVerboseMode(),[Tell(\"         \",diffPrec);Tell(\"         \",newRep);]);\n            ans      := RepToNumber(newRep);\n        ];\n    BuiltinPrecisionSet(BIP0);\n    ans;\n];\n\n\n15 # RoundToPrecision( N_IsInteger, newPrec_IsPositiveInteger ) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPrecision_I\",{N,newPrec}));\n    Local(oldRep,oldPrec,decN,newDecN,ans);\n    oldRep   := NumberToRep(N);\n    oldPrec  := oldRep[2];\n    decN     := N*1.0;\n    newDecN  := RoundToPrecision( decN, newPrec );\n    //If(InVerboseMode(),Tell(\"    \",oldRep));\n    //If(InVerboseMode(),Tell(\"   \",oldPrec));\n    //If(InVerboseMode(),Tell(\"   \",newPrec));\n    //If(InVerboseMode(),Tell(\"   \",newDecN));\n    If( newPrec <=? oldPrec, \n        ans := Round(newDecN),\n        ans := Round(newDecN*10^(newPrec-oldPrec))\n    );\n    ans;\n];\n\n\n20 # RoundToPrecision( N_IsComplex, newPrec_IsPositiveInteger ) <--\n[\n    //If(InVerboseMode(),Tell(\"RoundToPrecision_C\",{N,newPrec}));\n    Local(rr,ii);\n    rr := Re(N);\n    ii := Im(N);\n    Complex(RoundToPrecision(rr,newPrec),RoundToPrecision(ii,newPrec));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/RoundToPrecision.mpw";
        scriptMap.put("RoundToPrecision",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # StirlingNumber1(n_IsInteger,0) <-- If(n=?0,1,0);\n10 # StirlingNumber1(n_IsInteger,1) <-- (-1)^(n-1)*(n-1)!;\n10 # StirlingNumber1(n_IsInteger,2) <-- (-1)^n*(n-1)! * HarmonicNumber(n-1);\n10 # StirlingNumber1(n_IsInteger,n-1) <-- -BinomialCoefficient(n,2);\n10 # StirlingNumber1(n_IsInteger,3) <-- (-1)^(n-1)*(n-1)! * (HarmonicNumber(n-1)^2 - HarmonicNumber(n-1,2))/2;\n20 # StirlingNumber1(n_IsInteger,m_IsInteger) <--\n        Sum(k,0,n-m,(-1)^k*BinomialCoefficient(k+n-1,k+n-m)*BinomialCoefficient(2*n-m,n-k-m)*StirlingNumber2(k-m+n,k));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/StirlingNumber1.mpw";
        scriptMap.put("StirlingNumber1",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # StirlingNumber2(n_IsInteger,0) <-- If(n=?0,1,0);\n20 # StirlingNumber2(n_IsInteger,k_IsInteger) <-- Sum(i,0,k-1,(-1)^i*BinomialCoefficient(k,i)*(k-i)^n)/ k! ;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/StirlingNumber2.mpw";
        scriptMap.put("StirlingNumber2",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from:\n// Elementary Number Theory, David M. Burton\n// Theorem 7.3 p139\n\n10 # Totient(_n)        <--\n[\n        Check(IsPositiveInteger(n), \"Argument\", \"Totient: argument must be positive integer\");\n        Local(i,sum,factors,len);\n        sum:=n;\n        factors:=Factors(n);\n        len:=Length(factors);\n        For(i:=1,i<=?len,i++)[\n                sum:=sum*(1-1/factors[i][1]);\n        ];\n        sum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/Totient.mpw";
        scriptMap.put("Totient",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Algorithm adapted from: Number Theory: A Programmer's Guide\n//                        Mark Herkommer\n// Program 8.7.1c, p 264\n// This function needs to be modified to return the factors in\n// data structure instead of printing them out\n\n// THIS FUNCTION IS DEPRECATED NOW!\n// Use GaussianFactors instead (Pablo)\n// I've leave this here so that you can compare the eficiency of one\n// function against the other\n\nFunction(\"FactorGaussianInteger\",{x}) [\n        Check( IsGaussianInteger(x), \"Argument\", \"FactorGaussianInteger: argument must be a Gaussian integer\");\n        Local(re,im,norm,a,b,d,i,j);\n\n        re:=Re(x);im:=Im(x);\n\n        If(re<?0, re:=(-re) );\n        If(im<?0, im:=(-im) );\n        norm:=re^2+im^2;\n\n        if( IsComposite(norm) )[\n                For(i:=0, i^2 <=? norm, i++ )[        // real part\n                        For(j:=0, i^2 + j^2 <=? norm, j++)[        // complex part\n                                if( Not?( (i =? re And? j =? im) Or?\n                                         (i =? im And? j =? re) ) )[ // no associates\n                                        d:=i^2+j^2;\n                                        if( d >? 1 )[\n                                                a := re * i + im * j;\n                                                b := im * i - re * j;\n                                                While( (Modulo(a,d) =? 0) And?  (Modulo(b,d) =? 0) ) [\n                                                        FactorGaussianInteger(Complex(i,j));\n                                                        re:= a/d;\n                                                        im:= b/d;\n                                                        a := re * i + im * j;\n                                                        b := im * i - re * j;\n                                                        norm := re^2 + im^2;\n                                                ];\n                                        ];\n                                ];\n                        ];\n                ];\n                If( re !=? 1 Or? im !=? 0, Echo(Complex(re,im)) );\n        ] else [\n                Echo(Complex(re,im));\n        ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/FactorGaussianInteger.mpw";
        scriptMap.put("FactorGaussianInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* GaussianFactorPrime(p): auxiliary function for Gaussian factors.\nIf p is a rational prime of the form 4n+1, we find a factor of p in the\nGaussian Integers. We compute\n  a = (2n)!\nBy Wilson's theorem a^2 is -1 (mod p), it follows that\n\n        p| (a+I)(a-I)\n\nin the Gaussian integers. The desired factor is then the Gaussian GCD of a+i\nand p. Note: If the result is Complex(a,b), then p=a^2+b^2 */\n\nGaussianFactorPrime(p_IsInteger) <-- [\n Local(a,i);\n a := 1;\n For (i:=2,i<=?(p-1)/2,i++) a := Modulo(a*i,p);\n GaussianGcd(a+I,p);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/GaussianFactorPrime.mpw";
        scriptMap.put("GaussianFactorPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"GaussianFactors\",*);\n\n\n/* AddGaussianFactor: auxiliary function for Gaussian Factors.\nL is a lists of factors of the Gaussian integer z and p is a Gaussian prime\nthat we want to add to the list. We first find the exponent e of p in the\ndecomposition of z (into Gaussian primes). If it is not zero, we add {p,e}\nto the list */\n\nAddGaussianFactor(L_IsList,z_IsGaussianInteger,p_IsGaussianInteger) <--\n[\n Local(e);\n e :=0;\n While (IsGaussianInteger(z:= z/p)) e++;\n If (e !=? 0, DestructiveAppend(L,{p,e}));\n];\n\n\n\n\n/* \nGaussianFactors(n) : returns a list of factors of n, in a similar way to Factors(n).\nIf n is a rational integer, we factor n in the Gaussian integers, by first\nfactoring it in the rational integers, and after that factoring each of\nits integer prime factors. \n*/\n\n10 # GaussianFactors(n_IsInteger) <--\n[\n  // Chosing to factor this integer as a Gaussian Integer\n  Local(ifactors,gfactors,p,alpha);\n  ifactors := FactorizeInt(n);  // since we know it is an integer\n  gfactors := {};\n  ForEach(p,ifactors)\n  [\n     If (p[1]=?2, [ DestructiveAppend(gfactors,{1+I,p[2]});\n                   DestructiveAppend(gfactors,{1-I,p[2]}); ]);\n     If (Modulo(p[1],4)=?3, DestructiveAppend(gfactors,p));\n     If (Modulo(p[1],4)=?1, [ alpha := GaussianFactorPrime(p[1]);\n                          DestructiveAppend(gfactors,{alpha,p[2]});\n                          DestructiveAppend(gfactors,{Conjugate(alpha),p[2]});\n                        ]);\n  ];\ngfactors;\n];\n\n/* \nIf z is is a Gaussian integer, we find its possible Gassian prime factors,\nby factoring its norm \n*/\n\n20 # GaussianFactors(z_IsGaussianInteger) <--\n[\n Local(n,nfactors,gfactors,p);\n  gfactors :={};\n  n := GaussianNorm(z);\n  nfactors := Factors(n);\n  ForEach(p,nfactors)\n  [\n   If (p[1]=?2, [ AddGaussianFactor(gfactors,z,1+I);]);\n   If (Modulo(p[1],4)=?3, AddGaussianFactor(gfactors,z,p[1]));\n   If (Modulo(p[1],4)=?1, [ Local(alpha);\n                        alpha := GaussianFactorPrime(p[1]);\n                        AddGaussianFactor(gfactors,z,alpha);\n                        AddGaussianFactor(gfactors,z,Conjugate(alpha));\n                      ]);\n ];\n gfactors;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/GaussianFactors.mpw";
        scriptMap.put("GaussianFactors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # GaussianGcd(n_IsGaussianInteger,m_IsGaussianInteger) <--\n[\n        If(N(Abs(m))=?0,n, GaussianGcd(m,n - m*Round(n/m) ) );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/GaussianGcd.mpw";
        scriptMap.put("GaussianGcd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nGaussianMod(z_IsGaussianInteger,w_IsGaussianInteger) <-- z - w * Round(z/w);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/GaussianMod.mpw";
        scriptMap.put("GaussianMod",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nGaussianNorm(z_IsGaussianInteger) <-- Re(z)^2+Im(z)^2;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/GaussianNorm.mpw";
        scriptMap.put("GaussianNorm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5  # IsGaussianInteger(x_IsList)        <-- False;\n\n// ?????? why is the following rule needed?\n// 5  # IsGaussianInteger(ProductPrimesTo257)        <-- False;\n\n10 # IsGaussianInteger(x_IsComplex)          <-- (IsInteger(Re(x)) And? IsInteger(Im(x)));\n// to catch IsGaussianInteger(x+2) from Apart\n15 # IsGaussianInteger(_x)        <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/IsGaussianInteger.mpw";
        scriptMap.put("IsGaussianInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"IsGaussianPrime\",{x})\n[\n        if( IsGaussianInteger(x) )[\n                if( IsZero(Re(x)) )[\n                        ( Abs(Im(x)) % 4 =? 3 And? IsPrime(Abs(Im(x))) );\n                ] else if ( IsZero(Im(x)) ) [\n                        ( Abs(Re(x)) % 4 =? 3 And? IsPrime(Abs(Re(x))) );\n                ] else [\n                        IsPrime(Re(x)^2 + Im(x)^2);\n                ];\n        ] else [\n                False;\n        ];\n\n];\n\n\n/*\n10 # IsGaussianPrime(p_IsInteger) <-- IsPrime(p) And? Modulo(p,3)=1;\n20 # IsGaussianPrime(p_IsGaussianInteger) <-- IsPrime(GaussianNorm(p));\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/IsGaussianPrime.mpw";
        scriptMap.put("IsGaussianPrime",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsGaussianUnit(z_IsGaussianInteger) <-- GaussianNorm(z)=?1;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/gaussianintegers/IsGaussianUnit.mpw";
        scriptMap.put("IsGaussianUnit",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/* DivisorsList(n) = the list of divisors of n */\n\nDivisorsList(n_IsPositiveInteger) <--\n[\n Local(nFactors,f,result,oldresult,x);\n nFactors:= Factors(n);\n result := {1};\n ForEach (f,nFactors)\n    [\n      oldresult := result;\n      For (k:=1,k<=?f[2],k++)\n        ForEach (x,oldresult)\n          result:=Append(result,x*f[1]^k);\n    ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/DivisorsList.mpw";
        scriptMap.put("DivisorsList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/** Compute the Jacobi symbol JS(m/n) - n must be odd, both positive.\nSee the Algo book for documentation.\n\n*/\n\n10 # JacobiSymbol(_a, 1) <-- 1;\n15 # JacobiSymbol(0, _b) <-- 0;\n18 # JacobiSymbol(_a, _b) _ (Gcd(a,b)>?1) <-- 0;\n\n20 # JacobiSymbol(_a, b_IsOdd)_(a>=?Abs(b) Or? a<?0) <-- JacobiSymbol(Modulo(a,Abs(b)),Abs(b));\n\n30 # JacobiSymbol(a_IsEven, b_IsOdd) <--\n[\n        Local(c, s);\n        // compute c,s where a=c*2^s and c is odd\n        {c,s}:=FindPrimeFactorSimple(a, 2);        // use the \"Simple\" function because we don't expect a worst case here\n        If(Modulo(s,2)=?1 And? Abs(Modulo(b,8)-4)=?1, -1, 1) * JacobiSymbol(c,b);\n];\n\n40 # JacobiSymbol(a_IsOdd, b_IsOdd) <-- If(Modulo(a,4)=?3 And? Modulo(b,4)=?3, -1, 1) * JacobiSymbol(b,a);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/JacobiSymbol.mpw";
        scriptMap.put("JacobiSymbol",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/* Returns a list of pairs {d,m}\n   where d runs through the square free divisors of  n\n   and m=Moebius(m)\n   This is much more efficient than making a list of all\n   square-free divisors of n, and then compute Moebius on each of them.\n   It is useful for computing the Cyclotomic polinomials.\n   It can be useful in other computations based on\n   Moebius inversion formula. */\n\nMoebiusDivisorsList(n_IsPositiveInteger) <--\n[\n Local(nFactors,f,result,oldresult,x);\n nFactors:= Factors(n);\n result := {{1,1}};\n ForEach (f,nFactors)\n    [\n      oldresult := result;\n        ForEach (x,oldresult)\n          result:=Append(result,{x[1]*f[1],-x[2]});\n    ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/MoebiusDivisorsList.mpw";
        scriptMap.put("MoebiusDivisorsList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/* RamanujanSum(k,n) = the sum of the n-th powers of the\nk-th primitive roots of the identity */\n\n10 # RamanujanSum(k_IsPositiveInteger,0) <-- Totient(k);\n\n20 # RamanujanSum(k_IsPositiveInteger,n_IsPositiveInteger) <--\n[\n Local(s,gcd,d);\n s:= 0;\n gcd := Gcd(n,k);\n ForEach (d,DivisorsList(gcd))\n  s:=s+d*Moebius(k/d);\n s;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/RamanujanSum.mpw";
        scriptMap.put("RamanujanSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/* Returns a list of the square-free divisors of n */\nSquareFreeDivisorsList(n_IsPositiveInteger) <--\n[\n Local(nFactors,f,result,oldresult,x);\n nFactors:= Factors(n);\n result := {1};\n ForEach (f,nFactors)\n    [\n      oldresult := result;\n        ForEach (x,oldresult)\n          result:=Append(result,x*f[1]);\n    ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/SquareFreeDivisorsList.mpw";
        scriptMap.put("SquareFreeDivisorsList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Implementation of some number theoretical functions for MathPiper */\n/* (C) 2002 Pablo De Napoli <pdenapo@yahoo.com> under GNU GPL */\n\n/* This function performs a sum where sumvar runs through\n   the divisors of n\n   For example SumForDivisors(d,10,d^2)\n   sums d^2 with d walking through the divisors of 10\n   LocalSymbols is needed since we use Eval() inside\n   Look at Programming in MathPiper: Evaluating Variables in the Wrong\n   Scope */\n\nFunction (\"SumForDivisors\",{sumvar,n,sumbody}) LocalSymbols(s,d)\n[\n   Local(s,d);\n   s:=0;\n   ForEach (d,DivisorsList(n))\n   [\n    MacroLocal(sumvar);\n    MacroBind(sumvar,d);\n    s:=s+Eval(sumbody);\n   ];\n   s;\n];\nUnFence(\"SumForDivisors\",3);\nHoldArgument(\"SumForDivisors\",sumvar);\nHoldArgument(\"SumForDivisors\",sumbody); \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/numbers/numbertheory/SumForDivisors.mpw";
        scriptMap.put("SumForDivisors",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nOdeSolve\nOdeTest\nOdeOrder\n*/\n\n/*\n 1) implement more sub-solvers\n 2) test code\n 3) Done: documentation for OdeSolve and OdeTest\n */\n\nRulebase(\"yyy\",{x});\n\n10 # OdeLeftHandSideEq(_l == _r) <-- (l-r);\n20 # OdeLeftHandSideEq(_e) <-- e;\n\n10 # OdeNormChange(y(n_IsInteger)) <-- ListToFunction({yyy,n});\n20 # OdeNormChange(y) <-- yyy(0);\n25 # OdeNormChange(y') <-- yyy(1);\n25 # OdeNormChange(y'') <-- yyy(2);\n30 # OdeNormChange(_e) <-- e;\nOdeNormPred(_e) <-- (e !=? OdeNormChange(e));\n\n\nOdeNormalForm(_e) <--\n[\n  e := Substitute(OdeLeftHandSideEq(e),\"OdeNormPred\",\"OdeNormChange\");\n];\n\n/*TODO better OdeNormalForm?\nOdeNormalForm(_e) <--\n[\n  OdeLeftHandSideEq(e) /:\n    {\n      y <- yyy(0),\n      y' <- yyy(1),\n      y'' <- yyy(2),\n      y(_n) <- yyy(n)\n    };\n];\n*/\n\n10 # OdeChange(yyy(n_IsInteger)) <-- Apply(yn,{n});\n30 # OdeChange(_e) <-- e;\nOdePred(_e) <-- (e !=? OdeChange(e));\nUnFence(\"OdeChange\",1);\nUnFence(\"OdePred\",1);\nOdeSubstitute(_e,_yn) <--\n[\n  Substitute(e,\"OdePred\",\"OdeChange\");\n];\nUnFence(\"OdeSubstitute\",2);\n\nOdeConstantList(n_IsInteger) <--\n[\n  Local(result,i);\n  result:=ZeroVector(n);\n  For (i:=1,i<=?n,i++) result[i]:=UniqueConstant();\n  result;\n];\n\n\nRulebase(\"OdeTerm\",{px,list});\n\n/*5 # OdeFlatTerm(_x)_[Echo({x});False;] <-- True; */\n\n10# OdeFlatTerm(OdeTerm(_a0,_b0)+OdeTerm(_a1,_b1)) <-- OdeTerm(a0+a1,b0+b1);\n10# OdeFlatTerm(OdeTerm(_a0,_b0)-OdeTerm(_a1,_b1)) <-- OdeTerm(a0-a1,b0-b1);\n10# OdeFlatTerm(-OdeTerm(_a1,_b1)) <-- OdeTerm(-a1,-b1);\n10# OdeFlatTerm(OdeTerm(_a0,_b0)*OdeTerm(_a1,_b1))_\n    (IsZeroVector(b0) Or? IsZeroVector(b1)) <--\n[\n  OdeTerm(a0*a1,a1*b0+a0*b1);\n];\n\n10# OdeFlatTerm(OdeTerm(_a0,_b0)/OdeTerm(_a1,_b1))_\n    (IsZeroVector(b1)) <--\n    OdeTerm(a0/a1,b0/a1);\n\n10# OdeFlatTerm(OdeTerm(_a0,b0_IsZeroVector)^OdeTerm(_a1,b1_IsZeroVector)) <--\n    OdeTerm(a0^a1,b0);\n15 # OdeFlatTerm(OdeTerm(_a,_b)) <-- OdeTerm(a,b);\n\n15# OdeFlatTerm(OdeTerm(_a0,_b0)*OdeTerm(_a1,_b1)) <-- OdeTermFail();\n15# OdeFlatTerm(OdeTerm(_a0,b0)^OdeTerm(_a1,b1)) <-- OdeTermFail();\n15# OdeFlatTerm(OdeTerm(_a0,b0)/OdeTerm(_a1,b1)) <-- OdeTermFail();\n20 # OdeFlatTerm(a_IsAtom) <-- OdeTermFail();\n\n20 # OdeFlatTerm(_a+_b) <-- OdeFlatTerm(OdeFlatTerm(a) + OdeFlatTerm(b));\n20 # OdeFlatTerm(_a-_b) <-- OdeFlatTerm(OdeFlatTerm(a) - OdeFlatTerm(b));\n20 # OdeFlatTerm(_a*_b) <-- OdeFlatTerm(OdeFlatTerm(a) * OdeFlatTerm(b));\n20 # OdeFlatTerm(_a^_b) <-- OdeFlatTerm(OdeFlatTerm(a) ^ OdeFlatTerm(b));\n20 # OdeFlatTerm(_a/_b) <-- OdeFlatTerm(OdeFlatTerm(a) / OdeFlatTerm(b));\n\nOdeMakeTerm(xx_IsAtom) <-- OdeTerm(xx,FillList(0,10));\nOdeMakeTerm(yyy(_n)) <-- OdeTerm(0,BaseVector(n+1,10));\n\n\n20 # OdeMakeTerm(_xx) <-- OdeTerm(xx,FillList(0,10));\n10 # OdeMakeTermPred(_x+_y) <-- False;\n10 # OdeMakeTermPred(_x-_y) <-- False;\n10 # OdeMakeTermPred(  -_y) <-- False;\n10 # OdeMakeTermPred(_x*_y) <-- False;\n10 # OdeMakeTermPred(_x/_y) <-- False;\n10 # OdeMakeTermPred(_x^_y) <-- False;\n20 # OdeMakeTermPred(_rest) <-- True;\n\n\nOdeCoefList(_e) <--\n[\n  Substitute(e,\"OdeMakeTermPred\",\"OdeMakeTerm\");\n];\nOdeTermFail() <-- OdeTerm(Error,FillList(Error,10));\n\n// should check if it is linear...\nOdeAuxiliaryEquation(_e) <--\n[\n        // extra conversion that should be optimized away later\n        e:=OdeNormalForm(e);\n        e:=OdeSubstitute(e,{{n},aaa^n*Exp(aaa*x)});\n        e:=Subst(Exp(aaa*x),1)e;\n        Simplify(Subst(aaa,x)e);\n];\n\n/* Solving a Homogeneous linear differential equation\n   with real constant coefficients */\nOdeSolveLinearHomogeneousConstantCoefficients(_e) <--\n[\n  Local(roots,consts,auxeqn);\n\n  /* Try solution Exp(aaa*x), and divide by Exp(aaa*x), which\n   * should yield a polynomial in aaa.\n  e:=OdeSubstitute(e,{{n},aaa^n*Exp(aaa*x)});\n  e:=Subst(Exp(aaa*x),1)e;\n  auxeqn:=Simplify(Subst(aaa,x)e);\n  e:=auxeqn;\n  */\n  e:=OdeAuxiliaryEquation(e);\n  auxeqn:=e;\n\n  If(InVerboseMode(), Echo(\"OdeSolve: Auxiliary Eqn \",auxeqn) );\n\n\n  /* Solve the resulting polynomial */\n  e := Apply(\"RootsWithMultiples\",{e});\n  e := RemoveDuplicates(e);\n\n  /* Generate dummy constants */\n  if( Length(e) >? 0 )[\n    roots:=Transpose(e);\n    consts:= MapSingle(Hold({{nn},Add(OdeConstantList(nn)*(x^(0 .. (nn-1))))}),roots[2]);\n    roots:=roots[1];\n\n    /* Return results */\n    //Sum(consts * Exp(roots*x));\n    Add( consts * Exp(roots*x) );\n  ] else if ( Degree(auxeqn,x) =? 2 ) [\n    // we can solve second order equations without RootsWithMultiples\n    Local(a,b,c,roots);\n    roots:=ZeroVector(2);\n\n    // this should probably be incorporated into RootsWithMultiples\n    {c,b,a} := Coef(auxeqn,x,0 .. 2);\n\n\n    roots := PSolve(a*x^2+b*x+c,x);\n    If(InVerboseMode(),Echo(\"OdeSolve: Roots of quadratic:\",roots) );\n\n    // assuming real coefficients, the roots must come in a complex\n    // conjugate pair, so we don't have to check both\n    // also, we don't need to check to repeated root case, because\n    // RootsWithMultiples (hopefully) catches those, except for\n    // the case b,c=0\n\n    if( b=?0 And? c=?0 )[\n        Add(OdeConstantList(2)*{1,x});\n    ] else if( IsNumber(N(roots[1])) )[\n        If(InVerboseMode(),Echo(\"OdeSolve: Real roots\"));\n        Add(OdeConstantList(2)*{Exp(roots[1]*x),Exp(roots[2]*x)});\n    ] else [\n      If(InVerboseMode(),Echo(\"OdeSolve: Complex conjugate pair roots\"));\n      Local(alpha,beta);\n      alpha:=Re(roots[1]);\n      beta:=Im(roots[1]);\n      Exp(alpha*x)*Add( OdeConstantList(2)*{Sin(beta*x),Cos(beta*x)} );\n    ];\n\n  ] else [\n    Echo(\"OdeSolve: Could not find roots of auxilliary equation\");\n  ];\n];\n\n// this croaks on Sin(x)*y'' because OdeMakeTerm does\n10 # OdeOrder(_e) <-- [\n        Local(h,i,coefs);\n\n        coefs:=ZeroVector(10); //ugly\n        e:=OdeNormalForm(e);\n\n        If(InVerboseMode(),Echo(\"OdeSolve: Normal form is\",e));\n        h:=OdeFlatTerm(OdeCoefList(e));\n        If(InVerboseMode(),Echo(\"OdeSolve: Flatterm is\",h));\n\n        // get the list of coefficients of the derivatives\n        // in decreasing order\n        coefs:=Reverse(FunctionToList(h)[3]);\n        While( First(coefs) =? 0 )[\n                coefs:=Rest(coefs);\n        ];\n        Length(coefs)-1;\n];\n\n\n10 # OdeSolve(_expr)_(OdeOrder(expr)=?0)            <-- Echo(\"OdeSolve: Not? a differential equation\");\n\n// Solve the ever lovable seperable equation\n\n10 # OdeSolve(y'+_a==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==expr-a);\n10 # OdeSolve(y'-_a==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==expr+a);\n10 # OdeSolve(y'/_a==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==expr*a);\n10 # OdeSolve(_a*y'==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==expr/a);\n10 # OdeSolve(y'*_a==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==expr/a);\n10 # OdeSolve(_a/y'==_expr)_(IsFreeOf(y,a)) <-- OdeSolve(y'==a/expr);\n\n// only works for low order equations\n10 # OdeSolve(y'==_expr)_(IsFreeOf({y,y',y''},expr)) <--\n[\n        If(InVerboseMode(),Echo(\"OdeSolve: Integral in disguise!\"));\n        If(InVerboseMode(),Echo(\"OdeSolve: Attempting to integrate \",expr));\n\n        (Integrate(x) expr)+UniqueConstant();\n];\n\n50 # OdeSolve(_e) <--\n[\n  Local(h);\n  e:=OdeNormalForm(e);\n  If(InVerboseMode(),Echo(\"OdeSolve: Normal form is\",e));\n  h:=OdeFlatTerm(OdeCoefList(e));\n  If(InVerboseMode(),Echo(\"OdeSolve: Flatterm is\",h));\n  if (IsFreeOf(Error,h))\n  [\n    OdeSolveLinear(e,h);\n  ]\n  else\n    OdeUnsolved(e);\n];\n\n10 # OdeSolveLinear(_e,OdeTerm(0,_list))_(Length(VarList(list)) =? 0) <--\n[\n  OdeSolveLinearHomogeneousConstantCoefficients(OdeNormalForm(e));\n];\n\n100 # OdeSolveLinear(_e,_ode) <-- OdeUnsolved(e);\n\nOdeUnsolved(_e) <-- Subst(yyy,y)e;\n\n\n\n/*\nFT3(_e) <--\n[\n  e:=OdeNormalForm(e);\nEcho({e});\n  e:=OdeCoefList(e);\nEcho({e});\n  e:=OdeFlatTerm(e);\nEcho({e});\n  e;\n];\nOdeBoundaries(_solution,bounds_IsList) <--\n[\n];\n*/\n\nOdeTest(_e,_solution) <--\n[\n  Local(s);\n  s:= `Lambda({n},if (n>?0)(Differentiate(x,n)(@solution)) else (@solution));\n  e:=OdeNormalForm(e);\n  e:=Apply(\"OdeSubstitute\",{e,s});\n  e:=Simplify(e);\n  e;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/odesolver/odesolver.mpw";
        scriptMap.put("OdeSolve",scriptString);
        scriptMap.put("OdeTest",scriptString);
        scriptMap.put("OdeOrder",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nOrthoP\nOrthoG\nOrthoH\nOrthoL\nOrthoT\nOrthoU\nOrthoPSum\nOrthoGSum\nOrthoHSum\nOrthoLSum\nOrthoTSum\nOrthoUSum\nEvaluateHornerScheme\n*/\n\n/*\nOrthogonal polynomials\nversion 1.2\n(Serge Winitzki)\n\nPolynomials are found from direct recurrence relations. Sums of series of polynomials are found using the Clenshaw-Smith recurrence scheme.\n\nReference: Yudell L. Luke. Mathematical functions and their approximations. Academic Press, N. Y., 1975.\n\nUsage:\n  The polynomials are evaluated by functions named Ortho*, where * is one of P, G, H, L, T, U. The first argument of these functions is an integer.  The series of polynomials are evaluated by functions named Ortho*Sum. The first argument of these functions is a list of coefficients. The last argument is the value x at which the polynomials are to be computed; if x is numerical, a faster routine is used.\n\n  If n is an integer, n>=0, then:\n        OrthoP(n, x) gives the n-th Legendre polynomial, evaluated on x\n        OrthoP(n, a, b, x) gives the n-th Jacobi polynomial with parameters a, b, evaluated on x\n        OrthoG(n, a, x) gives the n-th Gegenbauer polynomial\n        OrthoH(n, x) gives the n-th Hermite polynomial\n        OrthoL(n, a, x) gives the n-th Laguerre polynomial\n        OrthoT(n, x) gives the n-th Tschebyscheff polynomial of the 1st kind\n        OrthoU(n, x) gives the n-th Tschebyscheff polynomial of the 2nd kind\n\n  If c is a list of coefficients c[1], c[2], ..., c[N], then Ortho*Sum(c, ...) where * is one of P, G, H, L, T, U, computes the sum of a series c[1]*P_0+c[2]*P_1+...+c[N]*P_N, where P_k is the relevant polynomial of k-th order. (For polynomials taking parameters: the parameters must remain constant throughout the summation.) Note that the intermediate polynomials are not evaluated and the recurrence relations are different for this computation, so there may be a numerical difference between Ortho*(c, ...) and computing the sum of the series directly.\n\n  Internal functions that may be useful:\n        OrthoPolyCoeffs(name_IsString, n_IsInteger, parameters_IsList) returns a list of coefficients of the polynomial. Here \"name\" must be one of the predefined names: \"Jacobi\", \"Gegenbauer\", \"Hermite\", \"Laguerre\", \"Tscheb1\",  \"Tscheb2\"; and \"parameters\" is a list of extra parameters for the given family of polynomials, e.g. {a,b} for the Jacobi, {a} for Laguerre and {} for Hermite polynomials.\n        OrthoPolySumCoeffs(name_IsString, c_IsList, parameters_IsList) returns a list of coefficients of the polynomial which is a sum of series with coefficients c.\n        EvaluateHornerScheme(coefficients, x) returns the Horner-evaluated polynomial on x. The \"coefficients\" is a list that starts at the lowest power. For example, EvaluateHornerScheme({a,b,c}, x) should return (a+x*(b+x*c))\n*/\n\n10 # EvaluateHornerScheme({}, _x) <-- 0;\n/* Strictly speaking, the following rule is not needed, but it doesn't hurt */\n10 # EvaluateHornerScheme({_coeffs}, _x) <-- coeffs;\n20 # EvaluateHornerScheme(coeffs_IsList, _x) <-- First(coeffs)+x*EvaluateHornerScheme(Rest(coeffs), x);\n\n/* Plain polynomials */\n// some are computed by general routines, and some are replaced by more efficient routines below\nOrthoP(n_IsInteger, _x)_(n>=?0) <-- OrthoP(n, 0, 0, x);\nOrthoP(n_IsInteger, a_IsRationalOrNumber, b_IsRationalOrNumber, _x)_(n>=?0 And? a>? -1 And? b>? -1) <-- OrthoPoly(\"Jacobi\", n, {a, b}, x);\n\nOrthoG(n_IsInteger, a_IsRationalOrNumber, _x)_(n>=?0 And? a>? -1/2) <-- OrthoPoly(\"Gegenbauer\", n, {a}, x);\n\nOrthoH(n_IsInteger, _x)_(n>=?0) <-- OrthoPoly(\"Hermite\", n, {}, x);\n\nOrthoL(n_IsInteger, a_IsRationalOrNumber, _x)_(n>=?0 And? a>? -1) <-- OrthoPoly(\"Laguerre\", n, {a}, x);\n\nOrthoT(n_IsInteger, _x)_(n>=?0) <-- OrthoPoly(\"Tscheb1\", n, {}, x);\nOrthoU(n_IsInteger, _x)_(n>=?0) <-- OrthoPoly(\"Tscheb2\", n, {}, x);\n\n/* Sums of series of orthogonal polynomials */\n\nOrthoPSum(c_IsList, _x) <-- OrthoP(c, 0, 0, x);\nOrthoPSum(c_IsList, a_IsRationalOrNumber, b_IsRationalOrNumber, _x)_(a>? -1 And? b>? -1) <-- OrthoPolySum(\"Jacobi\", c, {a, b}, x);\n\nOrthoGSum(c_IsList, a_IsRationalOrNumber, _x)_(a>? -1/2) <-- OrthoPolySum(\"Gegenbauer\", c, {a}, x);\n\nOrthoHSum(c_IsList, _x) <-- OrthoPolySum(\"Hermite\", c, {}, x);\n\nOrthoLSum(c_IsList, a_IsRationalOrNumber, _x)_(a>? -1) <-- OrthoPolySum(\"Laguerre\", c, {a}, x);\n\nOrthoTSum(c_IsList, _x) <-- OrthoPolySum(\"Tscheb1\", c, {}, x);\nOrthoUSum(c_IsList, _x) <-- OrthoPolySum(\"Tscheb2\", c, {}, x);\n\n/*\nOrthogonal polynomials are evaluated using a general routine OrthoPolyCoeffs that generates their coefficients recursively.\n\nThe recurrence relations start with n=0 and n=1 (the n=0 polynomial is always identically 1) and continue for n>=2. Note that the n=1 polynomial is not always given by the n=1 recurrence formula if we assume P_{-1}=0, so the recurrence should be considered undefined at n=1.\n\n        For Legendre/Jacobi polynomials: (a>?-1, b>?-1)\nP(0,a,b,x):=1\nP(1,a,b,x):=(a-b)/2+x*(1+(a+b)/2)\nP(n,a,b,x):=(2*n+a+b-1)*(a^2-b^2+x*(2*n+a+b-2)*(2*n+a+b))/(2*n*(n+a+b)*(2*n+a+b-2))*P(n-1,a,b,x)-(n+a-1)*(n+b-1)*(2*n+a+b)/(n*(n+a+b)*(2*n+a+b-2))*P(n-2,a,b,x)\n\n        For Hermite polynomials:\nH(0,x):=1\nH(1,x):=2*x\nH(n,x):=2*x*H(n-1,x)-2*(n-1)*H(n-2,x)\n\n        For Gegenbauer polynomials: (a>?-1/2)\nG(0,a,x):=1\nG(1,a,x):=2*a*x\nG(n,a,x):=2*(1+(a-1)/n)*x*G(n-1,a,x)-(1+2*(a-2)/n)*G(n-2,a,x)\n\n        For Laguerre polynomials: (a>?-1)\nL(0,a,x):=1\nL(1,a,x):=a+1-x\nL(n,a,x):=(2+(a-1-x)/n)*L(n-1,a,x)-(1+(a-1)/n)*L(n-2,a,x)\n\n        For Tschebycheff polynomials of the first kind:\nT(0,x):=1\nT(1,x):=x\nT(n,x):=2*x*T(n-1,x)-T(n-2,x)\n\n        For Tschebycheff polynomials of the second kind:\nU(0,x):=1\nU(1,x):=2*x\nU(n,x):=2*x*U(n-1,x)-U(n-2,x)\n\nThe database \"KnownOrthoPoly\" contains closures that return coefficients for the recurrence relations of each family of polynomials. KnownOrthoPoly[\"name\"] is a closure that takes two arguments: the order (n) and the extra parameters (p), and returns a list of two lists: the first list contains the coefficients {A,B} of the n=1 polynomial, i.e. \"A+B*x\"; the second list contains the coefficients {A,B,C} in the recurrence relation, i.e. \"P_n = (A+B*x)*P_{n-1}+C*P_{n-2}\". (So far there are only 3 coefficients in the second list, i.e. no \"C+D*x\", but we don't want to be limited.)\n\n*/\n\nLocalSymbols(knownOrthoPoly) [\n  knownOrthoPoly := Hold({\n    {\"Jacobi\", {{n, p}, {{(p[1]-p[2])/2, 1+(p[1]+p[2])/2}, {(2*n+p[1]+p[2]-1)*((p[1])^2-(p[2])^2)/(2*n*(n+p[1]+p[2])*(2*n+p[1]+p[2]-2)), (2*n+p[1]+p[2]-1)*(2*n+p[1]+p[2])/(2*n*(n+p[1]+p[2])), -(n+p[1]-1)*(n+p[2]-1)*(2*n+p[1]+p[2])/(n*(n+p[1]+p[2])*(2*n+p[1]+p[2]-2))}}}},\n    {\"Gegenbauer\", {{n, p}, {{0, 2*p[1]}, {0, 2+2*(p[1]-1)/n, -1-2*(p[1]-1)/n}}}},\n    {\"Laguerre\", {{n, p}, {{p[1]+1, -1}, {2+(p[1]-1)/n, -1/n, -1-(p[1]-1)/n}}}},\n    {\"Hermite\", {{n, p}, {{0,2}, {0, 2, -2*(n-1)}}}},\n    {\"Tscheb1\", {{n, p}, {{0,1}, {0,2,-1}}}},\n    {\"Tscheb2\", {{n, p}, {{0,2}, {0,2,-1}}}}\n  });\n  KnownOrthoPoly() := knownOrthoPoly;\n\n]; // LocalSymbols(knownOrthoPoly)\n\n/*\nFor efficiency, polynomials are represented by lists of coefficients rather than by MathPiper expressions. Polynomials are evaluated using the explicit Horner scheme. On numerical arguments, the polynomial coefficients are not computed, only the resulting value.\n*/\n\n/*\nSums of series of orthogonal polynomials are found using the Clenshaw-Smith recurrence scheme:\n        If $P_n$ satisfy $P_n = A_n p_{n-1} + B_n p_{n-2}$, $n>=2$, and if $A_1$ is defined so that $P_1 = A_1 P_0$, then $\\sum _{n=0}^N c_n P_n = X_0 P_0$, where $X_n$ are found from the following backward recurrence: $X_{N+1} = X_{N+2} = 0$, $X_n = c_n + A_{n+1} X_{n+1} + B_{n+2} X_{n+2}$, $n=N, N-1, ..., 0$.\n*/\n\n/* Numeric arguments are processed by a faster routine */\n\n10 # OrthoPoly(name_IsString, _n, p_IsList, x_IsRationalOrNumber) _ (KnownOrthoPoly()[name] !=? Empty) <-- OrthoPolyNumeric(name, n, p, x);\n20 # OrthoPoly(name_IsString, _n, p_IsList, _x) _ (KnownOrthoPoly()[name] !=? Empty) <-- EvaluateHornerScheme(OrthoPolyCoeffs(name, n, p), x);\n\n10 # OrthoPolySum(name_IsString, c_IsList, p_IsList, x_IsRationalOrNumber) _ (KnownOrthoPoly()[name] !=? Empty) <-- OrthoPolySumNumeric(name, c, p, x);\n20 # OrthoPolySum(name_IsString, c_IsList, p_IsList, _x) _ (KnownOrthoPoly()[name] !=? Empty) <-- EvaluateHornerScheme(OrthoPolySumCoeffs(name, c, p), x);\n\n/*\nOrthoPolyNumeric computes the value of the polynomial from recurrence relations directly. Do not use with non-numeric arguments, except for testing!\n*/\nOrthoPolyNumeric(name_IsString, n_IsInteger, p_IsList, _x) <-- [\n        Local(value1, value2, value3, ruleCoeffs, index);\n        value1 := 1;\n        ruleCoeffs := Apply(KnownOrthoPoly()[name], {n, p})[1];\n        value2 := ruleCoeffs[1] + x*ruleCoeffs[2];\n        index := 1;\n        /* value1, value2, value3 is the same as P_{n-2}, P_{n-1}, P_n where n = index */\n        While(index<?n) [\n                index := index + 1;\n                ruleCoeffs := Apply(KnownOrthoPoly()[name], {index, p})[2];\n                value3 := (ruleCoeffs[1] + x*ruleCoeffs[2])*value2 + ruleCoeffs[3]*value1;\n                value1 := value2;\n                value2 := value3;\n//Serge!                 Echo(index);\n        ];\n        value2;\n];\n\n/* Clenshaw-Smith recurrence scheme */\nOrthoPolySumNumeric(name_IsString, c_IsList, p_IsList, _x) <-- [\n        Local(value1, value2, value3, ruleCoeffs, ruleCoeffs1, index);\n        value1 := 0;\n        value2 := 0;\n        index := Length(c) - 1;\n        /* value1, value2, value3 is the same as X_{n+2}, X_{n+1}, X_n where n = index */\n        While(index>=?1) [\n                ruleCoeffs := Apply(KnownOrthoPoly()[name], {index+1, p})[2];\n                ruleCoeffs1 := Apply(KnownOrthoPoly()[name], {index+2, p})[2];\n                value3 := (ruleCoeffs[1] + x*ruleCoeffs[2])*value2 + ruleCoeffs1[3]*value1 + c[index+1];\n                value1 := value2;\n                value2 := value3;\n                index := index - 1;\n        ];\n        /* Last iteration by hand: works correctly also if c has only 1 element */\n        ruleCoeffs := Apply(KnownOrthoPoly()[name], {1, p})[1];\n        ruleCoeffs1 := Apply(KnownOrthoPoly()[name], {2, p})[2];\n        value2 := (ruleCoeffs[1] + x*ruleCoeffs[2])*value2 + ruleCoeffs1[3]*value1 + c[1];\n        value2;\n];\n\n/*\nOrthoPolyCoeffs(name, n, p) returns the list of coefficients for orthogonal polynomials, starting with the lowest powers.\n*/\n\n10 # OrthoPolyCoeffs(name_IsString, 0, p_IsList) <-- {1};\n10 # OrthoPolyCoeffs(name_IsString, 1, p_IsList) <-- Apply(KnownOrthoPoly()[name], {1, p})[1];\n\n/* Simple implementation, very slow, for testing only: recursive rule matches, no loops\n20 # OrthoPolyCoeffs(name_IsString, n_IsInteger, p_IsList)_(n>?1) <-- [\n        Local(ruleCoeffs, newCoeffs);\n        ruleCoeffs := Apply(KnownOrthoPoly()[name], {n, p})[2];\n        newCoeffs := OrthoPolyCoeffs(name, n-1, p);\n        Concat(newCoeffs,{0})*ruleCoeffs[1] + Concat(OrthoPolyCoeffs(name, n-2, p),{0,0})*ruleCoeffs[3] + Concat({0}, newCoeffs)*ruleCoeffs[2];\n];\n*/\n\n/* A fast implementation that works directly with lists and saves memory. Same recurrence as in OrthoPolyNumeric() */\n/* note: here we pass \"name\" instead of \"KnownOrthoPoly()[name]\" for efficiency, but strictly speaking we don't need to use this global constant */\n\n20 # OrthoPolyCoeffs(name_IsString, n_IsInteger, p_IsList)_(n>?1) <-- [\n        Local(ruleCoeffs, tmpCoeffs, newCoeffs, prevCoeffs, index, jndex, tmptmpCoeffs, prevCoeffsA, newCoeffsA, tmpCoeffsA);\n        /* For speed, allocate all lists now. Length is n+1 */\n        prevCoeffsA := ZeroVector(n+1);\n        newCoeffsA := ZeroVector(n+1);\n        tmpCoeffsA := ZeroVector(n+1);\n        /* pointers to arrays */\n        prevCoeffs := prevCoeffsA;\n        newCoeffs := newCoeffsA;\n        tmpCoeffs := tmpCoeffsA;\n        /* Initialize: n=0 and n=1 */\n        prevCoeffs[1] := 1;\n        ruleCoeffs := Apply(KnownOrthoPoly()[name], {n, p})[1];\n        newCoeffs[1] := ruleCoeffs[1];\n        newCoeffs[2] := ruleCoeffs[2];\n        /* Invariant: answer ready in \"newCoeffs\" at value of index */\n        index := 1;\n        /* main loop */\n        While(index <? n) [\n                index := index + 1;\n                /* Echo({\"index \", index}); */ /* in case this is slow */\n                ruleCoeffs := Apply(KnownOrthoPoly()[name], {index, p})[2];\n                tmpCoeffs[1] := ruleCoeffs[1]*newCoeffs[1] + ruleCoeffs[3]*prevCoeffs[1];\n                /* The polynomial tmpCoeffs must have (index+1) coefficients now */\n                For(jndex:=2, jndex <=? index, jndex:=jndex+1) [\n                        tmpCoeffs[jndex] := ruleCoeffs[1]*newCoeffs[jndex] + ruleCoeffs[3]*prevCoeffs[jndex] + ruleCoeffs[2]*newCoeffs[jndex-1];\n                ];\n                tmpCoeffs[index+1] := ruleCoeffs[2]*newCoeffs[index];\n/*\n                prevCoeffs := FlatCopy(newCoeffs);\n                newCoeffs := FlatCopy(tmpCoeffs);\n*/\n/* juggle pointers instead of copying lists */\n                tmptmpCoeffs := prevCoeffs;\n                prevCoeffs := newCoeffs;\n                newCoeffs := tmpCoeffs;\n                tmpCoeffs := tmptmpCoeffs;\n        ];\n        newCoeffs;\n];\n\n/*\nOrthoPolySumCoeffs(name, c, p) returns the list of coefficients for the sum of a series of orthogonal polynomials. Same recurrence as in OrthoPolySumNumeric()\n*/\n\nOrthoPolySumCoeffs(name_IsString, c_IsList, p_IsList) <-- [\n        Local(n, ruleCoeffs, ruleCoeffs1, tmpCoeffs, newCoeffs, prevCoeffs, index, jndex, tmptmpCoeffs, prevCoeffsA, newCoeffsA, tmpCoeffsA);\n        /* n is the max polynomial order we need */\n        n := Length(c) - 1;\n        /* For speed, allocate all lists now. Length is n+1 */\n        prevCoeffsA := ZeroVector(n+1);\n        newCoeffsA := ZeroVector(n+1);\n        tmpCoeffsA := ZeroVector(n+1);\n        /* pointers to arrays */\n        prevCoeffs := prevCoeffsA;\n        newCoeffs := newCoeffsA;\n        tmpCoeffs := tmpCoeffsA;\n        /* Invariant: answer ready in \"newCoeffs\" at value of index */\n        /* main loop */\n        For(index:=n, index >=? 1, index:=index-1) [\n                /* Echo({\"index \", index}); */ /* in case this is slow */\n                ruleCoeffs := Apply(KnownOrthoPoly()[name], {index+1, p})[2];\n                ruleCoeffs1 := Apply(KnownOrthoPoly()[name], {index+2, p})[2];\n                tmpCoeffs[1] := c[index+1] + ruleCoeffs[1]*newCoeffs[1] + ruleCoeffs1[3]*prevCoeffs[1];\n                /* The polynomial tmpCoeffs must have (n-index+1) coefficients now */\n                For(jndex:=2, jndex <=? n-index, jndex:=jndex+1) [\n                        tmpCoeffs[jndex] := ruleCoeffs[1]*newCoeffs[jndex] + ruleCoeffs1[3]*prevCoeffs[jndex] + ruleCoeffs[2]*newCoeffs[jndex-1];\n                ];\n                If(n-index>?0, tmpCoeffs[n-index+1] := ruleCoeffs[2]*newCoeffs[n-index]);\n/*\n                prevCoeffs := FlatCopy(newCoeffs);\n                newCoeffs := FlatCopy(tmpCoeffs);\n*/\n/* juggle pointers instead of copying lists */\n                tmptmpCoeffs := prevCoeffs;\n                prevCoeffs := newCoeffs;\n                newCoeffs := tmpCoeffs;\n                tmpCoeffs := tmptmpCoeffs;\n        ];\n        /* Last iteration by hand: works correctly also if c has only 1 element */\n        index:=0;\n        ruleCoeffs := Apply(KnownOrthoPoly()[name], {index+1, p})[1];\n        ruleCoeffs1 := Apply(KnownOrthoPoly()[name], {index+2, p})[2];\n        tmpCoeffs[1] := c[index+1] + ruleCoeffs[1]*newCoeffs[1] + ruleCoeffs1[3]*prevCoeffs[1];\n        /* The polynomial tmpCoeffs must have (n-index+1) coefficients now */\n        For(jndex:=2, jndex <=? n-index, jndex:=jndex+1) [\n                tmpCoeffs[jndex] := ruleCoeffs[1]*newCoeffs[jndex] + ruleCoeffs1[3]*prevCoeffs[jndex] + ruleCoeffs[2]*newCoeffs[jndex-1];\n        ];\n        tmpCoeffs[n-index+1] := ruleCoeffs[2]*newCoeffs[n-index];\n        tmpCoeffs;\n];\n\n//////////////////////////////////////////////////\n/// Very fast computation of Chebyshev polynomials\n//////////////////////////////////////////////////\n/// (This is not used now because of numerical instability, until I figure out how much to increase the working precision to get P correct digits.)\n/// See: W. Koepf. Efficient computation of Chebyshev polynomials in computer algebra (unpublished preprint). Contrary to Koepf's claim (unsupported by any calculation in his paper) that the method is numerically stable, I found unsatisfactory numerical behavior for very large orders.\n/// Koepf suggests to use M. Bronstein's algorithm for finding rational solutions of linear ODEs for all other orthogonal polynomials (may be faster than recursion if we want to find the analytic form of the polynomial, but still slower if an explicit formula is available).\n//////////////////////////////////////////////////\n/// Main formulae: T(2*n,x) = 2*T(n,x)^2-1; T(2*n+1,x) = 2*T(n+1,x)*T(n,x)-x;\n/// U(2*n,x) = 2*T(n,x)*U(n,x)-1; T(2*n+1,x) = 2*T(n+1,x)*U(n,x);\n/// We avoid recursive calls and build the sequence of bits of n to determine the minimal sequence of n[i] for which T(n[i], x) and U(n[i], x) need to be computed\n//////////////////////////////////////////////////\n/*\n/// This function will return the list of binary bits, e.g. BitList(10) returns {1,0,1,0}.\nBitList(n) := BitList(n, {});\n/// This will not be called on very large numbers so it's okay to use recursion\n1# BitList(0, _bits) <-- bits;\n2# BitList(_n, _bits) <-- BitList(Quotient(n,2), Push(bits, Modulo(n,2)));\n\n// Tchebyshev polynomials of 1st kind\n1 # FastOrthoT(0, _x) <-- 1;\n1 # FastOrthoT(1, _x) <-- x;\n// Tchebyshev polynomials of 2nd kind\n1 # FastOrthoU(0, _x) <-- 1;\n1 # FastOrthoU(1, _x) <-- 2*x;\n\n// guard against user errors\n2 # FastOrthoT(_n, _x) _ (IsInteger(n) And? n<?0) <-- Undefined;\n2 # FastOrthoU(_n, _x) _ (IsInteger(n) And? n<?0) <-- Undefined;\n\n// make T(), U() of even order more efficient: delegate gruntwork to odd order\n2 # FastOrthoT(n_IsEven, _x) <-- 2*FastOrthoT(Quotient(n,2), x)^2-1;\n2 # FastOrthoU(n_IsEven, _x) <-- 2*FastOrthoT(Quotient(n,2), x)*FastOrthoU(Quotient(n,2), x)-1;\n\n// FastOrthoT() of odd order\n3 # FastOrthoT(n_IsOdd, _x) <--\n[\n        Local(T1, T2, i);\n        // first bit in the list is always 1, so initialize the pair\n        T1 := FastOrthoT(1, x);\n        T2 := FastOrthoT(2, x);\n        ForEach(i, Rest(BitList(n)))        // skip first bit\n        [\n                // if the current bit is 1, we need to double the second index, else double the first index.\n                // Invariant: n[i+1] = 2*n[i] + BitList[i] and we need to have FastOrthoT(n[i]), FastOrthoT(1+n[i]) as T1, T2. Initially n[1]=1 and after the cycle n[i]=n.\n                {T1, T2} := If\n                (\n                        i=1,\n                        {2*T1*T2-x, 2*T2^2-1},\n                        {2*T1^2-1, 2*T1*T2-x}\n                );\n        ];\n        T1;\n];\n\n// FastOrthoU() of any order\n3 # FastOrthoU(_n, _x) <--\n[\n        Local(U1, T1, T2, i);\n        // first bit in the list is always 1, so initialize the pair\n        U1 := FastOrthoU(1, x);\n        T1 := FastOrthoT(1, x);\n        T2 := FastOrthoT(2, x);\n        ForEach(i, Rest(BitList(n)))        // skip first bit\n        [\n                // if the current bit is 1, we need to double the second index, else double the first index\n                // Invariant: n[i+1] = 2*n[i] + BitList[i] and we need to have U(n[i]), T(n[i]), T(1+n[i]) as U1, T1, T2. Initially n[1]=1 and after the cycle n[i]=n.\n                {U1, T1, T2} := If\n                (\n                        i=1,\n                        {2*U1*T2, 2*T1*T2-x, 2*T2^2-1},\n                        {2*U1*T1-1, 2*T1^2-1, 2*T1*T2-x}\n                );\n        ];\n        U1;\n];\n*/\n//////////////////////////////////////////////////\n/// Fast symbolic computation of some polynomials\n//////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////\n/// Fast symbolic computation of Legendre polynomials\n//////////////////////////////////////////////////\n\n8# OrthoPolyCoeffs(\"Jacobi\", n_IsInteger, {0,0}) <--\n[\n        Local(i, result);\n        result := ZeroVector(n+1);\n        result[n+1] := (2*n-1)!! /n!;        // coefficient at x^n\n        i := 1;\n        While(2*i<=?n)\n        [        // prepare coefficient at x^(n-2*i) now\n                result[n+1-2*i] := -(result[n+3-2*i]*(n-2*i+1)*(n-2*i+2)) / ((2*n-2*i+1)*2*i);\n                i++;\n        ];\n        result;\n];\n\n//////////////////////////////////////////////////\n/// Fast symbolic computation of Hermite polynomials\n//////////////////////////////////////////////////\n\nOrthoPolyCoeffs(\"Hermite\", n_IsInteger, {}) <-- HermiteCoeffs(n);\n\n/// Return the list of coefficiets of Hermite polynomials.\nHermiteCoeffs(n_IsEven)_(n>?0) <--\n[\n        Local(i, k, result);\n        k := Quotient(n,2);\n        result := ZeroVector(n+1);\n        result[1] := (-2)^k*(n-1)!!;        // coefficient at x^0\n        For(i:=1,i<=?k,i++)        // prepare coefficient at x^(2*i) now\n                result[2*i+1] := Quotient(-2*result[2*i-1] * (k-i+1), (2*i-1)*i);        // this division is always integer but faster with Quotient()\n        result;\n];\nHermiteCoeffs(n_IsOdd)_(n>?0) <--\n[\n        Local(i, k, result);\n        k := Quotient(n,2);\n        result := ZeroVector(n+1);\n        result[2] := 2*(-2)^k*(n!!);        // coefficient at x^1\n        For(i:=1,i<=?k,i++)        // prepare coefficient at x^(2*i+1) now\n                result[2*i+2] := Quotient(-2*result[2*i] * (k-i+1), i*(2*i+1));        // this division is always integer but faster with Quotient()\n        result;\n];\n\n//////////////////////////////////////////////////\n/// Fast symbolic computation of Laguerre polynomials\n//////////////////////////////////////////////////\n\n/// Return the list of coefficients of Laguerre polynomials.\nOrthoPolyCoeffs(\"Laguerre\", n_IsInteger, {_k}) <--\n[\n        Local(i, result);\n        result := ZeroVector(n+1);\n        result[n+1] := (-1)^n/n!;        // coefficient at x^n\n        For(i:=n,i>=?1,i--)        // prepare coefficient at x^(i-1) now\n                result[i] := -(result[i+1]*i*(k+i))/(n-i+1);\n        result;\n];\n\n\n//////////////////////////////////////////////////\n/// Fast symbolic computation of Chebyshev polynomials\n//////////////////////////////////////////////////\n\nOrthoPolyCoeffs(\"Tscheb1\", n_IsInteger, {}) <-- ChebTCoeffs(n);\nOrthoPolyCoeffs(\"Tscheb2\", n_IsInteger, {}) <-- ChebUCoeffs(n);\n\n1 # ChebTCoeffs(0) <-- {1};\n2 # ChebTCoeffs(n_IsInteger) <--\n[\n        Local(i, result);\n        result := ZeroVector(n+1);\n        result[n+1] := 2^(n-1);        // coefficient at x^n\n        i := 1;\n        While(2*i<=?n)\n        [        // prepare coefficient at x^(n-2*i) now\n                result[n+1-2*i] := -(result[n+3-2*i]*(n-2*i+2)*(n-2*i+1)) / ((n-i)*4*i);\n                i++;\n        ];\n        result;\n];\n\n1 # ChebUCoeffs(0) <-- {1};\n2 # ChebUCoeffs(n_IsInteger) <--\n[\n        Local(i, result);\n        result := ZeroVector(n+1);\n        result[n+1] := 2^n;        // coefficient at x^n\n        i := 1;\n        While(2*i<=?n)\n        [        // prepare coefficient at x^(n-2*i) now\n                result[n+1-2*i] := -(result[n+3-2*i]*(n-2*i+2)*(n-2*i+1)) / ((n-i+1)*4*i);\n                i++;\n        ];\n        result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/orthopoly/orthopoly.mpw";
        scriptMap.put("OrthoP",scriptString);
        scriptMap.put("OrthoG",scriptString);
        scriptMap.put("OrthoH",scriptString);
        scriptMap.put("OrthoL",scriptString);
        scriptMap.put("OrthoT",scriptString);
        scriptMap.put("OrthoU",scriptString);
        scriptMap.put("OrthoPSum",scriptString);
        scriptMap.put("OrthoGSum",scriptString);
        scriptMap.put("OrthoHSum",scriptString);
        scriptMap.put("OrthoLSum",scriptString);
        scriptMap.put("OrthoTSum",scriptString);
        scriptMap.put("OrthoUSum",scriptString);
        scriptMap.put("EvaluateHornerScheme",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* CForm: convert MathPiper objects to C/C++ code. */\n\n/* version 0.3 */\n\n/* Changelog\n        0.1        CForm() derived from TeXForm() v0.4. Have basic functionality. Do not allow list manipulation, unevaluated derivatives, set operations, limits, integrals, Infinity, explicit matrices. Complex numbers and expressions are handled just like real ones. Indexed symbols are assumed to be arrays and handled literally. No declarations or prototypes are supplied. Function definitions are not handled. Sum() is left as is (can be defined as a C function).\n        0.2 Fix for extra parens in Sin() and other functions; fixes for Exp(), Abs() and inverse trig functions\n        0.3 Fix for indexed expressions: support a[2][3][4]\n        0.3.1 Fix for CForm(integer): add a decimal point\n        0.4 Support While()[]. Added IsCFormable. Use Concat() instead of Union() on lists.\n        0.4.1 Support False, True\n  0.4.2 Changed it so that integers are not coerced to floats any more automatically (one can coerce integers to floats manually nowadays by adding a decimal point to the string representation, eg. 1. instead of 1).\n*/\n\n/* To do:\n        0. Find and fix bugs.\n        1. Chop strings that are longer than 80 chars?\n        2. Optimization of C code?\n*/\n\nRulebase(\"CForm\",{expression});\nRulebase(\"CForm\",{expression, precedence});\n\nFunction (\"CFormBracketIf\", {predicate, string})\n[\n        Check(IsBoolean(predicate) And? IsString(string), \"Argument\", \"CForm internal error: non-boolean and/or non-string argument of CFormBracketIf\");\n        If(predicate, ConcatStrings(\"( \", string, \") \"), string);\n];\n\nCFormDoublePrecisionNumber(x_IsNumber) <--\n[\n    Local(i,n,s,f);\n    s := ToString(x);\n    n := Length(s);\n    f := False;\n    For(i := 1, i <=? n, i++)\n    [\n        If(s[i] =? \"e\" Or? s[i] =? \".\", f := True);\n    ];\n    If(f, s, s : \".\");\n];\n\n/* Proceed just like TeXForm()\n*/\n\n// CFormMaxPrec should perhaps only be used from within this file, it is thus not in the .def file.\nCFormMaxPrec() := 60000;         /* This precedence will never be bracketed. It is equal to KMaxPrec */\n\n100 # CForm(_x) <-- CForm(x, CFormMaxPrec());\n\n/* Replace numbers and variables -- never bracketed except explicitly */\n110 # CForm(x_IsInteger, _p) <-- ToString(x);\n111 # CForm(x_IsZero, _p) <-- \"0.\";\n112 # CForm(x_IsNumber, _p) <-- CFormDoublePrecisionNumber(x);\n/* Variables are left as is, except some special ones */\n190 # CForm(False, _p) <-- \"false\";\n190 # CForm(True, _p) <-- \"true\";\n200 # CForm(x_IsAtom, _p) <-- ToString(x);\n\n/* Strings must be quoted but not bracketed */\n100 # CForm(x_IsString, _p) <-- ConcatStrings(\"\\\"\", x, \"\\\"\");\n\n/* Replace operations */\n\n/* arithmetic */\n\n/* addition, subtraction, multiplication, all comparison and logical operations are \"regular\" */\n\n\nLocalSymbols(cformRegularOps) [\n  cformRegularOps := { {\"+\",\" + \"}, {\"-\",\" - \"}, {\"*\",\" * \"},\n                       {\"/\",\" / \"}, {\":=\",\" = \"}, {\"==\",\" == \"},\n                       {\"=?\",\" == \"}, {\"!=?\",\" != \"}, {\"<=?\",\" <=? \"},\n                       {\">=?\",\" >= \"}, {\"<?\",\" < \"}, {\">?\",\" > \"},\n                       {\"And?\",\" && \"}, {\"Or?\",\" || \"}, {\">>\", \" >> \"},\n                       { \"<<\", \" << \" }, { \"&\", \" & \" }, { \"|\", \" | \" },\n                       { \"%\", \" % \" }, { \"^\", \" ^ \" },\n                     };\n\n  CFormRegularOps() := cformRegularOps;\n]; // LocalSymbols(cformRegularOps)\n\n        /* This is the template for \"regular\" binary infix operators:\n100 # CForm(_x + _y, _p) <-- CFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(CForm(x, LeftPrecedenceGet(\"+\")), \" + \", CForm(y, RightPrecedenceGet(\"+\")) ) );\n        */\n\n        /* unary addition */\n100 # CForm(+ _y, _p) <-- CFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(\" + \", CForm(y, RightPrecedenceGet(\"+\")) ) );\n\n        /* unary subtraction */\n100 # CForm(- _y, _p) <-- CFormBracketIf(p<?PrecedenceGet(\"-\"), ConcatStrings(\" - \", CForm(y, RightPrecedenceGet(\"-\")) ) );\n\n        /* power's argument is never bracketed but it must be put in braces. */\n100 # CForm(_x ^ _y, _p) <-- CFormBracketIf(p<=?PrecedenceGet(\"^\"), ConcatStrings(\"pow(\", CForm(x, CFormMaxPrec()), \", \", CForm(y, CFormMaxPrec()), \")\" ) );\n\n100 # CForm(if(_pred)_body, _p) <-- \"if (\":CForm(pred,60000):\") \":CForm(body);\n100 # CForm(_left else _right, _p) <-- CForm(left):\" else \":CForm(right);\n\n\nLocalSymbols(cformMathFunctions) [\n  cformMathFunctions :=\n    {\n      {\"Sqrt\",\"sqrt\"},\n      {\"Cos\",\"cos\"},\n      {\"Sin\",\"sin\"},\n      {\"Tan\",\"tan\"},\n      {\"Cosh\",\"cosh\"},\n      {\"Sinh\",\"sinh\"},\n      {\"Tanh\",\"tanh\"},\n      {\"Exp\",\"exp\"},\n      {\"Ln\",\"log\"},\n      {\"ArcCos\",\"acos\"},\n      {\"ArcSin\",\"asin\"},\n      {\"ArcTan\",\"atan\"},\n      {\"ArcCosh\",\"acosh\"},\n      {\"ArcSinh\",\"asinh\"},\n      {\"ArcTanh\",\"atanh\"},\n      {\"Maximum\",\"max\"},\n      {\"Minimum\",\"min\"},\n      {\"Abs\",\"fabs\"},\n      {\"Floor\",\"floor\"},\n      {\"Ceil\",\"ceil\"},\n    {\"!\",\"factorial\"}\n    };\n\n  CFormMathFunctions() := cformMathFunctions;\n\n]; // LocalSymbols(cformMathFunctions)\n\n/* Precedence of 120 because we'd like to process some special functions like pow() first */\n\n\n120 # CForm(expr_IsFunction, _p)_(ArgumentsCount(expr)=?2 And? Contains(AssocIndices(CFormRegularOps()), Type(expr)) ) <--\n      CFormBracketIf(p<?PrecedenceGet(Type(expr)), ConcatStrings(CForm(FunctionToList(expr)[2], LeftPrecedenceGet(Type(expr))), CFormRegularOps()[Type(expr)], CForm(FunctionToList(expr)[3], RightPrecedenceGet(Type(expr))) ) );\n\n\n/* Sin, Cos, etc. and their argument is always bracketed */\n\n120 # CForm(expr_IsFunction, _p) _\n      (ArgumentsCount(expr)=?1 And? Contains(AssocIndices(CFormMathFunctions()), Type(expr)) ) <--\n      ConcatStrings(CFormMathFunctions()[Type(expr)], \"(\", CForm( FunctionToList(expr)[2], CFormMaxPrec()),\")\" );\n\n/* functions */\n\n/* Unknown function, precedence 200. Leave as is, never bracket the function itself and bracket the argumentPointer(s) automatically since it's a list. Other functions are precedence 100 */\n\nCFormArgs(list_IsList) <--\n[\n  Local(i,nr,result);\n  result:=\"\";\n  nr:=Length(list);\n  For (i:=1,i<=?nr,i++)\n  [\n    result:=result:CForm(list[i]);\n    If (i<?nr, result:=result:\", \");\n  ];\n  result;\n];\n\n\n200 # CForm(_x, _p)_(IsFunction(x)) <--\n[\n  ConcatStrings(Type(x), \"(\", CFormArgs(Rest(FunctionToList(x))),\")\" );\n];\n\n/* Complex numbers */\n100 # CForm(Complex(0, 1), _p) <-- \"I\";\n100 # CForm(Complex(_x, 0), _p) <-- CForm(x, p);\n110 # CForm(Complex(_x, 1), _p) <-- CForm(x+Hold(I), p);\n110 # CForm(Complex(0, _y), _p) <-- CForm(Hold(I)*y, p);\n120 # CForm(Complex(_x, _y), _p) <-- CForm(x+Hold(I)*y, p);\n\n/* Some special functions: Mod */\n\n100 # CForm(Modulo(_x, _y), _p) <-- CFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(CForm(x, PrecedenceGet(\"/\")), \" % \", CForm(y, PrecedenceGet(\"/\")) ) )\n;\n\n/* Indexed expressions are never bracketed */\n// the rule with [ ] seems to have no effect?\n//100 # CForm(_x [ _i ], _p) <-- ConcatStrings(CForm(x, CFormMaxPrec()), \"[\", CForm(i, CFormMaxPrec()), \"]\");\n100 # CForm(Nth(_x, _i), _p) <-- ConcatStrings(CForm(x, CFormMaxPrec()), \"[\", CForm(i, CFormMaxPrec()), \"]\");\n\nLocalSymbols(cindent) [\n  cindent:=1;\n\n  NlIndented():=\n  [\n    Local(result);\n// carriage return, so needs to start at the beginning of the line\n    result:=\n\"\n\";\n    Local(i);\n    For(i:=1,i<?cindent,i++)\n    [\n      result:=result:\"  \";\n    ];\n    result;\n  ];\n  CIndent() :=\n  [\n  (cindent++);\n  \"\";\n  ];\n  CUndent() :=\n  [\n  (cindent--);\n  \"\";\n  ];\n]; // LocalSymbols(cindent)\n\nCFormStatement(_x) <-- CForm(x) : \";\" : NlIndented();\n\n120 # CForm(_x,_p)_(Type(x) =? \"Prog\") <--\n[\n  Local(result);\n  result:=CIndent():\"{\":NlIndented();\n  ForEach(item,Rest(FunctionToList(x)))\n  [\n    result:=result:CFormStatement(item);\n  ];\n  result:=result:\"}\":CUndent():NlIndented();\n  result;\n];\n\n120 # CForm(For(_from,_to,_step)_body,_p) <--\n  \"for(\" : CForm(from,CFormMaxPrec()) : \";\"\n        : CForm(to,CFormMaxPrec()) : \";\"\n        : CForm(step,CFormMaxPrec()) : \")\"\n        : CIndent() : NlIndented()\n        : CFormStatement(body) : CUndent();\n\n120 # CForm(While(_pred)_body, _p) <--\n        \"while(\" : CForm(pred,CFormMaxPrec()) : \")\"\n        : CIndent() : NlIndented()\n        : CFormStatement(body) : CUndent();\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/outputforms/CForm.mpw";
        scriptMap.put("CForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// IsCFormable\n//////////////////////////////////////////////////\n\nLocalSymbols(CFormAllFunctions) [\n\n  /// predicate to test whether an expression can be successfully exported to C code\n\n  /// interface with empty extra function list\n  // need the backquote stuff b/c we have HoldArgument now\n  IsCFormable(_expr) <-- `IsCFormable(@expr, {});\n\n  // need to check that expr contains only allowed functions\n  IsCFormable(_expr, funclist_IsList) <--\n  [\n    Local(bad'functions);\n    bad'functions := Difference(`FuncList(@expr), Concat(CFormAllFunctions, funclist));\n    If(Length(bad'functions)=?0,\n      True,\n      [\n        If(InVerboseMode(),\n          Echo(Concat({\"IsCFormable: Info: unexportable function(s): \"}, bad'functions))\n        );\n        False;\n      ]\n    );\n  ];\n  HoldArgumentNumber(\"IsCFormable\", 1, 1);\n  HoldArgumentNumber(\"IsCFormable\", 2, 1);\n\n  /// This is a list of all function atoms which CForm can safely handle\n  CFormAllFunctions := MapSingle(ToAtom, Concat(AssocIndices(CFormMathFunctions()), AssocIndices(CFormRegularOps()),\n  // list of \"other\" (non-math) functions supported by CForm: needs to be updated when CForm is extended to handle new functions\n  {\n    \"For\",\n    \"While\",\n    \"Prog\",\n    \"Nth\",\n    \"Modulo\",\n    \"Complex\",\n    \"if\",\n    \"else\",\n    \"++\",\n    \"--\",\n  }\n  ));\n\n\n]; // LocalSymbols(CFormAllFunctions)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/outputforms/IsCFormable.mpw";
        scriptMap.put("IsCFormable",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nEvalFormula\n*/\n\n\n/*\nTODO:\n- Func(a=b) prematurely evaluates a=b\n- clean up the code!\n  - document the code!!!\n- prefix/postfix currently not used!!!\n- some rules for rendering the formula are slooooww....\n\n- bin, derivative, sqrt, integral, summation, limits,\n      ___\n     / a |\n \\  /  -\n  \\/   b\n\n   /\n   |\n   |\n   |\n   /\n\n  d\n --- f( x )\n d x\n\n   2\n  d\n ----  f( x )\n    2\n d x\n\n  Infinity\n    ___\n    \\\n     \\    n\n     /   x\n    /__\n    n = 0\n                 Sin(x)\n     lim         ------\n x -> Infinity    x\n\n\n\n*/\n\n/*\nNLog(str):=\n[\n  WriteString(str);\n  NewLine();\n];\n*/\n\n\n\n\nCharList(length,item):=\n[\n  Local(line,i);\n  line:=\"\";\n  For(Bind(i,0),IsLessThan(i,length),Bind(i,AddN(i,1)))\n    Bind(line, line:item);\n  line;\n];\n\n\n\n\nCharField(width,height) := ArrayCreate(height,CharList(width,\" \"));\n\n\n\n\nWriteCharField(charfield):=\n[\n  Local(i,len);\n  len:=Length(charfield);\n  For(Bind(i,1),i<=?len,Bind(i,AddN(i,1)))\n  [\n    WriteString(charfield[i]);\n    NewLine();\n  ];\n  True;\n];\n\n\n\n\nColumnFilled(charfield,column):=\n[\n  Local(i,result,len);\n  result:=False;\n  len:=Length(charfield);\n  For(Bind(i, 1),(result =? False) And? (i<=?len),Bind(i,AddN(i,1)))\n  [\n    If(StringMidGet(column,1,charfield[i]) !=? \" \",result:=True);\n  ];\n  result;\n];\n\n\n\n\nWriteCharField(charfield,width):=\n[\n  Local(pos,length,len);\n  Bind(length, Length(charfield[1]));\n  Bind(pos, 1);\n  While(pos<=?length)\n  [\n    Local(i,thiswidth);\n    Bind(thiswidth, width);\n    If(thiswidth>?(length-pos)+1,\n      [\n        Bind(thiswidth, AddN(SubtractN(length,pos),1));\n      ],\n      [\n        While (thiswidth>?1 And? ColumnFilled(charfield,pos+thiswidth-1))\n        [\n          Bind(thiswidth,SubtractN(thiswidth,1));\n        ];\n        If(thiswidth =? 1, Bind(thiswidth, width));\n      ]\n    );\n    len:=Length(charfield);\n    For(Bind(i, 1),i<=?len,Bind(i,AddN(i,1)))\n    [\n      WriteString(StringMidGet(pos,thiswidth,charfield[i]));\n      NewLine();\n    ];\n    Bind(pos, AddN(pos, thiswidth));\n    NewLine();\n  ];\n  True;\n];\n\n\n\n\nPutString(charfield,x,y,string):=\n[\n  cf[y] := StringMidSet(x,string,cf[y]);\n  True;\n];\n\n\n\n\nMakeOper(x,y,width,height,oper,args,base):=\n[\n  Local(result);\n  Bind(result,ArrayCreate(7,0));\n  ArraySet(result,1,x);\n  ArraySet(result,2,y);\n  ArraySet(result,3,width);\n  ArraySet(result,4,height);\n  ArraySet(result,5,oper);\n  ArraySet(result,6,args);\n  ArraySet(result,7,base);\n  result;\n];\n\n\n\n\nMoveOper(f,x,y):=\n[\n  f[1]:=AddN(f[1], x); /* move x */\n  f[2]:=AddN(f[2], y); /* move y */\n  f[7]:=AddN(f[7], y); /* move base */\n];\n\n\n\n\nAlignBase(i1,i2):=\n[\n  Local(base);\n  Bind(base, Maximum(i1[7],i2[7]));\n  MoveOper(i1,0,SubtractN(base,(i1[7])));\n  MoveOper(i2,0,SubtractN(base,(i2[7])));\n];\n\n\n\n\n10 # BuildArgs({}) <-- Formula(ToAtom(\" \"));\n\n\n\n\n20 # BuildArgs({_head}) <-- head;\n\n\n\n\n30 # BuildArgs(_any)    <--\n     [\n        Local(item1,item2,comma,base,newitem);\n        Bind(item1, any[1]);\n        Bind(item2, any[2]);\n        Bind(comma, Formula(ToAtom(\",\")));\n        Bind(base, Maximum(item1[7],item2[7]));\n        MoveOper(item1,0,SubtractN(base,(item1[7])));\n        MoveOper(comma,AddN(item1[3],1),base);\n\n        MoveOper(item2,comma[1]+comma[3]+1,SubtractN(base,(item2[7])));\n        Bind(newitem, MakeOper(0,0,AddN(item2[1],item2[3]),Maximum(item1[4],item2[4]),\"Func\",{item1,comma,item2},base));\n        BuildArgs(newitem:Rest(Rest(any)));\n      ];\n\n\n\n\nFormulaBracket(f):=\n[\n  Local(left,right);\n  Bind(left, Formula(ToAtom(\"(\")));\n  Bind(right, Formula(ToAtom(\")\")));\n  left[4]:=f[4];\n  right[4]:=f[4];\n  MoveOper(left,f[1],f[2]);\n  MoveOper(f,2,0);\n  MoveOper(right,f[1]+f[3]+1,f[2]);\n  MakeOper(0,0,right[1]+right[3],f[4],\"Func\",{left,f,right},f[7]);\n];\n\n\n\n\n/* Rulebase(\"Formula\",{f}); */\n\n1 # Formula(f_IsAtom) <--\n  MakeOper(0,0,Length(ToString(f)),1,\"ToAtom\",ToString(f),0);\n\n\n\n\n2 # Formula(_xx ^ _yy) <--\n[\n  Local(l,r);\n  Bind(l, BracketOn(Formula(xx),xx,LeftPrecedenceGet(\"^\")));\n  Bind(r, BracketOn(Formula(yy),yy,RightPrecedenceGet(\"^\")));\n  MoveOper(l,0,r[4]);\n  MoveOper(r,l[3],0);\n  MakeOper(0,0,AddN(l[3],r[3]),AddN(l[4],r[4]),\"Func\",{l,r},l[2]+l[4]-1);\n];\n\n\n\n\n10 # FormulaArrayItem(xx_IsList) <--\n[\n  Local(sub,height);\n  sub := {};\n  height := 0;\n  ForEach(item,xx)\n  [\n    Local(made);\n    made := FormulaBracket(Formula(item));\n    If(made[4] >? height,Bind(height,made[4]));\n    DestructiveAppend(sub,made);\n  ];\n  MakeOper(0,0,0,height,\"List\",sub,height>>1);\n];\n\n\n\n20 # FormulaArrayItem(_item) <-- Formula(item);\n\n\n\n\n2 # Formula(xx_IsList) <--\n[\n  Local(sub,width,height);\n  sub:={};\n  width := 0;\n  height := 1;\n\n  ForEach(item,xx)\n  [\n    Local(made);\n    made := FormulaArrayItem(item);\n\n    If(made[3] >? width,Bind(width,made[3]));\n    MoveOper(made,0,height);\n    Bind(height,AddN(height,AddN(made[4],1)));\n    DestructiveAppend(sub,made);\n  ];\n\n  Local(thislength,maxlength);\n  maxlength:=0;\n  ForEach(item,xx)\n  [\n    thislength:=0;\n    if(IsList(item)) [thislength:=Length(item);];\n    if (maxlength<?thislength) [maxlength:=thislength;];\n  ];\n\n  If(maxlength>?0,\n  [\n    Local(i,j);\n    width:=0;\n    For(j:=1,j<=?maxlength,j++)\n    [\n      Local(w);\n      w := 0;\n      For(i:=1,i<=?Length(sub),i++)\n      [\n        if (IsList(xx[i]) And? j<=?Length(xx[i]))\n          If(sub[i][6][j][3] >? w,w := sub[i][6][j][3]);\n      ];\n\n      For(i:=1,i<=?Length(sub),i++)\n      [\n        if (IsList(xx[i]) And? j<=?Length(xx[i]))\n          MoveOper(sub[i][6][j],width,0);\n      ];\n      width := width+w+1;\n    ];\n    For(i:=1,i<=?Length(sub),i++)\n    [\n      sub[i][3] := width;\n    ];\n  ]\n  );\n\n  sub := MakeOper(0,0,width,height,\"List\",sub,height>>1);\n  FormulaBracket(sub);\n];\n\n\n\n\n\n2 # Formula(_xx / _yy) <--\n[\n  Local(l,r,dash,width);\n/*\n  Bind(l, BracketOn(Formula(xx),xx,LeftPrecedenceGet(\"/\")));\n  Bind(r, BracketOn(Formula(yy),yy,RightPrecedenceGet(\"/\")));\n*/\n  Bind(l, Formula(xx));\n  Bind(r, Formula(yy));\n  Bind(width, Maximum(l[3],r[3]));\n  Bind(dash, Formula(ToAtom(CharList(width,\"-\"))));\n  MoveOper(dash,0,l[4]);\n  MoveOper(l,(SubtractN(width,l[3])>>1),0);\n  MoveOper(r,(SubtractN(width,r[3])>>1),AddN(dash[2], dash[4]));\n  MakeOper(0,0,width,AddN(r[2], r[4]),\"Func\",{l,r,dash},dash[2]);\n];\n\n\n\n\nRulebase(\"BracketOn\",{op,f,prec});\n\nRule(\"BracketOn\",3,1,IsFunction(f) And? ArgumentsCount(f) =? 2\n     And? IsInfix(Type(f)) And? PrecedenceGet(Type(f)) >? prec)\n[\n FormulaBracket(op);\n];\n\n\n\n\nRule(\"BracketOn\",3,2,True)\n[\n  op;\n];\n\n\n\n\n\n10 # Formula(f_IsFunction)_(ArgumentsCount(f) =? 2 And? IsInfix(Type(f))) <--\n[\n  Local(l,r,oper,width,height,base);\n  Bind(l, Formula(f[1]));\n  Bind(r, Formula(f[2]));\n\n  Bind(l, BracketOn(l,f[1],LeftPrecedenceGet(Type(f))));\n  Bind(r, BracketOn(r,f[2],RightPrecedenceGet(Type(f))));\n\n  Bind(oper, Formula(f[0]));\n  Bind(base, Maximum(l[7],r[7]));\n  MoveOper(oper,AddN(l[3],1),SubtractN(base,(oper[7])));\n  MoveOper(r,oper[1] + oper[3]+1,SubtractN(base,(r[7])));\n  MoveOper(l,0,SubtractN(base,(l[7])));\n  Bind(height, Maximum(AddN(l[2], l[4]),AddN(r[2], r[4])));\n\n  MakeOper(0,0,AddN(r[1], r[3]),height,\"Func\",{l,r,oper},base);\n];\n\n\n\n\n11 # Formula(f_IsFunction) <--\n[\n  Local(head,args,all);\n  Bind(head, Formula(f[0]));\n  Bind(all, Rest(FunctionToList(f)));\n\n  Bind(args, FormulaBracket(BuildArgs(MapSingle(\"Formula\",Apply(\"Hold\",{all})))));\n  AlignBase(head,args);\n  MoveOper(args,head[3],0);\n\n  MakeOper(0,0,args[1]+args[3],Maximum(head[4],args[4]),\"Func\",{head,args},head[7]);\n];\n\n\n\nRulebase(\"RenderFormula\",{cf,f,x,y});\n\n/*\n/   /  /\n\\   |  |\n    \\  |\n       \\\n*/\n\nRule(\"RenderFormula\",4,1,f[5] =? \"ToAtom\" And? f[6] =? \"(\" And? f[4] >? 1)\n[\n  Local(height,i);\n  Bind(x, AddN(x,f[1]));\n  Bind(y, AddN(y,f[2]));\n  Bind(height, SubtractN(f[4],1));\n\n  cf[y] := StringMidSet(x, \"/\", cf[y]);\n  cf[AddN(y,height)] := StringMidSet(x, \"\\\\\", cf[AddN(y,height)]);\n  For (Bind(i,1),IsLessThan(i,height),Bind(i,AddN(i,1)))\n    cf[AddN(y,i)] := StringMidSet(x, \"|\", cf[AddN(y,i)]);\n];\n\n\n\n\nRule(\"RenderFormula\",4,1,f[5] =? \"ToAtom\" And? f[6] =? \")\" And? f[4] >? 1)\n[\n  Local(height,i);\n  Bind(x, AddN(x,f[1]));\n  Bind(y, AddN(y,f[2]));\n  Bind(height, SubtractN(f[4],1));\n  cf[y] := StringMidSet(x, \"\\\\\", cf[y]);\n  cf[y+height] := StringMidSet(x, \"/\", cf[y+height]);\n  For (Bind(i,1),IsLessThan(i,height),Bind(i,AddN(i,1)))\n    cf[AddN(y,i)] := StringMidSet(x, \"|\", cf[AddN(y,i)]);\n];\n\n\n\n\nRule(\"RenderFormula\",4,5,f[5] =? \"ToAtom\")\n[\n  cf[AddN(y, f[2]) ]:=\n    StringMidSet(AddN(x,f[1]),f[6],cf[AddN(y, f[2]) ]);\n];\n\n\n\n\nRule(\"RenderFormula\",4,6,True)\n[\n  ForEach(item,f[6])\n  [\n    RenderFormula(cf,item,AddN(x, f[1]),AddN(y, f[2]));\n  ];\n];\n\n\n\n\nLocalSymbols(formulaMaxWidth) [\n  SetFormulaMaxWidth(width):=\n  [\n    formulaMaxWidth := width;\n  ];\n  FormulaMaxWidth() := formulaMaxWidth;\n  SetFormulaMaxWidth(60);\n]; // LocalSymbols(formulaMaxWidth)\n\n\n\n\nFunction(\"PrettyForm\",{ff})\n[\n  Local(cf,f);\n\n  f:=Formula(ff);\n\n  cf:=CharField(f[3],f[4]);\n  RenderFormula(cf,f,1,1);\n\n  NewLine();\n  WriteCharField(cf,FormulaMaxWidth());\n\n  DumpErrors();\n  True;\n];\n/*\nHoldArgument(\"PrettyForm\",ff);\n*/\n\n\n\n\nEvalFormula(f):=\n[\n  Local(result);\n  result:= ListToFunction({ToAtom(\"=?\"),f,Eval(f)});\n  PrettyForm(result);\n  True;\n];\nHoldArgument(\"EvalFormula\",f);\n\n/*\n{x,y,width,height,oper,args,base}\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/outputforms/PrettyForm.mpw";
        scriptMap.put("PrettyForm",scriptString);
        scriptMap.put("EvalFormula",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nOMREP\nOMDef\nOMForm\nOMRead\nOMParse\nOMEcho\nOMEchoEscape\n*/\n\n////////////////////////\n// Written by Alberto González Palomo and Ayal Pinkus.\n////////////////////////\n\nRulebase(\"OMError\", {x,y});\nRulebase(\"OMError\", {x,y,z});\n\n/* The read-eval-print loop */\n/* It can take one parameter, that is the evaluation count. If it is greater\n   than zero, only that number of iterations will be performed before\n   exiting. This is particularly useful when connecting to MathPiper via pipes.\n*/\nRulebase(\"OMREP\",{});\nRule(\"OMREP\",0,1,True)\n[\n  OMREP(0);// 0 means keep repeating, as usual.\n];\nRulebase(\"OMREP\",{count});\nLocalSymbols(input,stringOut,result)\nRule(\"OMREP\",1,1,True)\n[\n  Local(input,stringOut,result);\n  While(Not?(IsExitRequested()))\n  [\n    Bind(errorObject, False);\n    ExceptionCatch(Bind(input, PipeFromString(ConcatStrings(ReadCmdLineString(\"\"),\" \"))OMRead()), Bind(errorObject,OMGetCoreError()));\n\n    If(Not?(errorObject =? False), errorObject); //todo:tk:check this code.\n\n    If (Not?(IsExitRequested()) And? errorObject =? False,\n    [\n      Bind(stringOut,\"\");\n      Bind(result,False);\n      ExceptionCatch(Bind(stringOut,PipeToString()[Secure(Bind(result,Eval(input)));]), Bind(errorObject,OMGetCoreError()));\n\n      If(Not?(errorObject =? False), errorObject); //todo:tk:check this code.\n\n      If(Not?(stringOut =? \"\"), WriteString(stringOut));\n      SetGlobalLazyVariable(%,result);\n      If(PrettyPrinterGet()=?\"\",\n      [\n        Apply(\"OMForm\",{result});\n      ],\n      Apply(PrettyPrinterGet(),{result}));\n      If(count >? 0 And? (count:=count-1) =? 0, Exit());\n    ]);\n  ];\n];\n\n\nLocalSymbols(omindent) [\n  // Function definitions\n  OMIndent() := [omindent := omindent + 2;];\n  OMUndent() := [omindent := omindent - 2;];\n  OMClearIndent() := [omindent := 0;];\n  OMIndentSpace() := Space(omindent);\n\n  // Initialization of indentation\n  OMClearIndent();\n]; // LocalSymbols(omindent)\n\n///////////////////////////////////////////////////////////////////////\n// Output\n\n10 # OMForm(_expression)\n     <--\n     [\n     OMClearIndent();\n     OMEcho(\"<OMOBJ>\");\n     OMIndent();\n     If(IsAtom(expression),\n        If(expression =? ToAtom(\"%\"),\n           Secure(expression := Eval(expression))\n           )\n        );\n     OMFormExpression(expression);\n     OMUndent();\n     OMEcho(\"</OMOBJ>\");\n     ];\n\n10 # OMFormExpression(i_IsString)  <-- OMEcho(\"<OMSTR>\":i:\"</OMSTR>\");\n11 # OMFormExpression(i_IsInteger) <-- OMEcho(\"<OMI>\":ToString(i):\"</OMI>\");\n12 # OMFormExpression(i_IsNumber)  <-- OMEcho(\"<OMF dec=\\\"\":ToString(i):\"\\\"/>\");\n13 # OMFormExpression(i_IsConstant)_(OMSymbol()[ ToString(i) ] !=? Empty)\n     <-- OMEcho(\"<OMS cd=\\\"\":OMSymbol()[ ToString(i) ][1]\n                :\"\\\" name=\\\"\":OMSymbol()[ ToString(i) ][2]:\"\\\"/>\"\n                );\n14 # OMFormExpression(i_IsConstant)// Should we rather evaluate it?\n     <-- OMEcho(\"<OMV name=\\\"\":ToString(i):\"\\\"/>\");\n15 # OMFormExpression(i_IsVariable)_(OMSymbol()[ ToString(i) ] !=? Empty)\n     <-- OMEcho(\"<OMS cd=\\\"\":OMSymbol()[ ToString(i) ][1]\n                :\"\\\" name=\\\"\":OMSymbol()[ ToString(i) ][2]:\"\\\"/>\"\n                );\n16 # OMFormExpression(i_IsVariable)\n     <-- OMEcho(\"<OMV name=\\\"\":ToString(i):\"\\\"/>\");\n16 # OMFormExpression(i_IsVariable)_(i =? Empty)\n     <-- False; // This is useful for void expressions.\n\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OMError\")\n     <--\n     [\n     Local(cd, name);\n     If(IsList(function[1]),\n        [ cd := function[1][1]; name := function[1][2]; ],\n        [ cd := \"error\";        name := function[1];    ]);\n     OMEcho(\"<OME>\");\n     OMIndent();\n     OMEcho(\"<OMS cd=\\\"\":cd:\"\\\" name=\\\"\":name:\"\\\"/>\");\n     ForEach(i, Rest(function)) OMFormExpression(i);\n     OMUndent();\n     OMEcho(\"</OME>\");\n     ];\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OME\")\n     <--\n     [\n     OMEcho(\"<OME>\");\n     OMIndent();\n     ForEach(i, function) OMFormExpression(i);\n     OMUndent();\n     OMEcho(\"</OME>\");\n     ];\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OMS\")\n     <-- OMEcho(\"<OMS cd=\\\"\":function[1]:\"\\\" name=\\\"\":function[2]:\"\\\"/>\");\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OMBIND\")\n     <--\n     [\n     OMEcho(\"<OMBIND>\");\n     OMIndent();\n     ForEach(i, function) OMFormExpression(i);\n     OMUndent();\n     OMEcho(\"</OMBIND>\");\n     ];\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OMBVAR\")\n     <--\n     [\n     OMEcho(\"<OMBVAR>\");\n     OMIndent();\n     ForEach(i, function) OMFormExpression(i);\n     OMUndent();\n     OMEcho(\"</OMBVAR>\");\n     ];\n10 # OMFormExpression(function_IsFunction)_(Type(function) =? \"OMA\")\n     <--\n     [\n     // This is not the same as the next rule: this is OMA(a,b,c,...),\n     // which is used for building OMA constructs in the mapping to OM.\n     OMEcho(\"<OMA>\");\n     OMIndent();\n     ForEach(i, function) OMFormExpression(i);\n     OMUndent();\n     OMEcho(\"</OMA>\");\n     ];\n11 # OMFormExpression(function_IsFunction)\n     <--\n     [\n     OMEcho(\"<OMA>\");\n     OMIndent();\n     OMFormFunction(function);\n     OMUndent();\n     OMEcho(\"</OMA>\");\n     ];\n\n11 # OMFormFunction(function_IsFunction)\n     <--\n     [\n     Local(arity);\n     arity := Length(function);\n     OMEcho(\"<OMS cd=\\\"piper\\\" name=\\\"\":Type(function):\"\\\"/>\");\n     If(arity >? 0, ForEach(arg, function) OMFormExpression(arg));\n     ];\n10 # OMFormFunction(function_IsFunction)_(OMSymbol()[ Type(function) ] !=? Empty)\n     <--\n     [\n     Local(symbolDef);\n     // [20051016 AGP] The \"signature\" feature is an old attempt at pattern\n     // matching, but now that we have real predicates in the mappings it's\n     // probably obsolete. I'll think about removing it.\n     symbolDef := OMSymbol()[ OMSignature(function) ];\n     If(symbolDef =? Empty, symbolDef := OMSymbol()[ Type(function) ] );\n     If(symbolDef =? Empty Or? Length(symbolDef) <? 3 Or? symbolDef[3] =? {},\n        [\n        OMEcho(\"<OMS cd=\\\"\":symbolDef[1]:\"\\\" name=\\\"\":symbolDef[2]:\"\\\"/>\");\n        ForEach(arg, function) OMFormExpression(arg);\n        ],\n        [\n        Local(result);\n        result := OMApplyMapping(function, symbolDef[3]);\n        //Check(IsList(result), \"Return Type\", PipeToString()Echo(\"Mapping result is not a list: \", result));\n        If(IsList(result),\n           [\n           result := ListToFunction(Subst($, function[0]) result);\n           OMFormExpression(result[0]);\n           ForEach(i, result) OMFormExpression(i);\n           ],\n           If(result =? Empty,\n              Echo(\"No rule matched \", function, symbolDef[3]),\n              Echo(\"Unexpected result value from OMApplyMapping(): \", result)\n             )\n          );\n        ]\n       );\n     ];\n\n\nOMWrite(_expression) <--\n[\n  Write(expression);\n];\n\nOMEcho(_expression) <--\n[\n  OMIndentSpace();\n  Write(expression);\n  NewLine();\n];\nOMEcho(expression_IsString) <--\n[\n  OMIndentSpace();\n  WriteString(expression);\n  NewLine();\n];\nOMEcho(expression_IsList) <--\n[\n  ForEach(arg, expression)\n  [\n    If (IsString(arg), WriteString(arg), Write(arg));\n  ];\n  NewLine();\n];\n\nOMEscape(_expression) <--\n[\n  \"<![CDATA[\":ToString(expression):\"]]>\";\n];\nOMEscapeString(_expression_IsString) <--\n[\n  \"<![CDATA[\":expression:\"]]>\";\n];\nOMWriteEscape(_expression) <--\n[\n  WriteString(OMEscape(expression));\n];\nOMWriteStringEscape(expression_IsString) <--\n[\n  WriteString(OMEscapeString(expression));\n];\nOMEchoEscape(_expression) <--\n[\n  OMWriteEscape(expression);\n  NewLine();\n];\nOMEchoEscape(expression_IsString) <--\n[\n  OMWriteStringEscape(expression);\n  NewLine();\n];\nOMEchoEscape(expression_IsList) <--\n[\n  WriteString(\"<![CDATA[\");\n  ForEach(arg, expression)\n  [\n    If (IsString(arg), WriteString(arg), Write(arg));\n  ];\n  WriteString(\"]]>\");\n  NewLine();\n];\n\n\nHoldArgumentNumber(\"OMForm\",1,1);\n//HoldArgumentNumber(\"OMFormExpression\",1,1);\n//HoldArgumentNumber(\"OMFormFunction\",1,1);\n\n\nOMSignature(_function) <-- \"\";\nOMSignature(function_IsFunction) <--\n[\n  Local(makeSig);\n  makeSig := {ConcatStrings, Type(function), \"_\"};\n  Local(type);\n  type := \"\";// If \"function\" doesn't have parameters, the signature is \"f_\".\n  ForEach(arg, function)\n  [\n    If(Type(arg) =? \"List\",\n       type := \"L\",\n       If(IsFunction(arg),\n          type := \"F\",\n          If(IsInteger(arg),\n             type := \"I\",\n             type := \"V\"\n             )\n          )\n       );\n    DestructiveAppend(makeSig, type);\n  ];\n  Secure(Eval(ListToFunction(makeSig)));\n];\nHoldArgumentNumber(\"OMSignature\", 1, 1);\n\n\n\n///////////////////////////////////////////////////////////////////////\n// Input\n\n// Troubleshooting guide:\n// \"encodingError:unexpected closing brace\": this happens in the ReadOMOBJ\n//      rules. It means that you forgot to call OMNextToken() from your rule.\n\nLocalSymbols(omtoken) [\n  OMNextToken() :=\n  [\n    omtoken := XmlExplodeTag(ToString(ReadToken()));\n  ];\n  OMToken() := omtoken;\n]; // LocalSymbols(omtoken)\n\nOMRead():=\n[\n  Local(result);\n  ExceptionCatch(\n  [\n    XmlTokenizer();\n    OMNextToken();\n    result := MatchOMOBJ(OMToken());\n    DefaultTokenizer();\n  ],\n  [\n    result := OMGetCoreError();\n    DefaultTokenizer();\n  ]);\n  result;\n];\n\n\nOMDump(str):=\nPipeFromString(str:\" EndOfFile\")\n[\n  Local(result);\n  XmlTokenizer();\n  OMNextToken();\n  While(OMToken() !=? \"EndOfFile\")\n  [\n    Echo(\"Exploded \",OMToken());\n    OMNextToken();\n  ];\n  DefaultTokenizer();\n  True;\n];\n\n\n\n10 # MatchClose(_x)_(x =? OMToken()) <-- [OMNextToken();True;];\n20 # MatchClose(_x) <-- Check(False, \"Syntax\", PipeToString()Echo(\"encodingError:unexpected closing brace\")); //@@@ TODO better error reporting\n\n10 # MatchOMOBJ(XmlTag(\"OMOBJ\",_attributes,\"Open\")) <--\n[\n  // Any attributes are ignored.\n  Local(result);\n  OMNextToken();\n  result := ReadOMOBJ(OMToken());\n  MatchClose(XmlTag(\"OMOBJ\",{},\"Close\"));\n  result;\n];\n10 # MatchOMOBJ(XmlTag(\"OMOBJ\",_attributes,\"OpenClose\")) <--\n[\n  OMNextToken();\n  // Any attributes are ignored.\n  // This is a void expression, of the form \"<OMOBJ/>\".\n  Empty;\n];\n20 # MatchOMOBJ(_rest) <-- Check(False, \"Type\", PipeToString()Echo(\"encodingError:not an OMOBJ :\",rest));\n\n10 # ReadOMOBJ(XmlTag(\"OMOBJ\",_attributes,\"Close\")) <--\n[\n  // This is a void expression, of the form \"<OMOBJ></OMOBJ>\".\n  Empty;\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMI\",{},\"Open\")) <--\n[\n  Local(result);\n  OMNextToken();\n  result := ToAtom(OMToken());\n  OMNextToken();\n  MatchClose(XmlTag(\"OMI\",{},\"Close\"));\n  result;\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMV\",{{\"NAME\",_name}},\"OpenClose\")) <--\n[\n  OMNextToken();\n  ToAtom(name);\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMF\",{{\"DEC\",_dec}},\"OpenClose\")) <--\n[\n  OMNextToken();\n  ToAtom(dec);\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMSTR\",{},\"Open\")) <--\n[\n  Local(result);\n  OMNextToken();\n  If(IsString(OMToken()), [result := OMToken(); OMNextToken();], result := \"\");\n  MatchClose(XmlTag(\"OMSTR\",{},\"Close\"));\n  result;\n];\n10 # ReadOMOBJ(XmlTag(\"OMSTR\",{},\"OpenClose\")) <--\n[\n  OMNextToken();\n  \"\";\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMA\",{},\"Open\")) <--\n[\n  Local(result, new);\n  result:={};\n  OMNextToken();\n  While (OMToken() !=? XmlTag(\"OMA\",{},\"Close\"))\n  [\n    new:=ReadOMOBJ(OMToken());\n    DestructiveAppend(result,new);\n  ];\n  MatchClose(XmlTag(\"OMA\",{},\"Close\"));\n  OMApplyReverseMapping(ListToFunction(result));\n];\n\n10 # ReadOMOBJ(XmlTag(\"OMBIND\",{},\"Open\")) <--\n[\n  Local(result, new);\n  result:={};\n  OMNextToken();\n  While (OMToken() !=? XmlTag(\"OMBIND\",{},\"Close\"))\n  [\n    new:=ReadOMOBJ(OMToken());\n    DestructiveAppend(result,new);\n  ];\n  MatchClose(XmlTag(\"OMBIND\",{},\"Close\"));\n  result;\n];\n10 # ReadOMOBJ(XmlTag(\"OMBVAR\",{},\"Open\")) <--\n[\n  Local(result, new);\n  result:={};\n  OMNextToken();\n  While (OMToken() !=? XmlTag(\"OMBVAR\",{},\"Close\"))\n  [\n    new:=ReadOMOBJ(OMToken());\n    DestructiveAppend(result,new);\n  ];\n  MatchClose(XmlTag(\"OMBVAR\",{},\"Close\"));\n  result;\n];\n\n10 # OMApplyReverseMapping(piperExp_IsFunction) <-- piperExp;\n10 # OMApplyReverseMapping(piperExp_IsFunction)_(OMSymbol()[ Type(piperExp) ] !=? Empty)\n     <--\n     [\n     Local(symbolDef, result);\n     symbolDef := OMSymbol()[ Type(piperExp) ];\n     If(symbolDef[4] =? {},\n        result := piperExp,\n        [\n          result := OMApplyMapping(piperExp, symbolDef[4]);\n          result := Subst($, piperExp[0]) result;\n          If(IsList(result), result := ListToFunction(result));\n        ]\n       );\n     result;\n     ];\n\n10 # OMApplyMapping(_function, _mapping) <--\n[\n  Local(expandRules, result);\n  expandRules := { _(_path) <- OMPathSelect(path, function) };\n  expandRules[1][2][2] := function;// the \"function\" variable is not expanded above.\n\n  mapping := (mapping /: expandRules);// \"/:\" has lower precedence than \":=\".\n\n  Local(ruleMatched);\n  ruleMatched := False;\n  If(Type(mapping) =? \"|\",\n     [\n     mapping := Flatten(mapping, \"|\");\n     ForEach(rule, mapping)\n       If(Not? ruleMatched,\n          [\n          If(Type(rule) =? \"_\",\n             If( Eval(rule[2]), [ result := rule[1]; ruleMatched := True; ] ),\n             [ result := rule; ruleMatched := True; ]\n            );\n          ]\n         );\n     ],\n     [\n     If(Type(mapping) =? \"_\",\n        If(Eval(mapping[2]),\n           result := mapping[1],\n           result := FunctionToList(function)\n          ),\n        result := mapping\n       );\n     ruleMatched := True;\n     ]\n    );\n\n  If(ruleMatched,\n     If(Type(result) =? \":\",\n        If(Length(result) =? 2,\n           result[1]:result[2],\n           result),// Perhaps we should give a warning here.\n        result),\n     Empty);\n];\n\n11 # OMPathSelect(path_IsNumber, _expression) <--\n[\n  If(path >=? 0 And? path <=? Length(expression),\n     expression[path],\n     Undefined);\n];\n11 # OMPathSelect(path_IsList, _expression) <--\n[\n  ForEach(i, path)\n    If(IsFunction(expression) And? i >=? 0 And? i <=? Length(expression),\n       expression := expression[i],\n       Undefined);\n  expression;\n];\nHoldArgumentNumber(\"OMPathSelect\", 2, 2);\n\n// Previously, any unknown symbols where reported as errors.\n// Now, we just store them as OMS(cd, name) since MathPiper is perfectly happy\n// with such unknown symbols, and will handle them right: When\n// producing an OpenMath result from them, they will be output back\n// unmodified, forming a valid OpenMath expression.\n// This way we don't have to bother defining bogus symbols for concepts that\n// MathPiper does not handle.\n100 # ReadOMOBJ(XmlTag(\"OMS\", _attributes, \"OpenClose\")) <--\n[\n  OMNextToken();\n  Local(omcd, omname);\n  omcd   := attributes[\"CD\"];\n  omname := attributes[\"NAME\"];\n  If(omcd =? Empty Or? omname =? Empty,\n     OMCheck(False, \"Argument\", OMError({\"moreerrors\", \"encodingError\"}, PipeToString()Echo(\"missing \\\"cd\\\" or \\\"name\\\" attribute: \",attributes))),\n     [\n     Local(cdTable, piperform);\n     cdTable := OMSymbolReverse()[ omcd ];\n     If(cdTable !=? Empty, piperform := cdTable[ omname ]);\n     // We can not optimize here by checking first whether the CD is mathpiper\n     // and avoiding the table lookup then, because for some symbols the\n     // OM name have to be different from the MathPiper name (e.g. \"/@\").\n     If(piperform =? Empty,\n        If(cd =? mathpiper, ToAtom(omname), OMS(omcd, omname)),\n        If(IsString(piperform), ToAtom(piperform), piperform));\n     ]\n    );\n];\n\n101 # ReadOMOBJ(_rest) <-- OMCheck(False, \"Unimplemented\", OMError({\"moreerrors\", \"encodingError\"}, PipeToString()Echo(\"unhandled tag: \",rest)));\n\n\n\n///////////////////////////////////////////////////////////////////////\n// Error reporting\n\nMacro(OMCheck,{predicate,error})\n[\n  If(Not?(@predicate),\n  [\n    Assert(\"omErrorObject\", @error) False;\n    Check(False, \"Undefined\", \"omErrorObject\");\n  ]\n  ,\n  True);\n];\n\n\n\nOMGetCoreError():=\n[\n  Local(result);\n  result := ExceptionGet(); //todo:tk:verify that ExceptionCheck works properly with the soft error handling functions.\n  If(result !=? False,\n     If( IsError(\"omErrorObject\"),\n        [result := GetError(\"omErrorObject\");                     ],\n        [result := OMError({\"moreerrors\", \"unexpected\"}, result); ])\n    );\n  result;\n];\n\n\n\n///////////////////////////////////////////////////////////////////////\n// Symbol mapping tables\n\nLocalSymbols(omsymbol, omsymbolreverse) [\n  // Initialization of the openmath symbol dictionaries\n  omsymbol := {};\n  omsymbolreverse := {};\n\n  // Access to the dictionaries\n  OMSymbol() := omsymbol;\n  OMSymbolReverse() := omsymbolreverse;\n\n]; // LocalSymbols(omsymbol, omsymbolreverse)OMDef\n\nOMDef(_piperform, omcd_IsString, omname_IsString, _directMapping, _reverseMapping) <--\n[\n  Local(cdTable);\n  If(IsString(piperform),\n     OMSymbol()[ piperform ] := {omcd, omname, directMapping, reverseMapping}\n     );\n  cdTable := OMSymbolReverse()[ omcd ];\n  If(cdTable =? Empty,\n     OMSymbolReverse()[ omcd ] := {{omname, piperform}},\n     [\n       Local(oldMathPiperform);\n       oldMathPiperform := cdTable[ omname ];\n       If(oldMathPiperform =? Empty,\n          cdTable[ omname ] := piperform,\n          [\n          If(oldMathPiperform !=? piperform,\n             [\n             cdTable[ omname ] := piperform;\n             Echo(\"Warning: the mapping for \", omcd, \":\", omname,\n                  \" was already defined as \", oldMathPiperform,\n                  \", but is redefined now as \", piperform\n                  );\n             ]\n            );\n          ]\n         );\n      ]\n     );\n  True;\n];\n\nOMDef(_piperform, omcd_IsString, omname_IsString)\n<-- OMDef(piperform, omcd, omname, {}, {});\n\nOMDef(piperalias_IsString, pipername_IsString) <--\n[\n  OMSymbol()[ piperalias ] := OMSymbol()[ pipername ];\n];\nHoldArgumentNumber(\"OMDef\", 5, 4);\nHoldArgumentNumber(\"OMDef\", 5, 5);\n\n// Many objects, such as matrices and sets, do not have a specific\n// encoding in MathPiper, but are represented as lists.\nOMDef( {},     \"set1\",\"emptyset\" );\nOMDef( \"List\", \"set1\",\"set\"      );\nOMDef( \"List\", \"linalg2\",\"matrix\"    );\nOMDef( \"List\", \"linalg2\",\"matrixrow\" );\nOMDef( \"List\", \"linalg2\",\"vector\"    );\nOMDef( \"List\", \"list1\",\"list\" );\n\n// [20010916 AGP] I couldn't find these symbols in the def files:\n//     \"E\"        ,  \"nums1\", \"e\"\n//     \"Gamma\"    ,  \"nums1\", \"gamma\"\nOMDef( \"Infinity\" ,  \"nums1\", \"infinity\" );\nOMDef( \"Undefined\",  \"nums1\", \"NaN\"      );\n// [20010916 AGP] From initialization.rep/stdopers.mpi:\nOMDef( \"And?\"   ,  \"logic1\", \"and\"        );\nOMDef( \"==\"    ,  \"logic1\", \"equivalent\" );\n/*Note:tk:when I had fixed the syntax error in this code, a redefinition error was created.\nOMDef( \"!=?=\"   ,  \"logic1\", \"not\",\n        { \"<OMA><OMS cd=\\\"logic1\\\" name=\\\"equivalent\\\"/>\",\n          1,\n          2,\n          \"</OMA>\"\n        },\n        {}\n      );\n*/\nOMDef( \"False\",  \"logic1\", \"false\" );\nOMDef( \"Or?\"   ,  \"logic1\", \"or\"    );\nOMDef( \"True\" ,  \"logic1\", \"true\"  );\n//[20010916 AGP ] Xor is not available in MathPiper.\n//     \"Xor\"  ,  \"logic1\", \"xor\"   );\nOMDef( \"&\" ,  mathpiper, \"bitwise_and\" );\nOMDef( \"|\" ,  mathpiper, \"bitwise_or\"  );\nOMDef( \"%\" ,  mathpiper, \"bitwise_xor\" );\nOMDef( \"/\" , \"arith1\", \"divide\");// This definition is for OM arith1:divide to MathPiper. In all other cases, the next one will be used.\nOMDef( \"/\" , \"nums1\", \"rational\", {$, _1, _2}_(IsRational(_1/_2)) | {OMS(\"arith1\", \"divide\"), _1, _2}, {/, _1, _2});\nOMDef( \"-\" ,  \"arith1\", \"unary_minus\");\nOMDef( \"-\" ,  \"arith1\", \"minus\"  );// We need a way of testing the arity.\nOMDef( \"+\" ,  \"arith1\", \"plus\"   );\nOMDef( \"^\" ,  \"arith1\", \"power\"  );\nOMDef( \"*\" ,  \"arith1\", \"times\"  );\n\n\n//LoadScriptOnce(\"constants.rep/om.mpi\");\nOMDef( \"I\", \"nums1\", \"i\" );\nOMDef( \"CachedConstant\",        mathpiper, \"CachedConstant\"        );\nOMDef( \"AssignCachedConstants\", mathpiper, \"AssignCachedConstants\" );\nOMDef( \"ClearCachedConstants\",  mathpiper, \"ClearCachedConstants\"  );\nOMDef( \"Pi\", \"nums1\", \"pi\" );\n\n\n//LoadScriptOnce(\"stdfuncs.rep/om.mpi\");\n/// coded by Serge Winitzki. See essays documentation for algorithms.\nOMDef( \"ArcSin\" , \"transc1\",\"arcsin\"  );\nOMDef( \"ArcCos\" , \"transc1\",\"arccos\"  );\nOMDef( \"ArcTan\" , \"transc1\",\"arctan\"  );\nOMDef( \"ArcSec\" , \"transc1\",\"arcsec\"  );\nOMDef( \"ArcCsc\" , \"transc1\",\"arccsc\"  );\nOMDef( \"ArcCot\" , \"transc1\",\"arccot\"  );\nOMDef( \"ArcSinh\", \"transc1\",\"arcsinh\" );\nOMDef( \"ArcCosh\", \"transc1\",\"arccosh\" );\nOMDef( \"ArcTanh\", \"transc1\",\"arctanh\" );\nOMDef( \"ArcSech\", \"transc1\",\"arcsech\" );\nOMDef( \"ArcCsch\", \"transc1\",\"arccsch\" );\nOMDef( \"ArcCoth\", \"transc1\",\"arccoth\" );\nOMDef( \"Sin\"    , \"transc1\",\"sin\"     );\nOMDef( \"Cos\"    , \"transc1\",\"cos\"     );\nOMDef( \"Tan\"    , \"transc1\",\"tan\"     );\nOMDef( \"Sec\"    , \"transc1\",\"sec\"     );\nOMDef( \"Csc\"    , \"transc1\",\"csc\"     );\nOMDef( \"Cot\"    , \"transc1\",\"cot\"     );\nOMDef( \"Sinh\"   , \"transc1\",\"sinh\"    );\nOMDef( \"Cosh\"   , \"transc1\",\"cosh\"    );\nOMDef( \"Tanh\"   , \"transc1\",\"tanh\"    );\nOMDef( \"Sech\"   , \"transc1\",\"sech\"    );\nOMDef( \"Csch\"   , \"transc1\",\"csch\"    );\nOMDef( \"Coth\"   , \"transc1\",\"coth\"    );\nOMDef( \"Exp\"    , \"transc1\",\"exp\"     );\nOMDef( \"Ln\"     , \"transc1\",\"ln\"      );\n// Related OM symbols not yet defined in MathPiper:\n//     \"log\"    , \"transc1\",\"log\"\n\n\n//LoadScriptOnce(\"stubs.rep/om.mpi\");\nOMDef( \"Not?\", \"logic1\",\"not\" );\nOMDef( \"=?\" , \"relation1\",\"eq\"  );\nOMDef( \">=?\", \"relation1\",\"geq\" );\nOMDef( \">\" , \"relation1\",\"gt\"  );\nOMDef( \"<=?\", \"relation1\",\"leq\" );\nOMDef( \"<?\" , \"relation1\",\"lt\"  );\nOMDef( \"!=?\", \"relation1\",\"neq\" );\nOMDef( \"Gcd\", \"arith1\",\"gcd\" );\nOMDef( \"Sqrt\", \"arith1\",\"root\", { $, _1, 2 }, $(_1)_(_2=?2) | (_1^(1/_2)) );\n// Test [result: Sqrt(16)]:\n// PipeFromString(\"<OMOBJ><OMA><OMS cd=\\\"arith1\\\" name=\\\"root\\\"/><OMI>16</OMI><OMI>2</OMI></OMA></OMOBJ> \")OMRead()\n// Test [result: IntNthRoot(16,3))]:\n// PipeFromString(\"<OMOBJ><OMA><OMS cd=\\\"arith1\\\" name=\\\"root\\\"/><OMI>16</OMI><OMI>3</OMI></OMA></OMOBJ> \")OMRead()\nOMDef( \"Abs\", \"arith1\",\"abs\" );\nOMDef( \"Lcm\", \"arith1\",\"lcm\" );\nOMDef( \"Floor\", \"rounding1\",\"floor\"   );\nOMDef( \"Ceil\" , \"rounding1\",\"ceiling\" );\nOMDef( \"Round\", \"rounding1\",\"round\"   );\nOMDef( \"Quotient\"   , mathpiper,\"div\"    );\nOMDef( \"Modulo\"   , mathpiper,\"mod\"    );\nOMDef( \"Expand\", mathpiper,\"expand\" );\nOMDef( \"Object\", mathpiper,\"object\" );\nOMDef( \"Sign\"  , mathpiper,\"sign\"   );\n\n\n//LoadScriptOnce(\"logic.rep/om.mpi\");\nOMDef( \"=>\" , \"logic1\",\"implies\" );\nOMDef( \"CNF\"          ,          mathpiper,\"cnf\"                      );\nOMDef( \"LogicSimplify\",          mathpiper,\"logic_simplify\"           );\nOMDef( \"CanProve\"     ,          mathpiper,\"can_prove\"                );\nOMDef( \"LogicRemoveTautologies\", mathpiper,\"logic_remove_tautologies\" );\nOMDef( \"Subsumes\"     ,          mathpiper,\"subsumes\"                 );\n// The following appear in the def file, but commented out:\n//     \"~\",  mathpiper, \"Not?\"\n//     \"|\",  mathpiper, \"Or?\"\n//     \"&\",  mathpiper, \"And?\"\n\n//LoadScriptOnce(\"complex.rep/om.mpi\");\nOMDef( \"Complex\"  , \"complex1\",\"complex_cartesian\" );\nOMDef( \"Re\"       , \"complex1\",\"real\"              );\nOMDef( \"Im\"       , \"complex1\",\"imaginary\"         );\nOMDef( \"Conjugate\", \"complex1\",\"conjugate\"         );\nOMDef( \"Arg\"      , \"complex1\",\"argument\"          );\nOMDef( \"IsComplex\", mathpiper,\"is_complex\"         );\n\n\n//LoadScriptOnce(\"integrate.rep/om.mpi\");\nOMDef( \"Integrate\", \"calculus1\",\"defint\", // Same argument reordering as Sum.\n       { $, _2 .. _3, OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) },\n       { $, _{2,2,1}, _{1,1}, _{1,2}, _{2,3} }\n      );\nOMDef( \"AntiDeriv\", mathpiper,\"AntiDeriv\" );\n\n\n//LoadScriptOnce(\"sums.rep/om.mpi\");\n// [2005-12-28 matmota]: I have to implement some better solution for the\n// MathPiper -> OM mapping for these symbols.\nOMDef( \"Minimum\", \"minmax1\",\"min\",\n       { \"<OMA>\", \"<OMS cd=\\\"set1\\\" name=\\\"set\\\"/>\",\n         1,2,3,4,5,6,7,8,9,10,11,12,13,14,\n         \"</OMS>\", \"</OMA>\" },\n       ($):_1 );\nOMDef( \"Maximum\", \"minmax1\",\"max\",\n       { \"<OMA>\", \"<OMS cd=\\\"set1\\\" name=\\\"set\\\"/>\",\n         1,2,3,4,5,6,7,8,9,10,11,12,13,14,\n         \"</OMS>\", \"</OMA>\" },\n       ($):_1 );\nOMDef( \"!\", \"integer1\",\"factorial\" );\nOMDef( \"BinomialCoefficient\", \"combinat1\",\"binomial\" );\nOMDef( \"!!\",  mathpiper,\"double_factorial\" );\nOMDef( \"***\", mathpiper,\"partial_factorial\" );\nOMDef( \"Add\", mathpiper,\"Add\" );\nOMDef( \"Sum\", \"arith1\",\"sum\", // Same argument reordering as Integrate.\n       { $, _2 .. _3, OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) },\n       { $, _{2,2,1}, _{1,1}, _{1,2}, _{2,3} }\n      );\nOMDef( \"Product\", mathpiper,\"Product\" );\nOMDef( \"Taylor\",    mathpiper,\"Taylor\" );\nOMDef( \"Subfactorial\", mathpiper,\"Subfactorial\" );\n\n\n//LoadScriptOnce(\"limit.rep/om.mpi\");\nOMDef(\"Limit\", \"limit1\",\"limit\",\n      {  _0, _2, OMS(\"limit1\", \"under\"), OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) }_(_3=?Left)\n      |{ _0, _2, OMS(\"limit1\", \"above\"), OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) }_(_3=?Right)\n      |{ _0, _2, OMS(\"limit1\", \"both_sides\"), OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _3) },\n      { _0, _{3,2,1}, _1, Left,  _{3,3}}_(_2=?OMS(\"limit1\", \"below\"))\n      |{_0, _{3,2,1}, _1, Right, _{3,3}}_(_2=?OMS(\"limit1\", \"above\"))\n      |{_0, _{3,2,1}, _1, _{3,3}}\n     );\n// Test [result Limit(x,0,Right)1/x]: PipeFromString(PipeToString()OMForm(Limit(x,0,Right) 1/x))OMRead()\n\n// As explained in the manual, \"limit1:both_sides\" and \"fns1:lambda\" will\n// be handled as OMS(\"limit1\", \"both_sides\") and OMS(\"fns1\", \"lambda\"), so\n// we don't need to define bogus mappings for them:\n// OMDef(\"OMSymbolLimit1BothSides\", \"limit1\", \"both_sides\");\n// OMDef(\"OMSymbolLambda\", \"fns1\", \"lambda\");\n// The same applies to \"Left\" and \"Right\", which are undefined symbols\n// that are used only inside limit expressions, so they don't need a mapping\n// of their own.\n// We could define them as follows:\n//OMDef(\"Left\",  \"limit1\",\"below\");\n//OMDef(\"Right\", \"limit1\",\"above\");\n// and then use the following rules instead:\n//      {  _0, _2, Left,  OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) }_(_3=Left)\n//      |{ _0, _2, Right, OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _4) }_(_3=Right)\n//      |{ _0, _2, OMS(\"limit1\", \"both_sides\"), OMBIND(OMS(\"fns1\", \"lambda\"), OMBVAR(_1), _3) },\n//      { _0, _{3,2,1}, _1, _2, _{3,3}}_(_2=Left Or? _2=Right)\n//      |{_0, _{3,2,1}, _1, _{3,3}}\n// The result is exactly the same. The only difference is when producing the\n// OMForm of the symbols themselves, outside the limit expression.\n\n\n//LoadScriptOnce(\"numbers.rep/om.mpi\");// Sqrt is loaded before (stubs.rep) than IntNthRoot.\nOMDef( \"BellNumber\",      mathpiper,\"BellNumber\" );\nOMDef( \"CatalanNumber\",   mathpiper,\"CatalanNumber\" );\nOMDef( \"DigitalRoot\",     mathpiper,\"DigitalRoot\" );\nOMDef( \"Divisors\",        mathpiper,\"Divisors\" );\nOMDef( \"DivisorsSum\",     mathpiper,\"DivisorsSum\" );\nOMDef( \"Euler\",           mathpiper,\"Euler\" );\nOMDef( \"EulerArray\",      mathpiper,\"EulerArray\" );\nOMDef( \"Eulerian\",        mathpiper,\"Eulerian\" );\nOMDef( \"FermatNumber\",    mathpiper,\"FermatNumber\" );\nOMDef( \"GetPrimePower\",   mathpiper,\"GetPrimePower\" );\nOMDef( \"HarmonicNumber\",  mathpiper,\"HarmonicNumber\" );\nOMDef( \"IntLog\",          mathpiper,\"IntLog\" );\nOMDef( \"IntNthRoot\",      mathpiper,\"IntNthRoot\" );\nOMDef( \"IsAmicablePair\",  mathpiper,\"IsAmicablePair\" );\nOMDef( \"IsCarmichaelNumber\", mathpiper,\"IsCarmichaelNumber\" );\nOMDef( \"IsComposite\",     mathpiper,\"IsComposite\" );\nOMDef( \"IsCoprime\",       mathpiper,\"IsCoprime\" );\nOMDef( \"IsIrregularPrime\", mathpiper,\"IsIrregularPrime\" );\nOMDef( \"IsPerfect\",       mathpiper,\"IsPerfect\" );\nOMDef( \"IsPrime\",         mathpiper,\"IsPrime\" );\nOMDef( \"IsPrimePower\",    mathpiper,\"IsPrimePower\" );\nOMDef( \"IsQuadraticResidue\", mathpiper,\"IsQuadraticResidue\" );\nOMDef( \"IsSmallPrime\",    mathpiper,\"IsSmallPrime\" );\nOMDef( \"IsSquareFree\",    mathpiper,\"IsSquareFree\" );\nOMDef( \"IsTwinPrime\",     mathpiper,\"IsTwinPrime\" );\nOMDef( \"LegendreSymbol\",  mathpiper,\"LegendreSymbol\" );\nOMDef( \"Moebius\",         mathpiper,\"Moebius\" );\nOMDef( \"NextPrime\",       mathpiper,\"NextPrime\" );\nOMDef( \"NextPseudoPrime\", mathpiper,\"NextPseudoPrime\" );\nOMDef( \"PartitionsP\",     mathpiper,\"PartitionsP\" );\nOMDef( \"ProductPrimesTo257\", mathpiper,\"ProductPrimesTo257\" );\nOMDef( \"ProperDivisors\",  mathpiper,\"ProperDivisors\" );\nOMDef( \"ProperDivisorsSum\", mathpiper,\"ProperDivisorsSum\" );\nOMDef( \"Repunit\",         mathpiper,\"Repunit\" );\nOMDef( \"StirlingNumber1\", mathpiper,\"StirlingNumber1\" );\nOMDef( \"StirlingNumber2\", mathpiper,\"StirlingNumber2\" );\nOMDef( \"Totient\",         mathpiper,\"Totient\" );\n\n// From GaussianIntegers.mpi.def\nOMDef( \"IsGaussianUnit\",    mathpiper,\"IsGaussianUnit\" );\nOMDef( \"IsGaussianInteger\", mathpiper,\"IsGaussianInteger\" );\nOMDef( \"IsGaussianPrime\",   mathpiper,\"IsGaussianPrime\" );\nOMDef( \"GaussianFactorPrime\", mathpiper,\"GaussianFactorPrime\" );\nOMDef( \"GaussianNorm\",      mathpiper,\"GaussianNorm\" );\nOMDef( \"GaussianMod\",       mathpiper,\"GaussianMod\" );\nOMDef( \"GaussianFactors\",   mathpiper,\"GaussianFactors\" );\nOMDef( \"AddGaussianFactor\", mathpiper,\"AddGaussianFactor\" );\nOMDef( \"FactorGaussianInteger\", mathpiper,\"FactorGaussianInteger\" );\nOMDef( \"GaussianGcd\",       mathpiper,\"GaussianGcd\" );\n\n// From nthroot.mpi.def\nOMDef( \"NthRoot\",      mathpiper,\"NthRoot\" );\nOMDef( \"NthRoot'Calc\", mathpiper,\"NthRoot'Calc\" );\nOMDef( \"NthRoot'List\", mathpiper,\"NthRoot'List\" );\nOMDef( \"NthRoot'Save\", mathpiper,\"NthRoot'Save\" );\nOMDef( \"NthRoot'Restore\", mathpiper,\"NthRoot'Restore\" );\nOMDef( \"NthRoot'Clear\", mathpiper,\"NthRoot'Clear\" );\n\n// From NumberTheory.mpi.def\nOMDef( \"DivisorsList\", mathpiper,\"DivisorsList\" );\nOMDef( \"SquareFreeDivisorsList\", mathpiper,\"SquareFreeDivisorsList\" );\nOMDef( \"MoebiusDivisorsList\",    mathpiper,\"MoebiusDivisorsList\" );\nOMDef( \"SumForDivisors\", mathpiper,\"SumForDivisors\" );\nOMDef( \"RamanujanSum\",   mathpiper,\"RamanujanSum\" );\nOMDef( \"JacobiSymbol\",   mathpiper,\"JacobiSymbol\" );\n\n\n//LoadScriptOnce(\"functional.rep/om.mpi\");\nOMDef( \":\"        , \"mathpiper\",\"prepend\"    );\nOMDef( \"@\"        , \"mathpiper\",\"apply\"      );\nOMDef( \"/@\"       , \"mathpiper\",\"list_apply\" );\nOMDef( \"..\"       , \"interval1\",\"integer_interval\" );\nOMDef( \"NFunction\", \"mathpiper\",\"NFunction\" );\n\n\n//LoadScriptOnce(\"specfunc.rep/om.mpi\");\nOMDef( \"Gamma\", \"nums1\", \"gamma\" );\nOMDef( \"LnGamma\"        , mathpiper, \"LnGamma\" );\nOMDef( \"Zeta\"           , mathpiper, \"Zeta\" );\nOMDef( \"Bernoulli\"      , mathpiper, \"Bernoulli\" );\nOMDef( \"ApproxInfSum\"   , mathpiper, \"ApproxInfSum\" );\nOMDef( \"BesselJ\"        , mathpiper, \"BesselJ\" );\nOMDef( \"BesselI\"        , mathpiper, \"BesselI\" );\nOMDef( \"BesselY\"        , mathpiper, \"BesselY\" );\nOMDef( \"Erf\"            , mathpiper, \"Erf\" );\nOMDef( \"Erfc\"           , mathpiper, \"Erfc\" );\nOMDef( \"Erfi\"           , mathpiper, \"Erfi\" );\nOMDef( \"FresnelSin\"     , mathpiper, \"FresnelSin\" );\nOMDef( \"FresnelCos\"     , mathpiper, \"FresnelCos\" );\nOMDef( \"LambertW\"       , mathpiper, \"LambertW\" );\nOMDef( \"Beta\"           , mathpiper, \"Beta\" );\nOMDef( \"DirichletEta\"   , mathpiper, \"DirichletEta\" );\nOMDef( \"DirichletLambda\", mathpiper, \"DirichletLambda\" );\nOMDef( \"DirichletBeta\"  , mathpiper, \"DirichletBeta\" );\nOMDef( \"Sinc\"           , mathpiper, \"Sinc\" );\nOMDef( \"PolyLog\"        , mathpiper, \"PolyLog\" );\nOMDef( \"CatalanConstNum\", mathpiper, \"CatalanConstNum\" );\nOMDef( \"Digamma\"        , mathpiper, \"Digamma\" );\nOMDef( \"DawsonIntegral\" , mathpiper, \"DawsonIntegral\" );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/outputforms/openmath.mpw";
        scriptMap.put("OMREP",scriptString);
        scriptMap.put("OMDef",scriptString);
        scriptMap.put("OMForm",scriptString);
        scriptMap.put("OMRead",scriptString);
        scriptMap.put("OMParse",scriptString);
        scriptMap.put("OMEcho",scriptString);
        scriptMap.put("OMEchoEscape",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nTeXForm\nTeXFormMaxPrec\nTexForm\n*/\n\n/* TeXForm: convert MathPiper objects to TeX math mode strings */\n\n/* version 0.4 */\n\n/* Changelog\n        0.1        basic functionality\n        0.2 fixed bracketing of Exp, added all infix ops and math functions\n        0.3 fixed bracketing of lists, changed bracketing of math functions, modified TeX representation of user-defined functions (up to two-letter functions are in italics), added TeX Greek letters\n        0.4 added nth roots, Sum, Limit, Integrate, hyperbolics, set operations, Abs, Max, Min, \"==\", \":=\", Infinity; support indexed expressions A[i] and matrices.\n        0.4.1 bugfixes for [] operator, support for multiple indices a[1][2][3]\n        0.4.2 fix for variable names ending on digits \"a2\" represented as $a_2$\n        0.4.3 bugfixes: complex I, indeterminate integration; relaxed bracketing of Sin()-like functions; implemented $TeX$ and $LaTeX$ correctly now (using \\textrm{})\n        0.4.4 use ordinary instead of partial derivative if expression has only one variable\n        0.4.5 fixes for bracketing of Sum(); added <> to render as \\sim and <=> to render as \\approx; added BinomialCoefficient()\n        0.4.6 moved the <> and <=> operators to initialization.rep/stdopers.mpi\n        0.4.7 added Product() i.e. Product()\n        0.4.8 added Differentiate(x,n), Deriv(x,n), =>, and fixed errors with ArcSinh, ArcCosh, ArcTanh\n        0.4.9 fixed omission: (fraction)^n was not put in brackets\n        0.4.10 cosmetic change: insert \\cdot between numbers in cases like 2*10^n\n        0.4.11 added DumpErrors() to TexForm for the benefit of TeXmacs notebooks\n        0.4.12 implement the % operation as Mod\n        0.4.13 added Bessel{I,J,K,Y}, Ortho{H,P,T,U}, with a general framework for usual two-argument functions of the form $A_n(x)$; fix for Max, Min\n        0.4.14 added mathematical notation for Floor(), Ceil()\n        0.4.15 added Prog() represented by ( )\n        0.4.16 added Zeta()\n*/\n\n/* To do:\n        0. Find and fix bugs.\n        1. The current bracketing approach has limitations: can't omit extra brackets sometimes. \" sin a b\" is ambiguous, so need to do either \"sin a sin b\" or \"(sin a) b\" Hold((a*b)*Sqrt(x)). The current approach is *not* to bracket functions unless the enveloping operation is more binding than multiplication. This produces \"sin a b\" for both Sin(a*b) and Sin(a)*b but this is the current mathematical practice.\n        2. Need to figure out how to deal with variable names such as \"alpha3\"\n*/\n\n//Retract(\"TeXForm\", *);\n\n/// TeXmacs prettyprinter\nTexForm(_expr) <-- [DumpErrors();WriteString(TeXForm(expr));NewLine();];\n\nRulebase(\"TeXForm\",{expression});\nRulebase(\"TeXForm\",{expression, precedence});\n\n/* Boolean predicate */\n\n\n/* this function will put TeX brackets around the string if predicate holds */\n\nFunction (\"TeXFormBracketIf\", {predicate, string})\n[\n        Check(IsBoolean(predicate) And? IsString(string), \"Argument\", \"TeXForm internal error: non-boolean and/or non-string argument of TeXFormBracketIf\");\n        If(predicate, ConcatStrings(\"( \", string, \") \"), string);\n];\n\n\n\n\nFunction (\"TeXFormMatrixBracketIf\", {predicate, string})\n[\n        Check(IsBoolean(predicate) And? IsString(string), \"Argument\", \"TeXForm internal error: non-boolean and/or non-string argument of TeXFormMatrixBracketIf\");\n        If(predicate, ConcatStrings(\"\\\\left[ \", string, \"\\\\right]\"), string);\n];\n\n\n\n/* First, we convert TeXForm(x) to TeXForm(x, precedence). The enveloping precedence will determine whether we need to bracket the results. So TeXForm(x, TeXFormMaxPrec()) will always print \"x\", while TeXForm(x,-TeXFormMaxPrec()) will always print \"(x)\".\n*/\n\nTeXFormMaxPrec() := 60000;         /* This precedence will never be bracketed. It is equal to KMaxPrec */\n\n/// main front-end\n100 # TeXForm(_x) <-- ConcatStrings(\"$\", TeXForm(x, TeXFormMaxPrec()), \"$\");\n\n/* Replace numbers and variables -- never bracketed except explicitly */\n\n110 # TeXForm(x_IsNumber, _p) <-- ToString(x);\n/* Variables */\n200 # TeXForm(x_IsAtom, _p) <-- TeXFormTeXify(ToString(x));\n\n\n/* Strings must be quoted but not bracketed */\n100 # TeXForm(x_IsString, _p) <--\n[\n    Local(characterList);\n\n    characterList := {};\n    ForEach(character, x)\n    [\n        If(character !=? \" \", DestructiveAppend(characterList, character), DestructiveAppend(characterList, \"\\\\hspace{2 mm}\"));\n    ];\n    ConcatStrings(\"\\\\mathrm{''\", ListToString(characterList), \"''}\");\n];\n\n\n\n/* FunctionToList(...) can generate lists with atoms that would otherwise result in unparsable expressions. */\n100 # TeXForm(x_IsAtom, _p)_(IsInfix(ToString(x))) <-- ConcatStrings(\"\\\\mathrm{\", ToString(x), \"}\");\n\n\n/* Lists: make sure to have matrices processed before them. Enveloping precedence is irrelevant because lists are always bracketed. List items are never bracketed. Note that TeXFormFinishList({a,b}) generates \",a,b\" */\n\n100 # TeXForm(x_IsList, _p)_(Length(x)=?0) <-- TeXFormBracketIf(True, \"\");\n110 # TeXForm(x_IsList, _p) <-- TeXFormBracketIf(True, ConcatStrings(TeXForm(First(x), TeXFormMaxPrec()), TeXFormFinishList(Rest(x)) ) );\n100 # TeXFormFinishList(x_IsList)_(Length(x)=?0) <-- \"\";\n110 # TeXFormFinishList(x_IsList) <-- ConcatStrings(\", \", TeXForm(First(x), TeXFormMaxPrec()), TeXFormFinishList(Rest(x)));\n\n/* Replace operations */\n\n\n        /* Template for \"regular\" binary infix operators:\n100 # TeXForm(_x + _y, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(TeXForm(x, LeftPrecedenceGet(\"+\")), \" + \", TeXForm(y, RightPrecedenceGet(\"+\")) ) );\n        */\n// special cases: things like x*2 and 2*10^x look ugly without a period\n// cases like x*2\n115 # TeXForm(_expr * n_IsNumber, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"*\"), ConcatStrings(TeXForm(expr, LeftPrecedenceGet(\"*\")), \"\\\\cdot \", TeXForm(n, RightPrecedenceGet(\"*\")) ) );\n// cases like a*20! and a*10^x\n116 # TeXForm(_n * _expr, _p) _ (IsFunction(expr) And? Contains({\"^\", \"!\", \"!!\"}, Type(expr)) And? IsNumber(FunctionToList(expr)[2])) <-- TeXFormBracketIf(p<?PrecedenceGet(\"*\"), ConcatStrings(TeXForm(n, LeftPrecedenceGet(\"*\")), \"\\\\cdot \", TeXForm(expr, RightPrecedenceGet(\"*\")) ) );\n\n        /* generic binary ops here */\n120 # TeXForm(expr_IsFunction, _p)_(ArgumentsCount(expr)=?2 And? IsInfix(Type(expr)) ) <-- TeXFormBracketIf(p<?PrecedenceGet(Type(expr)), ConcatStrings(TeXForm(FunctionToList(expr)[2], LeftPrecedenceGet(Type(expr))), TeXFormTeXify(Type(expr)), TeXForm(FunctionToList(expr)[3], RightPrecedenceGet(Type(expr))) ) );\n\n        /* Template for \"regular\" unary prefix operators:\n100 # TeXForm(+ _y, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(\" + \", TeXForm(y, RightPrecedenceGet(\"+\")) ) );\n        Note that RightPrecedenceGet needs to be defined for prefix ops or else we won't be able to tell combined prefix/infix ops like \"-\" from strictly prefix ops.\n        */\n\n        /* generic unary ops here */\n        /* prefix */\n120 # TeXForm(expr_IsFunction, _p)_(ArgumentsCount(expr)=?1 And? IsPrefix(Type(expr))) <-- TeXFormBracketIf(p<?PrecedenceGet(Type(expr)), ConcatStrings(\n        TeXFormTeXify(Type(expr)),\n        TeXForm(FunctionToList(expr)[2], RightPrecedenceGet(Type(expr)))\n) );\n        /* postfix */\n120 # TeXForm(expr_IsFunction, _p)_(ArgumentsCount(expr)=?1 And? IsPostfix(Type(expr))) <-- TeXFormBracketIf(p<?LeftPrecedenceGet(Type(expr)), ConcatStrings(\n        TeXForm(FunctionToList(expr)[2], LeftPrecedenceGet(Type(expr))),\n        TeXFormTeXify(Type(expr))\n) );\n\n        /* fraction and its operands are never bracketed except when they are under power */\n100 # TeXForm(_x / _y, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\"\\\\frac{\", TeXForm(x, TeXFormMaxPrec()), \"}{\", TeXForm(y, TeXFormMaxPrec()), \"} \") );\n\n        /* power's argument is never bracketed but it must be put in braces. Chained powers must be bracketed. Powers of 1/n are displayed as roots. */\n100 # TeXForm(_x ^ (1/2), _p) <-- ConcatStrings(\"\\\\sqrt{\", TeXForm(x, TeXFormMaxPrec()), \"}\");\n101 # TeXForm(_x ^ (1/_y), _p) <-- ConcatStrings(\"\\\\sqrt[\", TeXForm(y, TeXFormMaxPrec()), \"]{\", TeXForm(x, TeXFormMaxPrec()), \"}\");\n\n\n120 # TeXForm(_x ^ _y, _p) <-- TeXFormBracketIf(p<=?PrecedenceGet(\"^\"), ConcatStrings(TeXForm(x, PrecedenceGet(\"^\")), \" ^{\", TeXForm(y, TeXFormMaxPrec()), \"}\" ) );\n\n100 # TeXForm(if(_pred)_body, _p) <-- \"\\\\textrm{if }(\":TeXForm(pred,60000):\") \":TeXForm(body,60000);\n100 # TeXForm(_left else _right, _p) <-- TeXForm(left,60000):\"\\\\textrm{ else }\":TeXForm(right,60000);\n\n\n/* functions */\n\n\nLocalSymbols(TeXFormRegularOps, TeXFormRegularPrefixOps, TeXFormGreekLetters, TeXFormSpecialNames) [\n\n        /* addition, subtraction, multiplication, all comparison and logical operations are \"regular\" */\n\n  TeXFormRegularOps :=\n  {\n    {\"+\",\" + \"},\n    {\"-\",\" - \"},\n    {\"*\",\" \\\\cdot \"},\n    {\":=\",\" := \"}, //\\\\equiv \"},\n    {\"==\",\" = \"},\n    {\"=?\",\" = \"},\n    {\"!=?\",\"\\\\neq \"},\n    {\"<=?\",\"\\\\leq \"},\n    {\">=?\",\"\\\\geq \"},\n    {\"<?\",\" < \"},\n    {\">?\",\" > \"},\n    {\"And?\",\"\\\\wedge \"},\n    {\"Or?\", \"\\\\vee \"},\n    {\"<>\", \"\\\\sim \"},\n    {\"<=>\", \"\\\\approx \"},\n    {\"=>\", \"\\\\Rightarrow \"},\n    {\"%\", \"\\\\bmod \"},\n  };\n\n  TeXFormRegularPrefixOps := { {\"+\",\" + \"}, {\"-\",\" - \"}, {\"Not?\",\" \\\\neg \"} };\n\n\n\n    /* Unknown function: precedence 200. Leave as is, never bracket the function itself and bracket the argumentPointer(s) automatically since it's a list. Other functions are precedence 100 */\n\n  TeXFormGreekLetters := {\"Gamma\", \"Delta\", \"Theta\", \"Lambda\", \"Xi\", \"Pi\", \"Sigma\", \"Upsilon\", \"Phi\", \"Psi\", \"Omega\", \"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\", \"iota\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"xi\", \"pi\", \"rho\", \"sigma\", \"tau\", \"upsilon\", \"phi\", \"chi\", \"psi\", \"omega\", \"varpi\", \"varrho\", \"varsigma\", \"varphi\", \"varepsilon\"};\n  TeXFormSpecialNames := {\n    {\"I\", \"\\\\imath \"},        // this prevents a real uppercase I, use BesselI instead\n    {\"Pi\", \"\\\\pi \"},        // this makes it impossible to have an uppercase Pi... hopefully it's not needed\n    {\"Infinity\", \"\\\\infty \"},\n    {\"TeX\", \"\\\\textrm{\\\\TeX\\\\/}\"},\n    {\"LaTeX\", \"\\\\textrm{\\\\LaTeX\\\\/}\"},\n    {\"Maximum\", \"\\\\max \"},        // this replaces these function names\n    {\"Minimum\", \"\\\\min \"},\n    {\"Prog\", \" \"},\n    {\"Zeta\", \"\\\\zeta \"},\n  };\n\n\n  /* this function will take a user-defined variable or function name and output either this name unmodified if it's only 2 characters long, or the name in normal text if it's longer, or a TeX Greek letter code */\n  Function (\"TeXFormTeXify\", {string})\n  [\n    Check(IsString(string), \"Argument\", \"TeXForm internal error: non-string argument of TeXFormTeXify\");\n    /* Check if it's a greek letter or a special name */\n    If (Contains(AssocIndices(TeXFormSpecialNames), string), TeXFormSpecialNames[string],\n    If (Contains(TeXFormGreekLetters, string), ConcatStrings(\"\\\\\", string, \" \"),\n    If (Contains(AssocIndices(TeXFormRegularOps), string), TeXFormRegularOps[string],\n    If (Contains(AssocIndices(TeXFormRegularPrefixOps), string), TeXFormRegularPrefixOps[string],\n    If (Length(string) >=? 2 And? IsNumber(ToAtom(StringMidGet(2, Length(string)-1, string))), ConcatStrings(StringMidGet(1,1,string), \"_{\", StringMidGet(2, Length(string)-1, string), \"}\"),\n    If (Length(string) >? 2, ConcatStrings(\"\\\\mathrm{ \", string, \" }\"),\n    string\n    ))))));\n  ];\n\n];\n\n/* */\n\n/* Unknown bodied function */\n\n200 # TeXForm(x_IsFunction, _p) _ (IsBodied(Type(x))) <-- [\n        Local(func, args, last'arg);\n        func := Type(x);\n        args := Rest(FunctionToList(x));\n        last'arg := PopBack(args);\n        TeXFormBracketIf(p<?PrecedenceGet(func), ConcatStrings(\n          TeXFormTeXify(func), TeXForm(args, TeXFormMaxPrec()),  TeXForm(last'arg, PrecedenceGet(func))\n        ));\n];\n\n/* Unknown infix function : already done above\n210 # TeXForm(x_IsFunction, _p)_(IsInfix(Type(x))) <-- ConcatStrings(TeXFormTeXify(Type(x)), TeXForm(Rest(FunctionToList(x)), TeXFormMaxPrec()) );\n*/\n/* Unknown function that is not prefix, infix or postfix */\n220 # TeXForm(x_IsFunction, _p) <-- ConcatStrings(TeXFormTeXify(Type(x)), TeXForm(Rest(FunctionToList(x)), TeXFormMaxPrec()) );\n\n        /* Never bracket Sqrt or its arguments */\n100 # TeXForm(Sqrt(_x), _p) <-- ConcatStrings(\"\\\\sqrt{\", TeXForm(x, TeXFormMaxPrec()), \"}\");\n\n        /* Always bracket Exp's arguments */\n100 # TeXForm(Exp(_x), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\"\\\\exp \", TeXFormBracketIf(True, TeXForm(x, TeXFormMaxPrec())) ) );\n\n\nLocalSymbols(TeXFormMathFunctions, TeXFormMathFunctions2) [\n\n  /* Sin, Cos, etc. and their argument is bracketed when it's a sum or product but not bracketed when it's a power. */\n  /// supported MathPiper functions: \"mathematical\" functions of one argument which sometimes do not require parentheses (e.g. $\\sin x$ )\n  TeXFormMathFunctions := { {\"Cos\",\"\\\\cos \"}, {\"Sin\",\"\\\\sin \"}, {\"Tan\",\"\\\\tan \"}, {\"Cosh\",\"\\\\cosh \"}, {\"Sinh\",\"\\\\sinh \"}, {\"Tanh\",\"\\\\tanh \"}, {\"Ln\",\"\\\\ln \"}, {\"ArcCos\",\"\\\\arccos \"}, {\"ArcSin\",\"\\\\arcsin \"}, {\"ArcTan\",\"\\\\arctan \"}, {\"ArcCosh\",\"\\\\mathrm{arccosh}\\\\, \"}, {\"ArcSinh\",\"\\\\mathrm{arcsinh}\\\\, \"}, {\"ArcTanh\",\"\\\\mathrm{arctanh}\\\\, \"},\n  {\"Erf\", \"\\\\mathrm{erf}\\\\, \"}, {\"Erfc\", \"\\\\mathrm{erfc}\\\\, \"},\n  };\n\n  /// supported MathPiper functions: functions of two arguments of the form $A_n(x)$\n  TeXFormMathFunctions2 := {\n  {\"BesselI\", \"I \"}, {\"BesselJ\", \"J \"},\n  {\"BesselK\", \"K \"}, {\"BesselY\", \"Y \"},\n  {\"OrthoH\", \"H \"}, {\"OrthoP\", \"P \"},\n  {\"OrthoT\", \"T \"}, {\"OrthoU\", \"U \"},\n  };\n\n  // generic two-argument functions of the form $A(x,y)$ where just the name has to be changed: handle this using the usual naming conversion scheme (TeXFormSpecialNames)\n\n  /* Precedence of 120 because we'd like to process other functions like sqrt or exp first */\n\n  // generic math functions of one argument\n  120 # TeXForm(expr_IsFunction, _p) _ (ArgumentsCount(expr)=?1 And? Contains(AssocIndices(TeXFormMathFunctions), Type(expr)) ) <-- TeXFormBracketIf(p<?PrecedenceGet(\"*\"), ConcatStrings(TeXFormMathFunctions[Type(expr)], TeXForm( FunctionToList(expr)[2], PrecedenceGet(\"*\")) ) );\n\n  /// math functions two arguments of the form $A_n(x)$\n  120 # TeXForm(expr_IsFunction, _p) _ (ArgumentsCount(expr)=?2 And? Contains(AssocIndices(TeXFormMathFunctions2), Type(expr)) ) <-- TeXFormBracketIf(p<?PrecedenceGet(\"*\"),\n    ConcatStrings(\n    TeXFormMathFunctions2[Type(expr)],\n    \"_{\",\n    TeXForm( FunctionToList(expr)[2], TeXFormMaxPrec()),        // never bracket the subscript\n    \"}\",\n    TeXFormBracketIf(True, TeXForm(FunctionToList(expr)[3], TeXFormMaxPrec()) ) // always bracket the function argument\n    )\n  );\n\n]; // LocalSymbols(TeXFormMathFunctions, TeXFormMathFunctions2)\n\n\n/* Complex numbers */\n100 # TeXForm(Complex(0, 1), _p) <-- TeXForm(Hold(I), p);\n100 # TeXForm(Complex(_x, 0), _p) <-- TeXForm(x, p);\n110 # TeXForm(Complex(_x, 1), _p) <-- TeXForm(x+Hold(I), p);\n110 # TeXForm(Complex(0, _y), _p) <-- TeXForm(Hold(I)*y, p);\n120 # TeXForm(Complex(_x, _y), _p) <-- TeXForm(x+Hold(I)*y, p);\n\n/* Abs(), Floor(), Ceil() are displayed as special brackets */\n\n100 # TeXForm(Abs(_x), _p) <-- ConcatStrings(\"\\\\left| \", TeXForm(x, TeXFormMaxPrec()), \"\\\\right| \");\n100 # TeXForm(Floor(_x), _p) <-- ConcatStrings(\"\\\\left\\\\lfloor \", TeXForm(x, TeXFormMaxPrec()), \"\\\\right\\\\rfloor \");\n100 # TeXForm(Ceil(_x), _p) <-- ConcatStrings(\"\\\\left\\\\lceil \", TeXForm(x, TeXFormMaxPrec()), \"\\\\right\\\\rceil \");\n\n/* Some functions which are displayed as infix: Mod, Union, Intersection, Difference, Contains */\n\n100 # TeXForm(Modulo(_x, _y), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(TeXForm(x, PrecedenceGet(\"/\")), \"\\\\bmod \", TeXForm(y, PrecedenceGet(\"/\")) ) );\n\n100 # TeXForm(Union(_x, _y), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(TeXForm(x, PrecedenceGet(\"/\")), \"\\\\cup \", TeXForm(y, PrecedenceGet(\"/\")) ) );\n\n100 # TeXForm(Intersection(_x, _y), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(TeXForm(x, PrecedenceGet(\"/\")), \"\\\\cap \", TeXForm(y, PrecedenceGet(\"/\")) ) );\n\n100 # TeXForm(Difference(_x, _y), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(TeXForm(x, PrecedenceGet(\"/\")), \"\\\\setminus \", TeXForm(y, PrecedenceGet(\"/\")) ) );\n\n/* \"Contains\" is displayed right to left */\n\n100 # TeXForm(Contains(_x, _y), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(TeXForm(y, PrecedenceGet(\"/\")), \"\\\\in \", TeXForm(x, PrecedenceGet(\"/\")) ) );\n\n/// Binomial coefficients: always bracketed\n100 # TeXForm(BinomialCoefficient(_n, _m), _p) <-- TeXFormBracketIf(False, ConcatStrings(\"{\", TeXForm(n, TeXFormMaxPrec()), \" \\\\choose \", TeXForm(m, TeXFormMaxPrec()), \"}\" )\n);\n\n/* Some functions with limits: Lim, Sum, Integrate */\n\n100 # TeXForm(Sum(_x, _x1, _x2, _expr), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\"\\\\sum _{\", TeXForm(x, TeXFormMaxPrec()), \" = \", TeXForm(x1, TeXFormMaxPrec()), \"} ^{\", TeXForm(x2, TeXFormMaxPrec()), \"} \", TeXForm(expr, PrecedenceGet(\"*\")) ) );\n\n100 # TeXForm(Sum(_expr), _p) <-- TeXFormBracketIf(p <? PrecedenceGet(\"/\"), ConcatStrings(\"\\\\sum \", TeXForm(expr, PrecedenceGet(\"*\")) ) );\n\n\n100 # TeXForm(Product(_x, _x1, _x2, _expr), _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\"\\\\prod _{\", TeXForm(x, TeXFormMaxPrec()), \" = \", TeXForm(x1, TeXFormMaxPrec()), \"} ^{\", TeXForm(x2, TeXFormMaxPrec()), \"} \", TeXForm(expr, PrecedenceGet(\"*\")) ) );\n\n100 # TeXForm(Integrate(_x, _x1, _x2) _expr, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\n\"\\\\int _{\", TeXForm(x1, TeXFormMaxPrec()), \"} ^{\", TeXForm(x2, TeXFormMaxPrec()), \" } \", TeXForm(expr, PrecedenceGet(\"*\")), \" d\", TeXForm(x, TeXFormMaxPrec())\n) );\n\n/* indeterminate integration */\n100 # TeXForm(Integrate(_x) _expr, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\n\"\\\\int \", TeXForm(expr, PrecedenceGet(\"*\")), \" d\", TeXForm(x, TeXFormMaxPrec())\n) );\n\n100 # TeXForm(Limit(_x, _x1) _expr, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(\"\\\\lim _{\", TeXForm(x, TeXFormMaxPrec()), \"\\\\rightarrow \", TeXForm(x1, TeXFormMaxPrec()), \"} \", TeXForm(expr, PrecedenceGet(\"/\")) ) );\n\n/* Derivatives */\n\n/* Use partial derivative only when the expression has several variables */\n100 # TeXForm(Deriv(_x)_y, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"-\"), ConcatStrings(\n        If(Length(VarList(y))>?1, \"\\\\frac{\\\\partial}{\\\\partial \", \"\\\\frac{d}{d \"\n        ), TeXForm(x, PrecedenceGet(\"^\")), \"}\", TeXForm(y, PrecedenceGet(\"/\")) ) );\n\n100 # TeXForm(Deriv(_x, _n)_y, _p) <-- TeXFormBracketIf(p<?PrecedenceGet(\"-\"), ConcatStrings(\n        If(\n                Length(VarList(y))>?1,\n                \"\\\\frac{\\\\partial^\" : TeXForm(n, TeXFormMaxPrec()) : \"}{\\\\partial \",\n                \"\\\\frac{d^\" : TeXForm(n, TeXFormMaxPrec()) : \"}{d \"\n        ), TeXForm(x, PrecedenceGet(\"^\")), \" ^\", TeXForm(n, TeXFormMaxPrec()), \"}\", TeXForm(y, PrecedenceGet(\"/\")) ) );\n100 # TeXForm(Differentiate(_x)_y, _p) <-- TeXForm(Deriv(x) y, p);\n100 # TeXForm(Differentiate(_x, _n)_y, _p) <-- TeXForm(Deriv(x, n) y, p);\n\n/* Indexed expressions */\n\n/* This seems not to work because x[i] is replaced by Nth(x,i) */\n/*\n100 # TeXForm(_x [ _i ], _p) <-- ConcatStrings(TeXForm(x, TeXFormMaxPrec()), \" _{\", TeXForm(i, TeXFormMaxPrec()), \"}\");\n*/\n/* Need to introduce auxiliary function, or else have trouble with arguments of Nth being lists */\nRulebase(\"TeXFormNth\",{x,y});\n100 # TeXForm(Nth(Nth(_x, i_IsList), _j), _p) <-- TeXForm(TeXFormNth(x, Append(i,j)), p);\n100 # TeXForm(TeXFormNth(Nth(_x, i_IsList), _j), _p) <-- TeXForm(TeXFormNth(x, Append(i,j)), p);\n110 # TeXForm(Nth(Nth(_x, _i), _j), _p) <-- TeXForm(TeXFormNth(x, List(i,j)), p);\n120 # TeXForm(Nth(_x, _i), _p) <-- ConcatStrings(TeXForm(x, TeXFormMaxPrec()), \" _{\", TeXForm(i, TeXFormMaxPrec()), \"}\");\n120 # TeXForm(TeXFormNth(_x, _i), _p) <-- ConcatStrings(TeXForm(x, TeXFormMaxPrec()), \" _{\", TeXForm(i, TeXFormMaxPrec()), \"}\");\n\n/* Matrices are always bracketed. Precedence 80 because lists are at 100. */\n\n80 # TeXForm(M_IsMatrix, _p) <-- TeXFormMatrixBracketIf(True, TeXFormPrintMatrix(M));\n\nFunction (\"TeXFormPrintMatrix\", {M})\n[\n/*\n        Want something like \"\\begin{array}{cc} a & b \\\\ c & d \\\\ e & f \\end{array}\"\n        here, \"cc\" is alignment and must be given for each column\n*/\n        Local(row, col, result, ncol);\n        result := \"\\\\begin{array}{\";\n        ForEach(col, M[1]) result:=ConcatStrings(result, \"c\");\n        result := ConcatStrings(result, \"}\");\n\n        ForEach(row, 1 .. Length(M)) [\n                ForEach(col, 1 .. Length(M[row])) [\n                        result := ConcatStrings( result, \" \", TeXForm(M[row][col], TeXFormMaxPrec()), If(col =? Length(M[row]), If(row =? Length(M), \"\", \" \\\\\\\\\"), \" &\"));\n                ];\n        ];\n\n        ConcatStrings(result, \" \\\\end{array} \");\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/outputforms/texform.mpw";
        scriptMap.put("TeXForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Apart\",*);\n\nApart(_f) <-- Apart(f,x);\n\nApart(_f,_var) <--\n[\n  Local(rat);\n  //rat:=RationalForm(f,var);  // hso 100215  (this step seems superfluous and wrong!)\n  rat := {Numerator(f),Denominator(f)};\n  If(Degree(rat[1],var) =? 0 And? Degree(rat[2],var) =? 0,\n     [\n       rat:={Coef(rat[1],var,0),Coef(rat[2],var,0)};\n       Local(summed,add);\n       summed := Eval(PartFracExpand(Rem(rat[1],rat[2]),rat[2]));\n       add:=(rat[1]/rat[2] - summed);\n       add + summed;\n     ]\n     ,\n     [\n       /*TODO check this one! Do we have to do the same as with the\n        * integers?\n        */\n       Expand(Quotient(rat[1],rat[2])) + PartFracExpand(Rem(rat[1],rat[2]),rat[2]);\n     ]\n     );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/Apart.mpw";
        scriptMap.put("Apart",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Chinese Remaindering algorithm, as described in \"Modern Computer Algebra\".\n */\nChineseRemainderInteger(mlist_IsList,vlist_IsList) <--\n[\n  Local(m,i,nr,result,msub,euclid,clist);\n  clist:={};\n  m:=Product(mlist);\n  result:=0;\n\n  nr:=Length(mlist);\n  For(i:=1,i<=?nr,i++)\n  [\n    msub:=Quotient(m,mlist[i]);\n    euclid := ExtendedEuclidean(msub,mlist[i]);\n    Local(c);\n    c:=vlist[i] * euclid[2];\n    c:=Rem(c, mlist[i]);\n    DestructiveAppend(clist,c);\n    result:=result + msub * c;\n  ];\n  {result,clist};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/ChineseRemainderInteger.mpw";
        scriptMap.put("ChineseRemainderInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nChineseRemainderPoly(mlist_IsList,vlist_IsList) <--\n[\n  Local(m,i,nr,result,msub,euclid,clist);\n  clist:={};\n  m:=Product(mlist);\n  result:=0;\n\n/* Echo({mlist,m}); */\n\n\n  nr:=Length(mlist);\n  For(i:=1,i<=?nr,i++)\n  [\n    msub:=Quotient(m,mlist[i]);\n\n/* Echo({Factor(msub)}); */\n\n    euclid := ExtendedEuclideanMonic(msub,mlist[i]);\n    Local(c);\n\n    c:=vlist[i] * euclid[2];\n\n    c:=Modulo(c, mlist[i]);\n\n    DestructiveAppend(clist,c);\n    result:=result + msub * c;\n  ];\n  {Expand(result),clist};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/ChineseRemainderPoly.mpw";
        scriptMap.put("ChineseRemainderPoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Extended Euclidean algorithm. Algorithm taken from\n * \"Modern Computer Algebra\". It does a Gcd calculation, but\n * returns the intermediate results also.\n *\n * Returns {l,r,s,t}\n * where\n * - l the number of steps required\n * - r[i] the i-th remainder\n * - s[i] and t[i] the i-th bezout coefficients of f and g:\n     s[i]*f + t[i]*g = r[i] .\n * The gcd is r[l].\n *\n * This is a slightly modified version from the one described in\n * \"Modern Computer Algebra\", where the elements in list r are not\n * monic. If needed this can be done afterwards. As a consequence\n * this version works on integers as well as on polynomials.\n */\n\nExtendedEuclidean(_f,_g) <--\n[\n   Local(r,s,t,i);\n\n   /* Initialize the loop */\n   r:={f,g};\n   s:={1,0};\n   t:={0,1};\n   i:=1;\n\n   Local(q,newr,news,newt);\n   newr:=1;\n   While(newr !=? 0)\n   [\n     newr:=Rem(r[i],r[i+1]);\n     q   :=Quotient(r[i],r[i+1]);\n     news  :=(s[i]-q*s[i+1]);\n     newt  :=(t[i]-q*t[i+1]);\n     DestructiveAppend(r  ,newr);\n     DestructiveAppend(s,news);\n     DestructiveAppend(t,newt);\n     i++;\n   ];\n   {r[i],s[i],t[i]};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/ExtendedEuclidean.mpw";
        scriptMap.put("ExtendedEuclidean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nExtendedEuclideanMonic(_f,_g) <--\n[\n   Local(rho,r,s,t,i);\n\n/*\nEcho({f,g});\nEcho({});\n*/\n\n   /* Initialize the loop */\n   rho:={LeadingCoef(f),LeadingCoef(g)};\n   r:={Monic(f),Monic(g)};\n   s:={1/(rho[1]),0};\n   t:={0,1/(rho[2])};\n   i:=1;\n\n   Local(q,newr,news,newt,newrho);\n   newr:=r[2];\n   While(newr !=? 0)\n   [\n     q   :=Quotient(r[i],r[i+1]);\n     newr:=Modulo(r[i],r[i+1]);\n     newrho:=LeadingCoef(newr);\n\n\n     If (newr !=? 0, newr:=Monic(newr));\n     news  :=(s[i]-q*s[i+1]);\n     newt  :=(t[i]-q*t[i+1]);\n     If(newrho !=? 0,\n       [\n         news:=news/newrho;\n         newt:=newt/newrho;\n       ]);\n     DestructiveAppend(rho,newrho);\n     DestructiveAppend(r  ,newr);\n     DestructiveAppend(s,news);\n     DestructiveAppend(t,newt);\n     i++;\n   ];\n\n/*\nTableForm({i,r,s,t});\nEcho({});\n*/\n\n   {r[i],s[i],t[i]};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/ExtendedEuclideanMonic.mpw";
        scriptMap.put("ExtendedEuclideanMonic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Reduce rational function by dividing gcd away */\nGcdReduce(_f,_var)<--\n[\n  Local(rat,gcd);\n  rat:=RationalForm(f,var);\n  gcd:=Gcd(rat[1],rat[2]);\n/*  gcd:=gcd*Gcd(Content(rat[1]),Content(rat[2]));*/\n\n  Local(numer,denom,lc);\n  numer:=Quotient(rat[1],gcd);\n  denom:=Quotient(rat[2],gcd);\n  lc:=LeadingCoef(numer,var);\n  numer:=numer/lc;\n  denom:=denom/lc;\n  Expand(numer)/Expand(denom);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/GcdReduce.mpw";
        scriptMap.put("GcdReduce",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n TODO:\n\n\n\n\n - example:\n   20 # f(_x) <-- Sin(x);\n   10 # f(Eval(_x)) <-- Sin(Eval(x));\n   HoldArgumentNumber(\"f\",1,1);\n\n   Out( 0 ) = True;\n   In( 1 ) = f(2+3)\n   Out( 1 ) = Sin(2+3);\n   In( 2 ) = f(Eval(2+3))\n   Out( 2 ) = Sin(5);\n\n   Alternative:\n   f(x):=\n   [\n     Unholdable(x);\n     Sin(x);\n   ];\n\n   this is if you don't want to use patterns.\n\n\n Mini-module padic. This module creates a p-adic expansion of\n an expression:\n\n expression = a0 + a1*p + a2 * p^2 + ... etc.\n\n PAdicExpand and PAdicExpandInternal can be called with integer\n or univariate polynomial arguments.\n */\n\n\nExpand(x); /* TODO no idea why this is needed! Mod/Div/UniVariate thing :-( */\n\n10 # PAdicExpand(_x,_y) <--\n[\n  Local(coefs);\n  coefs:=PAdicExpandInternal(x,y);\n  Subst(p,y)Add(coefs*(p^(0 .. Length(coefs))));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/PAdicExpand.mpw";
        scriptMap.put("PAdicExpand",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # PAdicExpandInternal(0,_y) <-- {};\n20 # PAdicExpandInternal(_x,_y) <--\n[\n  Modulo(x,y) : PAdicExpandInternal(Quotient(x,y),y);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/PAdicExpandInternal.mpw";
        scriptMap.put("PAdicExpandInternal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Partial fraction expansion of g/f with Degree(g)<Degree(f) */\nPartFracExpand(_g,_f) <--\n[\n  Local(mlist,vlist,res);\n\n/* Echo({\"factors = \",Factors(f)}); */\n\n  mlist:=Map(\"^\",Transpose(Factors(f)));\n\n/* Echo({\"mlist = \",mlist}); */\n\n  vlist:=Map(\"Rem\",{FillList(g,Length(mlist)),mlist});\n\n\n/* Echo({\"g = \",g}); */\n/* Echo({\"vlist = \",vlist}); */\n\n  If(IsInteger(f),\n    res:=ChineseRemainderInteger(mlist,vlist)[2],\n    res:=ChineseRemainderPoly(mlist,vlist)[2]\n    );\n\n\n/* Echo({res,mlist});  */\n  Local(result,divlist);\n\n\n  divlist:=Map(\"/\",{res,mlist});\n\n  If(Length(divlist)<?2,\n    Add(divlist),\n    [\n      result:=divlist[1];\n      ForEach(item,Rest(divlist))\n      [\n        result:=ListToFunction({ToAtom(\"+\"),result,item});\n      ];\n      result;\n    ]);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/PartFracExpand.mpw";
        scriptMap.put("PartFracExpand",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # RationalForm((g_CanBeUni(var))/(f_CanBeUni(var)),_var)\n     <-- { MakeUni(g,var),MakeUni(f,var)};\n20 # RationalForm(f_CanBeUni(var),_var)\n     <-- { MakeUni(f,var),MakeUni(1,var)};\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/RationalForm.mpw";
        scriptMap.put("RationalForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Together\",*);\n\n10 # Together((_f/_g) + (_h/_i)) <--  Simplify(Expand(f*i+h*g)/Expand(g*i));\n\n10 # Together((_f/_g) - (_h/_i)) <--  Simplify(Expand(f*i-h*g)/Expand(g*i));\n\n20 # Together(_f + (_g / _h))    <--  Simplify(Expand(f*h+g)/h);\n\n20 # Together((_f/_g) + _h)      <--  Simplify(Expand(f+h*g)/g);\n\n20 # Together(_f - (_g / _h))    <--  Simplify(Expand(f*h-g)/h);\n\n20 # Together((_f/_g) - _h)      <--  Simplify(Expand(f-h*g)/g);\n\n20 # Together(- (_g / _h))       <--  Simplify((-g)/h);\n\n20 # Together((_f/_g) * _h)      <--  Simplify(Expand(f*h)/g);\n\n20 # Together(_h * (_f/_g))      <--  Simplify(Expand(f*h)/g);\n\n20 # Together((_f/_g) / _h)      <--  Simplify((f)/Expand(g*h));\n\n20 # Together(_h / (_f/_g))      <--  Simplify(Expand(g*h)/f);\n\n20 # Together(- _f)              <-- - Together(f);\n\n30 # Together(_f)                <--  f;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/padic/Together.mpw";
        scriptMap.put("Together",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"_\",{a});\nRulebase(\"_\",{a,b});\n\nRulebase(\"DefinePattern\",{leftOperand, rightOperand, rulePrecedence, postPredicate});\n\n\n\nRule(\"DefinePattern\",4,9,IsEqual(Type(leftOperand),\"_\"))\n[\n    DefinePattern(leftOperand[1], rightOperand, rulePrecedence, leftOperand[2]);\n];\n\n\n\nRule(\"DefinePattern\",4,10,True)\n[\n      Local(patternFlat,patternVariables, pattern, patternOperator, arg, arity);\n      \n      Bind(patternFlat, FunctionToList(leftOperand)); //Turn the pattern into a list.\n      \n      Bind(patternVariables, Rest(patternFlat)); //Remove the function name from the list.\n      \n      Bind(patternOperator,ToString(First(patternFlat))); //Obtain the function name.\n      \n      Bind(arity,Length(patternVariables)); //Obtain the arity of the function.\n      \n      //DefLoadFunction(patternOperator);  //Load the function if it exists.\n    \n      /*\n            If the function does not exist, create it.\n      */\n      If(Not?(RulebaseDefined(patternOperator,arity)),\n         [\n          MacroRulebase(patternOperator,MakeVector(arg,arity));\n         ]\n        );\n    \n      Bind(pattern,PatternCreate(patternVariables,postPredicate));\n    \n      MacroRulePattern(patternOperator,arity,rulePrecedence, pattern)rightOperand;\n    \n      True;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/patterns/DefinePattern.mpw";
        scriptMap.put("DefinePattern",scriptString);
        scriptMap.put("_",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"MakeVector\",{vec,dimension});\nRule(\"MakeVector\",2,1,True)\n[\n    Local(res,i);\n    res:={};\n    i:=1;\n    Bind(dimension,AddN(dimension,1));\n    While(IsLessThan(i,dimension))\n    [\n      DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));\n      Bind(i,AddN(i,1));\n    ];\n    DestructiveReverse(res);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/patterns/MakeVector.mpw";
        scriptMap.put("MakeVector",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"<--\",{leftOperand,rightOperand});\n\n\n\nRule(\"<--\",2,1,IsEqual(Type(leftOperand),\"#\"))\n[\n  DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);\n];\n\n\n\nRule(\"<--\",2,2,IsFunction(leftOperand))\n[\n DefinePattern(leftOperand,rightOperand,0,True);\n];\n\nHoldArgument(\"<--\",leftOperand);\nHoldArgument(\"<--\",rightOperand);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/patterns/lessthan_negative_negative_operator.mpw";
        scriptMap.put("<--",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// utility function: convert options lists of the form\n/// \"{key=value, key=value}\" into a hash of the same form.\n/// The argument list is kept unevaluated using \"HoldArgumentNumber()\".\n/// Note that symbolic values of type atom are automatically converted to strings, e.g. ListToHash({a -> b}) returns {{\"a\", \"b\"}}\nOptionsListToHash(list) :=\n[\n        Local(item, result);\n        result := {};\n        ForEach(item, list)\n                If(\n                        IsFunction(item) And? (Type(item) =? \"->\" ) And? IsAtom(item[1]),\n                        result[ToString(item[1])] := If(\n                                IsAtom(item[2]) And? Not? IsNumber(item[2]) And? Not? IsString(item[2]),\n                                ToString(item[2]),\n                                item[2]\n                        ),\n                        Echo({\"OptionsListToHash: Error: item \", item, \" is not of the format a -> b.\"})\n                );\n        \n        result;\n];\n\nHoldArgumentNumber(\"OptionsListToHash\", 1, 1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/OptionsListToHash.mpw";
        scriptMap.put("OptionsListToHash",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # RemoveRepeated({}) <-- {};\n10 # RemoveRepeated({_x}) <-- {x};\n20 # RemoveRepeated(list_IsList) <-- [\n        Local(i, done);\n        done := False;\n        For(i:=0, Not? done, i++)\n        [\n                While(i<?Length(list) And? list[i]=?list[i+1])\n                        DestructiveDelete(list, i);\n                If(i=?Length(list), done := True);\n        ];\n        list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/RemoveRepeated.mpw";
        scriptMap.put("RemoveRepeated",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// service function. WriteDataItem({1,2,3}, {}) will output \"1 2 3\" on a separate line.\n/// Writes data points to the current output stream, omits non-numeric values.\nWriteDataItem(tuple_IsList, _options'hash) <--\n[\n  Local(item);\n  If(        // do not write anything if one of the items is not a number\n          IsNumericList(tuple),\n        ForEach(item,tuple)\n        [\n                Write(item);\n                Space();\n        ]\n  );\n  NewLine();\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/WriteDataItem.mpw";
        scriptMap.put("WriteDataItem",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// Backends for 2D plotting\n//////////////////////////////////////////////////\n\n\n/// List of all defined backends and their symbolic labels.\n/// Add any new backends here\n\nLocalSymbols(options)\n[\n    options  := {\n        {\"default\", \"data\"},\n        {\"data\", \"Plot2DData\"},\n        {\"java\", \"Plot2DJava\"},\n    {\"geogebra\", \"Plot2DGeoGebra\"},\n    {\"jfreechart\", \"Plot2DJFreeChart\"},\n};\n    \n\nPlot2DOutputs() := options;\n\n];\n\n/*\n        How backends work:\n        Plot2D'<backend>(values, optionsHash)\n        optionsHash is a hash that contains all plotting options:\n        [\"xrange\"] - a list of {x1, x2}, [\"xname\"] - name of the variable to plot, [\"yname\"] - array of string representations of the function(s), and perhaps other options relevant to the particular backend.\n        {values} is a list of lists of pairs of the form {{{x1, y1}, {x2, y2}, ...}, {{x1, z1}, {x2, z2}, ...}, ...} corresponding to the functions y(x), z(x), ... to be plotted. The abscissa points x[i] are not the same for all functions.\n        The backend should prepare the graph of the function(s). The \"datafile\" backend Plot2D'datafile(values, optionsHash) may be used to output all data to file(s), in which case the file name should be given by the value optionsHash[\"filename\"]. Multiple files are created with names obtained by appending numbers to the filename.\n        Note that the \"data\" backend does not do anything and simply returns the data.\n        The backend Plot2D'datafile takes care not to write \"Infinity\" or \"Undefined\" data points (it just ignores them). Custom backends should either use Plot2D'datafile or take care of this themselves.\n*/\n\n/// trivial backend: return data list (do not confuse with Plot2D'get'data() defined in the main code which is the middle-level plotting routine)\nPlot2DData(values_IsList, _optionsHash) <-- values;\n\n/// The Java back-end generates a call-list that the Java graph plotter can handle\nPlot2DJava(values_IsList, _optionsHash) <--\n[\n  Local(result,count);\n  count := 0;\n  result:=\"$plot2d:\";\n\n  result := result:\" pensize 2.0 \";\n  ForEach(function,values)\n  [\n    result := result:ColorForGraphNr(count);\n    count++;\n    result:=result:\" lines2d \":ToString(Length(function));\n\n    function:=Select(function, Lambda({item},item[2] !=? Undefined));\n\n    ForEach(item,function)\n    [\n      result := result:\" \":ToString(item[1]):\" \":ToString(item[2]):\" \";\n    ];\n  ];\n  WriteString(result:\"$\");\n  True;\n];\n\n10 # ColorForGraphNr(0) <-- \" pencolor 64 64 128 \";\n10 # ColorForGraphNr(1) <-- \" pencolor 128 64 64 \";\n10 # ColorForGraphNr(2) <-- \" pencolor 64 128 64 \";\n20 # ColorForGraphNr(_count) <-- ColorForGraphNr(Modulo(count,3));\n\n\n\n\n//GeoGebra backend.\nPlot2DGeogebra(values_IsList, _optionsHash) <--\n[\n  Local(result,count);\n  count := 0;\n  result:=\"\";\n\n\n  ForEach(function,values)\n  [\n\n    function:=Select(function, Lambda({item},item[2] !=? Undefined));\n\n    ForEach(item,function)\n    [\n      result := result:\"(\":ToString(item[1]):\",\":ToString(item[2]):\")\":Nl();\n    ];\n  ];\n  WriteString(result);\n  True;\n];\n\n\n\n\n//JFreeChart backend.\n//Retract(\"Plot2DJFreeChart\", *);\nPlot2DJFreeChart(values_IsList, _optionsHash) <--\n[\n    Local(rangeList, domainList, function, allProcessedFunctionData, lineChartCallListForm);\n    \n    \n    \n    //Remove Plot2D's options so that they don't get passed through to LineChart();\n    ForEach(name, {\"xrange\", \"xname\", \"yname\", \"output\", \"precision\", \"points\", \"depth\"})\n    [\n        AssocDelete(optionsHash, name);\n    ];\n    \n    \n    \n    //Convert {x,y} pairs into {x,x,x,...} {y,y,y,...} form.\n    allProcessedFunctionData := {};\n    \n    ForEach(function,values)\n    [\n        rangeList := {};\n        \n        domainList := {};\n        \n        function := Select(function, Lambda({item},item[2] !=? Undefined));\n        \n        ForEach(item,function)\n        [\n            rangeList := Append(rangeList, item[1]);\n          \n            domainList := Append(domainList, item[2]);\n        ];\n        \n        allProcessedFunctionData := Append(allProcessedFunctionData, rangeList);\n        allProcessedFunctionData := Append(allProcessedFunctionData, domainList);\n    \n    ];\n\n\n    \n    //Put LineChart() function call into list form so it can be manipulated.\n    lineChartCallListForm := {LineChart, allProcessedFunctionData };\n    \n    \n    \n    //Add any options to the list.\n    ForEach(key, AssocIndices(optionsHash))\n    [\n        lineChartCallListForm := Append(lineChartCallListForm, Apply(\"->\", {key, optionsHash[key]}));\n    ];\n    \n    \n    \n    //Call the LineChart() function.\n    Eval(ListToFunction(lineChartCallListForm));\n    \n\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/_2d/backends.mpw";
        scriptMap.put("Plot2DOutputs",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Plot2D\", *);\n\n//////////////////////////////////////////////////\n/// Plot2D --- adaptive two-dimensional plotting\n//////////////////////////////////////////////////\n\n/// definitions of backends\n//LoadScriptOnce(\"plots.rep/backends_2d.mpi\");\n\n/*\n        Plot2D is an interface for various backends (Plot2D'...). It calls\nPlot2D'get'data to obtain the list of points and values, and then it calls\nPlot2D'<backend> on that data.\n\n        Algorithm for Plot2D'get'data:\n        1) Split the given interval into Quotient(points+3, 4) subintervals, and split each subinterval into 4 parts.\n        2) For each of the parts: evaluate function values and call Plot2D'adaptive\n        3) concatenate resulting lists and return\n*/\n\nLocalSymbols(var, func, range, option, options'list, delta, options'hash, c, fc, all'values, dummy)\n[\n\n// declaration of Plot2D with variable number of arguments\nFunction() Plot2D(func);\nFunction() Plot2D(func, range);\nFunction() Plot2D(func, range, options, ...);\n\n/// interface routines\n1 # Plot2D(_func) <-- (\"Plot2D\" @ {func, -5:5});\n2 # Plot2D(_func, _range) <-- (\"Plot2D\" @ {func, range, {}});\n3 # Plot2D(_func, _range, option_IsFunction) _ (Type(option) =? \"->\" )  <-- (\"Plot2D\" @ {func, range, {option}});\n\n/// Plot a single function\n5 # Plot2D(_func, _range, options'list_IsList)_(Not? IsList(func)) <-- (\"Plot2D\" @ {{func}, range, options'list});\n\n/// Top-level 2D plotting routine:\n/// plot several functions sharing the same xrange and other options\n4 # Plot2D(func'list_IsList, _range, options'list_IsList) <--\n[\n        Local(var, func, delta, options'hash, c, fc, all'values, dummy);\n        all'values := {};\n        options'hash := \"OptionsListToHash\" @ {options'list};\n    \n    \n        // this will be a string - name of independent variable\n        options'hash[\"xname\"] := \"\";\n        // this will be a list of strings - printed forms of functions being plotted\n        options'hash[\"yname\"] := {};\n        // parse range\n        If (\n                Type(range) =? \"->\",        // variable also specified -- ignore for now, store in options\n                [\n                        // store alternative variable name\n                        options'hash[\"xname\"] := ToString(range[1]);\n                        range := range[2];\n                ]\n        );\n        If(\n                Type(range) =? \":\",        // simple range\n                range := N(Eval({range[1], range[2]}))\n        );\n        // set default option values\n        If(\n                options'hash[\"points\"] =? Empty,\n                options'hash[\"points\"] := 23\n        );\n        If(\n                options'hash[\"depth\"] =? Empty,\n                options'hash[\"depth\"] := 5\n        );\n        If(\n                options'hash[\"precision\"] =? Empty,\n                options'hash[\"precision\"] := 0.0001\n        );\n        If(\n                options'hash[\"output\"] =? Empty Or? IsString(options'hash[\"output\"]) And? Plot2DOutputs()[options'hash[\"output\"]] =? Empty,\n                options'hash[\"output\"] := Plot2DOutputs()[\"default\"]\n        );\n        // a \"filename\" parameter is required when using data file\n        If(\n                options'hash[\"output\"] =? \"datafile\" And? options'hash[\"filename\"] =? Empty,\n                options'hash[\"filename\"] := \"output.data\"\n        );\n    \n        // we will divide each subinterval in 4 parts, so divide number of points by 4 now\n        options'hash[\"points\"] := N(Eval(Quotient(options'hash[\"points\"]+3, 4)));\n    \n        // in case it is not a simple number but an unevaluated expression\n        options'hash[\"precision\"] := N(Eval(options'hash[\"precision\"]));\n    \n        // store range in options\n        options'hash[\"xrange\"] := {range[1], range[2]};\n    \n        // compute the separation between grid points\n        delta := N(Eval( (range[2] - range[1]) / (options'hash[\"points\"]) ));\n    \n        // check that the input parameters are valid (all numbers)\n        Check(IsNumber(range[1]) And? IsNumber(range[2]) And? IsNumber(options'hash[\"points\"]) And? IsNumber(options'hash[\"precision\"]),\n                \"Argument\",\n                \"Plot2D: Error: plotting range '\"\n                :(PipeToString()Write(range))\n                :\"' and/or the number of points '\"\n                :(PipeToString()Write(options'hash[\"points\"]))\n                :\"' and/or precision '\"\n                :(PipeToString()Write(options'hash[\"precision\"]))\n                :\"' is not numeric\"\n        );\n        // loop over functions in the list\n        ForEach(func, func'list)\n        [\n                // obtain name of variable\n                var := VarList(func);        // variable name in a one-element list\n                Check(Length(var)<=?1, \"Argument\", \"Plot2D: Error: expression is not a function of one variable: \"\n                        :(PipeToString()Write(func))\n                );\n                // Allow plotting of constant functions\n                If(Length(var)=?0, var:={dummy});\n                // store variable name if not already done so\n                If(\n                        options'hash[\"xname\"] =? \"\",\n                        options'hash[\"xname\"] := ToString(VarList(var)[1])\n                );\n                // store function name in options\n                DestructiveAppend(options'hash[\"yname\"], PipeToString()Write(func));\n                // compute the first point to see if it's okay\n                c := range[1];\n                fc := N(Eval(Apply({var, func}, {c})));\n                Check(IsNumber(fc) Or? fc=?Infinity Or? fc=? -Infinity Or? fc=?Undefined,\n                        \"Argument\", \n                        \"Plot2D: Error: cannot evaluate function '\"\n                        :(PipeToString()Write(func))\n                        :\"' at point '\"\n                        :(PipeToString()Write(c))\n                        :\"' to a number, instead got '\"\n                        :(PipeToString()Write(fc))\n                        :\"'\"\n                );\n                // compute all other data points\n                DestructiveAppend(all'values,  Plot2D'get'data(func, var, c, fc, delta, options'hash) );\n        \n                If(InVerboseMode(), Echo({\"Plot2D: using \", Length(all'values[Length(all'values)]), \" points for function \", func}), True);\n        ];\n    \n        // call the specified output backend\n        Plot2DOutputs()[options'hash[\"output\"]] @ {all'values, options'hash};\n];\n\n//HoldArgument(\"Plot2D\", range);\n//HoldArgument(\"Plot2D\", options);\nHoldArgumentNumber(\"Plot2D\", 2, 2);\nHoldArgumentNumber(\"Plot2D\", 3, 2);\nHoldArgumentNumber(\"Plot2D\", 3, 3);\n\n\n\n//Retract(\"Plot2D'get'data\", *);\n/// this is the middle-level plotting routine; it generates the initial\n/// grid, calls the adaptive routine, and gathers data points.\n/// func must be just one function (not a list)\nPlot2D'get'data(_func, _var, _x'init, _y'init, _delta'x, _options'hash) <--\n[\n        Local(i, a, fa, b, fb, c, fc, result);\n        // initialize list by first points (later will always use Rest() to exclude first points of subintervals)\n        result := { {c,fc} := {x'init, y'init} };\n        For(i:=0, i<?options'hash[\"points\"], i++)\n        [\n                {a,fa} := {c, fc};        // this is to save time but here a = x'init + i*delta'x\n                // build subintervals\n                {b, c} := N(Eval({x'init + (i+1/2)*delta'x, x'init + (i+1)*delta'x}));        // this is not computed using \"a\" to reduce roundoff error\n                {fb, fc} := N(Eval(MapSingle({var, func}, {b, c})));\n                result := Concat(result,\n                        Rest(Plot2D'adaptive(func, var, {a,b,c}, {fa, fb, fc}, options'hash[\"depth\"],\n                                // since we are dividing into \"points\" subintervals, we need to relax precision\n                                options'hash[\"precision\"]*options'hash[\"points\"] )));\n        ];\n    \n        result;\n];\n\n//////////////////////////////////////////////////\n/// Plot2D'adaptive --- core routine to collect data\n//////////////////////////////////////////////////\n/*\n        Plot2D'adaptive returns a list of pairs of coordinates { {x1,y1}, {x2,y2},...}\n        All arguments except f() and var must be numbers. var is a one-element list containing the independent variable. The \"a,b,c\" and \"fa, fb, fc\" arguments are values of the function that are already computed -- we don't want to recompute them once more.\n        See documentation (Algorithms.chapt.txt) for the description of the algorithm.\n*/\n\n//Retract(\"Plot2D'adaptive\", *);\nPlot2D'adaptive(_func, _var, {_a,_b,_c}, {_fa, _fb, _fc}, _depth, _epsilon) <--\n[\n        Local(a1, b1, fa1, fb1);\n\n        a1 := N(Eval((a+b)/2));\n        b1 := N(Eval((b+c)/2));\n        {fa1, fb1} := N(Eval(MapSingle({var, func}, {a1, b1})));\n        If(\n                depth<=?0 Or?\n                (\n                  // condition for the values not to oscillate too rapidly\n                  sign'change(fa, fa1, fb) + sign'change(fa1, fb, fb1) + sign'change(fb, fb1, fc) <=? 2\n                  And?\n                  // condition for the values not to change too rapidly\n                  N(Eval(Abs( (fa-5*fa1+9*fb-7*fb1+2*fc)/24 ) ))        // this is the Simpson quadrature for the (fb,fb1) subinterval (using points b,b1,c), subtracted from the 4-point Newton-Cotes quadrature for the (fb,fb1) subinterval (using points a, a1, b, b1)\n                          <=? N(Eval( epsilon*(        // the expression here will be nonnegative because we subtract the minimum value\n                    //(fa+fc+2*fb+4*(fa1+fb1))/12        // this is 1/4 of the Simpson quadrature on the whole interval\n                        (5*fb+8*fb1-fc)/12        // this is the Simpson quadrature for the (fb,f1) subinterval\n                        - Minimum({fa,fa1,fb,fb1,fc}) ) ) )\n                ),\n                // okay, do not refine any more\n                {{a,fa}, {a1,fa1}, {b,fb}, {b1,fb1}, {c,fc}},\n                // not okay, need to refine more\n                Concat(\n                        // recursive call on two halves of the interval; relax precision by factor of 2\n                        Plot2D'adaptive(func, var, {a, a1, b}, {fa, fa1, fb}, depth-1, epsilon*2),        // Rest() omits the pair {b, fb}\n                        Rest(Plot2D'adaptive(func, var, {b, b1, c}, {fb, fb1, fc}, depth-1, epsilon*2))\n                )\n        );\n];\n\n];        // LocalSymbols()\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/_2d/plot2d.mpw";
        scriptMap.put("Plot2D",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// Backends for 3D plotting\n//////////////////////////////////////////////////\n\n/// List of all defined backends and their symbolic labels.\n/// Add any new backends here\nPlot3DS'outputs() := {\n        {\"default\", \"data\"},\n        {\"data\", \"Plot3DS'data\"},\n};\n\n/*\n        How backends work:\n        Plot3DS'<backend>(values, options'hash)\n        options'hash is a hash that contains all plotting options:\n        [\"xrange\"] - a list of {x1, x2}, [\"xname\"] - name of the variable to plot, same for \"yrange\";\n        [\"zname\"] - array of string representations of the function(s), and perhaps other options relevant to the particular backend.\n        {values} is a list of lists of triples of the form {{{x1, y1, z1}, {x2, y2, z2}, ...}, {{x1, y1, t1}, {x2, y2, t2}, ...}, ...} corresponding to the functions z(x,y), t(x,y), ... to be plotted. The points x[i], y[i] are not necessarily the same for all functions.\n        The backend should prepare the graph of the function(s). The \"datafile\" backend Plot3DS'datafile(values, options'hash) may be used to output all data to file(s), in which case the file name should be given by the value options'hash[\"filename\"]. Multiple files are created with names obtained by appending numbers to the filename.\n        Note that the \"data\" backend does not do anything and simply returns the data.\n        The backend Plot3DS'datafile takes care not to write \"Infinity\" or \"Undefined\" data points (it just ignores them). Custom backends should either use Plot3DS'datafile to prepare a file, or take care of this themselves.\n*/\n\n/// trivial backend: return data list (do not confuse with Plot3DS'get'data() defined in the main code which is the middle-level plotting routine)\nPlot3DS'data(values_IsList, _options'hash) <-- values;\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/_3d/backends.mpw";
        scriptMap.put("Plot3DS'outputs",scriptString);
        scriptMap.put("Plot3DS'data",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// Plot3DS --- adaptive three-dimensional surface plotting\n//////////////////////////////////////////////////\n\n/// definitions of backends\n//LoadScriptOnce(\"plots.rep/backends_3d.mpi\");\n\n/*\n        Plot3DS is an interface for various backends (Plot3DS'...). It calls\nPlot3DS'get'data to obtain the list of points and values, and then it calls\nPlot3DS'<backend> on that data.\n\n        Algorithm for Plot3DS'get'data:\n        1) Split the given square into Quotient(Sqrt(points)+1, 2) subsquares, and split each subsquare into 4 parts.\n        2) For each of the parts: evaluate function values and call Plot3DS'adaptive\n        3) concatenate resulting lists and return\n*/\n\n        LocalSymbols(var, func, xrange, yrange, option, options'list, xdelta, ydelta, options'hash, cx, cy, fc, all'values, dummy)\n[\n\n// declaration of Plot3DS with variable number of arguments\nFunction() Plot3DS(func);\nFunction() Plot3DS(func, xrange, yrange);\nFunction() Plot3DS(func, xrange, yrange, options, ...);\n\n\n/// interface routines\n1 # Plot3DS(_func) <-- (\"Plot3DS\" @ {func, -5:5, -5:5});\n2 # Plot3DS(_func, _xrange, _yrange) <-- (\"Plot3DS\" @ {func, xrange, yrange, {}});\n3 # Plot3DS(_func, _xrange, _yrange, option_IsFunction) _ (Type(option) =? \"->\" ) <-- (\"Plot3DS\" @ {func, xrange, yrange, {option}});\n\n/// Plot a single function\n5 # Plot3DS(_func, _xrange, _yrange, options'list_IsList)_(Not? IsList(func)) <-- (\"Plot3DS\" @ {{func}, xrange, yrange, options'list});\n\n/// Top-level 3D plotting routine:\n/// plot several functions sharing the same ranges and other options\n4 # Plot3DS(func'list_IsList, _xrange, _yrange, options'list_IsList) <--\n[\n        Local(var, func, xdelta, ydelta, options'hash, cx, cy, fc, all'values, dummy);\n        // this will be a list of all computed values\n        all'values := {};\n        options'hash := \"OptionsListToHash\" @ {options'list};\n        // this will be a string - name of independent variable\n        options'hash[\"xname\"] := \"\";\n        options'hash[\"yname\"] := \"\";\n        // this will be a list of strings - printed forms of functions being plotted\n        options'hash[\"zname\"] := {};\n        // parse range\n        If (\n                Type(xrange) =? \"->\",        // variable also specified -- ignore for now, store in options\n                [\n                        // store alternative variable name\n                        options'hash[\"xname\"] := ToString(xrange[1]);\n                        xrange := xrange[2];\n                ]\n        );\n        If (\n                Type(yrange) =? \"->\" ,        // variable also specified -- ignore for now, store in options\n                [\n                        // store alternative variable name\n                        options'hash[\"yname\"] := ToString(yrange[1]);\n                        yrange := yrange[2];\n                ]\n        );\n        If(\n                Type(xrange) =? \":\",        // simple range\n                xrange := N(Eval({xrange[1], xrange[2]}))\n        );\n        If(\n                Type(yrange) =? \":\",        // simple range\n                yrange := N(Eval({yrange[1], yrange[2]}))\n        );\n        // set default option values\n        If(\n                options'hash[\"points\"] =? Empty,\n                options'hash[\"points\"] := 10        // default # of points along each axis\n        );\n        If(\n                options'hash[\"xpoints\"] =? Empty,\n                options'hash[\"xpoints\"] := options'hash[\"points\"]\n        );\n        If(\n                options'hash[\"ypoints\"] =? Empty,\n                options'hash[\"ypoints\"] := options'hash[\"points\"]\n        );\n\n        If(\n                options'hash[\"depth\"] =? Empty,\n                options'hash[\"depth\"] := 2\n        );\n        If(\n                options'hash[\"precision\"] =? Empty,\n                options'hash[\"precision\"] := 0.0001\n        );\n        If(\n                options'hash[\"hidden\"] =? Empty Or? Not? IsBoolean(options'hash[\"hidden\"]),\n                options'hash[\"hidden\"] := True\n        );\n        If(\n                options'hash[\"output\"] =? Empty Or? IsString(options'hash[\"output\"]) And? Plot3DS'outputs()[options'hash[\"output\"]] =? Empty,\n                options'hash[\"output\"] := Plot3DS'outputs()[\"default\"]\n        );\n        // a \"filename\" parameter is required when using data file\n        If(\n                options'hash[\"output\"] =? \"datafile\" And? options'hash[\"filename\"] =? Empty,\n                options'hash[\"filename\"] := \"output.data\"\n        );\n        options'hash[\"used depth\"] := options'hash[\"depth\"];\n        // we will divide each subsquare in 4 parts, so divide number of points by 2 now\n        options'hash[\"xpoints\"] := N(Eval(Quotient(options'hash[\"xpoints\"]+1, 2)));\n        options'hash[\"ypoints\"] := N(Eval(Quotient(options'hash[\"ypoints\"]+1, 2)));\n        // in case it is not a simple number but an unevaluated expression\n        options'hash[\"precision\"] := N(Eval(options'hash[\"precision\"]));\n        // store range in options\n        options'hash[\"xrange\"] := {xrange[1], xrange[2]};\n        options'hash[\"yrange\"] := {yrange[1], yrange[2]};\n        // compute the separation between grid points\n        xdelta := N(Eval( (xrange[2] - xrange[1]) / (options'hash[\"xpoints\"]) ) );\n        ydelta := N(Eval( (yrange[2] - yrange[1]) / (options'hash[\"ypoints\"]) ) );\n        // check that the input parameters are valid (all numbers)\n        Check(IsNumericList({xrange[1], xrange[2], options'hash[\"xpoints\"], options'hash[\"ypoints\"], options'hash[\"precision\"]}),\n                \"Argument\", \n                \"Plot3DS: Error: plotting ranges '\"\n                :(PipeToString()Write(xrange, yrange))\n                :\"' and/or the number of points '\"\n                :(PipeToString()Write(options'hash[\"xpoints\"], options'hash[\"ypoints\"]))\n                :\"' and/or precision '\"\n                :(PipeToString()Write(options'hash[\"precision\"]))\n                :\"' is not numeric\"\n        );\n        // loop over functions in the list\n        ForEach(func, func'list)\n        [\n                // obtain name of variable\n                var := VarList(func);        // variable names in a list\n            Check(Length(var)<=?2, \"Argument\", \"Plot3DS: Error: expression is not a function of at most two variables: \"\n                        :(PipeToString()Write(func))\n                );\n                // Allow plotting of constant functions\n                If(Length(var)=?0, var:={dummy, dummy});\n                If(Length(var)=?1, var:={var[1], dummy});\n                // store variable name if not already done so\n                If(\n                        options'hash[\"xname\"] =? \"\",\n                        options'hash[\"xname\"] := ToString(var[1])\n                );\n                If(\n                        options'hash[\"yname\"] =? \"\",\n                        options'hash[\"yname\"] := ToString(var[2])\n                );\n                // store function name in options\n                DestructiveAppend(options'hash[\"zname\"], PipeToString()Write(func));\n                // compute the first point to see if it's okay\n                cx := xrange[1]; cy := yrange[1];\n                fc := N(Eval(Apply({var, func}, {cx, cy})));\n                Check(IsNumber(fc) Or? fc=?Infinity Or? fc=? -Infinity Or? fc=?Undefined,\n                        \"Argument\", \n                        \"Plot3DS: Error: cannot evaluate function '\"\n                        :(PipeToString()Write(func))\n                        :\"' at point '\"\n                        :(PipeToString()Write(cx, cy))\n                        :\"' to a number, instead got '\"\n                        :(PipeToString()Write(fc))\n                        :\"'\"\n                );\n                // compute all other data points\n                DestructiveAppend(all'values, RemoveRepeated(HeapSort( Plot3DS'get'data(func, var, {cx, cy, fc}, {xdelta, ydelta}, options'hash), Hold({{x,y},x[1]<?y[1] Or? x[1] =? y[1] And? x[2] <=? y[2] } ) )) );\n                If(InVerboseMode(), Echo({\"Plot3DS: using \", Length(all'values[Length(all'values)]), \" points for function \", func}), True);\n                If(InVerboseMode(), Echo({\"Plot3DS: max. used \", 2^(options'hash[\"depth\"] - options'hash[\"used depth\"]), \"subdivisions for \", func}), True);\n        ];\n        // call the specified output backend\n        Plot3DS'outputs()[options'hash[\"output\"]] @ {all'values, options'hash};\n];\n\nHoldArgumentNumber(\"Plot3DS\", 3, 2);\nHoldArgumentNumber(\"Plot3DS\", 3, 3);\nHoldArgumentNumber(\"Plot3DS\", 4, 2);\nHoldArgumentNumber(\"Plot3DS\", 4, 3);\nHoldArgumentNumber(\"Plot3DS\", 4, 4);\n\n/// this is the middle-level plotting routine; it generates the initial\n/// grid, calls the adaptive routine, and gathers data points.\n/// func must be just one function (not a list).\n/// init'values is a list with values {x,y,f}; deltas is a list {delta'x, delta'y}.\nPlot3DS'get'data(_func, _var, _init'values, _deltas, _options'hash) <--\n[\n        Local(i, j, xa, ya, fa, xb, yb, fb, result, row'cache);\n        // compute all grid points in the 0th row in the y direction;\n        // store this array in a temporary cache;\n        // also store this in the final list (\"result\");\n        // then, go in the y direction and compute the 1th row; call the adaptive routine and add all points it gives along the way. update the row cache along the way.\n        // in cases when depth=0, the adaptive routine gives no extra points, and we must make sure that the \"result\" array contains the grid in exact order\n        row'cache := {init'values};\n        For(i:=1, i<=?options'hash[\"ypoints\"], i++)\n        [\n                ya := N(Eval(init'values[2]+i*deltas[2]));\n                DestructiveAppend(row'cache, {init'values[1], ya, N(Eval(Apply({var, func}, {init'values[1], ya})))});\n        ];\n        result := row'cache;\n        // now loop over the x direction\n        For(i:=1, i<=?options'hash[\"xpoints\"], i++)\n        [\n                // start the next row\n                // the 0th point\n                xa := N(Eval(init'values[1]+i*deltas[1]));\n                ya := init'values[2];\n                fa := N(Eval(Apply({var, func}, {xa, ya})));\n                DestructiveAppend(result, {xa, ya, fa});\n                // now loop at each grid point in y direction\n                For(j:=1, j<=?options'hash[\"ypoints\"], j++)\n                [        // now we need to plot the data inside the following square:\n                        //        p  b\n                        //        r  a\n                        // xa, ya, fa are the values at the point a; the points p and r are stored as row'cache[j+1] and row'cache[j]. We just need to compute the point q and update the row'cache with the value at point a, and update xa, ya, fa also with b.\n                        yb := N(Eval(init'values[2] + j*deltas[2]));\n                        fb := N(Eval(Apply({var, func}, {xa, yb})));\n                        result := Concat(result, Plot3DS'adaptive(func, var, {row'cache[j][1], ya, xa, yb, row'cache[j][3], row'cache[j+1][3], fa, fb}, options'hash[\"depth\"],\n                                // since we are dividing into \"points\" subintervals, we need to relax precision\n                                options'hash[\"precision\"] * options'hash[\"xpoints\"] * options'hash[\"ypoints\"], options'hash ));\n                        // update row'cache\n                        row'cache[j] := {xa, ya, fa};\n                        ya := yb;\n                        fa := fb;\n                        DestructiveAppend(result, {xa, ya, fa});\n                ];\n        ];\n\n        result;\n];\n\n//////////////////////////////////////////////////\n/// Plot3DS'adaptive --- core routine to collect data\n//////////////////////////////////////////////////\n/*\n        Plot3DS'adaptive returns a list of triples of coordinates { {x1,y1,z1}, {x2,y2,z2},...} inside a given square. The corners of the square are not returned (they are already computed).\n        All arguments except f() and var must be numbers. var is a two-element list containing the independent variables. The \"square\" argument contains the values of the function that have been already computed -- we don't want to recompute them once more.\n        square = {x1, y1, x2, y2, f11, f12, f21, f22}\n\n        So the routine will return the list f13, f31, f33, f32, f23 and any points returned by recursive calls on subsquares.\n        See the Algo book for the description of the algorithm.\n*/\n\n10 # Plot3DS'adaptive(_func, _var, _square, 0, _epsilon, _options'hash) <-- {};\n20 # Plot3DS'adaptive(_func, _var, {_x1, _y1, _x2, _y2, _f11, _f12, _f21, _f22}, _depth, _epsilon, _options'hash) <--\n[\n        Local(x3, y3, f13, f31, f33, f32, f23, result);\n\n        // if we are here, it means we used one more recursion level\n        options'hash[\"used depth\"] := depth-1;\n        // bisection\n        x3 := N(Eval((x1+x2)/2));\n        y3 := N(Eval((y1+y2)/2));\n        // compute new values\n        // use the confusing Map semantics: the list of all x's separately from the list of all y's\n        f13 := N(Eval(Apply({var, func}, {x1, y3})));\n        f31 := N(Eval(Apply({var, func}, {x3, y1})));\n        f33 := N(Eval(Apply({var, func}, {x3, y3})));\n        f32 := N(Eval(Apply({var, func}, {x3, y2})));\n        f23 := N(Eval(Apply({var, func}, {x2, y3})));\n        result := {{x1,y3,f13}, {x3, y1, f31}, {x3, y3, f33}, {x3, y2, f32}, {x2, y3, f23}};\n/*\ny2        12  32  22\n\n        13  33  23\n\ny1        11  31  21\n\n        x1      x2\n*/\n        If(\n                // condition for the values not to oscillate too rapidly\n                sign'change(f11,f13,f12) + sign'change(f13,f12,f32) + sign'change(f12,f32,f22) <=? 2 And? sign'change(f22,f23,f21) + sign'change(f23,f21,f31) + sign'change(f21,f31,f11) <=? 2 And? \n                \n                // condition for the values not to change too rapidly\n                N(Eval(Abs( (f11-f23)/2-(f12-f21)/3+(f22-f13)/6+2*(f32-f33)/3 )))\n                        <=? N(Eval( epsilon*(        // the expression here will be nonnegative because we subtract the minimum value\n                        // cubature normalized to 1\n                (f11 + f12 + f21 + f22)/12 + 2*f33/3\n                - Minimum({f11, f12, f21, f22, f13, f31, f33, f32, f23}) ) ) )\n                ,\n                // okay, do not refine any more\n                result,\n                // not okay, need to refine more\n                Concat(\n                        // first, give the extra points,\n                        result,\n                        // then perform recursive calls on four quarters of the original square; relax precision by factor of 4\n                        Plot3DS'adaptive(func, var, {x1, y1, x3, y3, f11, f13, f31, f33}, depth-1, epsilon*4, options'hash),\n                        Plot3DS'adaptive(func, var, {x1, y3, x3, y2, f13, f12, f33, f32}, depth-1, epsilon*4, options'hash),\n                        Plot3DS'adaptive(func, var, {x3, y1, x2, y3, f31, f33, f21, f23}, depth-1, epsilon*4, options'hash),\n                        Plot3DS'adaptive(func, var, {x3, y3, x2, y2, f33, f32, f23, f22}, depth-1, epsilon*4, options'hash)\n                )\n        );\n];\n\n];        // LocalSymbols()\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/_3d/plot3ds.mpw";
        scriptMap.put("Plot3DS",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// utility function: check whether the derivative changes sign in given 3 numbers, return 0 or 1. Also return 1 when one of the arguments is not a number.\nsign'change(x,y,z) :=\nIf(\n        IsNumber(x) And? IsNumber(y) And? IsNumber(z)\n        And? Not? (\n                x>?y And? y<?z Or? \n                \n                x<?y And? y>?z\n        )\n, 0, 1); \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/plots/sign'change.mpw";
        scriptMap.put("sign'change",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # AllSatisfy(pred_IsString,lst_IsList) <-- Apply(\"And?\",(MapSingle(pred,lst)));\n\n20 # AllSatisfy(_pred,_lst) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/AllSatisfy.mpw";
        scriptMap.put("AllSatisfy",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// TODO FIXME document this: FloatIsInt returns True if the argument is integer after removing potential trailing\n/// zeroes after the decimal point\n// but in fact this should be a call to BigNumber::IsIntValue()\nFloatIsInt(_x) <--\n   [\n     x:=N(Eval(x));\n     Local(prec,result,n);\n     Bind(prec,BuiltinPrecisionGet());\n     If(IsZero(x),Bind(n,2),\n     If(x>?0,\n       Bind(n,2+FloorN(N(FastLog(x)/FastLog(10)))),\n       Bind(n,2+FloorN(N(FastLog(-x)/FastLog(10))))\n       ));\n     BuiltinPrecisionSet(n+prec);\n     Bind(result,IsZero(RoundTo(x-Floor(x),prec)) Or? IsZero(RoundTo(x-Ceil(x),prec)));\n     BuiltinPrecisionSet(prec);\n     result;\n   ];\n//  \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/FloatIsInt.mpw";
        scriptMap.put("FloatIsInt",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// HasExpr --- test for an expression containing a subexpression\n/// for checking dependence on variables, this may be faster than using VarList or IsFreeOf and this also can be used on non-variables, e.g. strings or numbers or other atoms or even on non-atoms\n// an expression contains itself -- check early\n10 # HasExpr(_expr, _atom) _ IsEqual(expr, atom) <-- True;\n// an atom contains itself\n15 # HasExpr(expr_IsAtom, _atom) <-- IsEqual(expr, atom);\n// a list contains an atom if one element contains it\n// we test for lists now because lists are also functions\n// first take care of the empty list:\n19 # HasExpr({}, _atom) <-- False;\n20 # HasExpr(expr_IsList, _atom) <-- HasExpr(First(expr), atom) Or? HasExpr(Rest(expr), atom);\n// a function contains an atom if one of its arguments contains it\n30 # HasExpr(expr_IsFunction, _atom) <-- HasExpr(Rest(FunctionToList(expr)), atom);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasExpr.mpw";
        scriptMap.put("HasExpr",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Analyse arithmetic expressions\n\nHasExprArith(expr, atom) := HasExprSome(expr, atom, {ToAtom(\"+\"), ToAtom(\"-\"), *, /});\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasExprArith.mpw";
        scriptMap.put("HasExprArith",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Same except only look at function arguments for functions in a given list\nHasExprSome(_expr, _atom, _look'list) _ IsEqual(expr, atom) <-- True;\n// an atom contains itself\n15 # HasExprSome(expr_IsAtom, _atom, _look'list) <-- IsEqual(expr, atom);\n// a list contains an atom if one element contains it\n// we test for lists now because lists are also functions\n// first take care of the empty list:\n19 # HasExprSome({}, _atom, _look'list) <-- False;\n20 # HasExprSome(expr_IsList, _atom, _look'list) <-- HasExprSome(First(expr), atom, look'list) Or? HasExprSome(Rest(expr), atom, look'list);\n// a function contains an atom if one of its arguments contains it\n// first deal with functions that do not belong to the list: return False since we have already checked it at #15\n25 # HasExprSome(expr_IsFunction, _atom, _look'list)_(Not? Contains(look'list, ToAtom(Type(expr)))) <-- False;\n// a function contains an atom if one of its arguments contains it\n30 # HasExprSome(expr_IsFunction, _atom, _look'list) <-- HasExprSome(Rest(FunctionToList(expr)), atom, look'list);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasExprSome.mpw";
        scriptMap.put("HasExprSome",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// HasFunc --- test for an expression containing a function\n/// function name given as string.\n10 # HasFunc(_expr, string_IsString) <-- HasFunc(expr, ToAtom(string));\n/// function given as atom.\n// atom contains no functions\n10 # HasFunc(expr_IsAtom, atom_IsAtom) <-- False;\n// a list contains the function List so we test it together with functions\n// a function contains itself, or maybe an argument contains it\n20 # HasFunc(expr_IsFunction, atom_IsAtom) <-- IsEqual(First(FunctionToList(expr)), atom) Or? ListHasFunc(Rest(FunctionToList(expr)), atom);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasFunc.mpw";
        scriptMap.put("HasFunc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Analyse arithmetic expressions\n\nHasFuncArith(expr, atom) := HasFuncSome(expr, atom, {ToAtom(\"+\"), ToAtom(\"-\"), *, /});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasFuncArith.mpw";
        scriptMap.put("HasFuncArith",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// function name given as string.\n10 # HasFuncSome(_expr, string_IsString, _look'list) <-- HasFuncSome(expr, ToAtom(string), look'list);\n/// function given as atom.\n// atom contains no functions\n10 # HasFuncSome(expr_IsAtom, atom_IsAtom, _look'list) <-- False;\n// a list contains the function List so we test it together with functions\n// a function contains itself, or maybe an argument contains it\n\n// first deal with functions that do not belong to the list: return top level function\n15 # HasFuncSome(expr_IsFunction, atom_IsAtom, _look'list)_(Not? Contains(look'list, ToAtom(Type(expr)))) <-- IsEqual(First(FunctionToList(expr)), atom);\n// function belongs to the list - check its arguments\n20 # HasFuncSome(expr_IsFunction, atom_IsAtom, _look'list) <-- IsEqual(First(FunctionToList(expr)), atom) Or? ListHasFuncSome(Rest(FunctionToList(expr)), atom, look'list);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/HasFuncSome.mpw";
        scriptMap.put("HasFuncSome",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n0 # IsBoolType(True) <-- True;\n0 # IsBoolType(False) <-- True;\n1 # IsBoolType(_anythingelse) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsBoolType.mpw";
        scriptMap.put("IsBoolType",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction (\"IsBoolean\", {x})\n        (x=?True) Or? (x=?False) Or? IsFunction(x) And? Contains({\"=?\", \">?\", \"<?\", \">=?\", \"<=?\", \"!=?\", \"And?\", \"Not?\", \"Or?\"}, Type(x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsBoolean.mpw";
        scriptMap.put("IsBoolean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsConstant(_n) <-- (VarList(n) =? {});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsConstant.mpw";
        scriptMap.put("IsConstant",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsDiagonal(A_IsMatrix) <--\n[\n        Local(i,j,m,n,result);\n        m      := Length(A);\n        n      := Length(A[1]);\n        result := (m=?n);    //    must be a square matrix\n        \n        i:=2;\n    While(i<=?m And? result)\n     [\n             j:=1;\n             While(j<=?n And? result)\n             [\n                     result:= (i=?j Or? A[i][j] =? 0);\n                     j++;\n             ];\n             i++;\n         ];\n        If(m=?2, [ result := result And? (A=?Transpose(A)); ]        );\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsDiagonal.mpw";
        scriptMap.put("IsDiagonal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"IsEquation\",*);\n\n10 # IsEquation(expr_IsAtom) <-- False;\n\n12 # IsEquation(_expr) <-- FunctionToList(expr)[1] =? == ;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsEquation.mpw";
        scriptMap.put("IsEquation",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsEven(n) := IsInteger(n) And? ( BitAnd(n,1)  =? 0 );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsEven.mpw";
        scriptMap.put("IsEven",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsEvenFunction(f,x):= (f =? Eval(Subst(x,-x)f));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsEvenFunction.mpw";
        scriptMap.put("IsEvenFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsHermitian(A_IsMatrix) <-- (Conjugate(Transpose(A))=?A);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsHermitian.mpw";
        scriptMap.put("IsHermitian",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsIdempotent(A_IsMatrix) <-- (A^2 =? A);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsIdempotent.mpw";
        scriptMap.put("IsIdempotent",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # IsInfinity(Infinity) <-- True;\n10 # IsInfinity(-(_x)) <-- IsInfinity(x);\n\n// This is just one example, we probably need to extend this further to include all\n// cases for f*Infinity where f can be guaranteed to not be zero\n11 # IsInfinity(Sign(_x)*y_IsInfinity) <-- True;\n\n60000 # IsInfinity(_x) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsInfinity.mpw";
        scriptMap.put("IsInfinity",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsLowerTriangular(A_IsMatrix) <-- (IsUpperTriangular(Transpose(A)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsLowerTriangular.mpw";
        scriptMap.put("IsLowerTriangular",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"CanBeMonomial\",*);\n//Retract(\"IsMonomial\",*);\n\n10 # CanBeMonomial(_expr)_(Type(expr)=?\"UniVariate\") <-- False;\n\n10 # CanBeMonomial(_expr)<--Not? (HasFunc(expr,ToAtom(\"+\")) Or? HasFunc(expr,ToAtom(\"-\")));\n\n10 # IsMonomial(expr_CanBeMonomial) <-- \n[\n    Local(r);\n    If( IsRationalFunction(expr),\n        r := (VarList(Denominator(expr)) =? {}),\n        r := True\n    );\n];\n\n15 # IsMonomial(_expr) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsMonomial.mpw";
        scriptMap.put("IsMonomial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNegativeInteger(x):= IsInteger(x) And? x <? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNegativeInteger.mpw";
        scriptMap.put("IsNegativeInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNegativeNumber(x):= IsNumber(x) And? x <? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNegativeNumber.mpw";
        scriptMap.put("IsNegativeNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* See if a number, when evaluated, would be a positive real value */\n\nIsNegativeReal(_r) <--\n[\n  r:=N(Eval(r));\n  (IsNumber(r) And? r <=? 0);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNegativeReal.mpw";
        scriptMap.put("IsNegativeReal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNonNegativeInteger(x):= IsInteger(x) And? x >=? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNonNegativeInteger.mpw";
        scriptMap.put("IsNonNegativeInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNonNegativeNumber(x):= IsNumber(x) And? x >=? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNonNegativeNumber.mpw";
        scriptMap.put("IsNonNegativeNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsNonZeroInteger(x) := (IsInteger(x) And? x !=? 0);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNonZeroInteger.mpw";
        scriptMap.put("IsNonZeroInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n10 # IsNotZero(x_IsNumber)       <-- ( RoundTo(x,BuiltinPrecisionGet()) !=? 0);\n*/\n\n\n10 # IsNotZero(x_IsNumber) <-- ( AbsN(x)  >=? PowerN(10, -BuiltinPrecisionGet()));\n10 # IsNotZero(x_IsInfinity) <-- True;\n60000 # IsNotZero(_x) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNotZero.mpw";
        scriptMap.put("IsNotZero",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// check that all items in the list are numbers\nIsNumericList(_arg'list) <-- IsList(arg'list) And?\n        (\"And?\" @ (MapSingle(Hold({{x},IsNumber(N(Eval(x)))}), arg'list)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsNumericList.mpw";
        scriptMap.put("IsNumericList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsOdd(n)  := IsInteger(n) And? ( BitAnd(n,1)  =? 1 );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsOdd.mpw";
        scriptMap.put("IsOdd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsOddFunction(f,x):= (f =? Eval(-Subst(x,-x)f));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsOddFunction.mpw";
        scriptMap.put("IsOddFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// why do we need this? Why doesn't x=1 not work?\n10 # IsOne(x_IsNumber) <-- IsZero(SubtractN(x,1));\n60000 # IsOne(_x) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsOne.mpw";
        scriptMap.put("IsOne",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsOrthogonal(A_IsMatrix) <-- (Transpose(A)*A=?Identity(Length(A)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsOrthogonal.mpw";
        scriptMap.put("IsOrthogonal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"IsPolynomial\",*);\n\n10 # IsPolynomial(expr_IsFunction) <-- \n[\n    Local(x,vars);\n    vars := VarList(expr);\n    If(Length(vars)>?1,vars:=HeapSort(vars,\"IsGreaterThan\"));    \n    x := vars[1];\n    IsPolynomial(expr,x);\n];\n\n15 # IsPolynomial(_expr) <-- False;\n\n\n10 # IsPolynomial(_expr,_var)_(CanBeUni(var,expr)) <-- True;\n\n15 # IsPolynomial(_expr,_var) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsPolynomial.mpw";
        scriptMap.put("IsPolynomial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"IsPolynomialOverIntegers\",*);\n\n10 # IsPolynomialOverIntegers(expr_IsFunction) <-- \n[\n    Local(x,vars);\n    vars := VarList(expr);\n    If(Length(vars)>?1,vars:=HeapSort(vars,\"IsGreaterThan\"));    \n    x := vars[1];\n    IsPolynomialOverIntegers(expr,x);\n];\n\n15 # IsPolynomialOverIntegers(_expr) <-- False;\n\n\n10 # IsPolynomialOverIntegers(_expr,_var)_(CanBeUni(var,expr)) <--\n[\n    If( AllSatisfy(\"IsInteger\",Coef(expr,var,0 .. Degree(expr,var))),\n        True,\n        False\n      );\n];\n\n15 # IsPolynomialOverIntegers(_expr,_var) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsPolynomialOverIntegers.mpw";
        scriptMap.put("IsPolynomialOverIntegers",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsPositiveInteger(x):= IsInteger(x) And? x >? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsPositiveInteger.mpw";
        scriptMap.put("IsPositiveInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsPositiveNumber(x):= IsNumber(x) And? x >? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsPositiveNumber.mpw";
        scriptMap.put("IsPositiveNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* See if a number, when evaluated, would be a positive real value */\nIsPositiveReal(_r) <--\n[\n  r:=N(Eval(r));\n  (IsNumber(r) And? r >=? 0);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsPositiveReal.mpw";
        scriptMap.put("IsPositiveReal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* changed definition of IsRational, Nobbi 030529\nFunction(\"IsRational\",{aLeft}) Type(aLeft) = \"/\";\n\nFunction(\"IsRationalNumeric\",{aLeft})\n    Type(aLeft) = \"/\" And?\n    IsNumber(aLeft[1]) And?\n    IsNumber(aLeft[2]);\n\nIsRationalOrNumber(_x) <-- (IsNumber(x) Or? IsRationalNumeric(x));\n\n10 # IsRationalOrInteger(x_IsInteger) <-- True;\n10 # IsRationalOrInteger(x_IsInteger / y_IsInteger) <-- True;\n20 # IsRationalOrInteger(_x) <-- False;\n\n*/\n\n10 # IsRational(x_IsInteger) <-- True;\n10 # IsRational(x_IsInteger / y_IsInteger) <-- True;\n10 # IsRational(-(x_IsInteger / y_IsInteger)) <-- True;\n60000 # IsRational(_x) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsRational.mpw";
        scriptMap.put("IsRational",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"IsRationalFunction\",*);\n\n10 # IsRationalFunction(_expr)_(Length(VarList(expr))=?0) <-- False;\n\n15 # IsRationalFunction(_expr) <-- IsRationalFunction(expr,VarList(expr));\n\n10 # IsRationalFunction(expr_IsRationalOrNumber,_var) <-- False;\n\n15 # IsRationalFunction(_expr,var_IsAtom)_(Type(expr)=?\"/\" Or? Type(-expr)=?\"/\") <--\n[\n    If (IsPolynomial(Numerator(expr),var) And? IsPolynomial(Denominator(expr),var),\n        Contains(VarList(Denominator(expr)),var),\n        False\n    );\n];\n\n20 # IsRationalFunction(_expr,vars_IsList)_(Type(expr)=?\"/\" Or? Type(-expr)=?\"/\") <--\n[\n    If (IsPolynomial(Numerator(expr),vars) And? IsPolynomial(Denominator(expr),vars),\n        Intersection(vars, VarList(expr)) !=? {},\n        False\n    );\n];\n\n60000 # IsRationalFunction(_expr,_var) <-- False;\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsRationalFunction.mpw";
        scriptMap.put("IsRationalFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # IsRationalOrNumber(x_IsNumber) <-- True;\n10 # IsRationalOrNumber(x_IsNumber / y_IsNumber) <-- True;\n10 # IsRationalOrNumber(-(x_IsNumber / y_IsNumber)) <-- True;\n60000 # IsRationalOrNumber(_x) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsRationalOrNumber.mpw";
        scriptMap.put("IsRationalOrNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsSkewSymmetric(A_IsMatrix) <-- (Transpose(A)=?(-1*A));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsSkewSymmetric.mpw";
        scriptMap.put("IsSkewSymmetric",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// an expression free of the variable -- obviously not a sum of terms in it\n10 # IsSumOfTerms(_var,expr_IsFreeOf(var)) <-- False;\n\n// an Atom cannot be a sum of terms\n12 # IsSumOfTerms(_var,expr_IsAtom()) <-- False;\n\n// after being \"Listified\", expr is a sum of terms if headed by \"+\" or \"-\"\n14 # IsSumOfTerms(_var,expr_IsList())_(expr[1]=?ToAtom(\"+\") Or? expr[1]=?ToAtom(\"-\")) <-- True;\n\n// after being \"Listified\", an expr headed by \"*\" is not considered a sum \n// of terms unless one or the other operand is free of the variable\n16 # IsSumOfTerms(_var,expr_IsList())_(expr[1]=?ToAtom(\"*\")) <-- Or?(IsFreeOf(var,expr[2]),IsFreeOf(var,expr[3]));\n\n// after being \"Listified\", an expr headed by \"/\" is not considered a sum \n// of terms unless the denominator (only) is free of the variable\n18 # IsSumOfTerms(_var,expr_IsList())_(expr[1]=?ToAtom(\"/\")) <-- IsFreeOf(var,expr[3]);\n\n// after being \"Listified\", any other expression is not a sum of terms\n20 # IsSumOfTerms(_var,expr_IsList()) <-- False;\n\n// if we get to this point, FunctionToList the expression and try again\n22 # IsSumOfTerms(_var,_expr) <-- IsSumOfTerms(var,FunctionToList(expr));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsSumOfTerms.mpw";
        scriptMap.put("IsSumOfTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsSymmetric(A_IsMatrix) <-- (Transpose(A)=?A);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsSymmetric.mpw";
        scriptMap.put("IsSymmetric",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsUnitary(A_IsMatrix) <-- (Transpose(Conjugate(A))*A =? Identity(Length(A)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsUnitary.mpw";
        scriptMap.put("IsUnitary",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsUpperTriangular(A_IsMatrix) <--\n[\n        Local(i,j,m,n,result);\n        m:=Length(A);\n        n:=Length(A[1]);\n        i:=2;\n        result:=(m=?n);\n        While(i<=?m And? result)\n        [\n                j:=1;\n                While(j<=?n And? result)\n                [\n                        result:= (i<=?j Or? A[i][j] =? 0);\n                        j++;\n                ];\n                i++;\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsUpperTriangular.mpw";
        scriptMap.put("IsUpperTriangular",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsVariable(_expr) <-- (IsAtom(expr) And? Not?(expr=?Infinity) And? Not?(expr=? -Infinity) And? Not?(expr=?Undefined) And? Not?(IsNumber(N(Eval(expr)))));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsVariable.mpw";
        scriptMap.put("IsVariable",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//10 # IsZero(x_IsNumber) <-- (DivideN( Round( MultiplyN(x, 10^BuiltinPrecisionGet()) ), 10^BuiltinPrecisionGet() ) = 0);\n\n// these should be calls to MathSign() and the math library should do this. Or it should be just MathEquals(x,0).\n// for now, avoid underflow and avoid IsZero(10^(-BuiltinPrecisionGet())) returning True.\n10 # IsZero(x_IsNumber) <-- ( MathSign(x) =? 0 Or? AbsN(x)  <? PowerN(10, -BuiltinPrecisionGet()));\n60000 # IsZero(_x) <-- False;\n\n//Note:tk:moved here from univariate.rep.\n20 # IsZero(UniVariate(_var,_first,_coefs)) <-- IsZeroVector(coefs);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/IsZero.mpw";
        scriptMap.put("IsZero",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// ListHasFunc --- test for one of the elements of a list to contain a function\n/// this is mainly useful to test whether a list has nested lists, \n/// i.e. ListHasFunc({1,2,3}, List)=False and ListHasFunc({1,2,{3}}, List)=True.\n// need to exclude the List atom itself, so don't use FunctionToList\n19 # ListHasFunc({}, _atom) <-- False;\n20 # ListHasFunc(expr_IsList, atom_IsAtom) <-- HasFunc(First(expr), atom) Or? ListHasFunc(Rest(expr), atom);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/ListHasFunc.mpw";
        scriptMap.put("ListHasFunc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n19 # ListHasFuncSome({}, _atom, _look'list) <-- False;\n20 # ListHasFuncSome(expr_IsList, atom_IsAtom, _look'list) <-- HasFuncSome(First(expr), atom, look'list) Or? ListHasFuncSome(Rest(expr), atom, look'list);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/ListHasFuncSome.mpw";
        scriptMap.put("ListHasFuncSome",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # NoneSatisfy(pred_IsString,lst_IsList) <-- Not? Apply(\"Or?\",(MapSingle(pred,lst)));\n\n20 # NoneSatisfy(_pred,_lst) <-- True;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/NoneSatisfy.mpw";
        scriptMap.put("NoneSatisfy",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nIsScalar\nIsMatrix\nIsVector\nIsSquareMatrix\n*/\n\nLocalSymbols(p,x)\n[\n// test for a scalar\nFunction(\"IsScalar\",{x}) Not?(IsList(x));\n\n\n\n// test for a vector\nFunction(\"IsVector\",{x})\n   If(IsList(x),\n   Length(Select(x, IsList))=?0,\n   False);\n\n// test for a vector w/ element test p\nFunction(\"IsVector\",{p,x})\n[\n   If(IsList(x),\n   [\n      Local(i,n,result);\n      n:=Length(x);\n      i:=1;\n      result:=True;\n      While(i<=?n And? result)\n      [\n         result:=Apply(p,{x[i]});\n         i++;\n      ];\n      result;\n   ],\n   False);\n];\n\n// test for a matrix (dr)\nFunction(\"IsMatrix\",{x})\nIf(IsList(x) And? Length(x)>?0,\n[\n   Local(n);\n   n:=Length(x);\n   If(Length(Select(x, IsVector))=?n,\n   MapSingle(Length,x)=?Length(x[1])+ZeroVector(n),\n   False);\n],\nFalse);\n\n// test for a matrix w/ element test p (dr)\nFunction(\"IsMatrix\",{p,x})\nIf(IsMatrix(x),\n[\n   Local(i,j,m,n,result);\n   m:=Length(x);\n   n:=Length(x[1]);\n   i:=1;\n   result:=True;\n   While(i<=?m And? result)\n   [\n      j:=1;\n      While(j<=?n And? result)\n      [\n         result:=Apply(p,{x[i][j]});\n         j++;\n      ];\n      i++;\n   ];\n   result;\n],\nFalse);\n\n/* remove? (dr)\nIsSquareMatrix(_x) <--\n[\n   Local(d);\n   d:=Dimensions(x);\n   Length(d)=2 And? d[1]=?d[2];\n];\n*/\n\n// test for a square matrix (dr)\nFunction(\"IsSquareMatrix\",{x}) IsMatrix(x) And? Length(x)=?Length(x[1]);\n// test for a square matrix w/ element test p (dr)\nFunction(\"IsSquareMatrix\",{p,x}) IsMatrix(p,x) And? Length(x)=?Length(x[1]);\n\n]; // LocalSymbols(p,x)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/predicates/matrix.mpw";
        scriptMap.put("IsScalar",scriptString);
        scriptMap.put("IsMatrix",scriptString);
        scriptMap.put("IsVector",scriptString);
        scriptMap.put("IsSquareMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Evaluates distribution dst at point x\n   known distributions are:\n   1. Discrete distributions\n   -- BernoulliDistribution(p)\n   -- BinomialDistribution(p,n)\n   -- DiscreteUniformDistribution(a,b)\n   -- PoissonDistribution(l)\n   -- HypergeometricDistribution(N, M)\n   2. Continuous distributions\n   -- ExponentialDistribution(l)\n   -- NormalDistrobution(a,s)\n   -- ContinuousUniformDistribution(a,b)\n   -- tDistribution(m)\n   -- GammaDistribution(m)\n   -- ChiSquareDistribution(m)\n\n  DiscreteDistribution(domain,probabilities) represent arbitrary\n  distribution with finite number of possible values; domain list\n  contains possible values such that\n  Pr(X=domain[i])=probabilities[i].\n  TODO: Should domain contain numbers only?\n*/\n\n\n/* Evaluates Cumulative probability function CDF(x)=Pr(X<x) */\n\n//Retract(\"CDF\", *);\n\n//Discrete distributions.\n\n10 # CDF(BernoulliDistribution(_p), x_IsNumber) <-- If(x<=?0,0,If(x>?0 And? x<=?1, p,1));\n11 # CDF(BernoulliDistribution(_p), _x) <-- Hold(If(x<=?0,0,If(x>?0 And? x<=?1, p,1)));\n\n10 # CDF(BinomialDistribution(_p,_n),m_IsNumber)_(m<?0) <-- 0;\n10 # CDF(BinomialDistribution(_p,n_IsInteger),m_IsNumber)_(m>?n) <-- 1;\n10 # CDF(BinomialDistribution(_p,_n),_m) <-- Sum @ { i, 0, Floor(m), PMF(BinomialDistribution(p,n),i)};\n\n10 # CDF(DiscreteUniformDistribution( a_IsNumber, b_IsNumber), x_IsNumber)_(x<=?a) <-- 0;\n10 # CDF(DiscreteUniformDistribution( a_IsNumber, b_IsNumber), x_IsNumber)_(x>?b) <-- 1;\n10 # CDF(DiscreteUniformDistribution( a_IsNumber, b_IsNumber), x_IsNumber)_(a<?x And? x<=?b) <-- (x-a)/(b-a+1);\n11 # CDF(DiscreteUniformDistribution( _a, _b), _x) <--Hold(If(x<=?a,0,If(x<=?b,(x-a)/(b-a),1)));\n\n10 # CDF(PoissonDistribution(_l), x_IsNumber)_(x<=?0) <-- 0;\n10 # CDF(PoissonDistribution(_l), _x) <-- Sum @ {i,0,x,PMF(PoissonDistribution(l),i)};\n\n10 # CDF(ChiSquareDistribution(_m), _x) <-- IncompleteGamma(m/2,x/2)/Gamma(x/2);\n10 # CDF(DiscreteDistribution( dom_IsList, prob_IsList), _x)   <--\n      [\n         Local(i,cdf,y);\n\n         i := 1;\n         cdf:=0;\n         y:=dom[i];\n         While(y<?x) [cdf:=cdf+prob[i];i++;];\n         cdf;\n      ];\n\n10 # CDF(HypergeometricDistribution( N_IsNumber, M_IsNumber, n_IsNumber), x_IsNumber)_(M <=? N And? n <=? N) <-- \n[\n    Sum @ {i,0,x,PMF(HypergeometricDistribution(N, M, n),i)};\n];\n\n\n//Continuous distributions.\n\n10 # CDF(NormalDistribution(_m,_s), _x) <-- 1/2 + 1/2 * ErrorFunction((x - m)/(s*Sqrt(2))); //See http://en.wikipedia.org/wiki/Normal_distribution.\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/probability/CDF.mpw";
        scriptMap.put("CDF",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Evaluates distribution dst at point x\n   known distributions are:\n   1. Discrete distributions\n   -- BernoulliDistribution(p)\n   -- BinomialDistribution(p,n)\n   -- DiscreteUniformDistribution(a,b)\n   -- PoissonDistribution(l)\n   2. Continuous distributions\n   -- ExponentialDistribution(l)\n   -- NormalDistrobution(a,s)\n   -- ContinuousUniformDistribution(a,b)\n   -- tDistribution(m)\n   -- GammaDistribution(m)\n   -- ChiSquareDistribution(m)\n\n  DiscreteDistribution(domain,probabilities) represent arbitrary\n  distribution with finite number of possible values; domain list\n  contains possible values such that\n  Pr(X=domain[i])=probabilities[i].\n  TODO: Should domain contain numbers only?\n*/\n\n\n\n10 # Expectation(BernoulliDistribution(_p)) <-- 1-p;\n\n10 # Expectation(BinomialDistribution(_p,_n)) <-- n*p;\n\n10 # Expectation( DiscreteDistribution( dom_IsList, prob_IsList))_( Length(dom)=?Length(prob) And? Simplify(Sum(prob))=?1) <-- Sum @ {i,1,Length(dom),dom[i]*prob[i]};\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/probability/Expectation.mpw";
        scriptMap.put("Expectation",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Evaluates distribution dst at point x\n   known distributions are:\n   1. Discrete distributions\n   -- BernoulliDistribution(p)\n   -- BinomialDistribution(p,n)\n   -- DiscreteUniformDistribution(a,b)\n   -- PoissonDistribution(l)\n   2. Continuous distributions\n   -- ExponentialDistribution(l)\n   -- NormalDistrobution(a,s)\n   -- ContinuousUniformDistribution(a,b)\n   -- tDistribution(m)\n   -- GammaDistribution(m)\n   -- ChiSquareDistribution(m)\n\n  DiscreteDistribution(domain,probabilities) represent arbitrary\n  distribution with finite number of possible values; domain list\n  contains possible values such that\n  Pr(X=domain[i])=probabilities[i].\n  TODO: Should domain contain numbers only?\n*/\n\n//Retract(\"PDF\", *);\n\n\n10 # PDF(ExponentialDistribution(_l), _x) <-- If(x<?0,0,l*Exp(-l*x));\n\n10 # PDF(NormalDistribution(_m,_s),_x) <-- Exp(-(x-m)^2/(2*s^2))/Sqrt(2*Pi*s^2); //See http://en.wikipedia.org/wiki/Normal_distribution.\n\n10 # PDF(ContinuousUniformDistribution(_a,_b),x)_(a<?b) <-- If(x<?a Or? x>?b,0,1/(b-a));\n\n10 # PDF(DiscreteDistribution( dom_IsList, prob_IsList), _x)_( Length(dom)=?Length(prob) And? Simplify(Add(prob))=?1) <--\n    [\n      Local(i);\n      i:=Find(dom,x);\n      If(i =? -1,0,prob[i]);\n    ];\n10 # PDF( ChiSquareDistribution( _m),x_IsRationalOrNumber)_(x<=?0) <-- 0;\n20 # PDF( ChiSquareDistribution( _m),_x) <-- x^(m/2-1)*Exp(-x/2)/2^(m/2)/Gamma(m/2);\n\n10 # PDF(tDistribution(_m),x) <-- Gamma((m+1)/2)*(1+x^2/m)^(-(m+1)/2)/Gamma(m/2)/Sqrt(Pi*m);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/probability/PDF.mpw";
        scriptMap.put("PDF",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Evaluates distribution dst at point x\n   known distributions are:\n   1. Discrete distributions\n   -- BernoulliDistribution(p)\n   -- BinomialDistribution(p,n)\n   -- DiscreteUniformDistribution(a,b)\n   -- PoissonDistribution(l)\n   \n   2. Continuous distributions\n   -- ExponentialDistribution(l)\n   -- NormalDistrobution(a,s)\n   -- ContinuousUniformDistribution(a,b)\n   -- tDistribution(m)\n   -- GammaDistribution(m)\n   -- ChiSquareDistribution(m)\n\n  DiscreteDistribution(domain,probabilities) represent arbitrary\n  distribution with finite number of possible values; domain list\n  contains possible values such that\n  Pr(X=domain[i])=probabilities[i].\n  TODO: Should domain contain numbers only?\n*/\n\n//Retract(\"PMF\", *);\n\n10 # PMF(BernoulliDistribution(_p),0) <-- p;\n10 # PMF(BernoulliDistribution(_p),1) <-- 1-p;\n10 # PMF(BernoulliDistribution(_p),x_IsNumber)_(x !=? 0 And? x !=? 1) <-- 0;\n10 # PMF(BernoulliDistribution(_p),_x) <-- Hold(If(x=?0,p,If(x=?1,1-p,0)));\n\n10 # PMF(BinomialDistribution(_p,_n),_k) <-- BinomialCoefficient(n,k)*p^k*(1-p)^(n-k);\n\n10 # PMF(DiscreteUniformDistribution(_a,_b), x_IsNumber) <-- If(x<?a Or? x>?b, 0 ,1/(b-a+1));\n11 # PMF(DiscreteUniformDistribution(_a,_b), _x) <-- Hold(If(x<?a Or? x>?b, 0 ,1/(b-a+1)));\n\n10 # PMF(PoissonDistribution(_l), n_IsNumber) <-- If(n<?0,0,Exp(-l)*l^n/n!);\n11 # PMF(PoissonDistribution(_l),_n) <-- Exp(-l)*l^n/n!;\n\n10 # PMF(GeometricDistribution(_p),_n) <--If(n<?0,0,p*(1-p)^n);\n\n\n\n10 # PMF(DiscreteDistribution( dom_IsList, prob_IsList), _x)_( Length(dom)=?Length(prob) And? Simplify(Add(prob))=?1) <--\n    [\n      Local(i);\n      i:=Find(dom,x);\n      If(i =? -1,0,prob[i]);\n    ];\n    \n\n\n10 # PMF(HypergeometricDistribution( N_IsNumber, M_IsNumber, n_IsNumber), x_IsNumber)_(M <=? N And? n <=? N) <-- (BinomialCoefficient(M,x) * BinomialCoefficient(N-M, n-x))/BinomialCoefficient(N,n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/probability/PMF.mpw";
        scriptMap.put("PMF",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Manipulate\",*);\n\nRulebase(\"Manipulate\",{symbolicEquation});\nHoldArgument(\"Manipulate\",symbolicEquation);\n10 # Manipulate(_symbolicEquation)_HasFunc(Eval(symbolicEquation), \"==\") <--\n[\n    Local(listForm, operator, operand, left, right, leftManipulated, rightManipulated, operandIndex, equationIndex, leftOrder, rightOrder);\n\n    listForm := FunctionToList(symbolicEquation);\n    \n    operator := listForm[1];\n    \n    If(HasFunc(Eval(listForm[2]),\"==\" ), [operandIndex := 3; equationIndex := 2; ], [ operandIndex := 2; equationIndex := 3;]);\n    \n    operand := listForm[operandIndex];\n    equation := Eval(listForm[equationIndex]);\n    left := EquationLeft(equation);\n    right := EquationRight(equation);\n    \n    If(operandIndex =? 3, [ leftOrder := `({left,operand});rightOrder := `({right,operand});],  [leftOrder := `({operand,left}); rightOrder := `({operand,right});]);\n    \n    \n    leftManipulated := ExpandBrackets(Simplify(Apply(ToString(operator), leftOrder)));\n    rightManipulated := ExpandBrackets(Simplify(Apply(ToString(operator), rightOrder)));   \n    \n    leftManipulated == rightManipulated;\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/equations/Manipulate.mpw";
        scriptMap.put("Manipulate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\nControlChart(data) :=\n[\n    A2 := .577;\n    D3 := 0;\n    D4 := 2.144;\n\n    means := {};\n    meansPoints := {};\n    \n    ranges := {};\n    rangesPoints := {};\n    \n    index := 1;\n    ForEach(group, data)\n    [\n        groupMean := Mean(group);\n        means := N(Append(means, groupMean));\n        meansPoints := N(Append(meansPoints,{index, groupMean} ));\n        \n\n        groupRange := Range(group);\n        ranges := N(Append(ranges, groupRange));\n        rangesPoints := N(Append(rangesPoints,{index, groupRange} ));\n        \n        index++;\n    ];\n    \n    xBarBar := N(Mean(means));\n    \n    rBar := N(Mean(ranges));\n    \n    xBarUCL := N(xBarBar + A2*rBar);\n    \n    xBarLCL := N(xBarBar - A2*rBar);\n    \n    rUCL := N(D4*rBar);\n    \n    rLCL := N(D3*rBar);\n];\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/ControlChart.mpw";
        scriptMap.put("ControlChart",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"GeoGebra\",*);\n\nLocalSymbols(options)\n[\n    options  := {};\n    \n    Local(updateObjects);\n    \n    updateObjects := \"\";\n    \n    options[\"updateObjects\"] := updateObjects;\n    \n    \n\nGeoGebra() := options;\n\n\nGeoGebra(list) := (options := list);\n\n\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/GeoGebra.mpw";
        scriptMap.put("GeoGebra",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"GeoGebraHistogram\",*);\n\nGeoGebraHistogram(classBoundaries, data) := \n[\n    Local(command);\n    //todo:tk: a check must be made to make sure that all data items fit into the class boundaries.\n    // If they don't, GeoGebra will not accept them.\n    \n    command := PatchString(\"Histogram[<?Write(classBoundaries);?>,<?Write(data);?>]\");\n    JavaCall(geogebra, \"evalCommand\", command);\n];\n\n\n\n\nGeoGebraHistogram(data) := \n[\n    Local(command, classBoundaries, noDuplicatesSorted, largestValue, smallestValue, x, numberOfUniqueValues);\n    \n    noDuplicatesSorted := HeapSort(RemoveDuplicates(data), \"<?\" );\n    \n    smallestValue := Floor(noDuplicatesSorted[1]);\n    \n    numberOfUniqueValues := Length(noDuplicatesSorted);\n    \n    largestValue := Ceil(noDuplicatesSorted[Length(noDuplicatesSorted)]);\n    \n    classBoundaries := N(Table(x,x,smallestValue-.5,largestValue+.5,1));\n    \n    command := PatchString(\"Histogram[<?Write(classBoundaries);?>,<?Write(data);?>]\");\n    JavaCall(geogebra, \"evalCommand\", command);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/GeoGebraHistogram.mpw";
        scriptMap.put("GeoGebraHistogram",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "//Retract(\"GeoGebraPlot\",*);\n\nRulebaseListed(\"GeoGebraPlot\",{arg1,arg2});\n\n\n\n5 # GeoGebraPlot(_arg1) <-- GeoGebraPlot(arg1,{});  //Handle single argument call.\n\n\n20 # GeoGebraPlot(function_IsFunction, options_IsList)_(Not? IsList(function)) <--\n[\n    Local(command);\n    \n    function := (Subst(==,=) function);\n    \n    command := ConcatStrings(PipeToString()Write(function));\n    \n    JavaCall(geogebra,\"evalCommand\",command);\n];\n\n\n\n\n10 # GeoGebraPlot(list_IsList, _options)_(IsNumericList(list) )  <--\n[\n    If(IsList(options), options := OptionsToAssociativeList(options), options := OptionsToAssociativeList({options}));\n\n    Local(length, index, labelIndex, pointTemplate, segmentCommandTemplate, segmentElementTemplate, command, code, x, y, pointSize);\n    \n    length := Length(list);\n    \n    If(IsOdd(length), list := Append(list,list[length])); //Make list even for line drawing.\n    \n    If(options[\"pointSize\"] !=? Empty, pointSize := options[\"pointSize\"], pointSize := \"1\");\n    \n    index := 1;\n    \n    labelIndex := 1;\n    \n    pointTemplate := \"<element type=\\\"point\\\" label=\\\"A<?Write(labelIndex);?>\\\"> <show object=\\\"true\\\" label=\\\"false\\\"/>?<objColor r=\\\"0\\\" g=\\\"0\\\" b=\\\"255\\\" alpha=\\\"0.0\\\"/>        <layer val=\\\"0\\\"/>        <animation step=\\\"0.1\\\" speed=\\\"1\\\" type=\\\"0\\\" playing=\\\"false\\\"/>        <coords x=\\\"<?Write(x);?>\\\" y=\\\"<?Write(y);?>\\\" z=\\\"1.0\\\"/>        <pointSize val=\\\"<?Write(ToAtom(pointSize));?>\\\"/></element>\";\n    segmentCommandTemplate := \"<command name=\\\"Segment\\\"><input a0=\\\"A1\\\" a1=\\\"A2\\\"/><output a0=\\\"a\\\"/>\";\n    segmentElementTemplate := \"<element type=\\\"segment\\\" label=\\\"a<?Write(labelIndex-1);?>\\\"><lineStyle thickness=\\\"2\\\" type=\\\"0\\\"/><show object=\\\"true\\\" label=\\\"false\\\"/><layer val=\\\"0\\\"/><coords x=\\\"-1.0\\\" y=\\\"1.0\\\" z=\\\"0.0\\\"/><lineStyle thickness=\\\"2\\\" type=\\\"0\\\"/><eqnStyle style=\\\"implicit\\\"/><outlyingIntersections val=\\\"false\\\"/><keepTypeOnTransform val=\\\"true\\\"/></element>\";\n    \n    \n    //todo:tk: this does not seem to be working JavaCall(geogebra, \"setRepaintingActive\", \"false\");\n    //JavaCall(geogebra, \"setLayerVisible\", \"0\", \"False\");\n    \n    While(index <? length+1)\n    [\n        x := list[index];\n        index++;\n        y := list[index];\n        index++;\n        \n        \n        code := PatchString(pointTemplate);\n\n        \n        JavaCall(geogebra,\"evalXML\",code);\n        \n        If(options[\"lines\"] =? \"True\" And? labelIndex >? 1,\n        [\n            \n            command := PatchString(\"a<?Write(labelIndex-1);?> = Segment[A<?Write(labelIndex-1);?>,A<?Write(labelIndex);?>]\");\n            JavaCall(geogebra, \"evalCommand\", command);\n\n            \n            code := PatchString(segmentElementTemplate);\n            JavaCall(geogebra,\"evalXML\",code);\n        ]\n        );\n       \n        labelIndex++;\n    ]; //end while.\n    \n     //todo:tk: this does not seem to be working  JavaCall(geogebra, \"setRepaintingActive\", \"true\");\n     //JavaCall(geogebra, \"setLayerVisible\", \"0\", \"True\");\n\n];\n\n\n5 # GeoGebraPlot(list_IsList, _options)_(IsMatrix(list)) <--\n[\n    Local(flatList);\n    \n    flatList := {};\n    \n    ForEach(subList,list)\n    [\n        DestructiveAppend(flatList,subList[1]);\n        DestructiveAppend(flatList, subList[2]);\n    ];\n    \n    GeoGebraPlot(flatList, options);\n\n];\n\n//HoldArgument(\"GeoGebraPlot\",arg2);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/GeoGebraPlot.mpw";
        scriptMap.put("GeoGebraPlot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "//Retract(\"GeoGebraPoint\",*);\n\n10 # GeoGebraPoint(name_IsString, x_IsNumber, y_IsNumber)  <--\n[\n    Local(command);\n    \n    command := PatchString(\"<?Write(ToAtom(name));?>=(<?Write(x);?>,<?Write(y);?>)\");\n    \n    JavaCall(geogebra,\"evalCommand\",command);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/GeoGebraPoint.mpw";
        scriptMap.put("GeoGebraPoint",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ggbLine\", *);\n\nggbLine(point1Label, point2Label) :=\n[\n    Local(command);\n    \n    command := PatchString(\"Line[<?Write(ToAtom(point1Label));?>,<?Write(ToAtom(point2Label));?>]\");\n    \n    \n    JavaCall(geogebra,\"evalCommand\",command);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geogebra/ggbLine.mpw";
        scriptMap.put("GgbLine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDistance(PointA_IsPoint,PointB_IsPoint) <--\n[\n    Local(x1,x2,y1,y2,distance);\n\n    x1 := PointA[1];\n    x2 := PointB[1];\n    y1 := PointA[2];\n    y2 := PointB[2];\n    \n    distance := Sqrt((x2 - x1)^2 + (y2 - y1)^2);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/Distance.mpw";
        scriptMap.put("Distance",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsPoint(p) := If(IsList(p) And? (Length(p) =? 2 Or? Length(p) =? 3),True,False);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/IsPoint.mpw";
        scriptMap.put("IsPoint",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsSegment(list_IsList) <--\n[\n    If(IsList(list[1]) And? Length(list[1])=?2 And? IsList(list[2]) And? Length(list[2])=?2,True,False);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/IsSegment.mpw";
        scriptMap.put("IsSegment",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMidpoint(PointA_IsPoint,PointB_IsPoint) <-- \n[\n    Local(x1,x2,y1,y2,midpointX,midpointY);\n    \n    x1 := PointA[1];\n    x2 := PointB[1];\n    y1 := PointA[2];\n    y2 := PointB[2];\n\n    midpointX := (x1 + x2)/2;\n    midpointY := (y1 + y2)/2;\n    \n    {midpointX,midpointY};\n\n];\n\n\n\nMidpoint(segment_IsSegment) <-- \n[\n    Local(x1,x2,y1,y2,midpointX,midpointY);\n    \n    x1 := segment[1][1];\n    x2 := segment[2][1];\n    y1 := segment[1][2];\n    y2 := segment[2][2];\n\n    midpointX := (x1 + x2)/2;\n    midpointY := (y1 + y2)/2;\n    \n    {midpointX,midpointY};\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/Midpoint.mpw";
        scriptMap.put("Midpoint",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nPoint(x,y) := List(x,y);\n\nPoint(x,y,z) := List(x,y,z);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/Point.mpw";
        scriptMap.put("Point",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nSegment(PointA_IsPoint,PointB_IsPoint) <--\n[\n    Local(x1,x2,y1,y2);\n    \n    x1 := PointA[1];\n    x2 := PointB[1];\n    y1 := PointA[2];\n    y2 := PointB[2];\n\n    {{x1,y1},{x2,y2}};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/Segment.mpw";
        scriptMap.put("Segment",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Slope(PointA_IsPoint,PointB_IsPoint) <--\n[\n    Local(x1,x2,y1,y2,slope);\n\n    x1 := PointA[1];\n    x2 := PointB[1];\n    y1 := PointA[2];\n    y2 := PointB[2];\n    \n    slope := (y2 - y1)/(x2 - x1);\n];\n\n\n\n10 # Slope(segment_IsList)_(Length(segment) =? 2 And? Length(segment[1]) =? 2 And? Length(segment[2]) =? 2) <--\n[\n    Local(x1,x2,y1,y2,slope);\n    \n    x1 := segment[1][1]; //PointA[1];\n    x2 := segment[2][1]; //PointB[1];\n    \n    \n    y1 := segment[1][2]; //PointA[2];\n    y2 := segment[2][2]; //PointB[2];\n\n    slope := (y2 - y1)/(x2 - x1);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/geometry/Slope.mpw";
        scriptMap.put("Slope",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n    The algorithm this function uses is on pp. 299-300 of\n    \"Discrete Mathematics and Its Applications\" (fourth edition)\n    by Kenneth H. Rosen.\n*/\nCombinationsList(inputList, r) :=\n[\n    Local(n,manipulatedIndexes,totalCombinations,combinationsList,combinationsLeft,combination,i,j,currentIndexes);\n    \n    Check(IsList(inputList) And? Length(inputList) >=? 1, \"Argument\", \"The first argument must be a list with 1 or more elements.\");\n    \n    n := Length(inputList);\n    \n    Check(r <=? n , \"Argument\", \"The second argument must be <=? the length of the list.\");\n    \n    manipulatedIndexes := 1 .. r; \n    \n    totalCombinations := Combinations(n,r);\n    \n    combinationsLeft := totalCombinations;\n    \n    combinationsList := {};\n    \n    While(combinationsLeft >? 0)\n    [\n        combination := {};\n      \n        if(combinationsLeft =? totalCombinations)\n        [ \n          combinationsLeft := combinationsLeft - 1;\n          \n          currentIndexes := manipulatedIndexes;\n        ]\n        else\n        [\n            i := r;\n        \n            While(manipulatedIndexes[i] =? n - r + i)\n            [\n              i--;\n            ];\n            \n            manipulatedIndexes[i] := manipulatedIndexes[i] + 1;\n            \n            For(j := i + 1, j <=? r, j++) \n            [\n              manipulatedIndexes[j] := manipulatedIndexes[i] + j - i;\n            ];\n        \n            combinationsLeft := combinationsLeft - 1;\n            \n            currentIndexes := manipulatedIndexes;\n        ];\n\n        For(i := 1, i <=? Length(currentIndexes), i++) \n        [\n            combination := Append(combination,(inputList[currentIndexes[i]]));\n        ];\n      \n        combinationsList := Append(combinationsList,combination);\n    ];\n    \n    combinationsList;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/CombinationsList.mpw";
        scriptMap.put("CombinationsList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ElementCount\",*);\n\nElementCount(list) :=\n[   \n    if(Length(list) =? 0)\n    [\n        0;\n    ]\n    else if(IsAtom(list))\n    [\n        1;\n    ]\n    else\n    [\n        ElementCount(First(list)) + ElementCount(Rest(list));\n    ];\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/ElementCount.mpw";
        scriptMap.put("ElementCount",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nIsListOfLists(listOfLists) :=\n[\n    Local(result);\n    \n    result := True;\n    \n    if(Not? IsList(listOfLists))\n    [\n        result := False;\n    ]\n    else \n    [\n        ForEach(list, listOfLists)\n        [\n            If(Not? IsList(list), result := False);\n        ];\n    ];\n    \n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/IsListOfLists.mpw";
        scriptMap.put("IsListOfLists",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n//Retract(\"ListToString\", *);\n\n\n10 # ListToString(list_IsList)_(Length(list) =? 0) <-- \"\";\n\n\n\n20 # ListToString(list_IsList) <--\n[\n    Local(resultString, character);\n    \n    resultString := \"\";\n    \n    ForEach(element, list)\n    [\n        If(IsString(element), character := element, character := ToString(element));\n        \n        resultString := resultString : character;\n    ];\n    \n    resultString;\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/ListToString.mpw";
        scriptMap.put("ListToString",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"NumberLineZoom\", *);\n\n//Retract(\"ZoomInOnce\", *);\n\nLocalSymbols(ZoomInOnce)\n[\n\n    10 # NumberLinePrintZoom(_lowValue, _highValue, divisions_IsPositiveInteger, depth_IsPositiveInteger)_(lowValue <? highValue) <-- \n    [\n    \n        Local(numbers, stepAmount, zoomIndexes, nextZoomIndex, outputWidth, numbersString, output, randomStep, randomZoomNumber, iteration);\n        \n        iteration := 1;\n        \n        While(iteration <=? depth)\n        [\n            {numbers, stepAmount} := ZoomInOnce(lowValue, highValue, divisions);\n            \n            zoomIndexes := {};\n            \n            outputWidth := 0;\n            \n            numbersString := \"\";\n            \n            ForEach(number, numbers)\n            [\n                output := PipeToString() Write(number);\n                \n                zoomIndexes := Append(zoomIndexes, Length(output));\n                \n                numbersString := numbersString : output : PipeToString() Space(3);\n                \n                outputWidth := outputWidth + Length(output) + 3;\n            \n            ];\n            \n            randomStep := RandomInteger(divisions);\n            \n            randomZoomNumber := Sum(Take(zoomIndexes, randomStep));\n            \n            If(randomStep =? 1, nextZoomIndex := randomZoomNumber + 1, nextZoomIndex := 3*(randomStep-1) + randomZoomNumber + 1);\n         \n            If(iteration >? 1, Echo(ListToString(FillList(\"-\", outputWidth-3)))); \n            \n            Echo(numbersString);\n            \n            If(iteration !=? depth,[Space(nextZoomIndex);Echo(\"|\");]);\n            \n            lowValue := numbers[randomStep];\n            \n            highValue := numbers[randomStep+1];\n            \n            iteration++;\n            \n        ];\n    \n    ];\n    \n    \n    \n    \n    ZoomInOnce(_lowValue, _highValue, divisions_IsPositiveInteger)_(lowValue <? highValue) <--\n    [\n        Local(stepAmount, x, numbers);\n        \n        stepAmount := If(IsDecimal(lowValue) Or? IsDecimal(highValue), N((highValue-lowValue)/divisions), (highValue-lowValue)/divisions);\n        \n        x := lowValue;\n        \n        numbers := {};\n        \n        While(x <=? highValue)\n        [\n        \n            numbers := Append(numbers, x);\n            \n            x := x + stepAmount;\n        \n        ];\n        \n        {numbers, stepAmount};\n    \n    ];\n\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/NumberLinePrintZoom.mpw";
        scriptMap.put("NumberLinePrintZoom",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "OptionsToAssociativeList(optionList) :=\n[\n    Local(associativeList, key, value);\n    \n    associativeList := {};\n    \n    ForEach(option, optionList)\n    [\n        If(option[0] =? ->,\n        [\n            If(IsString(option[1]), key := option[1], key := ToString(option[1]));\n            If(IsString(option[2]), value := option[2], value := ToString(option[2]));\n            \n            associativeList := {key, value} : associativeList;\n        \n        ]);\n    \n    ];\n    associativeList;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/OptionsToAssociativeList.mpw";
        scriptMap.put("OptionsToAssociativeList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"PadLeft\", *);\n\n10 # PadLeft(number_IsNumber, totalDigits_IsInteger) <--\n[\n    Local(integerString, padAmount, resultString);\n    \n    integerString := ToString(number);\n    \n    padAmount := totalDigits - Length(integerString);\n    \n    If(padAmount >? 0,\n        resultString := ListToString(FillList(0, padAmount)) : integerString,\n        resultString := integerString );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/PadLeft.mpw";
        scriptMap.put("PadLeft",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* RForm: convert MathPiper objects to R code. */\n\n//Retract(\"RForm\",*);\n//Retract(\"RIndent\",*);\n//Retract(\"RUndent\",*);\n//Retract(\"RNlIndented\",*); \n\nRulebase(\"RForm\",{expression});\nRulebase(\"RForm\",{expression, precedence});\n\nFunction (\"RFormBracketIf\", {predicate, string})\n[\n        Check(IsBoolean(predicate) And? IsString(string), \"Argument\", \"RForm internal error: non-boolean and/or non-string argument of RFormBracketIf\");\n        If(predicate, ConcatStrings(\"( \", string, \") \"), string);\n];\n\n/* Proceed just like TeXForm()\n*/\n\n// RFormMaxPrec should perhaps only be used from within this file, it is thus not in the .def file.\nRFormMaxPrec() := 60000;         /* This precedence will never be bracketed. It is equal to KMaxPrec */\n\n100 # RForm(_x) <-- RForm(x, RFormMaxPrec());\n\n/* Replace numbers and variables -- never bracketed except explicitly */\n110 # RForm(x_IsInteger, _p) <-- ToString(x);\n111 # RForm(x_IsZero, _p) <-- \"0.\";\n112 # RForm(x_IsNumber, _p) <-- ToString(x);\n/* Variables are left as is, except some special ones */\n190 # RForm(False, _p) <-- \"false\";\n190 # RForm(True, _p) <-- \"true\";\n190 # RForm(Pi, _p) <-- \"pi\";\n200 # RForm(x_IsAtom, _p) <-- ToString(x);\n\n/* Strings must be quoted but not bracketed */\n100 # RForm(x_IsString, _p) <-- ConcatStrings(\"\\\"\", x, \"\\\"\");\n\n/* Replace operations */\n\n/* arithmetic */\n\n/* addition, subtraction, multiplication, all comparison and logical operations are \"regular\" */\n\n\nLocalSymbols(rFormRegularOps) [\n  rFormRegularOps := \n  { \n    {\"+\",\"+\"},\n    {\"-\",\"-\"},\n    {\"*\",\"*\"},\n    {\"/\",\"/\"},\n    {\"/\",\"/\"},\n    {\"^\",\"^\"},\n    {\"=?\",\"==\"},\n    {\">=?\",\">=\"},\n    {\">?\",\">\"},\n    {\"<=?\",\"<=\"},\n    {\"<?\",\"<\"},\n    {\"!=\",\"!=\"},\n    {\"..\",\":\"},\n    {\"Not?\",\"!\"},\n    {\":=\",\"<-\"},\n    {\"sequence\",\":\"},\n    {\"True\",\"TRUE\"},\n    {\"Modulo\",\"%%\"},\n    {\"Quotient\",\"%/%\"},\n  };\n\n  RFormRegularOps() := rFormRegularOps;\n]; // LocalSymbols(rFormRegularOps)\n\n\n\n\nLocalSymbols(rFormMathFunctions) [\n  rFormMathFunctions :=\n  {\n    {\"NthRoot\",\"root\"},\n    {\"Infinite\",\"Inf\"},\n    {\"Undefined\",\"NaN\"},\n    {\"Sin\",\"sin\"},\n    {\"Cos\",\"cos\"},\n    {\"Tan\",\"tan\"},\n    {\"ArcSin\",\"asin\"},\n    {\"ArcCos\",\"acos\"},\n    {\"ArcTan\",\"atan\"},\n    {\"ArcSinh\",\"asinh\"},\n    {\"ArcCosh\",\"acosh\"},\n    {\"ArcTanh\",\"atanh\"},\n    {\"ArcCsc\",\"acsc\"},\n    {\"ArcCsch\",\"acsch\"},\n    {\"ArcSec\",\"asec\"},\n    {\"ArcSech\",\"asech\"},\n    {\"ArcCot\",\"acot\"},\n    {\"ArcCoth\",\"acoth\"},\n    {\"Exp\",\"exp\"},\n    {\"Ln\",\"log\"},\n    {\"Sqrt\",\"sqrt\"},\n    {\"Bin\",\"choose\"},\n    {\"Gamma\",\"gamma\"},\n    {\"!\",\"factorial\"},\n    {\"Limit\",\"limit\"},\n    {\"Deriv\",\"deriv\"},\n    {\"Integrate\",\"integrate\"},\n    {\"Taylor\",\"?\"},\n    {\"List\",\"list\"},\n  };\n\n  RFormMathFunctions() := rFormMathFunctions;\n\n]; // LocalSymbols(RFormMathFunctions)\n\n\n\n\n/* This is the template for \"regular\" binary infix operators:\n100 # RForm(_x + _y, _p) <-- RFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(RForm(x, LeftPrecedenceGet(\"+\")), \" + \", RForm(y, RightPrecedenceGet(\"+\")) ) );\n        */\n\n        /* unary addition */\n100 # RForm(+ _y, _p) <-- RFormBracketIf(p<?PrecedenceGet(\"+\"), ConcatStrings(\" + \", RForm(y, RightPrecedenceGet(\"+\")) ) );\n\n        /* unary subtraction */\n100 # RForm(- _y, _p) <-- RFormBracketIf(p<?PrecedenceGet(\"-\"), ConcatStrings(\" - \", RForm(y, RightPrecedenceGet(\"-\")) ) );\n\n        /* power's argument is never bracketed but it must be put in braces. */\n100 # RForm(_x ^ _y, _p) <-- RFormBracketIf(p <=? PrecedenceGet(\"^\"), ConcatStrings(RForm(x, RFormMaxPrec()), \"^\", RForm(y, RFormMaxPrec())) );\n\n100 # RForm(if(_pred)_body, _p) <-- \"if (\":RForm(pred,60000):\") \":RForm(body);\n100 # RForm(_left else _right, _p) <-- RForm(left):\" else \":RForm(right);\n\n/* Precedence of 120 because we'd like to process some special functions like pow() first */\n\n\n120 # RForm(expr_IsFunction, _p)_(ArgumentsCount(expr)=?2 And? Contains(AssocIndices(RFormRegularOps()), Type(expr)) ) <--\n      RFormBracketIf(p<?PrecedenceGet(Type(expr)), ConcatStrings(RForm(FunctionToList(expr)[2], LeftPrecedenceGet(Type(expr))), RFormRegularOps()[Type(expr)], RForm(FunctionToList(expr)[3], RightPrecedenceGet(Type(expr))) ) );\n\n\n/* Sin, Cos, etc. and their argument is always bracketed */\n\n120 # RForm(expr_IsFunction, _p) _\n      (ArgumentsCount(expr)=?1 And? Contains(AssocIndices(RFormMathFunctions()), Type(expr)) ) <--\n      ConcatStrings(RFormMathFunctions()[Type(expr)], \"(\", RForm( FunctionToList(expr)[2], RFormMaxPrec()),\")\" );\n\n/* functions */\n\n/* Unknown function, precedence 200. Leave as is, never bracket the function itself and bracket the argumentPointer(s) automatically since it's a list. Other functions are precedence 100 */\n\nRFormArgs(list_IsList) <--\n[\n  Local(i,nr,result);\n  result:=\"\";\n  nr:=Length(list);\n  For (i:=1,i<=?nr,i++)\n  [\n    result:=result:RForm(list[i]);\n    If (i<?nr, result:=result:\", \");\n  ];\n  result;\n];\n\n\n200 # RForm(_x, _p)_(IsFunction(x)) <--\n[\n  ConcatStrings(Type(x), \"(\", RFormArgs(Rest(FunctionToList(x))),\")\" );\n];\n\n/* Complex numbers */\n100 # RForm(Complex(0, 1), _p) <-- \"I\";\n100 # RForm(Complex(_x, 0), _p) <-- RForm(x, p);\n110 # RForm(Complex(_x, 1), _p) <-- RForm(x+Hold(I), p);\n110 # RForm(Complex(0, _y), _p) <-- RForm(Hold(I)*y, p);\n120 # RForm(Complex(_x, _y), _p) <-- RForm(x+Hold(I)*y, p);\n\n/* Some special functions: Mod */\n\n100 # RForm(Modulo(_x, _y), _p) <-- RFormBracketIf(p<?PrecedenceGet(\"/\"), ConcatStrings(RForm(x, PrecedenceGet(\"/\")), \" % \", RForm(y, PrecedenceGet(\"/\")) ) )\n;\n\n/* Indexed expressions are never bracketed */\n// the rule with [ ] seems to have no effect?\n//100 # RForm(_x [ _i ], _p) <-- ConcatStrings(RForm(x, RFormMaxPrec()), \"[\", RForm(i, RFormMaxPrec()), \"]\");\n100 # RForm(Nth(_x, _i), _p) <-- ConcatStrings(RForm(x, RFormMaxPrec()), \"[\", RForm(i, RFormMaxPrec()), \"]\");\n\nLocalSymbols(RIndent) [\n  RIndent:=1;\n\n  RNlIndented():=\n  [\n    Local(result);\n// carriage return, so needs to start at the beginning of the line\n    result:=\n\"\n\";\n    Local(i);\n    For(i:=1,i<?RIndent,i++)\n    [\n      result:=result:\"  \";\n    ];\n    result;\n  ];\n  RIndent() :=\n  [\n  (RIndent++);\n  \"\";\n  ];\n  RUndent() :=\n  [\n  (RIndent--);\n  \"\";\n  ];\n]; // LocalSymbols(RIndent)\n\nRFormStatement(_x) <-- RForm(x) : \";\" : RNlIndented();\n\n120 # RForm(_x,_p)_(Type(x) =? \"Prog\") <--\n[\n  Local(result);\n  result:=RIndent():\"{\":RNlIndented();\n  ForEach(item,Rest(FunctionToList(x)))\n  [\n    result:=result:RFormStatement(item);\n  ];\n  result:=result:\"}\":RUndent():RNlIndented();\n  result;\n];\n\n120 # RForm(For(_from,_to,_step)_body,_p) <--\n  \"for(\" : RForm(from,RFormMaxPrec()) : \";\"\n        : RForm(to,RFormMaxPrec()) : \";\"\n        : RForm(step,RFormMaxPrec()) : \")\"\n        : RIndent() : RNlIndented()\n        : RFormStatement(body) : RUndent();\n\n120 # RForm(While(_pred)_body, _p) <--\n        \"while(\" : RForm(pred,RFormMaxPrec()) : \")\"\n        : RIndent() : RNlIndented()\n        : RFormStatement(body) : RUndent();\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/RForm.mpw";
        scriptMap.put("RForm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"StringToList\", *);\n\n10 # StringToList(string_IsString)_(Length(string) =? 0) <-- {};\n\n\n20 # StringToList(string_IsString) <--\n[\n    Local(resultList);\n    \n    resultList := {};\n    \n    ForEach(character, string)\n    [\n        resultList := Append(resultList, character);\n    ];\n    \n    resultList;\n\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/StringToList.mpw";
        scriptMap.put("StringToList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "//Retract(\"StringToNumber\",*);\n\nStringToNumber( str_IsString ) <-- FromBase(10,str);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/StringToNumber.mpw";
        scriptMap.put("StringToNumber",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nVerifyNumeric(expression1, expression2, optionsList) :=\n[\n    Local(variablesList1, variablesList2, numericValue1, numericValue2, numericDifference, optionsVariableNamesList, optionsValuesList, associativeList);\n \n    variablesList1 := VarList(expression1);\n    \n    variablesList2 := VarList(expression2);\n    \n    if(Length(variablesList1) =? 0 And? Length(variablesList2) =? 0)\n    [\n        numericValue1 := N(expression1);\n        \n        numericValue2 := N(expression2);\n    ]\n    else\n    [\n        optionsList := HeapSort(optionsList, Lambda({x,y},IsLessThan(x[1],y[1])));\n        \n        associativeList := OptionsToAssociativeList(optionsList);\n        \n        optionsVariableNamesList := MapSingle(\"ToAtom\", AssocIndices(associativeList));\n        \n        optionsValuesList := MapSingle(\"ToAtom\", AssocValues(associativeList));\n        \n        variablesList1 := HeapSort(variablesList1,\"IsLessThan\");\n        \n        variablesList2 := HeapSort(variablesList2,\"IsLessThan\");\n        \n        Check(variablesList1 =? variablesList2 And? variablesList1 =? optionsVariableNamesList, \"Argument\", \"Both expressions and the options list must have the same variable names and the same number of variables.\");\n        \n        numericValue1 := N(WithValue(variablesList1, optionsValuesList, expression1));\n        \n        numericValue2 := N(WithValue(variablesList2, optionsValuesList, expression2 ));\n        \n        Echo(Map(\"->\",{variablesList1, optionsValuesList}));\n        \n        NewLine();\n    ];\n    \n    Echo(expression1, \"-> \", numericValue1);\n    \n    NewLine();\n    \n    Echo(expression2, \"-> \", numericValue2);\n    \n    numericDifference := N(numericValue1 - numericValue2);\n        \n    NewLine();\n    \n    Echo(\"Difference between the numeric values: \", numericDifference);\n    \n    numericDifference;\n];\n\n\n\n\nVerifyNumeric(expression1, expression2) :=\n[\n    VerifyNumeric(expression1, expression2, {});\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/miscellaneous/VerifyNumeric.mpw";
        scriptMap.put("VerifyNumeric",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* \n    This function was adapted from the Javascript version of function\n    that is located here:\n    \n    http://www.fourmilab.ch/rpkp/experiments/analysis/chiCalc.js\n    http://www.fourmilab.ch/rpkp/experiments/analysis/chiCalc.html\n    \n    The following JavaScript functions for calculating normal and\n    chi-square probabilities and critical values were adapted by\n    John Walker from C implementations\n    written by Gary Perlman of Wang Institute, Tyngsboro, MA\n    01879. Both the original C code and this JavaScript edition\n    are in the public domain. \n*/\n\n\n\n/*  CRITCHI  --  Compute critical chi-square value to\n                     produce given p.  We just do a bisection\n                     search for a value within CHI_EPSILON,\n                     relying on the monotonicity of pochisq().  \n*/\n\n\nAlphaToChiSquareScore(p, df) :=\n[\n    Local(ChiEpsilon, ChiMax, minchisq, maxchisq, chisqval, result);\n    \n    ChiEpsilon := 0.000001;   /* Accuracy of critchi approximation */\n    \n    ChiMax := 99999.0;        /* Maximum chi-square value */\n    \n    minchisq := 0.0;\n    \n    maxchisq := ChiMax;\n    \n    p := N(p);\n    \n    if( p <=? 0.0 Or? p >=? 1.0)\n    [\n    \n        if (p <=? 0.0) \n        [\n            result := maxchisq;\n        ] \n        else \n        [\n            if (p >=? 1.0) \n            [\n                result := 0.0;\n            ];\n        ];\n    \n    ]\n    else\n    [\n        chisqval := N(df / SqrtN(p));\n        \n        /* fair first value */\n        While ((maxchisq - minchisq) >? ChiEpsilon) \n        [\n            if (ChiSquareScoreToAlpha(chisqval, df) <? p) \n            [\n                maxchisq := chisqval;\n            ] \n            else \n            [\n                minchisq := chisqval;\n            ];\n            chisqval := (maxchisq + minchisq) * 0.5;\n        ];\n        \n        result := chisqval;\n    \n    ];\n    \n    N(result);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/AlphaToChiSquareScore.mpw";
        scriptMap.put("AlphaToChiSquareScore",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\nAnovaCompletelyRandomizedBlock(levelsList, alpha) :=\n[\n    Check(IsMatrix(levelsList), \"Argument\", \"The first argument must be a list of equal-length lists.\");\n    \n    Check(alpha >=? 0 And? alpha <=? 1, \"Argument\", \"The second argument must be a number between 0 and 1.\");\n    \n    Local(\n        topOfSummary,\n        anovaBlockTableRow1,\n        criticalFScore,\n        anovaBlockTableRow3,\n        anovaBlockTableRow2,\n        lengthsList,\n        summaryTableRow,\n        sumsList,\n        meanSquareWithin,\n        topOfPage,\n        htmlJavaString,\n        index,\n        variancesList,\n        grandMean,\n        row,\n        topOfAnovaBlock,\n        result,\n        fScoreBlock,\n        criticalFScoreBlock,\n        blockMeansList,\n        sumOfSquaresWithin',\n        meanSquareBetween,\n        sumOfSquaresBetween,\n        fScore,\n        summaryTableRows,\n        meansList,\n        sumOfSquaresBlock,\n        b,\n        blockSummaryTableRow,\n        bottomOfAnovaBlock,\n        sumOfSquaresWithin,\n        bottomOfPage,\n        k,\n        sumOfSquaresTotal,\n        meanSquareBlock,\n        bottomOfSummary\n    );\n    \n    meansList := {};\n    \n    variancesList := {};\n    \n    sumsList := {};\n    \n    lengthsList := {};\n    \n    \n    //ANOVA calculations.\n    ForEach(levelList, levelsList)\n    [\n        meansList := meansList : N(Mean(levelList));\n        \n        variancesList := variancesList : N(UnbiasedVariance(levelList));\n        \n        sumsList := sumsList : N(Sum(levelList));\n\n        lengthsList := lengthsList : Length(levelList);\n    ];\n    \n    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);\n\n    grandMean := N(Mean(meansList));\n    \n    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);\n    \n    \n    \n    //Block calculations.\n    blockMeansList := {};\n    \n    index := 1;\n    \n    While(index <=? Length(First(levelsList)) )\n    [\n        row := MatrixColumn(levelsList, index);\n        \n        blockMeansList := Append(blockMeansList,N(Mean(row)));\n    \n        index++;\n    ];\n    \n    b := Length(blockMeansList);\n    \n    k := Length(levelsList);\n    \n    sumOfSquaresBlock := Sum(j,1,b, k*(blockMeansList[j] - grandMean)^2);\n    \n    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);\n    \n    sumOfSquaresWithin' := N(sumOfSquaresTotal - sumOfSquaresBetween - sumOfSquaresBlock);\n    \n    meanSquareBetween := N(sumOfSquaresBetween/(k - 1));\n    \n    meanSquareWithin := N(sumOfSquaresWithin'/((k - 1)*(b - 1)));\n    \n    fScore := N(meanSquareBetween/meanSquareWithin);\n    \n    meanSquareBlock := N(sumOfSquaresBlock/(b - 1));\n    \n    fScoreBlock := N(meanSquareBlock/meanSquareWithin);\n    \n    criticalFScore := ProbabilityToFScore(k - 1, (k - 1)*(b - 1), 1-alpha);\n    \n    criticalFScoreBlock := ProbabilityToFScore(b - 1, (k - 1)*(b - 1), 1-alpha);\n    \n    \n    \n    topOfPage :=\n\"\n    <html>\n        <title>\n            Anova: Completely Randomized Block\n        </title>\n        \n        <body>\n\";\n    \n    topOfSummary :=\n\"\n            <h2>Anova: Completely Randomized Block</h2>\n            \n            <TABLE BORDER>\n                <CAPTION align=\\\"left\\\"> <h3>Summary</h3>  </CAPTION>\n                \n                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>\n\";\n\n    \n    summaryTableRows := \"\";\n    \n    summaryTableRow := \"<TR> <TD> <?Write(ToAtom(ToString(Level):ToString(index)));?> </TD> <TD align=\\\"right\\\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>\":Nl();\n    \n    \n    //Data summary.\n    index := 1;\n    \n    While(index <=? Length(levelsList))\n    [\n        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);\n    \n        index++;\n    ];\n    \n\n    //Block summary.\n    \n    blockSummaryTableRow := \"<TR> <TD> <?Write(ToAtom(\\\"Block\\\":ToString(index)));?> </TD> <TD align=\\\"right\\\"> <?Write(Length(row));?> </TD> <TD> <?Write(N(Sum(row)));?> </TD>  <TD> <?Write(N(Mean(row)));?> </TD> <TD> <?Write(N(UnbiasedVariance(row)));?> </TD> </TR>\":Nl();\n\n    index := 1;\n    \n    While(index <=? Length(First(levelsList)) )\n    [\n        row := MatrixColumn(levelsList, index);\n        \n        summaryTableRows := summaryTableRows : PatchString(blockSummaryTableRow);\n    \n        index++;\n    ];\n    \n    \n    \n    \n    \n    bottomOfSummary :=\n\"\n            </TABLE>\n\";\n    \n\n\n    topOfAnovaBlock :=\n\"\n            <br \\>\n            <br \\>\n            \n            <TABLE BORDER>\n                <CAPTION align=\\\"left\\\"> <h3>ANOVA: Completely Randomized Block</h3>  </CAPTION>\n                \n                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square </TH> <TH> F </TH> <TH> F Critical </TH> </TR>\n\";\n\n    \n    \n    anovaBlockTableRow1 := PatchString(\"<TR> <TD> <?Write(ToAtom(\\\"Between Levels\\\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(k - 1);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>\":Nl());\n    \n    anovaBlockTableRow2 := PatchString(\"<TR> <TD> <?Write(ToAtom(\\\"Between Blocks\\\"));?> </TD> <TD > <?Write(sumOfSquaresBlock);?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareBlock);?> </TD> <TD> <?Write(fScoreBlock);?> </TD> <TD> <?Write(criticalFScoreBlock);?> </TD> </TR>\":Nl());\n\n    anovaBlockTableRow3 := PatchString(\"<TR> <TD> <?Write(ToAtom(\\\"Within Levels\\\"));?> </TD> <TD > <?Write(sumOfSquaresWithin');?> </TD> <TD> <?Write(b - 1);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>\":Nl());\n\n    bottomOfAnovaBlock :=\n\"\n            </TABLE>\n\";\n\n\n    \n    bottomOfPage :=\n\"\n        </body>         \n    </html>\n\";\n    \n    htmlJavaString := JavaNew(\"java.lang.String\",\n                topOfPage : \n                topOfSummary : \n                summaryTableRows : \n                bottomOfSummary : \n                topOfAnovaBlock : \n                anovaBlockTableRow1 : \n                anovaBlockTableRow2 : \n                anovaBlockTableRow3 : \n                bottomOfAnovaBlock :\n                bottomOfPage);\n                \n                \n                \n     result := {};\n     \n     result[\"html\"] := htmlJavaString;\n     \n     result[\"sumOfSquaresWithin'\"] := sumOfSquaresWithin';\n     \n     result[\"sumOfSquaresBetween\"] := sumOfSquaresBetween;\n     \n     result[\"sumOfSquaresBlock\"] := sumOfSquaresBlock;\n     \n     result[\"sumOfSquaresTotal\"] := sumOfSquaresTotal;\n     \n     result[\"meanSquareBetween\"] := meanSquareBetween;\n     \n     result[\"meanSquareWithin\"] := meanSquareWithin;\n     \n     result[\"meanSquareBlock\"] := meanSquareBlock;\n     \n     result[\"fScore\"] := fScore;\n     \n     result[\"criticalFScore\"] := criticalFScore;\n     \n     result[\"fScoreBlock\"] := fScoreBlock;\n     \n     result[\"criticalFScoreBlock\"] := criticalFScoreBlock;\n     \n     result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/AnovaCompletelyRandomizedBlock.mpw";
        scriptMap.put("AnovaCompletelyRandomizedBlock",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"AnovaSingleFactor\",*);\n\nAnovaSingleFactor(levelsList, alpha) :=\n[\n    Check(IsListOfLists(levelsList), \"Argument\", \"The first argument must be a list of lists.\");\n    \n    Check(alpha >=? 0 And? alpha <=? 1, \"Argument\", \"The second argument must be a number between 0 and 1.\");\n    \n    Local(\n        anovaTableRow1,\n        anovaTableRow2,\n        anovaTableRow3,\n        anovaTableTotal,\n        bottomOfAnova,\n        bottomOfPage,\n        bottomOfSummary,\n        criticalFScore,\n        degreesOfFreedomBetween,\n        degreesOfFreedomWithin,\n        fScore,\n        grandMean,\n        htmlJavaString,\n        index,\n        lengthsList,\n        meansList,\n        meanSquareBetween,\n        meanSquareWithin,\n        result,\n        summaryTableRow,\n        summaryTableRows,\n        sumOfSquaresBetween,\n        sumOfSquaresTotal,\n        sumOfSquaresWithin,\n        sumsList,\n        topOfAnova,\n        topOfPage,\n        topOfSummary,\n        variancesList);\n\n    meansList := {};\n    \n    variancesList := {};\n    \n    sumsList := {};\n    \n    lengthsList := {};\n    \n    ForEach(levelList, levelsList)\n    [\n        meansList := meansList : N(Mean(levelList));\n        \n        variancesList := variancesList : N(UnbiasedVariance(levelList));\n        \n        sumsList := sumsList : N(Sum(levelList));\n\n        lengthsList := lengthsList : Length(levelList);\n    ];\n    \n    sumOfSquaresWithin := Sum((lengthsList - 1) * variancesList);\n\n    grandMean := N(Mean(Flatten(levelsList, \"List\")));\n    \n    sumOfSquaresBetween := Sum(lengthsList*(meansList - grandMean)^2);\n    \n    sumOfSquaresTotal := N(sumOfSquaresWithin + sumOfSquaresBetween);\n    \n    degreesOfFreedomBetween := (Length(levelsList)-1);\n    \n    degreesOfFreedomWithin := (ElementCount(levelsList) - Length(levelsList));\n    \n    meanSquareBetween := N(sumOfSquaresBetween/degreesOfFreedomBetween);\n    \n    meanSquareWithin := N(sumOfSquaresWithin/degreesOfFreedomWithin);\n    \n    fScore := N(meanSquareBetween/meanSquareWithin);\n    \n    criticalFScore := ProbabilityToFScore(degreesOfFreedomBetween, degreesOfFreedomWithin, 1-alpha);\n    \n    topOfPage :=\n\"\n    <html>\n        <title>\n            Anova: Single Factor\n        </title>\n        \n        <body>\n\";\n    \n    topOfSummary :=\n\"\n            <h2>Anova: Single Factor</h2>\n            \n            <TABLE BORDER>\n                <CAPTION align=\\\"left\\\"> <h3>Summary</h3>  </CAPTION>\n                \n                <TR> <TH> Level </TH> <TH> Count</TH> <TH> Sum </TH> <TH> Mean </TH> <TH> Variance </TH> </TR>\n\";\n\n    \n    summaryTableRows := \"\";\n    \n    summaryTableRow := \"<TR> <TD> <?Write(ToAtom(\\\"Level\\\":ToString(index)));?> </TD> <TD align=\\\"right\\\"> <?Write(lengthsList[index]);?> </TD> <TD> <?Write(sumsList[index]);?> </TD>  <TD> <?Write(meansList[index]);?> </TD> <TD> <?Write(variancesList[index]);?> </TD> </TR>\":Nl();\n    \n    index := 1;\n    While(index <=? Length(levelsList))\n    [\n        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);\n    \n        index++;\n    ];\n    \n    \n    bottomOfSummary :=\n\"\n            </TABLE>\n\";\n    \n\n\n    topOfAnova :=\n\"\n            <br \\>\n            <br \\>\n            \n            <TABLE BORDER>\n                <CAPTION align=\\\"left\\\"> <h3>ANOVA</h3>  </CAPTION>\n                \n                <TR> <TH> Source of Variation </TH> <TH> Sum of Squares </TH> <TH> Degrees of Freedom </TH> <TH> Mean Square Between </TH> <TH> F </TH> <TH> F Critical </TH> </TR>\n\";\n\n    \n    \n    anovaTableRow1 := PatchString(\"<TR> <TD> <?Write(ToAtom(\\\"Between Levels\\\"));?> </TD> <TD > <?Write(sumOfSquaresBetween);?> </TD> <TD> <?Write(degreesOfFreedomBetween);?> </TD>   <TD > <?Write(meanSquareBetween);?> </TD><TD> <?Write(fScore);?> </TD> <TD> <?Write(criticalFScore);?> </TD> </TR>\":Nl());\n    \n    anovaTableRow2 := PatchString(\"<TR> <TD> <?Write(ToAtom(\\\"Within Levels\\\"));?> </TD> <TD > <?Write(sumOfSquaresWithin);?> </TD> <TD> <?Write(degreesOfFreedomWithin);?> </TD>   <TD > <?Write(meanSquareWithin);?> </TD></TR>\":Nl());\n    \n    anovaTableTotal := PatchString(\"<TR> <TD> Total </TD> <TD> <?Write(sumOfSquaresTotal);?> </TD> <TD> <?Write(degreesOfFreedomBetween + degreesOfFreedomWithin);?> </TD> </TR>\");\n    \n    bottomOfAnova :=\n\"\n            </TABLE>\n\";\n\n\n    \n    bottomOfPage :=\n\"\n        </body>         \n    </html>\n\";\n    \n    htmlJavaString := JavaNew(\"java.lang.String\",\n                topOfPage : \n                topOfSummary : \n                summaryTableRows : \n                bottomOfSummary : \n                topOfAnova : \n                anovaTableRow1 : \n                anovaTableRow2 : \n                anovaTableTotal : \n                bottomOfAnova : \n                bottomOfPage);\n                \n                \n                \n     result := {};\n     \n     result[\"html\"] := htmlJavaString;\n     \n     result[\"sumOfSquaresWithin\"] := sumOfSquaresWithin;\n     \n     result[\"sumOfSquaresBetween\"] := sumOfSquaresBetween;\n     \n     result[\"sumOfSquaresTotal\"] := sumOfSquaresTotal;\n     \n     result[\"degreesOfFreedomBetween\"] := degreesOfFreedomBetween;\n     \n     result[\"degreesOfFreedomWithin\"] := degreesOfFreedomWithin;\n     \n     result[\"meanSquareBetween\"] := meanSquareBetween;\n     \n     result[\"meanSquareWithin\"] := meanSquareWithin;\n     \n     result[\"fScore\"] := fScore;\n     \n     result[\"criticalFScore\"] := criticalFScore;\n     \n     result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/AnovaSingleFactor.mpw";
        scriptMap.put("AnovaSingleFactor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n//Retract(\"BinomialDistributionMean\", *);\n\nBinomialDistributionMean(probability,numberOfTrials) :=\n[\n\n    Check(IsRationalOrNumber(probability) And? p >=? 0 And? p <=? 1, \"Argument\", \"The first argument must be a number between 0 and 1.\");\n    \n    Check(IsInteger(numberOfTrials) And? numberOfTrials >=? 0, \"Argument\", \"The second argument must be an integer which is greater than 0.\");\n    \n    numberOfTrials * probability;\n];\n        \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/BinomialDistributionMean.mpw";
        scriptMap.put("BinomialDistributionMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n//Retract(\"BinomialDistributionStandardDeviation\", *);\n\nBinomialDistributionStandardDeviation(probability,numberOfTrials) :=\n[\n\n    Check(IsRationalOrNumber(probability) And? p >=? 0 And? p <=? 1, \"Argument\", \"The first argument must be a number between 0 and 1.\");\n    \n    Check(IsInteger(numberOfTrials) And? numberOfTrials >=? 0, \"Argument\", \"The second argument must be an integer which is greater than 0.\");\n    \n    SqrtN(numberOfTrials * probability * (1 - probability));\n];\n        \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/BinomialDistributionStandardDeviation.mpw";
        scriptMap.put("BinomialDistributionStandardDeviation",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* \n    This function was adapted from the Javascript version of function\n    that is located here:\n    \n    http://www.fourmilab.ch/rpkp/experiments/analysis/chiCalc.js\n    http://www.fourmilab.ch/rpkp/experiments/analysis/chiCalc.html\n    \n    The following JavaScript functions for calculating normal and\n    chi-square probabilities and critical values were adapted by\n    John Walker from C implementations\n    written by Gary Perlman of Wang Institute, Tyngsboro, MA\n    01879. Both the original C code and this JavaScript edition\n    are in the public domain. \n*/\n\n\n/*  POCHISQ  --  probability of chi-square value\n\n          Adapted from:\n                  Hill, I. D. and Pike, M. C.  Algorithm 299\n                  Collected Algorithms for the CACM 1967 p. 243\n          Updated for rounding errors based on remark in\n                  ACM TOMS June 1985, page 185\n*/\n\nChiSquareScoreToAlpha(score, degreesOfFreedom) :=\n[\n    Local(a, y, s, e, c, z, LogSqrtPi, ISqrtPi,result);                     \n    \n    y := 0;\n    \n    LogSqrtPi := 0.5723649429247000870717135; /* log(sqrt(pi)) */\n    \n    ISqrtPi := 0.5641895835477562869480795;   /* 1 / sqrt(pi) */\n    \n    if(score <=? 0.0 Or? degreesOfFreedom <? 1) \n    [\n        result := 1.0;\n    ]\n    else\n    [\n        a := N(0.5 * score);\n        \n        if (degreesOfFreedom >? 1) \n        [\n            y := If(-a <? -20, 0, ExpN(-a));\n        ];\n        \n        s := If(IsEven(degreesOfFreedom), y , (2.0 * ZScoreToProbability(-SqrtN(score))));\n        \n        if (degreesOfFreedom >? 2) \n        [\n            score := 0.5 * (degreesOfFreedom - 1.0);\n            \n            z := If(IsEven(degreesOfFreedom), 1.0, 0.5);\n            \n            if (a >? 20) \n            [\n                e := If(IsEven(degreesOfFreedom), 0.0, LogSqrtPi);\n                \n                c := LogN(a);\n                \n                While(z <=? score) \n                [\n                    e := LogN(z) + e;\n                    s := s + If(c * z - a - e <? -20, 0, ExpN(c * z - a - e));\n                    z := z + 1.0;\n                ];\n                result := s;\n            ] \n            else \n            [\n                e := If(IsEven(degreesOfFreedom) , 1.0, (ISqrtPi / SqrtN(a)));\n                \n                c := 0.0;\n                \n                While(z <=? score) \n                [\n                    e := e * (a / z);\n                    c := c + e;\n                    z := z + 1.0;\n                ];\n                \n                result := c * y + s;\n            ];\n        ]\n        else\n        [\n            result := s;\n        ];\n    \n    ];\n    \n    N(result);\n];\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ChiSquareScoreToAlpha.mpw";
        scriptMap.put("ChiSquareScoreToAlpha",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nCoefficientOfDetermination(x,y) :=\n[   \n    Check(IsList(x), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(y), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(x) =? Length(y), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    N(CorrelationCoefficient(x,y)^2);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/CoefficientOfDetermination.mpw";
        scriptMap.put("CoefficientOfDetermination",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ConfidenceIntervalOfTheMean\",*);\n\nConfidenceIntervalOfTheMean(sampleMean,standardDeviation,standardDeviationIsKnown,sampleSize,confidenceLevel) :=\n[\n    Check(IsBoolean(standardDeviationIsKnown), \"Argument\", \"The third argument must be True or False.\");\n    \n    Local(criticalZScore,criticalTScore,standardErrorOfTheMean,upperLimitValue,lowerLimitValue,resultList);\n    \n    resultList := {};\n    \n    If(sampleSize >=? 30 Or? standardDeviationIsKnown =? True,\n    [\n        criticalZScore := N(ConfidenceLevelToZScore(confidenceLevel));\n        \n        resultList[\"criticalZScore\"] := criticalZScore;\n\n        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));\n        \n        lowerLimitValue := N(sampleMean - criticalZScore * standardErrorOfTheMean);\n        \n        upperLimitValue := N(sampleMean + criticalZScore * standardErrorOfTheMean);\n\n        \n        If(InVerboseMode(),\n            [\n                Echo(\"Using the normal distribution.\");\n                \n                Echo(\"Critical z-score: \", criticalZScore);\n                \n                Echo(\"Standard error of the mean: \", standardErrorOfTheMean);\n            ]);\n    ],\n    [   \n        criticalTScore := OneTailAlphaToTScore(sampleSize - 1, N((1 - confidenceLevel)/2));\n        \n        resultList[\"criticalTScore\"] := criticalTScore;\n        \n        standardErrorOfTheMean := N(StandardErrorOfTheMean(standardDeviation,sampleSize));\n        \n        lowerLimitValue := N(sampleMean - criticalTScore * standardErrorOfTheMean);\n        \n        upperLimitValue := N(sampleMean + criticalTScore * standardErrorOfTheMean);\n        \n        \n        If(InVerboseMode(),\n            [\n                Echo(\"Using the t-distribution.\");\n                \n                Echo(\"Critical t-score: \", criticalTScore);\n                \n                Echo(\"Standard error of the mean: \", standardErrorOfTheMean);\n            ]);\n    \n    ]);\n    \n    resultList[\"upperLimit\"] := upperLimitValue;\n    \n    resultList[\"lowerLimit\"] := lowerLimitValue;\n\n    resultList;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ConfidenceIntervalOfTheMean.mpw";
        scriptMap.put("ConfidenceIntervalOfTheMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ConfidenceIntervalOfTheProportion\",*);\n\nConfidenceIntervalOfTheProportion(numberOfSuccesses,sampleSize,confidenceLevel) :=\n[\n    Check(IsInteger(numberOfSuccesses) And? numberOfSuccesses >=? 0, \"Argument\", \"The first argument must be an integer which is >=?0\");\n    \n    Check(IsInteger(sampleSize) And? sampleSize >=? 0, \"Argument\", \"The second argument must be an integer which is >=?0\");\n    \n    Local(criticalZScore,approximateStandardErrorOfTheProportion,upperLimit,lowerLimit,resultList,proportion);\n    \n    resultList := {};\n    \n    criticalZScore := ConfidenceLevelToZScore(confidenceLevel);\n    \n    resultList[\"criticalZScore\"] := criticalZScore;\n    \n    proportion := N(numberOfSuccesses/sampleSize);\n    \n    approximateStandardErrorOfTheProportion := Sqrt((proportion*(1 - proportion))/sampleSize);\n    \n    upperLimit := N(proportion + criticalZScore * approximateStandardErrorOfTheProportion);\n    \n    lowerLimit := N(proportion - criticalZScore * approximateStandardErrorOfTheProportion);\n    \n    If(InVerboseMode(),\n        [\n            Echo(\"Critical z-score: \", criticalZScore);\n            \n            Echo(\"Proportion: \", proportion);\n            \n            Echo(\"Standard error of the proportion: \", N(approximateStandardErrorOfTheProportion));\n        ]);\n    \n    resultList[\"upperLimit\"] := upperLimit;\n    \n    resultList[\"lowerLimit\"] := lowerLimit;\n    \n    resultList;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ConfidenceIntervalOfTheProportion.mpw";
        scriptMap.put("ConfidenceIntervalOfTheProportion",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n//Retract(\"ConfidenceLevelToZScore\",*);\n\nConfidenceLevelToZScore(probability) :=\n[\n    //Shift the probability higher to turn it into a confidence interval.\n    probability := probability + (1 - probability)/2;\n    \n    ProbabilityToZScore(probability);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ConfidenceLevelToZScore.mpw";
        scriptMap.put("ConfidenceLevelToZScore",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nControlChartConstants(n) :=\n[   \n    Check(n >=? 2 And? n <=? 15, \"Argument\", \"The argument n must be 2 <=? n <=? 20.\");\n    \n    Local(result, table);\n    \n    result := {};\n    \n    n--;\n    \n    table := {\n        {1.880, 1.128, 0.000, 3.267},\n        {1.023, 1.693, 0.000, 2.574},\n        {0.729, 2.059, 0.000, 2.282},\n        {0.577, 2.326, 0.000, 2.114},\n        {0.483, 2.534, 0.000, 2.004},\n        {0.419, 2.704, 0.076, 1.924},\n        {0.373, 2.847, 0.136, 1.864},\n        {0.337, 2.970, 0.184, 1.816},\n        {0.308, 3.078, 0.223, 1.777},\n        {0.285, 3.173, 0.256, 1.744},\n        {0.266, 3.258, 0.283, 1.717},\n        {0.249, 3.336, 0.307, 1.693},\n        {0.235, 3.407, 0.328, 1.672},\n        {0.223, 3.472, 0.347, 1.653},\n        {0.212, 3.532, 0.363, 1.637},\n        {0.203, 3.588, 0.378, 1.622},\n        {0.194, 3.640, 0.391, 1.608},\n        {0.187, 3.689, 0.403, 1.597},\n        {0.180, 3.735, 0.415, 1.585},\n    };\n\n    result[\"D4\"] := table[n][4];\n    \n    result[\"D3\"] := table[n][3];\n    \n    result[\"d2\"] := table[n][2];\n        \n    result[\"A2\"] := table[n][1];\n    \n    result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ControlChartConstants.mpw";
        scriptMap.put("ControlChartConstants",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nCorrelationCoefficient(x,y) :=\n[   \n    Check(IsList(x), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(y), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(x) =? Length(y), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    Local(n);\n        \n    n := Length(x);\n    \n    N((n*Sum(x*y)-Sum(x)*Sum(y))/Sqrt((n*Sum(x^2)-(Sum(x))^2)*(n*Sum(y^2)-(Sum(y)^2))) );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/CorrelationCoefficient.mpw";
        scriptMap.put("CorrelationCoefficient",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nCorrelationMatrix(dataLists) := \n[\n    Local(namesList, correlationMatrix);\n    \n    ForEach(dataList, dataLists)\n    [\n        Check(IsMatrix(dataLists), \"Argument\", \"All lists must have the same number of elements.\");\n    ];\n\n    namesList := MatrixColumn(dataLists,1);\n    \n    namesList := \"\" : namesList;\n    \n    ForEach(dataList, dataLists)\n    [\n        PopFront(dataList);\n    ];\n    \n    correlationMatrix := ZeroMatrix(Length(dataLists)+1);\n    \n    ForEach(rowIndex, 1 .. Length(dataLists) + 1)\n    [\n        ForEach(columnIndex, 1 .. Length(dataLists) + 1)\n        [\n            if(rowIndex >=? 2 And? columnIndex >=? 2)\n            [\n                correlationMatrix[rowIndex][columnIndex] := N(CorrelationCoefficient(dataLists[rowIndex - 1],dataLists[columnIndex - 1]),2);\n            ]\n            else if(rowIndex =? 1)\n            [\n                correlationMatrix[rowIndex][columnIndex] := namesList[columnIndex];\n            ]\n            else\n            [\n                correlationMatrix[rowIndex][columnIndex] := namesList[rowIndex];\n            ];\n        ];\n    ];\n    \n    correlationMatrix;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/CorrelationMatrix.mpw";
        scriptMap.put("CorrelationMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nD2Value(k,n) :=\n[\n    Check(k >=? 0 And? k <=? 15, \"Argument\", \"The first argument k must be 0 <=? k <=? 15.\");\n    \n    Check(n >=? 2 And? n <=? 15, \"Argument\", \"The second argument n must be 2 <=? n <=? 15.\");\n    \n    n--;\n    \n    if(k =? 0)\n    [\n        {1.128,1.693,2.059,2.326,2.534,2.704,2.847,2.970,3.078,3.173,3.259,3.336,3.407,3.472}[n];\n    ]\n    else\n    [\n        {\n            {1.414, 1.912, 2.239, 2.481, 2.673, 2.830, 2.963, 3.078, 3.179, 3.269, 3.350, 3.424, 3.491, 3.553},\n            {1.279, 1.805, 2.151, 2.405, 2.604, 2.768, 2.906, 3.025, 3.129, 3.221, 3.305, 3.380, 3.449, 3.513},\n            {1.231, 1.769, 2.120, 2.379, 2.581, 2.747, 2.886, 3.006, 3.112, 3.205, 3.289, 3.366, 3.435, 3.499},\n            {1.206, 1.750, 2.105, 2.366, 2.570, 2.736, 2.877, 2.997, 3.103, 3.197, 3.282, 3.358, 3.428, 3.492},\n            {1.191, 1.739, 2.096, 2.358, 2.563, 2.730, 2.871, 2.992, 3.098, 3.192, 3.277, 3.354, 3.424, 3.488},\n            {1.181, 1.731, 2.090, 2.353, 2.558, 2.726, 2.867, 2.988, 3.095, 3.189, 3.274, 3.351, 3.421, 3.486},\n            {1.173, 1.726, 2.085, 2.349, 2.555, 2.723, 2.864, 2.986, 3.092, 3.187, 3.272, 3.349, 3.419, 3.484},\n            {1.168, 1.721, 2.082, 2.346, 2.552, 2.720, 2.862, 2.984, 3.090, 3.185, 3.270, 3.347, 3.417, 3.482},\n            {1.164, 1.718, 2.080, 2.344, 2.550, 2.719, 2.860, 2.982, 3.089, 3.184, 3.269, 3.346, 3.416, 3.481},\n            {1.160, 1.716, 2.077, 2.342, 2.549, 2.717, 2.859, 2.981, 3.088, 3.183, 3.268, 3.345, 3.415, 3.480},\n            {1.157, 1.714, 2.076, 2.340, 2.547, 2.716, 2.858, 2.980, 3.087, 3.182, 3.267, 3.344, 3.415, 3.479},\n            {1.155, 1.712, 2.074, 2.344, 2.546, 2.715, 2.857, 2.979, 3.086, 3.181, 3.266, 3.343, 3.414, 3.479},\n            {1.153, 1.710, 2.073, 2.338, 2.545, 2.714, 2.856, 2.978, 3.085, 3.180, 3.266, 3.343, 3.413, 3.478},\n            {1.151, 1.709, 2.072, 2.337, 2.545, 2.714, 2.856, 2.978, 3.085, 3.180, 3.265, 3.342, 3.413, 3.478},\n            {1.150, 1.708, 2.071, 2.337, 2.544, 2.713, 2.855, 2.977, 3.084, 3.179, 3.265, 3.342, 3.412, 3.477}\n        }[k][n];\n    ];\n    \n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/D2Value.mpw";
        scriptMap.put("D2Value",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nThis function came from http://www.johndcook.com/blog/2009/01/19/stand-alone-error-function-erf/\n\n\"This problem is typical in two ways: Abramowitz & Stegun has a solution, and \nyou've got to know a little background before you can use it.\n\nThe formula given in Abramowitz & Stegun is only good for x <=? 0. That's no problem if you \nknow that the error function is an odd function, i.e. erf(-x) = -erf(x). \nBut if you're an engineer who has never heard of the error function but \nneeds to use it, it may take a while to figure out how to handle negative inputs.\n\nOne other thing that someone just picking up A&S might not know is the \nbest way to evaluate polynomials. The formula appears as \n1 - (a1t1 + a2t2 + a3t3 + a4t4 + a5t5)exp(-x2), which is absolutely correct. \nBut directly evaluating an nth order polynomial takes O(n2) operations, \nwhile the factorization used in the code above uses O(n) operations. This \ntechnique is known as Horner's method. John D. Cook.\"\n\n*/\n\n//Retract(\"ErrorFunction\",*);\n\nErrorFunction(x) :=\n[\n    Local(a1,a2,a3,a4,a5,p,sign,t,y);\n    //constants\n    a1 :=  0.254829592;\n    a2 := -0.284496736;\n    a3 :=  1.421413741;\n    a4 := -1.453152027;\n    a5 :=  1.061405429;\n    p  :=  0.3275911;\n\n    //Save the sign of x\n    sign := 1;\n    \n    If(x <? 0, sign := -1);\n    \n    x := AbsN(x);\n\n    // Abramowitz & Stegun 7.1.26\n    t := 1.0/(1.0 + p*x);\n    y := N(1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Exp(-x*x));\n\n    sign*y;\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ErrorFunction.mpw";
        scriptMap.put("ErrorFunction",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"IsSubset\",*);\n\nIsSubset(bigList, littleList) :=\n[\n    Local(result);\n    result := True;\n    \n    ForEach(element, littleList)\n    [\n        If(Not? Contains(bigList,element), result := False);\n    ];\n\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/IsSubset.mpw";
        scriptMap.put("IsSubset",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMode(list) :=\n[\n    Check(Length(list) >? 0 And? IsNumericList(list), \"Argument\", \"Argument must be a nonempty numeric list.\");\n    \n    Local(noDuplicatesList, countsList, sortedList, highestCountsList, resultList);\n    \n    noDuplicatesList := RemoveDuplicates(list);\n    \n    countsList := {};\n    \n    ForEach(element, noDuplicatesList)\n    [\n        countsList := Append(countsList, {Count(list, element), element} );\n    ];\n    \n    sortedList := HeapSort(countsList,Lambda({x,y},x[1] >? y[1]));\n    \n    highestCountsList := Select(sortedList, Lambda({x},x[1] =? sortedList[1][1]));\n    \n    resultList := MapSingle(Lambda({x},x[2]), highestCountsList);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Mode.mpw";
        scriptMap.put("Mode",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Permutations\", *);\n\nPermutations(n) :=\n[\n    Check(IsInteger(n), \"Argument\", \"Argument must be an integer\");\n\n    n!;\n];\n\n\nPermutations(n, r) :=\n[\n    Check(IsInteger(n), \"Argument\", \"Argument 1 must be an integer\");\n    \n    Check(IsInteger(r), \"Argument\", \"Argument 2 must be an integer\");\n    \n    n! /(n-r)!;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Permutations.mpw";
        scriptMap.put("Permutations",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* \n    This function was adapted from the Javascript version of function\n    that is located here:\n    \n    http://www.fourmilab.ch/rpkp/experiments/analysis/zCalc.js\n    http://www.fourmilab.ch/rpkp/experiments/analysis/zCalc.html?\n    \n    The following JavaScript functions for calculating normal and\n    chi-square probabilities and critical values were adapted by\n    John Walker from C implementations\n    written by Gary Perlman of Wang Institute, Tyngsboro, MA\n    01879. Both the original C code and this JavaScript edition\n    are in the public domain. \n*/\n\n\n/* We just do a bisection\nsearch for a value within CHI_EPSILON,\nrelying on the monotonicity of pochisq(). */\n\n//Retract(\"ProbabilityToZScore\",*);\n\nProbabilityToZScore(probability) :=\n[\n    Local(ZMAX,ZEPSILON,minimumZ,maximumZ,zValue,probabilityValue);\n    \n    probability := N(probability);\n    \n    Check(probability >=? 0.0 And? probability <=? 1.0, \"Argument\", \"The argument must be between 0 and 1.\");\n    \n    ZMAX := 6; // Maximum �z value.\n    \n    ZEPSILON := 0.000001; /* Accuracy of z approximation */\n    \n    minimumZ := -ZMAX;\n    \n    maximumZ := ZMAX;\n    \n    zValue := 0.0;\n\n    While ((maximumZ - minimumZ) >? ZEPSILON) \n    [\n        probabilityValue := ZScoreToProbability(zValue);\n        \n        if (probabilityValue >? probability) \n        [\n            maximumZ := zValue;\n        ] \n        else \n        [\n            minimumZ := zValue;\n        ];\n        \n        zValue := (maximumZ + minimumZ) * 0.5;\n    ];\n    \n    zValue;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ProbabilityToZScore.mpw";
        scriptMap.put("ProbabilityToZScore",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Quartile\",*);\n\nQuartile(list) :=\n[\n    sortedList := HeapSort(list,\"<?\");\n    \n    secondQuartile := Median(sortedList);\n    \n    If(IsOdd(Length(sortedList)),\n    [   \n        secondQuartileIndex := Find(sortedList, secondQuartile);\n        \n        leftList := Take(sortedList, secondQuartileIndex-1);\n        rightList := Take(sortedList, -(Length(sortedList) - (secondQuartileIndex) ) );\n    ],\n    [\n\n        leftList := Take(sortedList, Length(sortedList)/2);\n        rightList := Take(sortedList, -Length(sortedList)/2);\n    ]\n    );\n    \n    firstQuartile := Median(leftList);\n    \n    thirdQuartile := Median(rightList);\n    \n    interquartileRange := thirdQuartile - firstQuartile;\n    \n    {firstQuartile, secondQuartile, thirdQuartile, interquartileRange};\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Quartile.mpw";
        scriptMap.put("Quartile",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RandomPick\",*);\n\n\nRandomPick(list) :=\n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Check(Length(list) >? 0, \"Argument\", \"The number of elements in the list must be greater than 0.\");\n    \n    Local(pickPosition);\n    \n    pickPosition := RandomInteger(Length(list));\n\n    list[pickPosition];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/RandomPick.mpw";
        scriptMap.put("RandomPick",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RandomPickVector\", *);\n\nRandomPickVector(list, count) :=\n[\n    Check(IsList(list), \"Argument\", \"Argument 1 must be a list.\");\n    \n    Check(IsInteger(count), \"Argument\", \"Argument 2 must be an integer.\");\n    \n    Table(RandomPick(list),x,1,count,1);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/RandomPickVector.mpw";
        scriptMap.put("RandomPickVector",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RandomPickWeighted\",*);\n\nRandomPickWeighted(list) :=\n[\n\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Local(element, probabilities, items, lastWeight, randomNumber, result);\n    \n    probabilities := 0;\n    \n    items := {};\n    \n    lastWeight := 0;\n    \n    \n    \n    //Make sure that the probabilities sum to 1.\n    ForEach(element,list)\n    [        \n        probability := element[2];\n\n        probabilities := probabilities + probability;\n    ];\n    \n    Check(probabilities =? 1, \"Argument\", \"The probabilities must sum to 1.\");\n    \n    \n    \n    //Place items in a list and associate it with a subrange in the range between 0 and 1.\n    ForEach(element,list)\n    [\n        probability := element[2];\n        \n        item := element[1];\n        \n        items := Append(items, {item, {lastWeight, lastWeight := lastWeight + N(probability)}} );\n    ];\n    \n    \n    \n    //Pick the item which is in the randomly determined range.\n    randomNumber := Random();\n    \n    ForEach(itemData,items)\n    [\n        If(randomNumber >=? itemData[2][1] And? randomNumber <=? itemData[2][2], result := itemData[1] );\n    ];\n    \n    \n    \n    result;\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/RandomPickWeighted.mpw";
        scriptMap.put("RandomPickWeighted",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRange(list) :=\n[\n    Check(Length(list) >? 0 And? IsNumericList(list), \"Argument\", \"Argument must be a nonempty numeric list.\");\n    \n    Maximum(list) - Minimum(list);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Range.mpw";
        scriptMap.put("Range",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRegressionLine(x,y) :=\n[   \n    Check(IsList(x), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(y), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(x) =? Length(y), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    Local(n,a,b,xMean,yMean,line,result);\n    \n    n := Length(x);\n    \n    b := N((n*Sum(x*y) - Sum(x)*Sum(y))/(n*Sum(x^2)-(Sum(x))^2));\n    \n    xMean := N(Mean(x));\n    \n    yMean := N(Mean(y));\n    \n    a := N(yMean - b*xMean);\n    \n    line := a + b*Hold(x);\n    \n    result := {};\n    \n    result[\"xMean\"] := xMean;\n    \n    result[\"yMean\"] := yMean;\n    \n    result[\"line\"] := line;\n    \n    result[\"yIntercept\"] := a;\n    \n    result[\"slope\"] := b;\n    \n    result[\"count\"] := n;\n    \n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/RegressionLine.mpw";
        scriptMap.put("RegressionLine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRegressionLineConfidenceInterval(x,y,xValue,confidenceLevel) :=\n[   \n    Check(IsList(x), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(y), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(x) =? Length(y), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    Check(confidenceLevel >=?0 And? confidenceLevel <=?1, \"Argument\", \"The confidence level must be >=? 0 and <=? 1.\");\n    \n    Local(n,a,b,xMean,part,result,criticalTScore,standardErrorOfTheEstimate/* regressionLine, todo:tk:causes an error if it is not global. */);\n    \n    regressionLine := RegressionLine(x,y);\n    \n    n := regressionLine[\"count\"];\n    \n    f(x) := [Eval(regressionLine[\"line\"]);];\n    \n    criticalTScore := OneTailAlphaToTScore(n-2, N((1 - confidenceLevel)/2));\n    \n    standardErrorOfTheEstimate := StandardErrorOfTheEstimate(x,y);\n\n    xMean := regressionLine[\"xMean\"];\n\n    part := N(criticalTScore * standardErrorOfTheEstimate * Sqrt(1/n + ((xValue - xMean)^2)/(Sum(x^2) - Sum(x)^2/n)));\n    \n    result := {};\n    \n    result[\"upper\"] := f(xValue) + part;\n    \n    result[\"lower\"] := f(xValue) - part;\n    \n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/RegressionLineConfidenceLevel.mpw";
        scriptMap.put("RegressionLineConfidenceInterval",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n\n//Retract(\"Repeat\",*);\n\n\n/*\n    These variables need to be declared as local symbols because\n    body is unfenced and expressions in the body could see them\n    otherwise.\n*/\nLocalSymbols(count, iterations, body)[\n\n\nRulebase(\"Repeat\",{iterations,body});\n\n/*\n  A Rule function needed to be used here because 10 # xxx <--\n  notation did not work if Bodied was executed before the\n  function was defined.  Bodied is evaluated in stdopers.mpw\n  because it needs to be evaluated for the parser to parse\n  Retract correctly.\n*/\n\nRule(\"Repeat\",2,10,IsInteger(iterations) And? iterations >? 0)\n[\n    Local(count);\n\n    count := 0;\n\n    While (iterations >? 0)\n    [\n        Eval(body);\n        iterations--;\n        count++;\n    ];\n\n    count;\n\n];\n\n\n\n\n\nRulebase(\"Repeat\",{body});\n\n\nRule(\"Repeat\",1,20,True)\n[\n    Local(count);\n\n    count := 0;\n    While (True)\n    [\n        Eval(body);\n        count++;\n    ];\n\n    count;\n];\n\n];//end LocalSymbols\n\nUnFence(\"Repeat\",2);\nHoldArgumentNumber(\"Repeat\",2,2);\nUnFence(\"Repeat\",1);\nHoldArgumentNumber(\"Repeat\",1,1);\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Repeat.mpw";
        scriptMap.put("Repeat",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Sample\",*);\n\nSample(list, sampleSize) :=\n[\n    Check(IsList(list), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsInteger(sampleSize) And? sampleSize >? 0, \"Argument\", \"The second argument must be an integer which is greater than 0.\");\n    \n    list := Shuffle(list);\n\n    Take(list, sampleSize);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Sample.mpw";
        scriptMap.put("Sample",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"SampleSizeForTheMean\",*);\n\nSampleSizeForTheMean(standardDeviation,confidenceLevel,marginOfError) :=\n[\n    Local(minimumSampleSize);\n    \n    zScore := ConfidenceLevelToZScore(confidenceLevel);\n    \n    minimumSampleSize := N(((zScore*standardDeviation)/marginOfError)^2);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/SampleSizeForTheMean.mpw";
        scriptMap.put("SampleSizeForTheMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"SampleSizeForTheProportion\",*);\n\nSampleSizeForTheProportion(probabilityOfSuccess,confidenceLevel,marginOfError) :=\n[\n    Check(probabilityOfSuccess >=?0 And? probabilityOfSuccess <=? 1, \"Argument\", \"The first argument must be between 0 and 1.\");\n\n    Local(minimumSampleSize,zScore);\n    \n    zScore := ConfidenceLevelToZScore(confidenceLevel);\n    \n    minimumSampleSize := N(probabilityOfSuccess*(1 - probabilityOfSuccess)*(zScore/marginOfError)^2);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/SampleSizeForTheProportion.mpw";
        scriptMap.put("SampleSizeForTheProportion",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nScheffeTest(levelsList, alpha) :=\n[\n    Check(IsListOfLists(levelsList), \"Argument\", \"The first argument must be a list of lists.\");\n    \n    Check(alpha >=? 0 And? alpha <=? 1, \"Argument\", \"The second argument must be a number between 0 and 1.\");\n    \n    Local(  result,\n            topOfSummary,\n            pairsList,\n            xBarB,\n            xBarA,\n            summaryTableRow,\n            ssw,\n            nA,\n            scheffeStatisticCalculated,\n            nB,\n            summaryList,\n            topOfPage,\n            htmlJavaString,\n            summaryTableRows,\n            meansList,\n            index,b,\n            pairList,\n            a,\n            bottomOfPage,\n            k,\n            countsList,\n            oneComparisonList,\n            scheffeStatistic,\n            bottomOfSummary,\n            resultList);\n    \n    anova := AnovaSingleFactor(levelsList, alpha);\n    \n    k := Length(levelsList);\n    \n    scheffeStatisticCalculated := (k-1)*anova[\"criticalFScore\"];\n    \n    resultList := {};\n    \n    resultList[\"scheffeStatisticCalculated\"] := scheffeStatisticCalculated;\n    \n    meansList := {};\n    \n    countsList := {};\n    \n    ForEach(levelList,levelsList)\n    [\n        meansList := meansList : N(Mean(levelList));\n    \n        countsList := countsList : Length(levelList);\n    ];\n    \n    pairsList := CombinationsList(1 .. Length(levelsList),2);\n    \n    summaryList := {};\n    \n    index := 1;\n    \n    ForEach(pairList, pairsList)\n    [   \n        a := pairList[1];\n        \n        b := pairList[2];\n        \n        xBarA := meansList[a];\n        \n        nA := countsList[a];\n        \n        xBarB := meansList[b];\n        \n        nB := countsList[b];\n        \n        ssw := anova[\"sumOfSquaresWithin\"];\n        \n        scheffeStatistic := ScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList);\n        \n        oneComparisonList := {};\n        \n        oneComparisonList[\"conclusion\"] := If(scheffeStatistic <=? scheffeStatisticCalculated, \"No Difference\", \"Difference\");\n        \n        oneComparisonList[\"scheffeStatistic\"] := scheffeStatistic;\n        \n        oneComparisonList[\"pair\"] := pairList;\n        \n        summaryList[\"pair\" : ToString(index)] := oneComparisonList;\n        \n        index++;\n    ];\n    \n    resultList[\"summary\"] := summaryList;\n    \n    \n    \n    \n    topOfPage :=\n\"\n    <html>\n        <title>\n            Scheffe Test Summary\n        </title>\n        \n        <body>\n\";\n    \n    topOfSummary :=\n\"\n            <h2>Scheffe Test Summary</h2>\n            \n            <TABLE BORDER>\n                <CAPTION align=\\\"left\\\"> <h3>Summary</h3>  </CAPTION>\n                \n                <TR> <TH> Sample Pair</TH> <TH> Measured Scheffe Statistic </TH> <TH> Calculated Scheffe Statistic </TH> <TH> Conclusion </TH> </TR>\n\";\n\n    \n    summaryTableRows := \"\";\n    \n    summaryTableRow := \"<TR> <TD align=\\\"center\\\"> <?Write(ToAtom(ToString(pairList[1]) : \\\" and \\\" : ToString(pairList[2])));?> </TD> <TD align=\\\"right\\\"> <?Write(summary[\\\"scheffeStatistic\\\"]);?> </TD> <TD align=\\\"right\\\"> <?Write(resultList[\\\"scheffeStatisticCalculated\\\"]);?> </TD>  <TD> <?Write(ToAtom(summary[\\\"conclusion\\\"]));?> </TD> </TR>\":Nl();\n    \n\n    \n    ForEach(summary, Reverse(resultList[\"summary\"]))\n    [\n        summary := summary[2];\n\n        pairList := summary[\"pair\"];\n        \n        summaryTableRows := summaryTableRows : PatchString(summaryTableRow);\n    \n        index++;\n    ];\n    \n    \n    bottomOfSummary :=\n\"\n            </TABLE>\n\";\n    \n    \n    bottomOfPage :=\n\"\n        </body>         \n    </html>\n\";\n    \n    htmlJavaString := JavaNew(\"java.lang.String\",\n                topOfPage : \n                topOfSummary : \n                summaryTableRows : \n                bottomOfSummary : \n                bottomOfPage);    \n    \n    \n    \n    \n    resultList[\"html\"] := htmlJavaString;\n    \n    \n    DestructiveReverse(resultList);\n\n];\n\n\n\n\n\n\nScheffeStatistic(xBarA,nA,xBarB,nB,ssw,k,countsList) :=\n[\n    N(((xBarA-xBarB)^2)/((ssw/Sum(i,1,k,(countsList[i] - 1))*(1/nA + 1/nB))));   \n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ScheffeTest.mpw";
        scriptMap.put("ScheffeTest",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Shuffle\",*);\n\n/*\n This function is based on the Fisher-Yates/Knuth shuffle algorithm\n which is described here at \n http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle .\n*/\nShuffle(list) :=\n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Local(index, randomIndex, temporary);\n    \n    list := FlatCopy(list);\n    \n    index := Length(list);\n    \n    While(index >? 1)\n    [\n        randomIndex := RandomInteger(1,index);\n        \n        temporary := list[randomIndex];\n        \n        list[randomIndex] := list[index];\n        \n        list[index] := temporary;\n        \n        index--;\n    ];      \n    \n    list;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/Shuffle.mpw";
        scriptMap.put("Shuffle",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ShuffledDeckNoSuits\",*);\n\n\nShuffledDeckNoSuits() := \n[\n   Shuffle(Concat(1 .. 13, 1 .. 13, 1 .. 13, 1 .. 13));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ShuffledDeckNoSuits.mpw";
        scriptMap.put("ShuffledDeckNoSuits",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nStandardErrorOfTheEstimate(xList,yList) :=\n[   \n    Check(IsList(xList), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(yList), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(xList) =? Length(yList), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    Local(n,a,b,regressionLine);\n    \n    regressionLine := RegressionLine(xList,yList);\n    \n    n := regressionLine[\"count\"];\n    \n    a := regressionLine[\"yIntercept\"];\n    \n    b := regressionLine[\"slope\"];\n        \n    N(Sqrt((Sum(yList^2) - a*Sum(yList) - b*Sum(xList*yList))/(n-2)));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/StandardErrorOfTheEstimate.mpw";
        scriptMap.put("StandardErrorOfTheEstimate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"StandardErrorOfTheMean\",*);\n\nStandardErrorOfTheMean(sigma, sampleSize) :=\n[\n    Check(sigma >? 0, \"Argument\", \"The first argument must be a number which is greater than 0.\");\n    \n    Check(IsInteger(sampleSize) And? sampleSize >? 0, \"Argument\", \"The second argument must be an integer which is greater than 0.\");\n    \n    sigma/Sqrt(sampleSize);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/StandardErrorOfTheMean.mpw";
        scriptMap.put("StandardErrorOfTheMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"StandardErrorOfTheProportion\",*);\n\nStandardErrorOfTheProportion(meanOfSampleProportions, sampleSize) :=\n[\n    Check(IsRationalOrNumber(meanOfSampleProportions), \"Argument\", \"The first argument must be a number.\");\n    \n    Check(IsInteger(sampleSize) And? sampleSize >? 0, \"Argument\", \"The second argument must be an integer which is greater than 0.\");\n    \n    Sqrt((meanOfSampleProportions*(1 - meanOfSampleProportions))/sampleSize);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/StandardErrorOfTheProportion.mpw";
        scriptMap.put("StandardErrorOfTheProportion",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nStandardErrorOfTheSlope(xList,yList) :=\n[   \n    Check(IsList(xList), \"Argument\", \"The first argument must be a list.\");\n    \n    Check(IsList(yList), \"Argument\", \"The second argument must be a list.\");\n    \n    Check(Length(xList) =? Length(yList), \"Argument\", \"The lists for argument 1 and argument 2 must have the same length.\");\n    \n    Local(standardErrorOfTheEstimate,n,xMean);\n    \n    standardErrorOfTheEstimate := StandardErrorOfTheEstimate(xList,yList);\n    \n    n := Length(xList);\n    \n    xMean := Mean(xList);\n    \n    N(standardErrorOfTheEstimate/Sqrt(Sum(xList^2) - n*xMean^2));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/StandardErrorOfTheSlope.mpw";
        scriptMap.put("StandardErrorOfTheSlope",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ValueToZScore\",*);\n\nValueToZScore(value,mean,standardDeviation) :=\n[\n    (value - mean)/standardDeviation;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ValueToZScore.mpw";
        scriptMap.put("ValueToZScore",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\nWeightedMean(list) :=\n[\n\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Local( values, lastWeight, weights );\n    \n    values := {};\n    \n    weights := {};\n    \n    \n    ForEach(element,list)\n    [        \n        Check(IsList(element), \"Argument\", \"Values and their associated weights must be in a list.\");\n        \n        Check(Length(element) =? 2, \"Argument\", \"Each value and its associated weight must be in a two element list.\");\n        \n        values := values : element[1];\n\n        weights := weights : element[2];\n    ];\n    \n    Sum(values * weights)/Sum(weights);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/WeightedMean.mpw";
        scriptMap.put("WeightedMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* \n    This function was adapted from the Javascript version of function\n    that is located here:\n    \n    http://www.fourmilab.ch/rpkp/experiments/analysis/zCalc.js\n    http://www.fourmilab.ch/rpkp/experiments/analysis/zCalc.html?\n    \n    The following JavaScript functions for calculating normal and\n    chi-square probabilities and critical values were adapted by\n    John Walker from C implementations\n    written by Gary Perlman of Wang Institute, Tyngsboro, MA\n    01879. Both the original C code and this JavaScript edition\n    are in the public domain. \n*/\n\n\n\n/* \n    POZ -- probability of normal z value\n\n    Adapted from a polynomial approximation in:\n    Ibbetson D, Algorithm 209\n    Collected Algorithms of the CACM 1963 p. 616\n    Note:\n    This routine has six digit accuracy, so it is only useful for absolute\n    z values <?:= 6. For z values > to 6.0, poz() returns 1.0.\n*/\n\nZScoreToProbability(zScore) :=\n[\n    zScore := N(zScore);\n    \n    Local( y, x, w, ZMAX, result);\n    \n    ZMAX := 6; // Maximum �z value\n    \n    if(zScore =? 0.0)\n    [\n        x := 0.0;\n    ]\n    else\n    [\n        y := 0.5 * AbsN(zScore);\n        \n        if(y >? ZMAX * 0.5)\n        [\n            x := 1.0;\n        ]\n        else if(y <? 1.0)\n        [\n            w := y * y;\n            x := ((((((((0.000124818987 * w\n            - 0.001075204047) * w + 0.005198775019) * w\n            - 0.019198292004) * w + 0.059054035642) * w\n            - 0.151968751364) * w + 0.319152932694) * w\n            - 0.531923007300) * w + 0.797884560593) * y * 2.0;\n        ]\n        else\n        [\n            y := y - 2.0;\n            \n            x := (((((((((((((-0.000045255659 * y\n            + 0.000152529290) * y - 0.000019538132) * y\n            - 0.000676904986) * y + 0.001390604284) * y\n            - 0.000794620820) * y - 0.002034254874) * y\n            + 0.006549791214) * y - 0.010557625006) * y\n            + 0.011630447319) * y - 0.009279453341) * y\n            + 0.005353579108) * y - 0.002141268741) * y\n            + 0.000535310849) * y + 0.999936657524;\n        ];\n    ];\n    \n        \n    If(zScore >? 0.0 , result := (x + 1.0) * 0.5 , result := (1.0 - x) * 0.5);\n    \n    result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ZScoreToProbability.mpw";
        scriptMap.put("ZScoreToProbability",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"ZScoreToValue\",*);\n\nZScoreToValue(zScore) :=\n[\n    -((-mean)/standardDeviation - zScore)*standardDeviation;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/proposed/statistics/ZScoreToValue.mpw";
        scriptMap.put("ZScoreToValue",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*********************************************************************************************#\n#                       The PSLQ Integer Relation Algorithm                                   #\n#                                                                                             #\n# Aut.: Helaman R.P. Ferguson and David Bailey \"A Polynomial Time, Numerically Stable         #\n#       Integer Relation Algorithm\" (RNR Technical Report RNR-92-032)    helaman@super.org    #\n# Ref.: David Bailey and Simon Plouffe \"Recognizing Numerical Constants\" dbailey@nas.nasa.gov #\n# Cod.: Raymond Manzoni  raymman@club-internet.fr                                             #\n#*********************************************************************************************#\n# Creation:97/11                    #\n# New termination criteria:97/12/15 #\n# this code is free...              #\n\nPorted to MathPiper 2000 Ayal Pinkus.\n\nGiven a list of constants x find coefficients sol[i] such that\n      sum(sol[i]*x[i], i=1..n) = 0    (where n=Length(x))\n\n    x is the list of real expressions\n          N(x[i]) must evaluate to floating point numbers!\n    precision is the number of digits needed for completion;\n          must be greater or equal to log10(max(sol[i]))*n\n    returns the list of solutions with initial precision\n          and the confidence (the lower the better)\n\n    Example:\n\n    In> Pslq({2*Pi-4*Exp(1),Pi,Exp(1)},20)\n    Result: {1,-2,4};\n\n*/\n\nPslq(x, precision) :=\n[\n  Local (ndigits, gam, A, B, H, n, i, j, k, s, y, tmp, t, m, maxi, gami,\n         t0, t1, t2, t3, t4, mini, Confidence, norme,result);\n  n:=Length(x);\n  ndigits:=BuiltinPrecisionGet();\n  BuiltinPrecisionSet(precision+10); // 10 is chosen arbitrarily, but should always be enough. Perhaps we can optimize by lowering this number\n  Confidence:=10^(-FloorN(N(Eval(precision/3))));\n//Echo(\"Confidence is \",Confidence);\n\n  gam:=N(Sqrt(4/3));\n  For (i:=1, i<=?n,i++) x[i]:=N(Eval(x[i]));\n\n//Echo(\"1...\");\n\n  A:=Identity(n); /*A and B are of Integer type*/\n  B:=Identity(n); /*but this doesn't speed up*/\n  s:=ZeroVector(n);\n  y:=ZeroVector(n);\n\n//Echo(\"2...\");\n\n  For(k:=1,k<=?n,k++)\n  [\n    tmp:=0;\n    For (j:=k,j<=?n,j++) tmp:=tmp + N(x[j]^2);\n//tmp:=DivideN(tmp,1.0);\n//Echo(\"tmp is \",tmp);\n//MathDebugInfo(tmp);\n/*If(Not? IsPositiveNumber(tmp),\n  Echo(\"******** not a positive number: \",tmp)\n);\nIf(Not? IsNumber(tmp),\n  Echo(\"******** not a number: \",tmp)\n);\nIf(IsLessThan(tmp,0),\n[\n  Echo(\"******** not positive: \",tmp);\n]\n);*/\n\n    s[k]:=SqrtN(tmp);\n\n\n/*If(Not? IsNumber(tmp),\n[\nEcho(\"************** tmp = \",tmp);\n]);\nIf(Not? IsNumber(s[k]),\n[\nEcho(\"************** s[k] = \",s[k]);\n]);*/\n\n  ];\n\n//Echo(\"3...\");\n\n  tmp:=N(Eval(s[1]));\n/*If(Not? IsNumber(tmp),\n[\nEcho(\"************** tmp = \",tmp);\n]);*/\n\n  For (k:= 1,k<=? n,k++)\n  [\n    y[k]:=N(Eval(x[k]/tmp));\n    s[k]:=N(Eval(s[k]/tmp));\n\n//Echo(\"1...\",\" \",y[k],\" \",s[k]);\n/*If(Not? IsNumber(y[k]),\n[\nEcho(\"************** y[k] = \",y[k]);\n]);\nIf(Not? IsNumber(s[k]),\n[\nEcho(\"************** s[k] = \",s[k]);\n]);*/\n\n  ];\n  H:=ZeroMatrix(n, n-1);\n\n//Echo(\"4...\",n);\n  For (i:=1,i<=? n,i++)\n  [\n\n    if (i <=? n-1)  [ H[i][i]:=N(s[i + 1]/s[i]); ];\n\n//Echo(\"4.1...\");\n    For (j:= 1,j<=?i-1,j++)\n    [\n//Echo(\"4.2...\");\n      H[i][j]:= N(-(y[i]*y[j])/(s[j]*s[j + 1]));\n//Echo(\"4.3...\");\n\n/*If(Not? IsNumber(H[i][j]),\n[\nEcho(\"************** H[i][j] = \",H[i][j]);\n]\n);*/\n\n    ];\n  ];\n\n//Echo(\"5...\");\n\n  For (i:=2,i<=?n,i++)\n  [\n    For (j:=i-1,j>=? 1,j--)\n    [\n//Echo(\"5.1...\");\n      t:=Round(H[i][j]/H[j][j]);\n//Echo(\"5.2...\");\n      y[j]:=y[j] + t*y[i];\n//Echo(\"2...\",\" \",y[j]);\n      For (k:=1,k<=?j,k++) [ H[i][k]:=H[i][k]-t*H[j][k]; ];\n      For (k:=1,k<=?n,k++)\n      [\n        A[i][k]:=A[i][k]-t*A[j][k];\n        B[k][j]:=B[k][j] + t*B[k][i];\n      ];\n    ];\n  ];\n  Local(found);\n  found:=False;\n\n//Echo(\"Enter loop\");\n\n  While (Not?(found))\n  [\n    m:=1;\n//Echo(\"maxi 1...\",maxi);\n    maxi:=N(gam*Abs(H[1][1]));\n//Echo(\"maxi 2...\",maxi);\n    gami:=gam;\n//Echo(\"3...\");\n    For (i:= 2,i<=? n-1,i++)\n    [\n      gami:=gami*gam;\n      tmp:=N(gami*Abs(H[i][i]));\n      if (maxi <? tmp)\n      [\n        maxi:=tmp;\n//Echo(\"maxi 3...\",maxi);\n        m:=i;\n      ];\n    ];\n//Echo(\"4...\",maxi);\n    tmp:=y[m + 1];\n    y[m + 1]:=y[m];\n    y[m]:=tmp;\n//Echo(\"3...\",\" \",y[m]);\n//Echo(\"5...\");\n    For (i:= 1,i<=?n,i++)\n    [\n      tmp:=A[m + 1][ i];\n      A[m + 1][ i]:=A[m][ i];\n      A[m][ i]:=tmp;\n      tmp:=B[i][ m + 1];\n      B[i][ m + 1]:=B[i][ m];\n      B[i][ m]:=tmp;\n    ];\n    For (i:=1,i<=?n-1,i++)\n    [\n      tmp:=H[m + 1][ i];\n\n      H[m + 1][ i]:=H[m][ i];\n      H[m][ i]:=tmp;\n    ];\n//Echo(\"7...\");\n    if (m <? n-1)\n    [\n      t0:=N(Eval(Sqrt(H[m][ m]^2 + H[m][ m + 1]^2)));\n\n      t1:=H[m][ m]/t0;\n      t2:=H[m][ m + 1]/t0;\n\n//      If(IsZero(t0),t0:=N(Confidence));\n//Echo(\"\");\n//Echo(\"H[m][ m] = \",N(H[m][ m]));\n//Echo(\"H[m][ m+1] = \",N(H[m][ m+1]));\n\n//If(IsZero(t0),[t1:=Infinity;t2:=Infinity;]);\n//Echo(\"t0=\",N(t0));\n//Echo(\"t1=\",N(t1));\n//Echo(\"t2=\",N(t2));\n\n      For (i:=m,i<=?n,i++)\n      [\n        t3:=H[i][ m];\n        t4:=H[i][ m + 1];\n//Echo(\"    t1 = \",t1);\n//Echo(\"    t2 = \",t2);\n//Echo(\"    t3 = \",t3);\n//Echo(\"    t4 = \",t4);\n        H[i][ m]:=t1*t3 + t2*t4;\n//Echo(\"7.1... \",H[i][ m]);\n        H[i][ m + 1]:= -t2*t3 + t1*t4;\n//Echo(\"7.2... \",H[i][ m+1]);\n      ];\n    ];\n//Echo(\"8...\");\n    For (i:= 1,i<=? n,i++)\n    [\n      For (j := Minimum(i-1, m + 1),j>=? 1,j--)\n      [\n        t:=Round(H[i][ j]/H[j][ j]);\n//Echo(\"MATRIX\",H[i][ j],\" \",H[j][ j]);\n//Echo(\"5... before\",\" \",y[j],\" \",t,\" \",y[i]);\n        y[j]:=y[j] + t*y[i];\n//Echo(\"5... after\",\" \",y[j]);\n        For (k:=1,k<=?j,k++) H[i][ k]:=H[i][ k]-t*H[j][ k];\n        For (k:= 1,k<=?n,k++)\n        [\n          A[i][ k]:=A[i][ k]-t*A[j][ k];\n          B[k][ j]:=B[k][ j] + t*B[k][ i];\n        ];\n      ];\n    ];\n//Echo(\"9...\",N(H[1],10));\n\n    /* BuiltinPrecisionSet(10);*/ /*low precision*/\n//    maxi := N(Dot(H[1],  H[1]),10);\n    maxi := N(Dot(H[1], H[1]));\n//Echo(\"H[1] = \",H[1]);\n//Echo(\"N(H[1]) = \",N(H[1]));\n//Echo(\"N(Dot(H[1], H[1])) = \",N(Dot(H[1], H[1])));\n//Echo(\"maxi 4...\",maxi);\n\n//Echo(\"9... maxi = \",maxi);\n\n    For (j:=2,j<=?n,j++)\n    [\n//Echo(\"9.1...\");\n      tmp:=N(Dot(H[j], H[j]),10);\n//Echo(\"9.2...\");\n      if (maxi <? tmp) [ maxi:=tmp; ];\n//Echo(\"maxi 5...\",maxi);\n//Echo(\"9.3...\");\n    ];\n//Echo(\"10...\");\n    norme:=N(Eval(1/Sqrt(maxi)));\n    m:=1;\n    mini:=N(Eval(Abs(y[1])));\n//Echo(\"y[1] = \",y[1],\" mini = \",mini);\n    maxi:=mini;\n\n//Echo(\"maxi 6...\",maxi);\n//Echo(\"11...\");\n    For (j:=2,j<=?n,j++)\n    [\n      tmp:=N(Eval(Abs(y[j])));\n      if (tmp <? mini)\n      [\n        mini:=tmp;\n        m:=j;\n      ];\n      if (tmp >? maxi) [ maxi:=tmp; ];\n//Echo(\"maxi 7...\",maxi);\n    ];\n    /* following line may be commented */\n//Echo({\"Norm bound:\",norme,\" Min=\",mini,\" Conf=\",mini/maxi,\" required \",Confidence});\n    if ((mini/maxi) <? Confidence) /*prefered to : if mini <? 10^(- precision) then*/\n    [\n    /* following line may be commented */\n/*      Echo({\"Found with Confidence \",mini/maxi}); */\n      BuiltinPrecisionSet(ndigits);\n      result:=Transpose(B)[m];\n      found:=True;\n    ]\n    else\n    [\n      maxi:=Abs(A[1][ 1]);\n      For (i:=1,i<=?n,i++)\n      [\n//Echo(\"i = \",i,\" n = \",n);\n        For (j:=1,j<=?n,j++)\n        [\n//Echo(\"j = \",j,\" n = \",n);\n          tmp:=Abs(A[i][ j]);\n          if (maxi <? tmp) [ maxi:=tmp;];\n        ];\n      ];\n//Echo(\"maxi = \",maxi);\n      if (maxi >? 10^(precision))\n      [\n        BuiltinPrecisionSet(ndigits);\n        result:=Fail;\n        found:=True;\n      ];\n      BuiltinPrecisionSet(precision+2);\n//Echo(\"CLOSE\");\n    ];\n  ];\n  result;\n];\n\n/* end of file */\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/pslq/Pslq.mpw";
        scriptMap.put("Pslq",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n * File `rabinmiller.mpi' is an implementation of the\n *           Rabin-Miller primality test.\n */\n\n\n/*\n * FastModularPower(a, b, n) computes a^b (mod n) efficiently.\n * This function is called by IsStronglyProbablyPrime.\n */\n\nFastModularPower(a_IsPositiveInteger, b_IsPositiveInteger, n_IsPositiveInteger) <--\n[\n  Local(p, j, r);\n  p := a;\n  j := b;\n  r := 1;\n\n  While (j >? 0)\n    [\n      If (IsOdd(j), r := ModuloN(r*p, n));\n      p := ModuloN(p*p, n);\n      j := ShiftRight(j, 1);\n    ];\n  r;\n];\n\n\n/*\n * An integer n is `strongly-probably-prime' for base b if\n *\n *                   b^q = 1 (mod n) or\n * b^(q*2^i) = -1 (mod n) for some i such that 0 <= i < r\n *\n *    where q and r are such that n-1 = q*2^r and q is odd.\n *\n * If an integer is not strongly-probably-prime for a given\n * base b, then it is composed. The reciprocal is false.\n * Composed strongly-probably-prime numbers for base b\n * are called `strong pseudoprimes' for base b.\n */\n// this will return a pair {root, True/False}\nIsStronglyProbablyPrime(b_IsPositiveInteger, n_IsPositiveInteger) <--\n[\n  Local(m, q, r, a, flag, i, root);\n  m := n-1;\n  q := m;\n  r := 0;\n  root := 0;        // will be the default return value of the \"root\"\n  While (IsEven(q))\n  [\n    q := ShiftRight(q, 1);\n    r++;\n  ];\n\n  a := FastModularPower(b, q, n);\n  flag := (a =? 1 Or? a =? m);\n  i := 1;\n\n  While (Not?(flag) And? (i <? r))\n  [\n        root := a;        // this is the value of the root if flag becomes true now\n    a := ModuloN(a*a, n);\n    flag := (a =? m);\n    i++;\n  ];\n\n  {root, flag};        // return a root of -1 (or 0 if not found)\n];\n\n\n/*\n * For numbers less than 3.4e14, exhaustive computations have\n * shown that there is no strong pseudoprime simultaneously for\n * bases 2, 3, 5, 7, 11, 13 and 17.\n * Function RabinMillerSmall is based on the results of these\n * computations.\n */\n\n10 # RabinMillerSmall(1) <-- False;\n\n10 # RabinMillerSmall(2) <-- True;\n\n20 # RabinMillerSmall(n_IsEven) <-- False;\n\n20 # RabinMillerSmall(3) <-- True;\n\n30 # RabinMillerSmall(n_IsPositiveInteger) <--\n[\n  Local(continue, prime, i, primetable, pseudotable, root);\n  continue := True;\n  prime := True;\n  i := 1;\n  primetable := {2, 3, 5, 7, 11, 13, 17};\n  pseudotable := {2047, 1373653, 25326001, 3215031751, 2152302898747,\n                  3474749660383, 34155071728321};\n  // if n is strongly probably prime for all bases up to and including primetable[i], then n is actually prime unless it is >= pseudotable[i].\n  While (continue And? prime And? (i <? 8))\n  [        // we do not really need to collect the information about roots of -1 here, so we do not do anything with root\n    {root, prime} := IsStronglyProbablyPrime(primetable[i], n);\n    //If(InVerboseMode() And? prime, Echo(\"RabinMiller: Info: \", n, \"is spp base\", primetable[i]));\n    continue := (n >=? pseudotable[i]);\n    i++;\n  ];\n  // the function returns \"Overflow\" when we failed to check (i.e. the number n was too large)\n  If (continue And? (i =? 8), Overflow, prime);\n];\n\n\n/*\n * RabinMillerProbabilistic(n, p) tells whether n is prime.\n * If n is actually prime, the result will always be `True'.\n * If n is composed the probability to obtain the wrong\n * result is less than 4^(-p).\n */\n// these 4 rules are not really used now because RabinMillerProbabilistic is only called for large enough n\n10 # RabinMillerProbabilistic(1, _p) <-- False;\n\n10 # RabinMillerProbabilistic(2, _p) <-- True;\n\n20 # RabinMillerProbabilistic(n_IsEven, _p) <-- False;\n\n20 # RabinMillerProbabilistic(3, _p) <-- True;\n\n30 # RabinMillerProbabilistic(n_IsPositiveInteger, p_IsPositiveInteger) <--\n[\n  Local(k, prime, b, roots'of'minus1, root);\n  k := 1+IntLog(IntLog(n,2),4)+p;        // find k such that Ln(n)*4^(-k) < 4^(-p)\n  b := 1;\n  prime := True;\n  roots'of'minus1 := {0};        // accumulate the set of roots of -1 modulo n\n  While (prime And? k>?0)\n    [\n      b := NextPseudoPrime(b);        // use only prime bases, as suggested by Davenport; weak pseudo-primes are good enough\n      {root, prime} := IsStronglyProbablyPrime(b, n);\n          If(prime, roots'of'minus1 := Union(roots'of'minus1, {root}));\n          If(Length(roots'of'minus1)>?3, prime := False);\n          //If(InVerboseMode() And? prime, Echo(\"RabinMiller: Info: \", n, \"is spp base\", b));\n          If( // this whole If() clause is only working when InVerboseMode() is in effect and the test is terminated in the unusual way\n                  InVerboseMode() And? Length(roots'of'minus1)>?3,\n                  [        // we can actually find a factor of n now\n                        Local(factor);\n                        roots'of'minus1 := Difference(roots'of'minus1,{0});\n                        //Echo(\"RabinMiller: Info: \", n, \"is composite via roots of -1 ; \", roots'of'minus1);\n                        factor := Gcd(n, If(\n                                roots'of'minus1[1]+roots'of'minus1[2]=?n,\n                                roots'of'minus1[1]+roots'of'minus1[3],\n                                roots'of'minus1[1]+roots'of'minus1[2]\n                        ));\n                        Echo(n, \" = \", factor, \" * \", n/factor);\n                ]\n          );\n      k--;\n    ];\n  prime;\n];\n\n\n/*\n * This is the frontend function, which uses RabinMillerSmall for\n * ``small'' numbers and RabinMillerProbabilistic for bigger ones.\n *\n * The probability to err is set to 1e-25, hopeing this is less\n * than the one to step on a rattlesnake in northern Groenland. :-)\n */\n\nRabinMiller(n_IsPositiveInteger) <--\n[\n        //If(InVerboseMode(), Echo(\"RabinMiller: Info: Testing \", n));\n        If(\n                n <? 34155071728321,\n                RabinMillerSmall(n),\n                RabinMillerProbabilistic(n, 40)        // 4^(-40)\n        );\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/rabinmiller/RabinMiller.mpw";
        scriptMap.put("RabinMiller",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RadSimp\",*);\n\n/* Simplification of nested radicals.\n*/\n\n10 # RadSimp(_n)_(Length(VarList(n))<?1) <--\n[\n  Local(max, result);\n  Bind(max, CeilN(N(Eval(n^2))));\n  Bind(result,0);\n  Bind(result,RadSimpTry(n,0,1,max));\n\n//Echo(\"result is \",result);\n  if (CheckRadicals(n,result))\n    result\n  else\n    n;\n];\n\n\n20 # RadSimp(_n) <-- n;\n\n\n/*Echo({\"Try \",test}); */\n\nCheckRadicals(_n,_test) <-- Abs(N(Eval(n-test),20)) <? 0.000001;\n\n10 # ClampRadicals(_r)_(N(Eval(Abs(r)), 20)<?0.000001) <-- 0;\n20 # ClampRadicals(_r) <-- r;\n\n\n\nRadSimpTry(_n,_result,_current,_max)<--\n[\n//Echo(result,\" \",n,\" \",current);\n  if (IsLessThan(N(Eval(result-n)), 0))\n  [\n    Local(i);\n\n    // First, look for perfect match\n    i:=BSearch(max,Hold({{try},ClampRadicals(N(Eval((result+Sqrt(try))-n),20))}));\n    If(i>?0,\n    [\n      Bind(result,result+Sqrt(i));\n      Bind(i,AddN(max,1));\n      Bind(current,AddN(max,1));\n    ]);\n\n    // Otherwise, search for another solution\n    if (IsLessThan(N(Eval(result-n)), 0))\n    [\n      For (Bind(i,current),i<=?max,Bind(i,AddN(i,1)))\n      [\n        Local(new, test);\n        Bind(test,result+Sqrt(i));\n\n/* Echo({\"Full-try \",test}); */\n\n        Bind(new,RadSimpTry(n,test,i,max));\n        if (CheckRadicals(n,new))\n        [\n          Bind(result,new);\n          Bind(i,AddN(max,1));\n        ];\n      ];\n    ];\n  ];\n  result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/radsimp/RadSimp.mpw";
        scriptMap.put("RadSimp",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RandomInteger\", *);\n\n\n10 # RandomInteger(_n) <--\n[\n    Check(IsPositiveInteger(n), \"Argument\", \"The argument must be a positive integer.\");\n\n    CeilN(Random() * n);\n];\n\n\n\n10 # RandomInteger(_lowerBoundInclusive, _upperBoundInclusive) <--\n[\n    Check(IsInteger(lowerBoundInclusive) And? IsInteger(upperBoundInclusive), \"Argument\", \"Both arguments must be integers.\");\n\n    Check(lowerBoundInclusive <? upperBoundInclusive, \"Argument\", \"The first argument must be less than the second argument.\");\n\n    FloorN(lowerBoundInclusive + Random() * (upperBoundInclusive + 1 - lowerBoundInclusive) );\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/RandomInteger.mpw";
        scriptMap.put("RandomInteger",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRandomIntegerList(_count,_coefmin,_coefmax) <--\n  Table(FloorN(coefmin+Random()*(coefmax+1-coefmin)),i,1,count,1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/RandomIntegerList.mpw";
        scriptMap.put("RandomIntegerList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRandomIntegerMatrix(_rows,_cols,_coefmin,_coefmax) <--\n        GenMatrix({{i,j}, FloorN(coefmin+Random()*(coefmax+1-coefmin))}, rows, cols );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/RandomIntegerMatrix.mpw";
        scriptMap.put("RandomIntegerMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"RandomInterestingPolynomial\",*);\n//Retract(\"NewRandomPoly\",*);\n//Retract(\"RandomIrreducibleQuadratic\",*);\n//Retract(\"RandomIrreducibleQuadraticWithComplexRoots\",*);\n//Retract(\"RandomIrreducibleQuadraticWithRealRoots\",*);\n\n\n10 # RandomInterestingPolynomial( deg_IsPositiveInteger, _var ) <--\n[\n    RandomSeed( SystemTimer() );   //  randomize random number generator\n    NewRandomPoly(deg,var);   \n];\n\n\n10 # NewRandomPoly( _deg, _var )_(IsEqual(deg,1)) <--\n[\n    Local(p,i1,i2);\n    i1 := RandomInteger(1,10);\n    i2 := RandomInteger(-10,10);\n    p  := NormalForm(UniVariate(var,0,{i2,i1}));\n];\n\n\n10 # NewRandomPoly( _deg, _var )_(IsEqual(deg,2)) <--\n[\n    Local(ii,i1,i2,p,quadPoly);\n    p := FillList(0,2);\n    For(ii:=1,ii<=?2,ii++)\n    [\n        i1 := RandomInteger(10);\n        i2 := RandomInteger(-10,10);\n        If( i1 >? 1, i2 := i1*i2 );\n        p[ii] := NormalForm(UniVariate(var,0,{i2,i1}));\n    ];\n    quadPoly := ExpandBrackets(p[1]*p[2]);\n    quadPoly := Simplify(Quotient(quadPoly,LeadingCoef(quadPoly)));\n];\n\n\n10 # RandomIrreducibleQuadratic( _var ) <--\n[\n    Local(ii,coeffs,discrim,u,p,f);\n    // Use random integers for coefficients a2 and a1.  Then select a0 \n    // in one of two ways:\n    //  (1) so that discriminant is negative integer,  or\n    //  (2) so that discriminant is positive integer but not square.\n    If(RandomInteger(2)=?1,\n        RandomIrreducibleQuadraticWithComplexRoots(var),\n        RandomIrreducibleQuadraticWithRealRoots(var)\n    );\n];\n\n\n10 # RandomIrreducibleQuadraticWithRealRoots(_var) <--\n[\n    Local(coeffs,ijk);\n    coeffs    := FillList(1,3);\n    coeffs[2] := RandomInteger(-10,10);\n    coeffs[3] := RandomInteger(1,10);\n    ijk := Floor(coeffs[2]^2 / (4*coeffs[3]));\n    coeffs[1] := RandomInteger(-10,ijk);\n    discrim := coeffs[2]^2-4*coeffs[1]*coeffs[3];\n    NormalForm(UniVariate(var,0,coeffs));\n];\n\n\n10 # RandomIrreducibleQuadraticWithComplexRoots(_var) <--\n[\n    Local(coeffs,ijk);\n    coeffs := {1,RandomInteger(-10,10),RandomInteger(1,10)};\n    coeffs[1] := Ceil(N(coeffs[2]^2/(4*coeffs[3]))) + RandomInteger(1,5);\n    NormalForm(UniVariate(var,0,coeffs));\n];\n\n\n10 # NewRandomPoly( _deg, _var )_(IsEqual(deg,3)) <--\n[\n    Local(ii,i1,i2,i3,p,CubicPoly);\n    p := FillList(1,3);\n    If( RandomInteger(3) =? 1,\n      [\n        For(ii:=1,ii<=?3,ii++)\n        [\n          i1 := RandomInteger(2);\n          i2 := RandomInteger(-10,10);\n          If( i1 >? 1, i2 := i1*i2 );\n          p[ii] := NormalForm(UniVariate(var,0,{i2,i1}));\n        ];\n      ],\n      [\n          i1 := RandomInteger(2);\n          i2 := RandomInteger(-10,10);\n          If( i1 >? 1, i2 := i1*i2 );\n          p[1] := NormalForm(UniVariate(var,0,{i2,i1}));\n          p[2] := RandomIrreducibleQuadratic(var);\n      ]\n    );\n    CubicPoly := ExpandBrackets(Product(p));\n];\n\n\n10 # NewRandomPoly( _deg, _var )_(IsEqual(deg,4)) <--\n[\n    Local(ii,i1,i2,i3,i4,p,QuarticPoly);\n    p := FillList(1,4);\n    If( RandomInteger(2) =? 1,\n      [\n          p[1] := NewRandomPoly(3,x);\n          i1 := RandomInteger(2);\n          i2 := RandomInteger(-10,10);\n          If( i1 >? 1, i2 := i1*i2 );\n          p[2] := NormalForm(UniVariate(var,0,{i2,i1}));\n      ],\n      [\n          p[1] := NewRandomPoly(2,x);\n          p[2] := NewRandomPoly(2,x);\n      ]\n    );\n    QuarticPoly := ExpandBrackets(Product(p));\n];\n\n\n10 # NewRandomPoly( _deg, _var )_(IsEqual(deg,5)) <--\n[\n    Local(ii,i1,i2,i3,i4,p,QuinticPoly);\n    p := FillList(1,4);\n    p[1] := NewRandomPoly(1,x);\n    p[2] := RandomIrreducibleQuadraticWithRealRoots(x);\n    p[3] := RandomIrreducibleQuadraticWithComplexRoots(x);\n    QuinticPoly := ExpandBrackets(Product(p));\n];\n\n\n11 # NewRandomPoly( deg_IsPositiveInteger, _var )_(deg >? 5) <--\n[\n    Local(p,n,m);\n    p := {};\n    m := deg;\n    Until( m <? 3 )\n    [\n        n := RandomInteger(2,Floor(N(deg/2)));\n        Tell(\"     \",{m,n});\n        Push(p,NewRandomPoly(n,var));\n        m := m - n;\n    ];\n    Tell(\"      \",m);\n    If( m >? 0, Push(p,NewRandomPoly(m,x)));\n    Expand(Product(p));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/RandomInterestingPolynomial.mpw";
        scriptMap.put("RandomInterestingPolynomial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Generate a random polynomial */\n\nRandomPoly(_var,_degree,_coefmin,_coefmax) <--\n  NormalForm(UniVariate(var,0,RandomIntegerList(degree+1,coefmin,coefmax)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/RandomPoly.mpw";
        scriptMap.put("RandomPoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\n\nRandomSeed\nRandom\nRng\nRngSeed\nRngCreate\n*/\n\n/*\nRandom number generators implemented in an object-oriented manner.\n\nOld interface (still works):\n\n        RandomSeed(123);\n        Random(); Random();\n\nIt provides only one global RNG with a globally assigned seed.\n\nNew interface allows creating many RNG objects:\n\n        r1:=RngCreate();        // create a default RNG object, assign structure to r1\n        r2:=RngCreate(12345);        // create RNG object with given seed\n        r3:=RngCreate(seed->0, engine->advanced, dist->gauss);         // extended options: specify seed, type of RNG engine and the type of statistical distribution\n        Rng(r1); Rng(r1); Rng(r2);        // generate some floating-point numbers\n        RngSeed(r1, 12345);        // r1 is re-initialized with given seed, r2 is unaffected\n\nMore \"RNG engines\" and \"RNG distribution adaptors\" can be defined later (at run time).\n\nRngCreate() will return an object of the following structure:\n        {SomeDist, SomeEngine, state }\n\nhere SomeEngine is a function atom that describes the RNG engine,\nSomeDist is a function atom that specifies the distribution adaptor,\nand state is a \"RNG state object\", e.g. a list of all numbers that specify the current RNG state (seeds, temporaries, etc.).\n\nRngSeed(r1, seed) expects an integer seed.\nIt will re-initialize the RNG object r1 with the given seed.\n\nThe \"RNG engine API\": calling RngCreate with engine->SomeEngine expects that:\n        SomeEngine(seed_IsInteger) will create and initialize a state object with given seed and return the new state object (a list). SomeEngine can assume that \"seed\" is a positive integer.\n        SomeEngine(state1_IsList) will update the RNG state object state1 and return the pair {new state object, new number}.\n\nThe \"RNG distribution adaptor API\": calling RngCreate with distribution->SomeDist expects that:\n        SomeDist(r1) will update the RNG object r1 and return the pair {new state object, new number}. r1 is a full RNG object, not just a state object.\n\n\n*/\n\n//////////////////////////////////////////////////\n/// lists of defined RNG entities\n//////////////////////////////////////////////////\n\n/// The idea is that options must be easy to type, but procedure names could be long.\n\nLocalSymbols(knownRNGEngines, knownRNGDists) [\n  knownRNGEngines :=\n  {\n    { \"default\", \"RNGEngine'LCG'2\"},\n    { \"advanced\", \"RNGEngine'L'Ecuyer\"},\n  };\n\n  knownRNGDists :=\n  {\n    {\"default\", \"FlatRNGDist\"},\n    {\"flat\", \"FlatRNGDist\"},\n  //        {\"uniform\", \"FlatRNGDist\"},        // we probably don't need this alias...\n    {\"gauss\", \"GaussianRNGDist\"},\n  };\n\n  KnownRNGDists() := knownRNGDists;\n  KnownRNGEngines() := knownRNGEngines;\n];\n\n\n//////////////////////////////////////////////////\n/// RNG object API\n//////////////////////////////////////////////////\n\nFunction() RngCreate();\nFunction() RngCreate(seed, ...);\n//HoldArgument(\"RngCreate\", seed);        // this is needed to prevent evaluation of = and also to prevent substitution of variables, e.g. if \"seed\" is defined\n//UnFence(\"RngCreate\", 0);\n//UnFence(\"RngCreate\", 1);\nFunction() RngSeed(r, seed);\n//UnFence(\"RngSeed\", 2);\n/// accessor for RNG objects\nFunction() Rng(r);\n//UnFence(\"Rng\", 1);\n\n\nRngCreate() <-- RngCreate(0);\n\n10 # RngCreate(a'seed_IsInteger) <-- (RngCreate @ {seed -> a'seed});\n\n// a single option given: convert explicitly to a list\n20 # RngCreate(_key -> _value) <-- `(RngCreate({@key -> value}));\n\n// expect a list of options\n30 # RngCreate(options_IsList) <--\n[\n        options := OptionsListToHash @ {options};\n\n        // check options and assign defaults\n        If(\n                options[\"seed\"] =? Empty Or? options[\"seed\"] <=? 0,\n                options[\"seed\"] := 76544321        // some default seed out of the blue sky\n        );\n        If(\n                options[\"engine\"] =? Empty Or? Not? (Assert(\"warning\", {\"RngCreate: invalid engine\", options[\"engine\"]}) KnownRNGEngines()[options[\"engine\"] ] !=? Empty),\n                options[\"engine\"] := \"default\"\n        );\n        If(\n                options[\"dist\"] =? Empty Or? Not? (Assert(\"warning\", {\"RngCreate: invalid distribution\", options[\"dist\"]}) KnownRNGDists()[options[\"dist\"] ] !=? Empty),\n                options[\"dist\"] := \"default\"\n        );\n\n        // construct a new RNG object\n        // a RNG object has the form {\"SomeDist\", \"SomeEngine\", {state}}\n        {\n                KnownRNGDists()[options[\"dist\"] ], KnownRNGEngines()[options[\"engine\"] ],\n                // initialize object with given seed using \"SomeEngine\"(seed)\n                KnownRNGEngines()[options[\"engine\"] ] @ { options[\"seed\"] }\n        };\n];\n\n/// accessor function: will call SomeDist(r) and update r\nRng(_r) <--\n[\n        Local(state, result);\n        {state, result} := (r[1] @ {r});        // this calls SomeDist(r)\n        DestructiveReplace(r, 3, state);        // update RNG object\n        result;        // return floating-point number\n];\n\n/// set seed: will call SomeEngine(r, seed) and update r\nRngSeed(_r, seed_IsInteger) <--\n[\n        Local(state);\n        (Assert(\"warning\", {\"RngSeed: seed must be positive\", seed}) seed >? 0\n        ) Or? (seed:=76544321);\n        state := (r[2] @ {seed});        // this calls SomeEngine(r)\n        DestructiveReplace(r, 3, state);        // update object\n        True;\n];\n\n//////////////////////////////////////////////////\n/// RNG distribution adaptors\n//////////////////////////////////////////////////\n\n/// trivial distribution adaptor: flat distribution, simply calls SomeEngine(r)\n/* we have to return whole objects; we can't use references b/c the core\nfunction ApplyFast will not work properly on references, i.e. if r =? {\"\", \"\", {1}} so that\nr[3] =? {1}, then LCG'2(r[3]) modifies r[3], but LCG'2 @ r[3] or\nApplyFast(\"LCG'2\", {r[3]}) do not actually modify r[3].\n*/\n\n// return pair {state, number}\nFlatRNGDist(_r) <-- (r[2] @ {r[3]});        // this calls SomeEngine(state)\n\n/// Gaussian distribution adaptor, returns a complex number with normal distribution with unit variance, i.e. Re and Im are independent and both have unit variance\n/* Gaussian random number, Using the Box-Muller transform, from Knuth,\n   \"The Art of Computer Programming\",\n   Volume 2 (Seminumerical algorithms, third edition), section 3.4.1\n */\nGaussianRNGDist(_rng) <--\n[\n        // a Gaussian distributed complex number p + I*q is made up of two uniformly distributed numbers x,y according to the formula:\n        // a:=2*x-1, b:=2*y-1, m:=a^2+b^2; p =? a*Sqrt(-2*Ln(m)/m); q:=b*Sqrt(-2*Ln(m)/m);\n        // here we need to make sure that m is nonzero and strictly less than 1.\n        Local(a,b,m, new'state, rnumber);\n        new'state := rng[3];        // this will be updated at the end\n        m:=0;\n        While(m=?0 Or? m>=?1)        // repeat generating new x,y  - should not take more than one iteration really\n        [\n                {new'state, rnumber} := (rng[2] @ {new'state});\n                a:=2*rnumber-1;\n                {new'state, rnumber} := (rng[2] @ {new'state});\n                b:=2*rnumber-1;\n                m:=a*a+b*b;\n        ];\n        {new'state, (a+I*b)*SqrtN(-2*DivideN(Internal'LnNum(m),m))};\n];\n\n\n//////////////////////////////////////////////////\n/// RNG engines\n//////////////////////////////////////////////////\n\n/// default RNG engine: the LCG generator\n\n// first method: initialize a state object with given seed\nRNGEngine'LCG'1(seed_IsInteger) <-- {seed};\n// second method: update state object and return new number\nRNGEngine'LCG'1(state_IsList) <-- LCG'1(state);\n\n// first method: initialize a state object with given seed\nRNGEngine'LCG'2(seed_IsInteger) <-- {seed};\n// second method: update state object and return new number\nRNGEngine'LCG'2(state_IsList) <-- LCG'2(state);\n\n// first method: initialize a state object with given seed\nRNGEngine'LCG'3(seed_IsInteger) <-- {seed};\n// second method: update state object and return new number\nRNGEngine'LCG'3(state_IsList) <-- LCG'3(state);\n\n// first method: initialize a state object with given seed\nRNGEngine'LCG'4(seed_IsInteger) <-- {seed};\n// second method: update state object and return new number\nRNGEngine'LCG'4(state_IsList) <-- LCG'4(state);\n\n/// parameters from P. Hellekalek, 1994; see G. S. Fishman, Math. Comp. vol. 54, 331 (1990)\nLCG'1(state) := RandomLCG(state, 2147483647,950706376,0);\nLCG'2(state) := RandomLCG(state, 4294967296,1099087573,0);\nLCG'3(state) := RandomLCG(state, 281474976710656,68909602460261,0);\nLCG'4(state) := RandomLCG(state, 18014398509481984,2783377640906189,0);\n\n/// Linear congruential generator engine: backend\n// state is a list with one element\nRandomLCG(_state, _im, _ia, _ic) <--\n{\n        DestructiveReplace(state,1, ModuloN(state[1]*ia+ic,im)),\n        DivideN(state[1], im)        // division should never give 1\n};\n\n/// Advanced RNG engine due to L'Ecuyer et al.\n/// RNG from P. L'ecuyer et al (2000). Period approximately 2^191\n// state information: 6 32-bit integers, corresponding to {x3,x2,x1,y3,y2,y1}\n\n// first method: initialize a state object with given seed\nRNGEngine'L'Ecuyer(a'seed_IsInteger) <--\n[\n        // use LCG'2 as auxiliary RNG to fill the seeds\n        Local(rng'aux, result);\n        rng'aux := (RngCreate @ {a'seed});\n        // this will be the state vector\n        result:=ZeroVector(6);\n        // fill the state object with random numbers\n        Local(i);\n        For(i:=1, i<=?6, i++)\n        [\n                Rng(rng'aux);\n                result[i] := rng'aux[3][1];        // hack to get the integer part\n        ];\n        // return the state object\n        result;\n];\n\n// second method: update state object and return a new random number (floating-point)\nRNGEngine'L'Ecuyer(state_IsList) <--\n[\n        Local(new'state, result);\n        new'state := {\n                Modulo(1403580*state[2]-810728*state[3], 4294967087), state[1], state[2],\n                Modulo(527612*state[4]-1370589*state[6], 4294944433), state[4], state[5]\n        };\n        result:=Modulo(state[1]-state[4], 4294967087);\n        {\n                new'state,\n                DivideN(If(result=?0, 4294967087, result), 4294967088)\n        };\n];\n\n//////////////////////////////////////////////////\n/// old interface: using one global RNG object\n//////////////////////////////////////////////////\n/* this is a little slower but entirely equivalent to the code below\nGlobalRNG := RngCreate(76544321);\nRandom() := Rng(GlobalRNG);\nRandomSeed(seed) := RngSeed(GlobalRNG, seed);\n*/\n\nLocalSymbols(RandSeed) [\n  // initial seed should be nonzero\n  RandSeed := SystemTimer(); //Was 76544321.\n\n  /// assign random seed\n  Function(\"RandomSeed\", {seed}) Bind(RandSeed, seed);\n\n  /// Linear congruential generator\n  RandomLCG(_im, _ia, _ic) <--\n  [\n    RandSeed:=ModuloN(RandSeed*ia+ic,im);\n    DivideN(RandSeed,im);        // should never give 1\n  ];\n]; // LocalSymbols(RandSeed)\n\n\nFunction(\"Random1\",{}) RandomLCG(4294967296,1103515245,12345);\nFunction(\"Random6\",{}) RandomLCG(1771875,2416,374441);\n/// parameters from P. Hellekalek, 1994; see G. S. Fishman, Math. Comp. vol. 54, 331 (1990)\nFunction(\"Random2\",{}) RandomLCG(2147483647,950706376,0);\nFunction(\"Random3\",{}) RandomLCG(4294967296,1099087573,0);\nFunction(\"Random4\",{}) RandomLCG(281474976710656,68909602460261,0);\nFunction(\"Random5\",{}) RandomLCG(18014398509481984,2783377640906189,0);\n\n// select one of them\nFunction(\"Random\",{}) Random3();\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/random/random.mpw";
        scriptMap.put("RandomSeed",scriptString);
        scriptMap.put("Random",scriptString);
        scriptMap.put("Rng",scriptString);
        scriptMap.put("RngSeed",scriptString);
        scriptMap.put("RngCreate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Combine\",*);\n\n10 # Combine(expr_IsZero) <-- 0;\n\n20 # Combine(_expr) <-- \n[\n    Local(L);\n    L := ReassembleListTerms(DisassembleExpression(expr));\n    UnFlatten(L,\"+\",0);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/Combine.mpw";
        scriptMap.put("Combine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nEliminate(_var,_replace,_function) <-- Simplify(Subst(var,replace)function);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/Eliminate.mpw";
        scriptMap.put("Eliminate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(AssembleTerms, AssembleTermsRecursive)\n[\n\n    AssembleTerms(list) :=\n    [\n        Check(IsList(list), \"Argument\", \"The argument must be a list.\");\n\n        If(Length(list) =? 1,\n            First(list),\n            AssembleTermsRecursive(Reverse(list)) \n        );\n    ];\n\n\n    AssembleTermsRecursive(list) :=\n    [\n        If(Type(list[1]) =? \"-\" Or? IsNegativeNumber(list[1]) Or? Type(list[1]) =? \"/\" And? (Type(Numerator(list[1])) =? \"-\" Or? IsNegativeNumber(Numerator(list[1]))),\n            If(Length(list) =? 2,\n                ListToFunction({ToAtom(\"-\"), list[2], -list[1]} ),\n                ListToFunction({ToAtom(\"-\"), AssembleTermsRecursive(Rest(list)), -First(list)} )\n            ),\n            If(Length(list) =? 2,\n                ListToFunction({ToAtom(\"+\"), list[2], list[1]} ),\n                ListToFunction({ToAtom(\"+\"), AssembleTermsRecursive(Rest(list)), First(list)} )\n            )\n        );\n    ];\n\n\n10 # ExpandBrackets(xx_IsZero) <-- 0;\n\n20 # ExpandBrackets(_xx)_(Type(xx)=?\"/\" Or? Type(-xx)=?\"/\") <--\n[\n    Local(N,D,t);\n    N := ReassembleListTerms(DisassembleExpression(Numerator(xx)));\n    D := ExpandBrackets(Denominator(xx));\n    AssembleTerms(MapSingle({{t}, t / D}, N));\n];\n\n\n30 # ExpandBrackets(_xx) <-- AssembleTerms(ReassembleListTerms(DisassembleExpression(xx)));\n\n];\n\n\n\n//ExpandBrackets(_xx) <-- SimpExpand(SimpImplode(SimpFlatten(xx)));\n//ExpandBrackets(x) := NormalForm(MM(x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/ExpandBrackets.mpw";
        scriptMap.put("ExpandBrackets",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//////////////////////////////////////////////////\n/// ExpandFrac --- normalize rational functions (no simplification)\n//////////////////////////////////////////////////\n\n5 # ExpandFrac(expr_IsList) <-- MapSingle(\"ExpandFrac\", expr);\n\n// expression does not contain fractions\n10 # ExpandFrac(_expr)_Not?(HasFuncSome(expr, \"/\", {ToAtom(\"+\"), ToAtom(\"-\"), *, /, ^})) <-- expr;\n15 # ExpandFrac(a_IsRationalOrNumber) <-- a;\n20 # ExpandFrac(_expr) <-- ExpandFrac'combine(GetNumerDenom(expr));\n\nExpandFrac'combine({_a, _b}) <-- a/b;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/ExpandFrac.mpw";
        scriptMap.put("ExpandFrac",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"DoFlatten\",{doflattenx});\nUnFence(\"DoFlatten\",1);\n\n10 # DoFlatten(_doflattenx)_(Type(doflattenx)=?flattenoper) <--\n     Apply(\"Concat\",MapSingle(\"DoFlatten\",Rest(FunctionToList(doflattenx))));\n20 # DoFlatten(_doflattenx) <-- { doflattenx };\n\n\nFunction(\"Flatten\",{body,flattenoper})\n[\n  DoFlatten(body);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/Flatten.mpw";
        scriptMap.put("Flatten",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// GetNumerDenom(x) returns a pair of expressions representing normalized numerator and denominator; GetNumerDenom(x, a) multiplies the numerator by the number a\nGetNumerDenom(_expr, _a) <-- GetNumerDenom(expr)*{a,1};\n\n// on expressions that are not fractions, we return unit denominator\n10 # GetNumerDenom(_expr)_Not?(HasFuncSome(expr, \"/\", {ToAtom(\"+\"), ToAtom(\"-\"), *, /, ^})) <-- {expr, 1};\n// rational numbers are not simplified\n15 # GetNumerDenom(a_IsRationalOrNumber) <-- {a, 1};\n// arithmetic\n20 # GetNumerDenom(_a + _b) <-- ExpandFrac'add(GetNumerDenom(a), GetNumerDenom(b));\n20 # GetNumerDenom(_a - _b) <-- ExpandFrac'add(GetNumerDenom(a), GetNumerDenom(b, -1));\n20 # GetNumerDenom(- _a) <-- GetNumerDenom(a, -1);\n20 # GetNumerDenom(+ _a) <-- GetNumerDenom(a);\n20 # GetNumerDenom(_a * _b) <-- ExpandFrac'multiply(GetNumerDenom(a), GetNumerDenom(b));\n20 # GetNumerDenom(_a / _b) <-- ExpandFrac'divide(GetNumerDenom(a), GetNumerDenom(b));\n// integer powers\n20 # GetNumerDenom(_a ^ b_IsInteger)_(b >? 1) <-- ExpandFrac'multiply(GetNumerDenom(a), GetNumerDenom(a^(b-1)));\n20 # GetNumerDenom(_a ^ b_IsInteger)_(b <? -1) <-- ExpandFrac'divide(GetNumerDenom(1), GetNumerDenom(a^(-b)));\n20 # GetNumerDenom(_a ^ b_IsInteger)_(b =? -1) <-- ExpandFrac'divide(GetNumerDenom(1), GetNumerDenom(a));\n// non-integer powers are not considered to be rational functions\n25 # GetNumerDenom(_a ^ _b) <-- {a^b, 1};\n\n// arithmetic on fractions; not doing any simplification here, whereas we might want to\nExpandFrac'add({_a, _b}, {_c, _d}) <-- {a*d+b*c, b*d};\nExpandFrac'multiply({_a, _b}, {_c, _d}) <-- {a*c, b*d};\nExpandFrac'divide({_a, _b}, {_c, _d}) <-- {a*d, b*c};\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/GetNumerDenom.mpw";
        scriptMap.put("GetNumerDenom",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"SimpAdd\",{x,y});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpAdd.mpw";
        scriptMap.put("SimpAdd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"SimpDiv\",{x,y});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpDiv.mpw";
        scriptMap.put("SimpDiv",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # SimpExpand(SimpAdd(_x,_y)) <-- SimpExpand(x) + SimpExpand(y);\n10 # SimpExpand(SimpMul(_x,_y)) <-- SimpExpand(x) * SimpExpand(y);\n10 # SimpExpand(SimpDiv(_x,_y)) <-- SimpExpand(x) / SimpExpand(y);\n20 # SimpExpand(_x) <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpExpand.mpw";
        scriptMap.put("SimpExpand",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # SimpFlatten((_x)+(_y)) <-- SimpAdd(SimpFlatten(x),SimpFlatten(y));\n10 # SimpFlatten((_x)-(_y)) <-- SimpAdd(SimpFlatten(x),SimpMul(-1,SimpFlatten(y)));\n10 # SimpFlatten(    -(_y)) <-- SimpMul(-1,SimpFlatten(y));\n\n10 # SimpFlatten((_x)*(_y)) <-- SimpMul(SimpFlatten(x),SimpFlatten(y));\n10 # SimpFlatten((_x)/(_y)) <-- SimpDiv(SimpFlatten(x),SimpFlatten(y));\n10 # SimpFlatten((_x)^(n_IsPositiveInteger)) <--\n     SimpMul(SimpFlatten(x),SimpFlatten(x^(n-1)));\n\n100 # SimpFlatten(_x) <--\n[\n  x;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpFlatten.mpw";
        scriptMap.put("SimpFlatten",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Distributed multiplication rule */\n10 # SimpImplode(SimpMul(SimpAdd(_x,_y),_z)) <--\n     SimpImplode(SimpAdd(SimpImplode(SimpMul(x,z)),\n                 SimpImplode(SimpMul(y,z))));\n10 # SimpImplode(SimpMul(_z,SimpAdd(_x,_y))) <--\n     SimpImplode(SimpAdd(SimpImplode(SimpMul(z,x)),\n                 SimpImplode(SimpMul(z,y))));\n/* Distributed division rule  */\n10 # SimpImplode(SimpDiv(SimpAdd(_x,_y),_z)) <--\n     SimpImplode(SimpAdd(SimpImplode(SimpDiv(x,z)),\n     SimpImplode(SimpDiv(y,z))));\n\n\n\n20 # SimpImplode(SimpAdd(_x,_y)) <--\n     SimpAdd(SimpImplode(x),SimpImplode(y));\n20 # SimpImplode(SimpMul(_x,_y)) <--\n     SimpMul(SimpImplode(x),SimpImplode(y));\n20 # SimpImplode(SimpDiv(_x,_y)) <--\n     SimpDiv(SimpImplode(x),SimpImplode(y));\n30 # SimpImplode(_x) <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpImplode.mpw";
        scriptMap.put("SimpImplode",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"SimpMul\",{x,y});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/SimpMul.mpw";
        scriptMap.put("SimpMul",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Simplify\",*);\n\n10 # Simplify(expr_IsList) <-- MapSingle(\"Simplify\",expr);\n\n15 # Simplify(Complex(_r,_i)) <-- Complex(Simplify(r),Simplify(i));\n\n20 # Simplify((_xex) == (_yex)) <-- (Simplify(xex-yex) == 0);\n\n20 # Simplify((_xex) >? (_yex)) <-- (Simplify(xex-yex) >? 0);\n20 # Simplify((_xex) <? (_yex)) <-- (Simplify(xex-yex) <? 0);\n20 # Simplify((_xex) >=? (_yex)) <-- (Simplify(xex-yex) >=? 0);\n20 # Simplify((_xex) <=? (_yex)) <-- (Simplify(xex-yex) <=? 0);\n20 # Simplify((_xex) !== (_yex)) <-- (Simplify(xex-yex) !== 0);\n\n// conditionals\n25 # Simplify(if (_a) _b) <-- \"if\" @ {Simplify(a), Simplify(b)};\n25 # Simplify(_a else _b) <-- \"else\" @ {Simplify(a), Simplify(b)};\n\n// otherwise\n40 # Simplify(_expr)_(Type(expr)=?\"Ln\") <--\n[\n    //If(InVerboseMode(),Tell(\"Simplify_Ln\",expr));\n    LnCombine(expr);\n];\n\n40 # Simplify(_expr)_(Type(expr)=?\"Exp\") <--\n[\n    //If(InVerboseMode(),Tell(\"Simplify_Exp\",expr));\n    expr;\n];\n\n50 # Simplify(_expr) <-- \n[\n    //If(InVerboseMode(),Tell(\"Simplify_other\",expr));\n    MultiSimp(Eval(expr));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/Simplify.mpw";
        scriptMap.put("Simplify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # UnFlatten({},_op,_identity) <-- identity;\n20 # UnFlatten(list_IsList,_op,_identity) <--\n     Apply(op,{First(list),UnFlatten(Rest(list),op,identity)});\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/UnFlatten.mpw";
        scriptMap.put("UnFlatten",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* FactorialSimplify algorithm:\n   1) expand binomials into factors\n   2) expand brackets as much as possible\n   3) for the remaining rational expressions x/y,\n      take all the factors of x and y, and match them\n      up one by one to determine if they can be\n      factored out. The algorithm will look at expressions like x^n/x^m\n      where (n-m) is an integer, or at expressions x!/y! where (x-y)\n      is an integer. The routine CommonDivisors does these steps, and\n      returns the new numerator and denominator factor.\n  FactorialSimplifyWorker does the actual O(n^2) algorithm of\n  matching all terms up.\n*/\n\nFactorialNormalForm(x):=\n[\n  // Substitute binomials\n  x:=(x/:{BinomialCoefficient(_n,_m)<- (n!)/((m!)*(n-m)!)});\n  // Expand expression as much as possible so that the terms become\n  // simple rationals.\n\n  x:=(\n      x/::Hold({\n          (_a/_b)/_c <- (a)/(b*c),\n          (-(_a/_b))/_c <- (-a)/(b*c),\n          (_a/_b)*_c <- (a*c)/b,\n          (_a*_b)^_m <- a^m*b^m,\n          (_a/_b)^_m*_c <- (a^m*c)/b^m,\n          _a*(_b+_c) <- a*b+a*c,\n          (_b+_c)*_a <- a*b+a*c,\n          (_b+_c)/_a <- b/a+c/a,\n          _a*(_b-_c) <- a*b-a*c,\n          (_b-_c)*_a <- a*b-a*c,\n          (_b-_c)/_a <- b/a-c/a\n     }));\n  x;\n];\n\nFactorialSimplify(x):=\n[\n  x := FactorialNormalForm(x);\n  FactorialSimplifyWorker(x);\n];\n\n\n/* CommonDivisors takes two parameters x and y as input, determines a common divisor g\n   and then returns {x/g,y/g,g}.\n */\n10 # CommonDivisors(_x^(_n),_x^(_m)) <-- {x^Simplify(n-m),1,x^m};\n10 # CommonDivisors(_x^(_n),_x)  <-- {x^Simplify(n-1),1,x};\n10 # CommonDivisors(_x,_x^(_m)) <-- {x^Simplify(1-m),1,x^m};\n10 # CommonDivisors((_x) !,_x) <-- {(x-1)!,1,x};\n10 # CommonDivisors(_x,_x) <-- {1,1,x};\n10 # CommonDivisors(- _x,_x) <-- {-1,1,x};\n10 # CommonDivisors(_x,- _x) <-- {1,-1,x};\n10 # CommonDivisors((_x),(_x)!) <-- {1,(x-1)!,x};\n10 # CommonDivisors((_x)!, (_y)!)_IsInteger(Simplify(x-y))  <-- CommonFact(Simplify(x-y),y);\n\n\n10 # CommonDivisors((_x)! ^ _m, (_y)! ^ _m)_IsInteger(Simplify(x-y))  <-- CommonFact(Simplify(x-y),y)^m;\n\n10 # CommonFact(dist_IsNegativeInteger,_y)\n   <-- {1,Product(i,1,-dist,Simplify(y+i+dist)),Simplify(y+dist)!};\n11 # CommonFact(_dist,_y)\n   <-- {Product(i,1,dist,Simplify(y+i)),1,Simplify(y)!};\n60000 # CommonDivisors(_x,_y) <-- {x,y,1};\n\n10 # CommonFactors((_x)!,_y)_(Simplify(y-x) =? 1) <-- {y!,1};\n10 # CommonFactors((_x)!,_y)_(Simplify((-y)-x) =? 1) <-- {(-y)!,-1};\n\n10 # CommonFactors(_x^_n,_x^_m) <-- {x^Simplify(n+m),1};\n10 # CommonFactors(_x^_n,_x) <-- {x^Simplify(n+1),1};\n\n60000 # CommonFactors(_x,_y) <-- {x,y};\n\n10 # FactorialSimplifyWorker(_x+_y) <-- FactorialSimplifyWorker(x)+FactorialSimplifyWorker(y);\n10 # FactorialSimplifyWorker(_x-_y) <-- FactorialSimplifyWorker(x)-FactorialSimplifyWorker(y);\n10 # FactorialSimplifyWorker(  -_y) <--                     -FactorialSimplifyWorker(y);\n\nLocalSymbols(x,y,i,j,n,d)[\n\n20 # FactorialSimplifyWorker(_x/_y) <--\n[\n  // first separate out factors of the denominator\n  Local(numerCommon,numerTerms);\n  {numerCommon,numerTerms}:=FactorialGroupCommonDivisors(x);\n  Local(denomCommon,denomTerms);\n  {denomCommon,denomTerms}:=FactorialGroupCommonDivisors(y);\n  Local(n,d,c);\n  {n,d,c} := FactorialDivideTerms(numerCommon,denomCommon);\n  (n/d)*Simplify((numerTerms)/(denomTerms));\n];\n\n\n\n20 # FactorialGcd(_x,_y) <--\n[\n  // first separate out factors of the denominator\n  Local(numerCommon,numerTerms);\n  {numerCommon,numerTerms}:=FactorialGroupCommonDivisors(x);\n  Local(denomCommon,denomTerms);\n  {denomCommon,denomTerms}:=FactorialGroupCommonDivisors(y);\n  Local(n,d,c);\n  {n,d,c} := FactorialDivideTerms(numerCommon,denomCommon);\n  c;\n];\n\n\n\n\n\n10 # FactorialDivideTerms(- _x,- _y) <-- FactorialDivideTermsAux(x,y);\nLocalSymbols(n,d,c)\n[\n  20 # FactorialDivideTerms(- _x,  _y)\n    <--\n    [\n      Local(n,d,c);\n      {n,d,c} := FactorialDivideTermsAux(x,y);\n      {-n,d,c};\n    ];\n  30 # FactorialDivideTerms(  _x,- _y)\n    <--\n    [\n      Local(n,d,c);\n      {n,d,c} := FactorialDivideTermsAux(x,y);\n      {n,-d,c};\n    ];\n];\n40 # FactorialDivideTerms(  _x,  _y)\n   <--\n   [\n//     Echo(\"GOTHERE 40\");\n     FactorialDivideTermsAux(x,y);\n   ];\n\nLocalSymbols(n,d,c)\n[\n  10 # FactorialDivideTermsAux(_x,_y) <--\n  [\n    x:=Flatten(x,\"*\");\n    y:=Flatten(y,\"*\");\n\n    Local(i,j,common);\n    common:=1;\n    For(i:=1,i<=?Length(x),i++)\n    For(j:=1,j<=?Length(y),j++)\n    [\n      Local(n,d,c);\n//Echo(\"inp is \",x[i],\" \",y[j]);\n      {n,d,c} := CommonDivisors(x[i],y[j]);\n\n//Echo(\"aux is \",{n,d,c});\n      x[i] := n;\n      y[j] := d;\n      common:=common*c;\n    ];\n//Echo(\"final \",{x,y,common});\n//Echo(\"finalor \",{Product(x),Product(y),common});\n    {Product(x),Product(y),common};\n  ];\n];\n\n];\n\n60000 # FactorialSimplifyWorker(_x)\n      <--\n      [\n  // first separate out factors of the denominator\n  Local(numerCommon,numerTerms);\n  {numerCommon,numerTerms}:=FactorialGroupCommonDivisors(x);\n  numerCommon*numerTerms;\n      ];\n\n/* FactorialFlattenAddition accepts an expression of form a+b+c-d+e-f+ ... +z with arbitrary additions\n   and subtractions, and converts it to a list of terms. Terms that need to be subtracted start with a\n   negation sign (useful for pattern matching).\n */\n10 # FactorialFlattenAddition(_x+_y) <-- Concat(FactorialFlattenAddition(x), FactorialFlattenAddition(y));\n10 # FactorialFlattenAddition(_x-_y) <-- Concat(FactorialFlattenAddition(x),-FactorialFlattenAddition(y));\n10 # FactorialFlattenAddition(  -_y) <--                           -FactorialFlattenAddition(y);\n20 # FactorialFlattenAddition(_x   ) <--                           {x};\n\nLocalSymbols(n,d,c)\n[\n  10 # FactorialGroupCommonDivisors(_x) <--\n  [\n    Local(terms,common,tail);\n    terms:=FactorialFlattenAddition(x);\n//Echo(\"terms is \",terms);\n    common := First(terms);\n    tail:=Rest(terms);\n    While (tail !=? {})\n    [\n      Local(n,d,c);\n      {n,d,c} := FactorialDivideTerms(common,First(tail));\n\n//Echo(common, \" \",First(tail),\" \",c);\n      common := c;\n      tail:=Rest(tail);\n    ];\n    Local(i,j);\n\n//  Echo(\"common is \",common);\n\n    For(j:=1,j<=?Length(terms),j++)\n    [\n      Local(n,d,c);\n//  Echo(\"IN = \",terms[j],\" \",common);\n//  Echo(\"n = \",n);\n      {n,d,c} := FactorialDivideTerms(terms[j],common);\n//  Echo(\"n = \",n);\n//  Echo(\"{n,d,c} = \",{n,d,c});\n      Check(d =? 1, \"Math\",\n        PipeToString()[\n        Echo(\"FactorialGroupCommonDivisors failure 1 : \",d);\n        ]);\n/*\n      Check(Simplify(c-common) = 0, \"Math\",\n        PipeToString()\n        [\n          Echo(\"FactorialGroupCommonDivisors failure 2 : \");\n          Echo(c,\" \",common);\n          Echo(Simplify(c-common));\n        ]);\n*/\n      terms[j] := n;\n    ];\n    terms:=Add(terms);\n\n    common:=Flatten(common,\"*\");\n    For(j:=1,j<=?Length(common),j++)\n    [\n      Local(f1,f2);\n      {f1,f2}:=CommonFactors(common[j],terms);\n      common[j]:=f1;\n      terms:=f2;\n\n      For(i:=1,i<=?Length(common),i++)\n      If(i !=? j,\n        [\n          {f1,f2}:=CommonFactors(common[j],common[i]);\n          common[j]:=f1;\n          common[i]:=f2;\n        ]);\n    ];\n    common := Product(common);\n    {common,terms};\n  ];\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/simplify/factorial/FactorialSimplify.mpw";
        scriptMap.put("FactorialSimplify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Assume\",*);\n//Retract(\"AssumptionsAbout\",*);\n//Retract(\"UnAssume\",*);\n//Retract(\"IsAssumed\",*);\n//Retract(\"AssumptionsGet\",*);\n\nLocalSymbols(assumptions) [\n\nassumptions := {};\n\n10 # Assume( L_IsList ) <--\n[\n    If(InVerboseMode(),Tell(\"AssumeLst\",L));\n    Local(len,s);\n    len := Length(L);\n    If( len >? 0, ForEach(s,L) [ Assume(s); ] );\n    assumptions;\n];\n\n\n10 # Assume( _x -> _y ) <--\n[ \n    If(InVerboseMode(),Tell(\"AssumeItem\",{x,y}));\n    Local(key,value);\n    key   := Hold(x); \n    value := Hold(y);\n    If(InVerboseMode(),Tell(\"       \",{key,value}));\n    \n    DestructiveAppend(assumptions,{Eval(key),Eval(value)});\n    assumptions;\n];\n\n\n10 # AssumptionsGet() <-- assumptions;\n\n\n10 # AssumptionsAbout(_key) <--\n[\n    Local(props);\n    props := Select(assumptions,Lambda({X},X[1]=?key));\n    If( Length(props) >? 0, Transpose(props)[2], {} );\n];\n\n\n10 # IsAssumed( _key, _valueExpected ) <-- Contains(AssumptionsAbout(key),valueExpected);\n\n\n10 # UnAssume( _x )_(Contains(AssocIndices(assumptions),x)) <--\n[\n    Local(lst,len,jj);\n    lst := Lambda({X},If(IsList(X),X[1])) /@ assumptions;\n    jj := Find(lst,x);\n    If( jj >? 0, DestructiveDelete(assumptions,jj) );\n    lst := Lambda({X},If(IsList(X),X[1])) /@ assumptions;\n    jj := Find(lst,x);\n    If( jj >? 0, UnAssume(x), True );\n];\n\n];  //  LocalSymbols\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/Assume.mpw";
        scriptMap.put("Assume",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"CheckSolution\",*);\n\n10 # CheckSolution( _expr, _var, solution_IsList )_(Not? IsFreeOf(var,expr)) <--\n  [\n      Local(expr0,result,s,r);\n      If( IsEquation(expr),\n          Bind(expr0,EquationLeft(expr)-EquationRight(expr)),\n          Bind(expr0,expr)\n      );\n      result := {};\n      ForEach(s,solution) \n        [\n            r := ( expr0 Where s );\n            If(r=?0,Push(result,s));\n        ];\n        Reverse(result);\n  ];\n  \n  \n20 # CheckSolution( _expr, _var, _solution ) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/CheckSolution.mpw";
        scriptMap.put("CheckSolution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Newton\",{function,variable,initial,accuracy})\n[        // since we call a function with HoldArgument(), we need to evaluate some variables by hand\n  `Newton(@function,@variable,initial,accuracy,-Infinity,Infinity);\n];\n\nFunction(\"Newton\",{function,variable,initial,accuracy,min,max})\n[\n  Local(result,adjust,delta,requiredPrec);\n  MacroLocal(variable);\n  requiredPrec := BuiltinPrecisionGet();\n  accuracy:=N((accuracy/10)*10); // Making sure accuracy is rounded correctly\n  BuiltinPrecisionSet(requiredPrec+2);\n  function:=N(function);\n  adjust:= -function/Apply(\"Differentiate\",{variable,function});\n  delta:=10000;\n  result:=initial;\n  While (result >? min And? result <? max\n      // avoid numerical underflow due to fixed point math, FIXME when have real floating math\n      And? N(Eval( Maximum(Re(delta), -Re(delta), Im(delta), -Im(delta)) ) ) >? accuracy)\n  [\n    MacroBind(variable,result);\n    delta:=N(Eval(adjust));\n    result:=result+delta;\n  ];\n\n  BuiltinPrecisionSet(requiredPrec);\n  result:=N(Eval((result/10)*10)); // making sure result is rounded to correct precision\n  if (result <=? min Or? result >=? max) [result := Fail;];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/Newton.mpw";
        scriptMap.put("Newton",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "/********** Solve'System **********/\n\n// for now, just use a very simple backsubstitution scheme\nSolve'System(_eqns, _vars) <-- Solve'SimpleBackSubstitution(eqns,vars);\n\n// Check(False, \"Unimplemented\", \"Solve'System: not implemented\");\n\n10 # Solve'SimpleBackSubstitution'FindAlternativeForms((_lx) == (_rx)) <--\n[\n  Local(newEq);\n  newEq := (Simplify(lx) == Simplify(rx));\n  If (newEq !=? (lx == rx) And? newEq !=? (0==0),DestructiveAppend(eq,newEq));\n  newEq := (Simplify(lx - rx) == 0);\n  If (newEq !=? (lx == rx) And? newEq !=? (0==0),DestructiveAppend(eq,newEq));\n];\n20 # Solve'SimpleBackSubstitution'FindAlternativeForms(_equation) <--\n[\n];\nUnFence(\"Solve'SimpleBackSubstitution'FindAlternativeForms\",1);\n\n/* Solving sets of equations using simple backsubstitution.\n * Solve'SimpleBackSubstitution takes all combinations of equations and\n * variables to solve for, and it then uses SuchThat to find an expression\n * for this variable, and then if found backsubstitutes it in the other\n * equations in the hope that they become simpler, resulting in a final\n * set of solutions.\n */\n10 # Solve'SimpleBackSubstitution(eq_IsList,var_IsList) <--\n[\n If(InVerboseMode(), Echo({\"Entering Solve'SimpleBackSubstitution\"}));\n\n  Local(result,i,j,nrvar,nreq,sub,nrSet,origEq);\n  eq:=FlatCopy(eq);\n  origEq:=FlatCopy(eq);\n  nrvar:=Length(var);\n  result:={FlatCopy(var)};\n  nrSet := 0;\n\n//Echo(\"Before: \",eq);\n  ForEach(equation,origEq)\n  [\n//Echo(\"equation \",equation);\n    Solve'SimpleBackSubstitution'FindAlternativeForms(equation);\n  ];\n//  eq:=Simplify(eq);\n//Echo(\"After: \",eq);\n\n  nreq:=Length(eq);\n\n  /* Loop over each variable, solving for it */\n\n/* Echo({eq});  */\n\n  For(j:=1,j<=?nreq And? nrSet <? nrvar,j++)\n  [\n    Local(vlist);\n    vlist:=VarListAll(eq[j],`Lambda({pt},Contains(@var,pt)));\n    For(i:=1,i<=?nrvar And? nrSet <? nrvar,i++)\n    [\n\n//Echo(\"eq[\",j,\"] = \",eq[j]);\n//Echo(\"var[\",i,\"] = \",var[i]);\n//Echo(\"varlist = \",vlist);\n//Echo();\n\n      If(Count(vlist,var[i]) =? 1,\n         [\n           sub := FunctionToList(eq[j]);\n           sub := sub[2]-sub[3];\n//Echo(\"using \",sub);\n           sub:=SuchThat(sub,var[i]);\n           If(InVerboseMode(), Echo({\"From \",eq[j],\" it follows that \",var[i],\" = \",sub}));\n           If(SolveFullSimplify=?True,\n             result:=Simplify(Subst(var[i],sub)result),\n             result[1][i]:=sub\n             );\n//Echo(\"result = \",result,\" i = \",i);\n           nrSet++;\n\n//Echo(\"current result is \",result);\n           Local(k,reset);\n           reset:=False;\n           For(k:=1,k<=?nreq  And? nrSet <? nrvar,k++)\n           If(Contains(VarListAll(eq[k],`Lambda({pt},Contains(@var,pt))),var[i]),\n           [\n             Local(original);\n             original:=eq[k];\n             eq[k]:=Subst(var[i],sub)eq[k];\n             If(Simplify(Simplify(eq[k])) =? (0 == 0),\n               eq[k] := (0 == 0),\n               Solve'SimpleBackSubstitution'FindAlternativeForms(eq[k])\n               );\n//             eq[k]:=Simplify(eq[k]);\n//             eq[k]:=Simplify(eq[k]); //@@@??? TODO I found one example where simplifying twice gives a different result from simplifying once!\n             If(original!=?(0==0) And? eq[k] =? (0 == 0),reset:=True);\n             If(InVerboseMode(), Echo({\"   \",original,\" simplifies to \",eq[k]}));\n           ]);\n           nreq:=Length(eq);\n           vlist:=VarListAll(eq[j],`Lambda({pt},Contains(@var,pt)));\n           i:=nrvar+1;\n           // restart at the beginning of the variables.\n           If(reset,j:=1);\n         ]);\n    ];\n  ];\n\n\n//Echo(\"Finished finding results \",var,\" = \",result);\n//  eq:=origEq;\n//  nreq := Length(eq);\n  Local(zeroeq,tested);\n  tested:={};\n//  zeroeq:=FillList(0==0,nreq);\n\n  ForEach(item,result)\n  [\n/*\n    Local(eqSimplified);\n    eqSimplified := eq;\n    ForEach(map,Transpose({var,item}))\n    [\n      eqSimplified := Subst(map[1],map[2])eqSimplified;\n    ];\n    eqSimplified := Simplify(Simplify(eqSimplified));\n\n    Echo(eqSimplified);\n\n    If(eqSimplified =? zeroeq,\n    [\n      DestructiveAppend(tested,Map(\"==\",{var,item}));\n    ]);\n*/\n    DestructiveAppend(tested,Map(\"==\",{var,item}));\n  ];\n\n\n\n/* Echo({\"tested is \",tested});  */\n If(InVerboseMode(), Echo({\"Leaving Solve'SimpleBackSubstitution\"}));\n  tested;\n];\n\n\n\n\n/********** OldSolve **********/\n10 # OldSolve(eq_IsList,var_IsList) <-- Solve'SimpleBackSubstitution(eq,var);\n\n\n90 # OldSolve((left_IsList) == right_IsList,_var) <--\n      OldSolve(Map(\"==\",{left,right}),var);\n\n\n100 # OldSolve(_left == _right,_var) <--\n     SuchThat(left - right , 0 , var);\n\n/* HoldArgument(\"OldSolve\",arg1); */\n/* HoldArgument(\"OldSolve\",arg2); */\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/OldSolve.mpw";
        scriptMap.put("OldSolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nPSolve( _uni ) <-- YacasPSolve( uni );\n\nPSolve( _uni, _var ) <-- YacasPSolve( uni, var );\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/PSolve.mpw";
        scriptMap.put("PSolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"SolveMatrix\",{matrix,vector})\n[\n  If(InVerboseMode(),Tell(\"   SolveMatrix\",{matrix,vector}));\n  Local(perms,indices,inv,det,n);\n  n:=Length(matrix);\n  indices:=Table(i,i,1,n,1);\n  perms:=PermutationsList(indices);\n  inv:=ZeroVector(n);\n  det:=0;\n  ForEach(item,perms)\n  [\n    Local(i,lc);\n    lc := LeviCivita(item);\n    det:=det+Product(i,1,n,matrix[i][item[i] ])* lc;\n    For(i:=1,i<=?n,i++)\n        [\n         inv[i] := inv[i]+\n           Product(j,1,n,\n           If(item[j] =? i,vector[j ],matrix[j][item[j] ]))*lc;\n        ];\n  ];\n  Check(det !=? 0, \"Math\", \"Zero determinant\");\n  (1/det)*inv;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/SolveMatrix.mpw";
        scriptMap.put("SolveMatrix",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*-------------------------------------------------------------------\n *  NOTE:  this is a diversion of the SolveSystem modules to a\n *  new file all its own.  Previously, it was named \"Solve'System\",\n *  and was contained in the file OldSolve.mpw.\n *\n *  For the time being, we are just reconnecting the new file to\n *  point to the same old file  Solve'SimpleBackSubstitution .\n *  This will be changed soon.\n *    started   hso 100630.\n *    begin mods    100701\n *-------------------------------------------------------------------*/\n\n//Retract(\"SolveSystem\",*);\n//Retract(\"VarsAndDegs\",*);\n//Retract(\"MakeCoefMatrix\",*);\n//Retract(\"SolveLinearSystem\",*);\n//Retract(\"SolveNonlinearSystem\",*);\n\n/*\n10 # SolveSystem( eqns_IsList, vars_IsList ) <--\n[\n    // This is the old, now obsolete method\n    If(InVerboseMode(),Tell(\"SolveSystem0\",{eqns,vars}));\n    Solve'SimpleBackSubstitution(eqns,vars);\n];\n*/\n\n10 # SolveSystem( eqns_IsList, vars_IsList )_(Length(eqns)=?1 And? Length(vars)=?1) <--\n[\n    {Solve(eqns[1],vars[1])};\n];\n\n12 # SolveSystem( eqns_IsList, vars_IsList ) <--\n[\n    // This is the first try at a better algorithm for doing this\n    If(InVerboseMode(),Tell(\"SolveSystem\",{eqns,vars}));\n    \n    Local(eq,expr,exprns,VaD,isLinearSet,ans);\n    // express as set of polynomials, to be equated to zero\n    exprns := {};\n    ForEach(eq,eqns)\n     [\n         expr := If( IsEquation(eq), EquationLeft(eq)-EquationRight(eq), eq );\n         DestructiveAppend(exprns,expr);\n     ];\n    If(InVerboseMode(),Tell(\" \",exprns));\n    \n    // are all polynomials linear in given variables?\n    VaD := VarsAndDegs(exprns,vars);\n    If(InVerboseMode(),Tell(\" \",VaD));\n    isLinearSet := Maximum(Flatten(VaD,\"List\"))=?1;\n    If(InVerboseMode(),Tell(\" \",isLinearSet));\n    \n    If( isLinearSet,\n        ans:=SolveLinearSystem( exprns, vars ),\n        ans:=SolveNonlinearSystem( exprns, vars )\n    );\n\n    If(ans !=? {}, ans := Map(\"==\",{vars,ans}));\n\n    If(InVerboseMode(),Tell(\"\",ans));\n\n    ans;\n];\n\n\n10 # VarsAndDegs(exs_IsList,vars_IsList) <--\n[\n    Local(ex,v,result);\n    result := {};\n    ForEach(ex,exs)\n     [\n         Local(res);\n         res := {};\n         ForEach(v,vars)\n          [\n              DestructiveAppend(res,Apply(\"Degree\",{ex,v}));\n          ];\n          DestructiveAppend(result,res);\n     ];\n    result;\n];\n\n\n\n10 # SolveLinearSystem( polys_IsList, vars_IsList ) <--\n[\n    Local(A, E);\n\n    If(InVerboseMode(),Tell(\"   SolveLinearSystem\",{polys,vars}));\n    // note  Coef(polys[1],vars[1],1) etc, to create matrix of coefficients\n    Local(lhs,rhs,zeros);\n    lhs := MakeCoefMatrix(polys,vars);\n    If(InVerboseMode(),Tell(\"       \",lhs));\n    zeros := ZeroVector(Length(vars));\n    rhs := -WithValue(vars,zeros,polys);\n    If(InVerboseMode(),Tell(\"       \",rhs));\n    \n    A := Transpose(Concat(Transpose(lhs),{rhs}));\n    E := RREF(A);\n\n    If(Contains(E,BaseVector(Dimensions(E)[2],Dimensions(E)[2])),\n        {},\n        MatrixColumn(E,Dimensions(E)[2]) - (ExtractSubMatrix(E, 1, 1, Length(E), Length(E)) - Identity(Length(E))) * vars);\n];\n\n\n\n10 # MakeCoefMatrix(polys_IsList,vars_IsList) <--\n[\n    If(InVerboseMode(),Tell(\"      MakeCoefMatrix\",{polys,vars}));\n    Local(p,v,result);\n    result := {};\n    ForEach(p,polys)\n     [\n         Local(res);\n         res := {};\n         ForEach(v,vars)\n          [\n              DestructiveAppend(res,Apply(\"Coef\",{p,v,1}));\n          ];\n          DestructiveAppend(result,res);\n     ];\n    result;\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/SolveSystem.mpw";
        scriptMap.put("SolveSystem",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ContainsExpression(_body,_body) <-- True;\n15 # ContainsExpression(body_IsAtom,_expr) <-- False;\n20 # ContainsExpression(body_IsFunction,_expr) <--\n[\n  Local(result,args);\n  result:=False;\n  args:=Rest(FunctionToList(body));\n  While(args !=? {})\n  [\n    result:=ContainsExpression(First(args),expr);\n    args:=Rest(args);\n    if (result =? True) (args:={});\n  ];\n  result;\n];\n\n\nSuchThat(_function,_var) <-- SuchThat(function,0,var);\n\n10 # SuchThat(_left,_right,_var)_(left =? var) <-- right;\n\n/*This interferes a little with the multi-equation solver...\n15 # SuchThat(_left,_right,_var)_CanBeUni(var,left-right) <--\n     PSolve(MakeUni(left-right,var));\n*/\n\n20 # SuchThat(left_IsAtom,_right,_var) <-- var;\n\n30 # SuchThat((_x) + (_y),_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right-y , var);\n30 # SuchThat((_y) + (_x),_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right-y , var);\n\n30 # SuchThat(Complex(_r,_i),_right,_var)_ContainsExpression(r,var) <--\n    SuchThat(r , right-I*i , var);\n30 # SuchThat(Complex(_r,_i),_right,_var)_ContainsExpression(i,var) <--\n    SuchThat(i , right+I*r , var);\n\n30 # SuchThat(_x * _y,_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right/y , var);\n30 # SuchThat(_y * _x,_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right/y , var);\n\n30 # SuchThat(_x ^ _y,_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right^(1/y) , var);\n30 # SuchThat(_x ^ _y,_right,_var)_ContainsExpression(y,var) <--\n    SuchThat(y , Ln(right)/Ln(x) , var);\n\n30 # SuchThat(Sin(_x),_right,_var) <--\n    SuchThat(x , ArcSin(right) , var);\n30 # SuchThat(ArcSin(_x),_right,_var) <--\n    SuchThat(x , Sin(right) , var);\n\n30 # SuchThat(Cos(_x),_right,_var) <--\n    SuchThat(x , ArcCos(right) , var);\n30 # SuchThat(ArcCos(_x),_right,_var) <--\n    SuchThat(x , Cos(right) , var);\n\n30 # SuchThat(Tan(_x),_right,_var) <--\n    SuchThat(x , ArcTan(right) , var);\n30 # SuchThat(ArcTan(_x),_right,_var) <--\n    SuchThat(x , Tan(right) , var);\n\n30 # SuchThat(Exp(_x),_right,_var) <--\n    SuchThat(x , Ln(right) , var);\n30 # SuchThat(Ln(_x),_right,_var) <--\n    SuchThat(x , Exp(right) , var);\n\n30 # SuchThat(_x / _y,_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right*y , var);\n30 # SuchThat(_y / _x,_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , y/right , var);\n\n30 # SuchThat(- (_x),_right,_var) <--\n    SuchThat(x , -right , var);\n\n30 # SuchThat((_x) - (_y),_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , right+y , var);\n30 # SuchThat((_y) - (_x),_right,_var)_ContainsExpression(x,var) <--\n    SuchThat(x , y-right , var);\n\n30 # SuchThat(Sqrt(_x),_right,_var) <--\n    SuchThat(x , right^2 , var);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/SuchThat.mpw";
        scriptMap.put("SuchThat",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"YacasPSolve\",{uni});\n\nRule(\"YacasPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 0)\n    {};\n\nRule(\"YacasPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 1)\n    -Coef(uni,0)/Coef(uni,1);\n\n\nRule(\"YacasPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 2)\n    [\n     Local(a,b,c,d,q,r);\n     c:=Coef(uni,0);\n     b:=Coef(uni,1);\n     a:=Coef(uni,2);\n     d:=b*b-4*a*c;\n     q:=Sqrt(d)/(2*a);\n     // Removed to avoid excessive time RadSimp takes for larger numbers\n     // If(Im(q) !=? 0,\n     //     q := Complex(RadSimp(Re(q)), RadSimp(Im(q))),\n     //     q := RadSimp(q));\n     r:=-b/(2*a);\n     If(InVerboseMode(),[ Tell(\"   \",{c,b,a,d}); Tell(\"   \",{q,r}); ]);\n     {r+q,r-q};\n    ];\n\n\nRule(\"YacasPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 3 )\n    [\n     Local(p,q,r,w,ww,a,b);\n     Local(coef0,coef1,coef3,adjust);\n\n/* Get coefficients for a new polynomial, such that the coefficient of\n   degree 2 is zero:\n   Take f(x)=a0+a1*x+a2*x^2+a3*x^3 and substitute x = x' + adjust\n   This gives g(x) = b0+b1*x+b2*x^2+b3*x^3 where\n   b3 = a3;\n   b2 = 0 => adjust = (-a2)/(3*a3);\n   b1 = 2*a2*adjust+3*a3*adjust^2+a1;\n   b0 = a2*adjust^2+a3*adjust^3+adjust*a1+a0;\n\n   After solving g(x') = 0, return x = x' + adjust.\n*/\n\n     adjust := (-Coef(uni,2))/(3*Coef(uni,3));\n     coef3 := Coef(uni,3);\n     coef1 := 2*Coef(uni,2)*adjust+3*Coef(uni,3)*adjust^2+Coef(uni,1);\n     coef0 := Coef(uni,2)*adjust^2+Coef(uni,3)*adjust^3+\n              adjust*Coef(uni,1)+Coef(uni,0);\n\n     p:=coef3;\n     q:=coef1/p;\n     r:=coef0/p;\n    w:=Complex(-1/2,Sqrt(3/4));\n    ww:=Complex(-1/2,-Sqrt(3/4));\n\n/* Equation is xxx + qx + r = 0 */\n/*         Let x = a + b\n        a^3 + b^3 + 3(aab + bba) + q(a + b) + r = 0\n        a^3 + b^3 + (3ab+q)x + r = 0\n\n        Let 3ab+q = 0. This is permissible, for we can still find a+b == x\n\n        a^3 + b^3 = -r\n        (ab)^3 = -q^3/27\n\n        So a^3 and b^3 are the roots of t^2 + rt - q^3/27 = 0\n\n        Let\n                a^3 = -r/2 + Sqrt(q^3/27+ rr/4)\n                b^3 = -r/2 - Sqrt(q^3/27+ rr/4)\n        Therefore there are three values for each of a and b.\n        Clearly if ab = -q/3 is true then (wa)(wwb) == (wb)(wwa) == -q/3\n*/\n\n  a:=(-r/2 + Sqrt(q^3/27+ r*r/4))^(1/3);\n  b:=(-r/2 - Sqrt(q^3/27+ r*r/4))^(1/3);\n\n  {a+b+adjust,w*a+ww*b+adjust,ww*a+w*b+adjust};\n];\n\n/*\nHow to solve the quartic equation?\n\nThe equation is x^4 + a1 x^3 + a2 x^2 + a3 x + a4 = 0.\nThe idea is to write the left-hand side as the difference of two\nsquares: (x^2 + p x + q)^2 - (s x + t)^2.\nEliminating the parentheses and equation coefficients yields four\nequations for the four unknowns p, q, s and t:\n  a1 = 2p              (1)\n  a2 = p^2 + 2q - s^2  (2)\n  a3 = 2pq - 2st       (3)\n  a4 = q^2 - t^2       (4)\nFrom the first equation, we find that p = a1/2. Substituting this in\nthe other three equations and rearranging gives\n  s^2 = a1^2/4 - a2 + 2q   (5)\n  2st = a1 q - a3          (6)\n  t^2 = q^2 - a4           (7)\nWe now take the square (6) and substitute (5) and (7):\n  4 (a1^2/4 - a2 + 2q) (q^2 - a4) = (a1 q - a3)^2  <==>\n  8 q^3 - 4 a2 q^2 + (2 a1 a3 - 8 a4) q + 4 a2 a4 - a1^2 a4 - a3^2 = 0.\nMiraculously, we got a cubic equation for q. Suppose we can solve this\nequation. We can then compute t from (7): t = sqrt(q^2 - a4). If t is\nnonzero, we can compute s from (6). Note that we cannot compute s from\n(5), since we introduced an extra solution when squaring (6). However,\nif t is zero, then no extra solution was introduced and we can safely\nuse (5). Having found the values of p, q, s and t, we can factor the\ndifference of squares and solve the quartic:\n  x^4 + a1 x^3 + a2 x^2 + a3 x + a4 = (x^2 + p x + q)^2 - (s x + t)^2\n                 = (x^2 + p x + q + s x + t) (x^2 + p x + q - sx - t).\nThe four roots of the quartic are the two roots of the first quadratic\nfactor plus the two roots of the second quadratic factor.\n*/\n\nRule(\"YacasPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 4 )\n[\n    Local(coef4,a1,a2,a3,a4,y,y1,z,t,s);\n\n    coef4:=Coef(uni,4);\n    a1:=Coef(uni,3)/coef4;\n    a2:=Coef(uni,2)/coef4;\n    a3:=Coef(uni,1)/coef4;\n    a4:=Coef(uni,0)/coef4;\n\n    /* y1 = 2q, with q as above. */\n    y1:=First(YacasPSolve(y^3-a2*y^2+(a1*a3-4*a4)*y+(4*a2*a4-a3^2-a1^2*a4),y));\n    t := Sqrt(y1^2/4-a4);\n    If(t=?0, s:=Sqrt(y1+a1^2/4-a2), s:=(a1*y1-2*a3)/(4*t));\n    Concat(YacasPSolve(z^2+(a1/2+s)*z+y1/2+t,z),\n           YacasPSolve(z^2+(a1/2-s)*z+y1/2-t,z));\n];\n\nFunction(\"YacasPSolve\",{uni,var}) [\n     Local(u, factors, f, r, s);\n\n     u := MakeUni(uni, var);\n\n     If(Type(u) =? \"UniVariate\" And? (And? @ (Lambda({x}, IsNumber(x) Or? IsRational(x)) /@ u[3])), [\n         Local(coeffs);\n         coeffs := Rationalize(u[3]);\n         coeffs := If(Length(coeffs) >? 1, \n                       Lcm(Denominator /@ coeffs) * coeffs, \n                       (Denominator /@ coeffs) * coeffs);\n         DestructiveReplace(u, 3, coeffs);\n         factors := If(Degree(u)>?0, \n                        Factors(NormalForm(u)), \n                        {NormalForm(u), 1});\n     ], [\n         factors := {{uni, 1}};\n     ]);\n\n     r := {};\n     ForEach(f, factors) [\n         s := YacasPSolve(MakeUni(f[1],var));\n         r := Union(r, If(IsList(s), s, {s}));\n     ];\n\n     If(Length(r) =? 1, r[1], r);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/YacasPSolve.mpw";
        scriptMap.put("YacasPSolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"jSolveUniPoly\",*);\n\n10 # jSolveUniPoly( _lhs==_rhs, var_IsAtom ) <--\n[\n   jSolveUniPoly(lhs-rhs,var);\n];\n\n15 # jSolveUniPoly( poly_IsPolynomial, var_IsAtom )_(Length(VarList(poly))=?1) <--\n[\n   If(InVerboseMode(),Tell(jSolveUniPoly,{poly,var}));\n   Local(factorList,f,fac,mult,ii,answer);\n   factorList := Factors(poly);\n   If(InVerboseMode(),Tell(\"   \",factorList));\n   answer := {};\n   ForEach(f,factorList)\n    [\n        {fac,mult} := f;\n        soln := Solve(fac,var);\n        If(InVerboseMode(),[Tell(\"      \",{fac,mult});Tell(\"      \",soln);]);\n        ForEach(ii,1 .. mult)\n         [  DestructiveAppend(answer,soln); ];\n    ];\n    answer;\n];\n\n20 # jSolveUniPoly( poly_IsPolynomial, var_IsAtom ) <-- Failed;\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/jSolveUniPoly.mpw";
        scriptMap.put("jSolveUniPoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Solve\",*);\n\n/*\n * Strategy for Solve(expr, x):\n *\n * 10.  Call SolveSystem for systems of equations [now in its own file]\n * 20.  Check arguments.\n * 30.  Get rid of \"==\" in 'expr'.\n * 40.  Special cases.\n * 50.  If 'expr' is a polynomial in 'x', try to use PSolve.\n * 60.  If 'expr' is a product, solve for either factor.\n * 70.  If 'expr' is a quotient, solve for the denominator.\n * 80.  If 'expr' is a sum and one of the terms is free of 'x',\n *      try to use Solve'Simple.\n * 90.  If every occurance of 'x' is in the same context, use this to reduce\n *      the equation. For example, in 'Cos(x) + Cos(x)^2 == 1', the variable\n *      'x' always occurs in the context 'Cos(x)', and hence we can attack\n *      the equation by first solving 'y + y^2 == 1', and then 'Cos(x) == y'.\n *      This does not work for 'Exp(x) + Cos(x) == 2'.\n * 100. Apply Simplify to 'expr', and try again.\n * 110. Give up.\n */\n\nLocalSymbols(res)\n[\n  10  # Solve(expr_IsList, var_IsList) <-- SolveSystem(expr, var);\n  12  # Solve(_expr, var_IsList)_(Length(var)=?1) <--\n        [ {Solve(expr,var[1])}; ];\n  \n  20  # Solve(_expr, _var)_(IsNumber(var) Or? IsString(var)) <--\n        [ Assert(\"Solve'TypeError\", \"Second argument, \":(PipeToString() Write(var)):\", is not the name of a variable\") False; {}; ];\n  22  # Solve(_expr, _var)_(Not? IsAtom(var) And? Not? HasExpr(expr,var)) <--\n        [ Assert(\"Solve'TypeError\", \"Second argument, \":(PipeToString() Write(var)):\", is not the name of a variable\") False; {}; ];\n  24  # Solve(False,_var) <-- Check(False, \"Argument\", \"Bad input: possibly '=' instead of '==' \");\n\n  30  # Solve(_lhs == _rhs, _var) <-- Solve(lhs - rhs, var);\n  40  # Solve(0, _var) <-- {var == var};\n  41  # Solve(a_IsConstant, _var) <-- {};\n  42  # Solve(_expr, _var)_(Not? HasExpr(expr,var)) <--\n        [ Assert(\"Solve\", \"expression \":(PipeToString() Write(expr)):\" does not depend on \":PipeToString() Write(var)) False; {}; ];\n  50  # Solve(_expr, _var)_((res := Solve'Poly(expr, var)) !=? Failed) <-- res;\n  60  # Solve(_e1 * _e2, _var) <-- [\n      Local(t,u,s);\n      t := Union(Solve(e1,var), Solve(e2,var));\n      u := {};\n      ForEach(s, t) [\n         Local(v1,v2);\n         v1 := WithValue(var, s[2], e1);\n         v2 := WithValue(var, s[2], e2);\n         If(Not? (IsInfinity(v1) Or? (v1 =? Undefined) Or?\n                 IsInfinity(v2) Or? (v2 =? Undefined)),\n             DestructiveAppend(u, s));\n      ];\n      u;\n  ];\n  70  # Solve(_e1 / _e2, _var) <-- [\n      Local(tn, t, s);\n      tn := Solve(e1, var);\n      t := {};\n      ForEach(s, tn)\n          If(Not?(IsZero(WithValue(var, s[2], e2))), \n              DestructiveAppend(t, s)\n          );\n      t;\n  ];\n  80  # Solve(_e1 + _e2, _var)_(Not? HasExpr(e2,var) And? (res := Solve'Simple(e1,-e2,var)) !=? Failed) <-- res;\n  80  # Solve(_e1 + _e2, _var)_(Not? HasExpr(e1,var) And? (res := Solve'Simple(e2,-e1,var)) !=? Failed) <-- res;\n  80  # Solve(_e1 - _e2, _var)_(Not? HasExpr(e2,var) And? (res := Solve'Simple(e1,e2,var)) !=? Failed) <-- res;\n  80  # Solve(_e1 - _e2, _var)_(Not? HasExpr(e1,var) And? (res := Solve'Simple(e2,e1,var)) !=? Failed) <-- res;\n  85  # Solve(_expr, _var)_((res := Solve'Simple(expr, 0, var)) !=? Failed) <-- res;\n  90  # Solve(_expr, _var)_((res := Solve'Reduce(expr, var)) !=? Failed) <-- res;\n  95  # Solve(_expr, _var)_((res := Solve'Divide(expr, var)) !=? Failed) <-- res;\n  100 # Solve(_expr, _var)_((res := Simplify(expr)) !=? expr) <-- Solve(res, var);\n  110 # Solve(_expr, _var) <--\n        [ Assert(\"Solve'Fails\", \"cannot solve equation \":(PipeToString() Write(expr)):\" for \":PipeToString() Write(var)) False; {}; ];\n];\n\n/********** Solve'Poly **********/\n\n/* Tries to solve by calling PSolve */\n/* Returns Failed if this doesn't work, and the solution otherwise */\n\n/* CanBeUni is not documented, but defined in univar.rep/code.mpi */\n/* It returns True iff 'expr' is a polynomial in 'var' */\n\n10 # Solve'Poly(_expr, _var)_(Not? CanBeUni(var, expr)) <-- Failed;\n\n/* The call to PSolve can have three kind of results\n *   1) PSolve returns a single root\n *   2) PSolve returns a list of roots\n *   3) PSolve remains unevaluated\n */\n\n20 # Solve'Poly(_expr, _var) <--\nLocalSymbols(x)\n[\n  Local(roots);\n  roots := PSolve(expr, var);\n  If(Type(roots) =? \"YacasPSolve\",\n     If(roots =? YacasPSolve(0), {var == var}, Failed),   /* Case 3 */\n     If(Type(roots) =? \"List\",\n        MapSingle({{x},var==x}, roots),                  /* Case 2 */\n        {var == roots}));                                /* Case 1 */\n];\n\n/********** Solve'Reduce **********/\n\n/* Tries to solve by reduction strategy */\n/* Returns Failed if this doesn't work, and the solution otherwise */\n\n10 # Solve'Reduce(_expr, _var) <--\n[\n  ClearError(\"Solve'Fails\"); // ..in case one was left over from prior failure\n  Local(context, expr2, var2, res, sol, sol2, i);\n  context := Solve'Context(expr, var);\n  If(context =? False,\n     res := Failed,\n     [\n       expr2 := Eval(Subst(context, var2) expr);\n       If(CanBeUni(var2, expr2) And? (Degree(expr2, var2) =? 0 Or? (Degree(expr2, var2) =? 1 And? Coef(expr2, var2, 1) =? 1)),\n          res := Failed, /* to prevent infinite recursion */\n          [\n                sol2 := Solve(expr2, var2);\n            If(IsError(\"Solve'Fails\"),\n               [\n                 ClearError(\"Solve'Fails\");\n                 res := Failed;\n               ],\n                   [\n                     res := {};\n                     i := 1;\n                     While(i <=? Length(sol2) And? res !=? Failed) [\n                       sol := Solve(context == (var2 Where sol2[i]), var);\n                   If(IsError(\"Solve'Fails\"),\n                      [\n                        ClearError(\"Solve'Fails\");\n                        res := Failed;\n                      ],\n                          res := Union(res, sol));\n                       i++;\n                     ];\n                   ]);\n                 ]);\n     ]);\n  res;\n];\n\n/********** Solve'Context **********/\n\n/* Returns the unique context of 'var' in 'expr', */\n/* or {} if 'var' does not occur in 'expr',       */\n/* or False if the context is not unique.         */\n\n10 # Solve'Context(expr_IsAtom, _var) <-- If(expr=?var, var, {});\n\n20 # Solve'Context(_expr, _var) <--\n[\n  Local(lst, foundVarP, context, i, res);\n  lst := FunctionToList(expr);\n  foundVarP := False;\n  i := 2;\n  While(i <=? Length(lst) And? Not? foundVarP) [\n    foundVarP := (lst[i] =? var);\n    i++;\n  ];\n  If(foundVarP,\n     context := expr,\n     [\n       context := {};\n       i := 2;\n       While(i <=? Length(lst) And? context !=? False) [\n         res := Solve'Context(lst[i], var);\n         If(res !=? {} And? context !=? {} And? res !=? context, context := False);\n         If(res !=? {} And? context =? {}, context := res);\n         i++;\n       ];\n     ]);\n  context;\n];\n\n/********** Solve'Simple **********/\n\n/* Simple solver of equations\n *\n * Returns (possibly empty) list of solutions,\n * or Failed if it cannot handle the equation\n *\n * Calling format: Solve'Simple(lhs, rhs, var)\n *                 to solve 'lhs == rhs'.\n *\n * Note: 'rhs' should not contain 'var'.\n */\n\n20 # Solve'Simple(_e1 + _e2, _rhs, _var)_(e1 =? var And? Not? HasExpr(e2,var)) <-- { var == rhs-e2 };\n20 # Solve'Simple(_e1 + _e2, _rhs, _var)_(e2 =? var And? Not? HasExpr(e1,var)) <-- { var == rhs-e1 };\n\n20 # Solve'Simple(_e1 - _e2, _rhs, _var)_(e1 =? var And? Not? HasExpr(e2,var)) <-- { var == rhs+e2 };\n20 # Solve'Simple(_e1 - _e2, _rhs, _var)_(e2 =? var And? Not? HasExpr(e1,var)) <-- { var == e1-rhs };\n20 # Solve'Simple(-(_e1), _rhs, _var)_(e1 =? var) <-- { var == -rhs };\n\n20 # Solve'Simple(_e1 * _e2, _rhs, _var)_(e1 =? var And? Not? HasExpr(e2,var)) <-- { var == rhs/e2 };\n20 # Solve'Simple(_e1 * _e2, _rhs, _var)_(e2 =? var And? Not? HasExpr(e1,var)) <-- { var == rhs/e1 };\n\n20 # Solve'Simple(_e1 / _e2, _rhs, _var)_(e1 =? var And? Not? HasExpr(e2,var)) <-- { var == rhs*e2 };\n10 # Solve'Simple(_e1 / _e2, 0,    _var)_(e2 =? var And? Not? HasExpr(e1,var)) <-- { };\n20 # Solve'Simple(_e1 / _e2, _rhs, _var)_(e2 =? var And? Not? HasExpr(e1,var)) <-- { var == e1/rhs };\n\nLocalSymbols(x)\n[\n  20 # Solve'Simple(_e1 ^ _n, _rhs, _var)_(e1 =? var And? IsPositiveInteger(n))\n       <-- MapSingle({{x}, var == rhs^(1/n)*x}, Exp(2*Pi*I*(1 .. n)/n));\n  20 # Solve'Simple(_e1 ^ _n, _rhs, _var)_(e1 =? var And? IsNegativeInteger(n))\n       <-- MapSingle({{x}, var == rhs^(1/n)*x}, Exp(2*Pi*I*(1 .. (-n))/(-n)));\n];\n\n20 # Solve'Simple(_e1 ^ _e2, _rhs, _var)\n     _ (IsPositiveReal(e1) And? e1 !=? 0 And? e2 =? var And? IsPositiveReal(rhs) And? rhs !=? 0)\n     <-- { var == Ln(rhs)/Ln(e1) };\n\n/* Note: These rules do not take the periodicity of the trig. functions into account */\n10 # Solve'Simple(Sin(_e1), 1,    _var)_(e1 =? var) <-- { var == 1/2*Pi };\n10 # Solve'Simple(Sin(_e1), _rhs, _var)_(e1 =? var And? rhs =? -1) <-- { var == 3/2*Pi };\n20 # Solve'Simple(Sin(_e1), _rhs, _var)_(e1 =? var) <-- { var == ArcSin(rhs), var == Pi-ArcSin(rhs) };\n10 # Solve'Simple(Cos(_e1), 1,    _var)_(e1 =? var) <-- { var == 0 };\n10 # Solve'Simple(Cos(_e1), _rhs, _var)_(e1 =? var And? rhs =? -1) <-- { var == Pi };\n20 # Solve'Simple(Cos(_e1), _rhs, _var)_(e1 =? var) <-- { var == ArcCos(rhs), var == -ArcCos(rhs) };\n20 # Solve'Simple(Tan(_e1), _rhs, _var)_(e1 =? var) <-- { var == ArcTan(rhs) };\n\n20 # Solve'Simple(ArcSin(_e1), _rhs, _var)_(e1 =? var) <-- { var == Sin(rhs) };\n20 # Solve'Simple(ArcCos(_e1), _rhs, _var)_(e1 =? var) <-- { var == Cos(rhs) };\n20 # Solve'Simple(ArcTan(_e1), _rhs, _var)_(e1 =? var) <-- { var == Tan(rhs) };\n\n/* Note: Second rule neglects (2*I*Pi)-periodicity of Exp() */\n10 # Solve'Simple(Exp(_e1), 0,    _var)_(e1 =? var) <-- { };\n20 # Solve'Simple(Exp(_e1), _rhs, _var)_(e1 =? var) <-- { var == Ln(rhs) };\n20 # Solve'Simple(_b^_e1, _rhs, _var)_(e1 =? var And? IsFreeOf(var,b) And? Not? IsZero(b)) <-- { var == Ln(rhs) / Ln(b) };\n20 # Solve'Simple(Ln(_e1),  _rhs, _var)_(e1 =? var) <-- { var == Exp(rhs) };\n\n/* The range of Sqrt is the set of (complex) numbers with either\n * positive real part, together with the pure imaginary numbers with\n * nonnegative real part. */\n20 # Solve'Simple(Sqrt(_e1), _rhs, _var)_(e1 =? var And? IsPositiveReal(Re(rhs)) And? Re(rhs) !=? 0) <-- { var == rhs^2 };\n20 # Solve'Simple(Sqrt(_e1), _rhs, _var)_(e1 =? var And? Re(rhs)=?0 And? IsPositiveReal(Im(rhs))) <-- { var == rhs^2 };\n20 # Solve'Simple(Sqrt(_e1), _rhs, _var)_(e1 =? var And? Re(rhs)=?0 And? IsNegativeReal(Im(rhs)) And? Im(rhs) !=? 0) <-- { };\n20 # Solve'Simple(Sqrt(_e1), _rhs, _var)_(e1 =? var And? IsNegativeReal(Re(rhs)) And? Re(rhs) !=? 0) <-- { };\n\n30 # Solve'Simple(_lhs, _rhs, _var) <-- Failed;\n\n\n/********** Solve'Divide **********/\n/* For some classes of equations, it may be easier to solve them if we\n * divide through by their first term.  A simple example of this is the\n * equation  Sin(x)+Cos(x)==0\n * One problem with this is that we may lose roots if the thing we\n * are dividing by shares roots with the whole equation.\n * The final HasExprs are an attempt to prevent infinite recursion caused by\n * the final Simplify step in Solve undoing what we do here.  It's conceivable\n * though that this won't always work if the recurring loop is more than two\n * steps long.  I can't think of any ways this can happen though :)\n */\n\n10 # Solve'Divide(_e1 + _e2, _var)_(HasExpr(e1, var) And? HasExpr(e2, var)\n                And? Not? (HasExpr(Simplify(1 + (e2/e1)), e1)\n                      Or? HasExpr(Simplify(1 + (e2/e1)), e2)))\n                                           <-- Solve(1 + (e2/e1), var);\n10 # Solve'Divide(_e1 - _e2, _var)_(HasExpr(e1, var) And? HasExpr(e2, var)\n                And? Not? (HasExpr(Simplify(1 - (e2/e1)), e1)\n                      Or? HasExpr(Simplify(1 - (e2/e1)), e2)))\n                                           <-- Solve(1 - (e2/e1), var);\n\n20 # Solve'Divide(_e, _v) <-- Failed;\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/solve.mpw";
        scriptMap.put("Solve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"xPSolve\",*);\n//Retract(\"xPSolveCubic\",*);\n//Retract(\"xPSC1\",*);\n//Retract(\"xPSC2\",*);\n\n/*-------------------------------------------------------\n * NOTES: TODO: RadSimp() may have a problem with \n *        roots of complex numbers\n *-------------------------------------------------------*/\n\n \nRulebase(\"xPSolve\",{uni});\n\nRule(\"xPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 1)\n[\n    If(iDebug,Tell(\"   xPSolve_1\",uni));\n    {-Coef(uni,0)/Coef(uni,1)};\n];\n\nRule(\"xPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 2)\n[\n     If(iDebug,Tell(\"   xPSolve_2\",uni));\n     Local(a,b,c,d,q,r);\n     c:=Coef(uni,0);\n     b:=Coef(uni,1);\n     a:=Coef(uni,2);\n     If(iDebug,Tell(\"        \",{a,b,c}));\n     d:=b*b-4*a*c;\n     If(iDebug,Tell(\"              \",d));\n     //q:=RadSimp(Sqrt(d)/(2*a));\n     q:=Sqrt(d)/(2*a);\n     If(iDebug,Tell(\"              \",q));\n     r:=Simplify(-b/(2*a));\n     If(iDebug,Tell(\"              \",r));\n     {r+q,r-q};\n];\n\n/*\n    How to solve the cubic equation?\n\n   The equation is  a3 x^3 + a2 x^2 + a1 x + a0  = 0.  \n   \n   Get coefficients for a new polynomial, such that the coefficient of\n   degree 2 is zero:\n   Take f(x)=a0+a1*x+a2*x^2+a3*x^3 and substitute x = x' + adjust\n   to get the expression  g(x) = b0+b1*x+b2*x^2+b3*x^3,\n   where\n      b3 = a3;\n      b2 = 0 => adjust = (-a2)/(3*a3);\n      b1 = 2*a2*adjust+3*a3*adjust^2+a1;\n      b0 = a2*adjust^2+a3*adjust^3+adjust*a1+a0;\n\n   After solving g(x') = 0, return x = x' + adjust.\n   \n   Since b2 = 0 by construction, we have the equation\n      g(x) = x^3 + q x + r = 0,\n   where\n      r = b0/b3  and  q = b1/b3.\n      \n    Let x = a + b, so\n           a^3 + b^3 + 3 (a^2 b + b^2 a) + q (a + b) + r = 0\n           a^3 + b^3 + (3 a b + q) x + r = 0\n\n        Let 3 a b + q = 0. This is permissible, for we can still find a+b == x\n\n        a^3 + b^3 = -r\n        (a b)^3 = -q^3/27\n\n        So a^3 and b^3 are the roots of t^2 + r t - q^3/27 = 0\n\n        Let\n                a^3 = -r/2 + Sqrt(q^3/27+ r^2/4)\n                b^3 = -r/2 - Sqrt(q^3/27+ r^2/4)\n        Therefore there are three values for each of a and b.\n        Clearly if ab = -q/3 is true then (wa)(w^2b) == (wb)(w^2a) == -q/3\n*/\n\nRule(\"xPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 3 )\n[\n     If(iDebug,Tell(\"   xPSolve_3\",uni));\n     Local(p,q,r,s,t,w1,w2,a,b);\n     Local(c0,c1,c3,adjust);\n\n     //  w1 and w2 are constants: the \"other\" two cube-roots of unity\n     w1 := (1/2)*Complex(-1, Sqrt(3));\n     w2 := Conjugate(w1);\n     If( iDebug, Tell(\"   \",{w1,w2}) );\n     \n     // Now we begin to find solutions\n     adjust := (-uni[3][3])/(3*uni[3][4]);\n     If( iDebug, Tell(\"   \",adjust));\n     c3  := uni[3][4];\n     c1  := (3*uni[3][4]*adjust+2*uni[3][3])*adjust+uni[3][2];\n     c0  :=((uni[3][4]*adjust+uni[3][3])*adjust+uni[3][2])*adjust+uni[3][1];\n     If( iDebug, Tell(\"   \",{c0,c1,c3})); \n\n     // Invariant: c0, c1, c2 are all REAL\n     Assert(\"Invariant\", \"Coefficients Must be Real\") And?(Im(c0)=?0,Im(c1)=?0,Im(c2)=?0);\n     If( IsError(\"Invariant\"), DumpErrors() );\n\n     p :=c3;\n     q :=c1/p;\n     r :=c0/p;\n     If( iDebug, Tell(\"   \",{p,q,r}));\n     Local(a3,b3,qq,r1,r2,r3);\n     qq := Sqrt(q^3/27 + r^2/4);\n     a3 := -r/2 + qq;\n     b3 := -r/2 - qq;\n     // NOTE: If q < 0 and r = 0, then qq is pure imaginary, a3 = qq, b3 = -qq.\n     If( iDebug, [Tell(\"   \",{qq,a3,b3}); Tell(\"   \",N(a3+b3+r)); Tell(\"   \",N(a3-b3-2*qq));]);\n     a  := (a3)^(1/3);\n     b  := (b3)^(1/3);\n     If( iDebug, Tell(\"   \",{a,b}));\n     r1 := a+b+adjust;\n     r2 := w1*a+w2*b+adjust;\n     r3 := w2*a+w1*b+adjust;\n     // NOTE: If q < 0 and r = 0, then r3 = adjust  and  r2 = Sqrt(3)*qqi + adjust\n     If( iDebug,\n       [\n          Tell(\"   \",r1);\n          Tell(\"   \",r2);\n          Tell(\"   \",r3);\n       ]\n     );\n     {r1,r2,r3};\n];\n\n\n/*\nHow to solve the quartic equation?\n\nThe equation is x^4 + a1 x^3 + a2 x^2 + a3 x + a4 = 0.\nThe idea is to write the left-hand side as the difference of two\nsquares: (x^2 + p x + q)^2 - (s x + t)^2.\nEliminating the parentheses and equation coefficients yields four\nequations for the four unknowns p, q, s and t:\n  a1 = 2p              (1)\n  a2 = p^2 + 2q - s^2  (2)\n  a3 = 2pq - 2st       (3)\n  a4 = q^2 - t^2       (4)\nFrom the first equation, we find that p = a1/2. Substituting this in\nthe other three equations and rearranging gives\n  s^2 = a1^2/4 - a2 + 2q   (5)\n  2st = a1 q - a3          (6)\n  t^2 = q^2 - a4           (7)\nWe now take the square (6) and substitute (5) and (7):\n  4 (a1^2/4 - a2 + 2q) (q^2 - a4) = (a1 q - a3)^2  <==>\n  8 q^3 - 4 a2 q^2 + (2 a1 a3 - 8 a4) q + 4 a2 a4 - a1^2 a4 - a3^2 = 0.\nMiraculously, we got a cubic equation for q. Suppose we can solve this\nequation. We can then compute t from (7): t = sqrt(q^2 - a4). If t is\nnonzero, we can compute s from (6). Note that we cannot compute s from\n(5), since we introduced an extra solution when squaring (6). However,\nif t is zero, then no extra solution was introduced and we can safely\nuse (5). Having found the values of p, q, s and t, we can factor the\ndifference of squares and solve the quartic:\n  x^4 + a1 x^3 + a2 x^2 + a3 x + a4 = (x^2 + p x + q)^2 - (s x + t)^2\n                 = (x^2 + p x + q + s x + t) (x^2 + p x + q - sx - t).\nThe four roots of the quartic are the two roots of the first quadratic\nfactor plus the two roots of the second quadratic factor.\n*/\n\nRule(\"xPSolve\",1,1,IsUniVar(uni) And? Degree(uni) =? 4 )\n[\n    If(iDebug,Tell(\"   xPSolve_4\",uni));\n    Local(coef4,a1,a2,a3,a4,y,y1,z,t,s);\n\n    coef4:=Coef(uni,4);\n    a1:=Coef(uni,3)/coef4;\n    a2:=Coef(uni,2)/coef4;\n    a3:=Coef(uni,1)/coef4;\n    a4:=Coef(uni,0)/coef4;\n    If( iDebug, Tell(\"        \",{a1,a2,a3,a4}));\n\n    /* y1 = 2q, with q as above. */\n    Local(ys);\n    ys := xPSolveCubic(y^3-a2*y^2+(a1*a3-4*a4)*y+(4*a2*a4-a3^2-a1^2*a4));\n    If( iDebug, [NewLine(); Tell(\"        \",ys[1]);] );\n    y1:=First(ys);\n    If( iDebug, Tell(\"        \",y1));\n    t := Sqrt(y1^2/4-a4);\n    If( iDebug, Tell(\"        \",t));\n    If(t=?0, s:=Sqrt(y1+a1^2/4-a2), s:=(a1*y1-2*a3)/(4*t));\n    If( iDebug, Tell(\"        \",s));\n    \n    Local(q11,q12,q21,q2,quad1,quad2);\n    q11 := a1/2+s;    q12 := y1/2+t;\n    q21 := a1/2-s;    q22 := y1/2-t;\n    If( iDebug, Tell(\"        \",{q11,q12}));\n    If( iDebug, Tell(\"        \",{q21,q22}));\n    quad1 := z^2 + q11*z + q12;\n    quad2 := z^2 + q21*z + q22;\n    If( iDebug, Tell(\"        \",{quad1,quad2}));\n    \n    Local(r1,r2,r3,r4);\n    {r1,r2} := xPSolve( quad1, z );\n    {r3,r4} := xPSolve( quad2, z );\n    r1 := NearRational(N(r1,10),8);\n    r2 := NearRational(N(r2,10),8);\n    r3 := NearRational(N(r3,10),8);\n    r4 := NearRational(N(r4,10),8);\n    \n    {r1,r2,r3,r4};\n];\n\n\nFunction(\"xPSolve\",{expr,var})\n[\n    If( Not? IsBound(iDebug), iDebug := False );\n    If(iDebug,Tell(\"xPSolve_notUni\",{expr,var}));  \n    Local(lhs,rhs,cc,pp,uni,solnpp,solncc,soln);\n    If( IsEquation(expr), \n      [\n         If(iDebug,Tell(\"   is Equation\"));\n         lhs  := EquationLeft(expr);\n         rhs  := EquationRight(expr);\n         expr := lhs - rhs;\n      ]\n    );\n    If(iDebug,Tell(\"   \",expr));\n    cc := xContent(expr);\n    pp := xPrimitivePart(expr,cc);\n    If(iDebug,Tell(\"   \",{cc,pp}));\n    solnpp := xPSolve(MakeUni(pp,var));\n    If(iDebug,Tell(\"   \",solnpp));\n    If( Length(VarList(cc)) >? 0 And? Contains(VarList(cc),var ),\n      [\n         solncc := xPSolve(MakeUni(cc,var));\n         If(iDebug,Tell(\"   \",solncc));\n         soln   := Concat(solncc,solnpp);\n      ],\n      [\n         soln   := solnpp;\n      ]\n    );\n    soln;\n];\n\n\n10 # xPSolveCubic( poly_IsPolynomial )_\n                   (Length(VarList(poly))=?1 And? Degree(poly)=?3) <--\n[\n    If( iDebug, Tell(\"  xPSolveCubic\",poly) );\n    Local(var,coeffs,ans);\n    var    := VarList(poly)[1];\n    coeffs := Coef(poly,var,3 .. 0);\n    If( iDebug, Tell(\"     \",{var,coeffs}));\n    ans    := xPSC1(coeffs);    \n];\nUnFence(\"xPSolveCubic\",1);\n\n\n10 # xPSC1( coeffs_IsList ) <--\n[\n    If( iDebug, Tell(\"    xPSC1\",coeffs) );\n    /*\n     * This function solves a general cubic equation with REAL coefficients.\n     * It is based on an algorithm described in the book\n     * \"Handbook of Applied Mathematics for Engineers and Scientists\",\n     * by Max Curtz.\n     */\n     Local(f,g,h,j,iType,ans);\n     f := coeffs[2]/coeffs[1]/3;\n     g := coeffs[3]/coeffs[1]/3 - f^2;\n     h := coeffs[4]/coeffs[1]/2 + f^3 - f * coeffs[3]/coeffs[1]/2;\n     j := g^3 + h^2;\n     If( iDebug, Tell(\"     \",{f,g,h,j}) );\n     ans := xPSC2( {f,g,h,j} );\n];\n\n\n10 # xPSC2( xs_IsList )_(xs[4]=?0) <--\n[\n    If( iDebug, Tell(\"        Type 1\",xs) );                 \n    Local(f,g,h,j,m,r1,r2,r3,ans);\n    {f,g,h,j} := FlatCopy(xs);\n    m   := 2*(-h)^(1/3);\n    r1  := NearRational(N(m - f,10),8);\n    r2  := NearRational(N(-m/2 - f,10),8);\n    r3  := NearRational(N(-m/2 - f,10),8);\n    ans := {r1,r2,r3};\n];\n\n10 # xPSC2( xs_IsList )_(xs[4]>?0) <--\n[\n    If( iDebug, Tell(\"        Type 2\",xs) ); \n    Local(f,g,h,j,k,l1,l2,m,n,r1,r2,r3,ans); \n    {f,g,h,j} := FlatCopy(xs);\n    k   := Sqrt(j);\n    l1  := (-h + k)^(1/3);\n    l2  := (-h - k)^(1/3);\n    m   := l1 + l2;\n    n   := (l1 - l2)*Sqrt(3)/2;\n    r1  := NearRational(N(m - f,10),8);\n    r2  := NearRational(N(-m/2 - f + I*n,10),8);\n    r3  := NearRational(N(Conjugate(r2),10),8);\n    ans := {r1,r2,r3};\n    \n];\n\n10 # xPSC2( xs_IsList )_(xs[4]<?0 And? xs[3]=?0) <--\n[\n    If( iDebug, Tell(\"        Type 3a\",xs) );\n    Local(f,g,h,j,p,r1,r2,r3,ans);\n    {f,g,h,j} := FlatCopy(xs);\n    p   := 2*Sqrt(-g);\n    r1  := NearRational(N(-f,10),8);\n    r2  := NearRational(N( p*Sqrt(3)/2 - f,10),8);\n    r3  := NearRational(N(-p*Sqrt(3)/2 - f,10),8);\n    ans := {r1,r2,r3};\n];\n\n10 # xPSC2( xs_IsList )_(xs[4]<?0 And? xs[3]>?0) <--\n[\n    If( iDebug, Tell(\"        Type 3b\",xs) );\n    Local(p,x,alpha,beta,gama,r1,r2,r3,ans);\n    {f,g,h,j} := FlatCopy(xs);\n    p     := 2*Sqrt(-g);\n    k     := Sqrt(-j);\n    alpha := ArcTan(k/(-h));   //  alpha should be Acute\n    beta  := Pi + alpha;\n    gama  := beta / 3;\n    If( iDebug,\n      [\n         Tell(\"          \",{p,k});\n         Tell(\"          \",{alpha,beta,gama});\n         Tell(\"          \",57.2957795*N({alpha,beta,gama}));\n         Tell(\"          \",N(Cos(gama)));\n      ]\n    );\n    r1    := NearRational(N(p * Cos(gama) - f,10),8);\n    r2    := NearRational(N(p * Cos(gama+2*Pi/3) - f,10),8);\n    r3    := NearRational(N(p * Cos(gama+4*Pi/3) - f,10),8);\n    ans   := {r1,r2,r3};\n];\n\n10 # xPSC2( xs_IsList )_(xs[4]<?0 And? xs[3]<?0) <--\n[\n    If( iDebug, Tell(\"        Type 3c\",xs) );\n    Local(f,g,h,j,p,k,alpha,beta,gama,r1,r2,r3,ans);\n    {f,g,h,j} := FlatCopy(xs);\n    p     := 2*Sqrt(-g);\n    k     := Sqrt(-j);\n    alpha := ArcTan(k/(-h));   //  alpha should be Acute\n    beta  := alpha;\n    gama  := beta / 3;\n    If(iDebug,[Tell(\"          \",{p,k}); Tell(\"          \",{alpha,beta,gama});]);\n    r1    := NearRational(N(p * Cos(gama) - f,10),8);\n    r2    := NearRational(N(p * Cos(gama+2*Pi/3) - f,10),8);\n    r3    := NearRational(N(p * Cos(gama+4*Pi/3) - f,10),8);\n    ans   := {r1,r2,r3};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/solve/xPSolve.mpw";
        scriptMap.put("xPSolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n// Ex:\n// Bessel of order n:\n// ApproxInfSum((-1)^k*(x/2)^(2*k+c[1])/(k! * Gamma(k+c[1]+1) ),1,x,{n} );\n\nFunction(\"ApproxInfSum\",{expr,start,x})[\n        ApproxInfSum(expr,start,x,{0});\n];\n\n/// FIXME this has a roundoff problem when InNumericMode()=True\n// Summation must be on k\nFunction(\"ApproxInfSum\",{expr,start,x,c})\n[\n        Local(term,result,k);\n        Local(prec,eps,tmp);\n        prec:=BuiltinPrecisionGet();\n//        BuiltinPrecisionSet(Ceil(1.2*prec)); // this is a guess\n        BuiltinPrecisionSet(prec+2); // this is a guess\n//        eps:=5*10^(-prec);\n        eps:=10^(-prec);\n//Echo(expr);\n//Echo(\"     eps = \",N(Eval(eps)));\n\n        term:=1;\n        k:=start;\n        result:=0;\n        While( N(Abs(term) >=? eps) )[\n                term:=N(Eval(expr));\n                //Echo({\"term is \",term});\n                k:=k+1;\n                result:=result+term;\n\n        ];\n                If(InVerboseMode(), Echo(\"ApproxInfSum: Info: using \", k, \" terms of the series\"));\n        BuiltinPrecisionSet(prec);\n        // This should not round, only truncate\n        // some outputs will be off by one in the last digit\n\n//Echo(\"lastterm = \",N(Eval(term)));\n\n//Echo(\"r1\",result);\n//Echo(\"r2\",RoundTo(result,prec));\n//Echo(\"r3\",N((result/10)*10));\n\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/ApproxInfSum.mpw";
        scriptMap.put("ApproxInfSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/////////////////////////////////////////////////\n/// Bernoulli numbers and polynomials\n/////////////////////////////////////////////////\n/// Serge Winitzki\n\n/// Bernoulli(n): interface to Bernoulli numbers\n10 # Bernoulli(0) <-- 1;\n10 # Bernoulli(1) <-- -1/2;\n15 # Bernoulli(n_IsInteger)_(n<?0) <-- Undefined;\n30 # Bernoulli(n_IsOdd) <-- 0;\n\n/// numerical computations of Bernulli numbers use two different methods, one good for small numbers and one good only for very large numbers (using Zeta function)\n20 # Bernoulli(n_IsEven)_(n<=?Bernoulli1Threshold()) <-- Internal'BernoulliArray(n)[n+1];\n20 # Bernoulli(n_IsEven)_(n>?Bernoulli1Threshold()) <-- Bernoulli1(n);\n\nLocalSymbols(bernoulli1Threshold) [\n  /// Bernoulli1Threshold could in principle be set by the user\n  If(Not? IsBound(bernoulli1Threshold), bernoulli1Threshold := 20);\n\n  Bernoulli1Threshold() := bernoulli1Threshold;\n  SetBernoulli1Threshold(threshold) := [ bernoulli1Threshold := threshold;];\n\n] ; // LocalSymbols(bernoulli1Threshold)\n\n/// Bernoulli polynomials of degree n in variable x\nBernoulli(n_IsInteger, _x) <-- [\n        Local(B, i, result);\n        B := Internal'BernoulliArray(n);\n        result := B[1];\n        For(i:=n-1, i>=?0, i--) [\n                result := result * x + B[n-i+1]*BinomialCoefficient(n,i);\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Bernoulli.mpw";
        scriptMap.put("Bernoulli",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # BesselI(0,0)        <-- 1;\n\n10 # BesselI(_n,0)_(n>?0) <-- 0;\n\n10 # BesselI(_n,0)_(n<?0 And? IsInteger(n)) <-- 0;\n\n\n// The following should be ComplexInfinity, if/when that is implemented\n10 # BesselI(_n,0)_(n<?0 And? Not? IsInteger(n)) <-- Infinity;\n\n\n20 # BesselI(1/2,_x)        <-- Sqrt(2/(x*Pi))*Sinh(x);\n\n\n20 # BesselI(3/2,_x)    <-- Sqrt(2/(x*Pi))*(Cosh(x) - Sinh(x)/x);\n\n\n20 # BesselI(5/2,_x)    <-- Sqrt(2/(x*Pi))*((3/x^2 + 1)*Sinh(x) - 3*Cosh(x)/x );\n\n\n30 # BesselI(_n,_z)_(n<?0 And? IsInteger(n) ) <-- BesselI(-n,z);\n\n\n// When I put \"And? InNumericMode()\" on the next rule, I lose precision. Why ?\n// Also, if I move the the \"_IsComplex\" to the end with \"IsComplex(x)\"\n// I lose precision.\n\n\n//40 # BesselI(_n,x_IsComplex)_(Abs(x)<=? 2*Gamma(n) )  <-- N(BesselNsmall(n,x,1));\n\n\n40 # BesselI(_n,x_IsComplex)_(IsConstant(x) And? Abs(x)<=? 2*Gamma(n) )  <--\n[\nApproxInfSum((x/2)^(2*k+c[1])/(k! * Gamma(k+c[1]+1) ),0,x,{n} );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/BesselI.mpw";
        scriptMap.put("BesselI",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # BesselJ(0,0)         <-- 1;\n10 # BesselJ(_n,0)_(n>?0) <-- 0;\n10 # BesselJ(_n,0)_(n<?0 And? IsInteger(n)) <-- 0;\n10 # BesselJ(_n,0)_(n<?0 And? Not? IsInteger(n)) <-- Infinity;\n10 # BesselJ(0,Infinity)<-- 0;\n20 # BesselJ(1/2,_x)        <-- Sqrt(2/(x*Pi))*Sin(x);\n20 # BesselJ(-1/2,_x)        <-- Sqrt(2/(x*Pi))*Cos(x);\n20 # BesselJ(3/2,_x)        <-- Sqrt(2/(x*Pi))*(Sin(x)/x - Cos(x));\n20 # BesselJ(-3/2,_x)        <-- Sqrt(2/(x*Pi))*(Cos(x)/x + Sin(x));\n20 # BesselJ(5/2,_x)        <-- Sqrt(2/(x*Pi))*((3/x^2 - 1)*Sin(x) - 3*Cos(x)/x );\n20 # BesselJ(-5/2,_x)      <-- Sqrt(2/(x*Pi))*( (3/x^2 -1)*Cos(x) + 3*Sin(x)/x );\n\n\n// Forward recursion, works great, but really slow when n << x\n30 # BesselJ(_n,_x)_(IsConstant(x) And? IsInteger(n) And? N(Abs(x) >? 2*Gamma(n))) <-- N((2*(n+1)/x)*BesselJ(n+1,x) - BesselJ(n+2,x));\n\n30 # BesselJ(_n,_z)_(n<?0 And? IsInteger(n) ) <-- (-1)^n*BesselJ(-n,z);\n\n// When I put \"And? InNumericMode()\" on the next rule, I lose precision. Why ?\n// Also, if I move the the \"_IsComplex\" to the end with \"IsComplex(x)\"\n// I lose precision.\n\n//40 # BesselJ(_n,x_IsComplex)_(Abs(x)<=? 2*Gamma(n) )  <-- N(BesselNsmall(n,x,0));\n\n40 # BesselJ(_n,x_IsComplex)_(N(Abs(x)<=? 2*Gamma(n)) )  <--\n[\nApproxInfSum((-1)^k*(x/2)^(2*k+c[1])/(k! * Gamma(k+c[1]+1) ),0,x,{n} );\n];\n\n50 # BesselJ(0,x_IsComplex)_(InNumericMode()) <-- N(BesselJN0(x));\n\n//50 # BesselJ(_n_IsPositiveNumber,_z_IsComplex) <-- BesselJN(n,z);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/BesselJ.mpw";
        scriptMap.put("BesselJ",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "//Jonathan Leto\n\n// This is buggy\n40 # BesselY(_n,x_IsComplex)_(Abs(x)<=? 2*Gamma(n) )  <-- N((Cos(n*Pi)*BesselJ(n,x) - BesselJ(-n,x))/Sin(Pi*n));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/BesselY.mpw";
        scriptMap.put("BesselY",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # Beta(_n,_m)        <-- Gamma(m)*Gamma(n)/Gamma(m+n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Beta.mpw";
        scriptMap.put("Beta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n/////////////////////////////////////////////////\n/// Catalan's constant, various algorithms for comparison. (SW)\n/////////////////////////////////////////////////\n\n/* Brent-Fee's method based on Ramanujan's identity and Brent's trick.\n * Geometric convergence as 2^(-n). */\nCatalanConstNum1() :=\n[\n  Local(prec,Aterm,Bterm,nterms,result,n);\n  prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(10);\n        // estimate the number of terms from above\n        nterms := 1+Floor(N((prec*Ln(10)+Ln(prec*Ln(10)/Ln(2)))/Ln(2)));\n  BuiltinPrecisionSet(prec+5);\n        Aterm:=N(1/2);\n  result:= Aterm;\n  Bterm:=Aterm;\n  For(n:=1, n<=?nterms, n++ )\n        [\n/*\n    Bterm := MultiplyNum(Bterm, n/(2*n+1));\n    Aterm:= DivideN(MultiplyNum(Aterm,n)+Bterm, 2*n+1);\n/* this is faster: */\n    Bterm:=DivideN(MultiplyN(Bterm,n), 2*n+1); // Bterm = (k!)^2*2^(k-1)/(2*k+1)!\n    Aterm:=DivideN(MultiplyN(Aterm,n)+Bterm, 2*n+1); // Aterm = Bterm * Sum(k,0,n,1/(2*k+1))\n/**/\n    result := result + Aterm;\n  ];\n  BuiltinPrecisionSet(prec);\n  RoundTo(result,prec);\n];\n\n/* Bailey 1997's method.\n * Geometric convergence as 4^(-n). */\n\nCatalanConstNum() :=\n[\n        Local(prec, n, result);\n        prec:=BuiltinPrecisionGet();\n\n        // number of terms\n        n := 1+Quotient(prec*1068+642,643); // prec*Ln(10)/Ln(4)\n        BuiltinPrecisionSet(prec+2);        // 2 guard digits\n\n        result := N(1/(2*n+1));\n        While(n>?0)\n        [\n/*\n                result := MultiplyNum(result, n/(4*n+2))+N(1/(2*n-1));\n/* this is faster: */\n                result := DivideN(MultiplyN(result, n), 4*n+2)+DivideN(1,2*n-1);\n/**/\n                n := n-1;\n        ];\n        result := MultiplyNum(result, 3/8) + N(Pi/8*Ln(2+Sqrt(3)));\n        BuiltinPrecisionSet(prec);\n        RoundTo(result,prec);\n];\n\n/* Broadhurst's series.\n * Geometric convergence as 16^(-n). */\n\nCatalanConstNum2() :=\n[\n        Local(prec, n, result1, result2);\n        prec:=BuiltinPrecisionGet();\n\n        // first series\n        // number of terms\n        n := 1+Quotient(prec*534+642,643); // prec*Ln(10)/Ln(16)\n        BuiltinPrecisionSet(prec+2);        // 2 guard digits\n\n        result1 := 0;\n        While(n>=?0)\n        [\n                result1 := DivideN(result1, 16)+N(\n                        +1/(8*n+1)^2 -1/(8*n+2)^2 +1/2/(8*n+3)^2 -1/4/(8*n+5)^2 +1/4/(8*n+6)^2 -1/8/(8*n+7)^2\n                );\n                n := n-1;\n        ];\n\n        // second series\n        // number of terms\n        n := 1+Quotient(prec*178+642,643); // prec*Ln(10)/Ln(4096)\n        BuiltinPrecisionSet(prec+2);        // 2 guard digits\n\n        result2 := 0;\n        While(n>=?0)\n        [\n                result2 := DivideN(result2, 4096)+N(\n                        +1/(8*n+1)^2 +1/2/(8*n+2)^2 +1/8/(8*n+3)^2 -1/64/(8*n+5)^2 -1/128/(8*n+6)^2 -1/512/(8*n+7)^2\n                );\n                n := n-1;\n        ];\n        result1 := MultiplyNum(result1, 3/2) - MultiplyNum(result2, 1/4);\n        BuiltinPrecisionSet(prec);\n        RoundTo(result1,prec);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/CatalanConstNum.mpw";
        scriptMap.put("CatalanConstNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n// needs Erf() that takes complex argument\n/*\n10 # DawsonIntegral(_x) <-- [\n        Local(result,prec);\n        prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(prec+5);\n        result:=N(I*Sqrt(Pi)*Exp(-x^2)*Erf(-I*x)/2);\n        BuiltinPrecisionSet(prec);\n        RoundTo(result,prec);\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/DawsonIntegral.mpw";
        scriptMap.put("DawsonIntegral",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # Digamma(_n)_(IsPositiveInteger(n)) <-- Sum(m,1,n-1,1/m) - gamma;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Digamma.mpw";
        scriptMap.put("Digamma",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n// This is really slow for x <=? 3\n5  # DirichletBeta(1)                <-- Pi/4;\n5  # DirichletBeta(2)                <-- Catalan;\n5  # DirichletBeta(3)                <-- Pi^3/32;\n6  # DirichletBeta(n_IsOdd)        <-- [\n                Local(k);\n                k:=(n-1)/2;\n                (-1)^k*Euler(2*k)*(Pi/2)^(2*k+1)/(2*(2*k)!);\n];\n\n\n10 # DirichletBeta(x_IsRationalOrNumber)_(InNumericMode() And? x>=?1 ) <-- [\n        Local(prec,eps,term,result,k);\n        prec:=BuiltinPrecisionGet();\n  BuiltinPrecisionSet(prec+3);\n        eps:=10^(-prec);\n        result:=0;\n        term:=1;\n        For(k:=0, Abs(term) >? eps, k++ )[\n                term:=(-1)^k/(2*k+1)^x;\n                Echo(\"term is \",term);\n                result:=result+term;\n        ];\n        BuiltinPrecisionSet(prec);\n        RoundTo(result,prec);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/DirichletBeta.mpw";
        scriptMap.put("DirichletBeta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # DirichletEta(_z)        <-- (1-2/2^z)*Zeta(z);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/DirichletEta.mpw";
        scriptMap.put("DirichletEta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # DirichletLambda(_z)<-- (1-1/2^z)*Zeta(z);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/DirichletLambda.mpw";
        scriptMap.put("DirichletLambda",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n/////////////////////////////////////////////////\n/// Error and complementary error functions\n/////////////////////////////////////////////////\n\n10 # Erf(0)                <-- 0;\n//10 # Erfc(0)                <-- 1;\n10 # Erf(Infinity)        <-- 1;\n10 # Erf(Undefined) <-- Undefined;\n//10 # Erfc(Infinity)        <-- 0;\n10 # Erf(x_IsNumber)_(x<?0)        <-- -Erf(-x);\n//40 # Erf(x_IsNumber)_(Abs(x) <=? 1 )  <-- N(2/Sqrt(Pi)*ApproxInfSum((-1)^k*x^(2*k+1)/((2*k+1)*k!),0,x));\n\nLocalSymbols(k)\n[\n        40 # Erf(_x)_(InNumericMode() And? (IsNumber(x) Or? IsComplex(x)) And? Abs(x) <=? 1) <--\n[\n  Local(prec);\n  prec := BuiltinPrecisionGet(); // N(...) modifies the precision\n  2 / SqrtN(Internal'Pi()) * x\n        * SumTaylorNum(x^2, 1, {{k}, -(2*k-1)/(2*k+1)/k},\n        // the number of terms n must satisfy n*Ln(n/Exp(1))>10^prec\n//        Hold({{k}, [Echo(k); k;]}) @\n                N(1+87/32*Exp(LambertW(prec*421/497)), 20)\n        );\n\n];\n\n];        // LocalSymbols(k)\n\n// asymptotic expansion, can be used only for low enough precision or large enough |x| (see predicates). Also works for complex x.\nLocalSymbols(n'max, k)\n[\n\n        50 # Erf(_x)_(InNumericMode() And? (IsNumber(x) Or? IsComplex(x))\n                And? (\n                        [        // strongest condition: the exp(-x^2) asymptotic is already good\n                                n'max := 0;\n                                Re(x^2) >? BuiltinPrecisionGet()*3295/1431+0.121;\n                        ]\n                        Or?\n                        [        // next condition: the exp(-x^2) helps but we need a few terms of the series too\n                                n'max := N(Minimum((BuiltinPrecisionGet()*3295/1431+0.121)/Internal'LnNum(Abs(x)), 2*Internal'LnNum(Abs(x))), 10);\n                                2*Abs(x)+Re(x^2) >? BuiltinPrecisionGet()*3295/1431+0.121;\n                        ]\n                        Or?\n                        [        // worst case: exp(-x^2) does not help and we need the full series\n        // hack: save a value computed in the predicate to use in the body of rule\n                                n'max := N(({{k}, k+Internal'LnNum(k)} @ BuiltinPrecisionGet()*3295/1431)/2 - 3/2, 10);\n                                Abs(x) >? n'max+3/2;\n                        ]\n                )\n        ) <-- If(Re(x)!=?0, Sign(Re(x)), 0) - Exp(-x^2)/x/SqrtN(Internal'Pi())\n        // the series is 1 - 1/2/x^2 + 1*3/2^2/x^4 - 1*3*5/2^3/x^6 + ...\n        * SumTaylorNum(1/x^2, 1, {{k}, -(2*k-1)/2 }, Maximum(0, Floor(n'max)));\n\n];        // LocalSymbols(n'max, k)\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Erf.mpw";
        scriptMap.put("Erf",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # Erfc(_x)                <-- 1 - Erf(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Erfc.mpw";
        scriptMap.put("Erfc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # Erfi(_x)                <-- -I*Erf(x*I);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Erfi.mpw";
        scriptMap.put("Erfi",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # FresnelCos(0)              <-- 0;\n10 # FresnelCos(Infinity)       <-- 1/2;\n10 # FresnelCos(x_IsNumber)_(x<?0)       <-- -FresnelCos(x);\n\n40 # FresnelCos(x_IsNumber)_(Abs(x) <=? 1) <-- N(Sqrt(2/Pi)*ApproxInfSum((-1)^(k+1)*x^(4*k-3)/((4*k-3) * (2*k-2)! ),1,x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/FresnelCos.mpw";
        scriptMap.put("FresnelCos",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n/////////////////////////////////////////////////\n/// Fresnel integrals\n/////////////////////////////////////////////////\n\n10 # FresnelSin(0)                <-- 0;\n10 # FresnelSin(Infinity)        <-- 1/2;\n10 # FresnelSin(x_IsNumber)_(x<?0)        <-- -FresnelSin(x);\n\n40 # FresnelSin(x_IsNumber)_(Abs(x) <=? 1) <-- N(Sqrt(2/Pi)*ApproxInfSum((-1)^(k+1)*x^(2*k+1)/(k! * (2*k+1)),1,x));\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/FresnelSin.mpw";
        scriptMap.put("FresnelSin",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/////////////////////////////////////////////////\n/// Euler's Gamma function\n////////////////////////////////////////////////////\n/// Serge Winitzki\n\n/// User visible functions: Gamma(x), LnGamma(x)\n\n5 # Gamma(Infinity)        <-- Infinity;\n\n10 # Gamma(_n)_(IsInteger(n) And? n<=?0) <-- Infinity;\n\n\n20 # Gamma(n_IsRationalOrNumber)_(IsPositiveInteger(n) Or? FloatIsInt(2*n)) <-- (Round(2*n)/2-1)!;\n\n\n30 # Gamma(x_IsConstant)_(InNumericMode()) <-- Internal'GammaNum(N(Eval(x)));\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Gamma.mpw";
        scriptMap.put("Gamma",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n/////////////////////////////////////////////////\n/// Lambert's $W$ function.\n/////////////////////////////////////////////////\n/// Serge Winitzki\n\n10 # LambertW(0) <-- 0;\n10 # LambertW(Infinity) <-- Infinity;\n10 # LambertW(Undefined) <-- Undefined;\n10 # LambertW(-Infinity) <-- Infinity + I*Pi;\n10 # LambertW(-Exp(-1)) <-- -1;\n20 # LambertW(_x * Ln(_x)) <-- Ln(x);\n20 # LambertW(Ln(_x) * _x) <-- Ln(x);\n\n30 # LambertW(x_IsConstant) _ InNumericMode() <-- Internal'LambertWNum(Eval(x));\n\n/* {Internal'LambertWNum} computes a numeric approximation of Lambert's $W$ function\nto the current precision. It uses a Halley iteration\n$$ W'=W-(W-x*Exp(-W))/(W+1-(W+2)/(W+1)*(W-x*Exp(-W))/2) $$.\nThe function has real values for real $x >= -Exp(-1)$. (This point is a logarithmic branching point.)\n*/\n10 # Internal'LambertWNum(x_IsNumber)_(x <? -ExpN(-1)) <-- Undefined;\n20 # Internal'LambertWNum(x_IsNumber) <--\n[\n        Local(W);\n        NewtonNum(\n          `Hold(\n          {\n          {W},\n          [\n                  Local(a);\n                a:=W- @x*ExpN(-W);\n                W-a/(W+1-(W+2)/(W+1)*a/2.);\n          ]}),\n        // initial approximation is the two-point global Pade:\n          If(\n                x<?0,\n                x*ExpN(1) / (1+1 / (1 / SqrtN(2*(x*ExpN(1)+1)) - 1 / SqrtN(2) + 1/(ExpN(1)-1))),\n                Internal'LnNum(1+x)*(1-Internal'LnNum(1+Internal'LnNum(1+x))/(2+Internal'LnNum(1+x)))\n          ),\n          10,        // initial approximation is good to about 3 digits\n          3        // 3rd order scheme\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/LambertW.mpw";
        scriptMap.put("LambertW",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n///// Serge Winitzki\n\n10 # LnGamma(_n)_(IsInteger(n) And? n<=?0) <-- Infinity;\n\n20 # LnGamma(n_IsRationalOrNumber)_(IsPositiveInteger(n) Or? FloatIsInt(2*n)) <-- Ln((Round(2*n)/2-1)!);\n\n30 # LnGamma(x_IsConstant)_(InNumericMode()) <-- Internal'LnGammaNum(N(Eval(x)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/LnGamma.mpw";
        scriptMap.put("LnGamma",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n////// Polylogarithm Function\n/// coded by Jonathan Leto: PolyLog, Dirichlet*, Digamma, Bessel*, Erf*, Fresnel*, Beta,\n///                            CatalanConstNum, Sinc, Beta, DawsonIntegral\n// Note: currently, the numerics are only working for x \\in [-1,1]\n\n10 # PolyLog(_n,0)                <-- 0;\n// this is nicer than -Ln(1/2)\n10 # PolyLog(1,1/2)             <-- Ln(2);\n10 # PolyLog(_n,1)                <-- Zeta(n);\n10 # PolyLog(_n,_m)_(m=? -1)        <-- DirichletEta(n);\n10 # PolyLog(_n,_x)_(n<? 0)        <-- (1/((1-x)^(-n+1)))*Sum(i,0,-n,Eulerian(-n,i)*x^(-n-i) );\n//10 # PolyLog(_n,_x)_(n= -3)        <-- x*(x^2 + 4*x + 1)/(x-1)^4;\n//10 # PolyLog(_n,_x)_(n= -2)        <-- x*(x+1)/(1-x)^3;\n//10 # PolyLog(_n,_x)_(n= -1)        <-- x/(1-x)^2;\n10 # PolyLog(0,_x)                <-- x/(1-x);\n10 # PolyLog(1,_x)                <-- -Ln(1-x);\n// special values\n10 # PolyLog(2,1/2)                <-- (Pi^2 - 6*Ln(2)^2)/12;\n10 # PolyLog(3,1/2)                <-- (4*Ln(2)^3 - 2*Pi^2*Ln(2)+21*Zeta(3))/24;\n10 # PolyLog(2,2)                <-- Pi^2/4 - Pi*I*Ln(2);\n\n20 # PolyLog(_n,_x)_(InNumericMode() And?  x <? -1 )  <-- [\n        Local(prec,result);\n        prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(prec+5);\n        Echo(\"Warning: PolyLog is only currently accurate for x in [-1,1]\");\n        result:= (-1)^(n-1)*PolyLog(n,1/x) - ((Ln(-x))^n)/n! -\n        Sum(r,1,Round(n/2),\n                2^(2*r-2)*Pi^(2*r)*Abs(Bernoulli(2*r))*Ln(-x)^(n-2*r)/( (2*r)! * (n - 2*r)! ) );\n        BuiltinPrecisionSet(prec);\n        RoundTo(N(result),prec);\n];\n20 # PolyLog(_n,_x)_(InNumericMode() And? x>=? -1 And? x <? 0 ) <-- [\n        // this makes the domain [-1,0) into [0,1],\n        // so if the summation representation is used, it is monotone\n        Local(prec,result);\n        prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(prec+5);\n\n        result:=PolyLog(n,x^2)/2^(n-1) - PolyLog(n,-x) ;\n        BuiltinPrecisionSet(prec);\n        RoundTo(N(result),prec);\n\n];\n/* this is very slow at high precision\n20 # PolyLog(_n,_x)_(InNumericMode() And? x >? 0 And? x <=? 1) <-- [\n        Local(result,prec,term,k,eps);\n        prec:=BuiltinPrecisionGet();\n  BuiltinPrecisionSet(prec+5);\n        eps:=10^(-prec);\n        result:=0;\n        // Sorry Serge, I was only getting 2 digits of precision with this\n                // so why didn't you ask me? :) -- Serge\n        //terms:=Floor(10 + N(prec*Ln(10)/Ln(prec) - 1));\n        //BuiltinPrecisionSet( prec + Floor(N(Ln(6*terms)/Ln(10))) );\n        //result:=SumTaylorNum(x, {{k}, x^(k+1)/(k+1)^n }, terms );\n        term:=1;\n        For(k:=1,Abs(term)>?eps,k++)[\n                term:=N(x^k/k^n);\n                result:=result+term;\n        ];\n        BuiltinPrecisionSet(prec);\n        RoundTo(result,prec);\n];\n*/\n\n20 # PolyLog(_n,_x)_(InNumericMode() And? x >? 0 And? x <? 1) <--\n[        // use Taylor series x^(k+1)/(k+1)^n, converges for -1<x<1\n        Local(prec, result, terms);\n        prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(15);        // to calculate the number of terms\n        terms := Floor(-prec*Ln(10)/Ln(x));\n        terms := Floor(-(prec*Ln(10)-(n-1)*Ln(terms))/Ln(x));\n//        Echo(\"used\", terms, \"terms\");\n        If(terms <? 4, terms := 4);\n        BuiltinPrecisionSet(prec+2*IntLog(prec,10)+5);\n        result := x*SumTaylorNum(x, {{k}, 1/(k+1)^n}, terms);\n        BuiltinPrecisionSet(prec);\n        RoundTo(result, prec);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/PolyLog.mpw";
        scriptMap.put("PolyLog",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Jonathan Leto\n\n10 # Sinc(_x)                <-- If(x=?0,1,Sin(x)/x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Sinc.mpw";
        scriptMap.put("Sinc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/////////////////////////////////////////////////\n/// Riemann's Zeta function\n/////////////////////////////////////////////////\n/// Serge Winitzki\n\n/// identities for exact values of Zeta\n\n10 # Zeta(1) <-- Infinity;\n10 # Zeta(0) <-- -1/2;        // let's save time\n10 # Zeta(3)_InNumericMode() <-- Zeta3();        // special case\n10 # Zeta(n_IsEven)_(n>?0) <-- Pi^n*(2^(n-1)/n! *Abs(Bernoulli(n)));\n10 # Zeta(n_IsInteger)_(n<?0) <-- -Bernoulli(-n+1)/(-n+1);\n11 # Zeta(n_IsInfinity) <-- 1;\n\n/// compute numeric value\n20 # Zeta(s_IsConstant)_(InNumericMode()) <-- Internal'ZetaNum(N(Eval(s)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/Zeta.mpw";
        scriptMap.put("Zeta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Find one Bernoulli number for large index\n/// compute Riemann's zeta function and combine with the fractional part\nBernoulli1(n_IsEven)_(n>=?2) <-- [\n        Local(B, prec);\n        prec := BuiltinPrecisionGet();\n        // estimate the size of B[n] using Stirling formula\n        // and compute Ln(B[n])/Ln(10) to find the number of digits\n        BuiltinPrecisionSet(10);\n        BuiltinPrecisionSet(\n                Ceil(N((1/2*Ln(8*Pi*n)-n+n*Ln(n/2/Pi))/Ln(10)))+3        // 3 guard digits\n        );\n        If (InVerboseMode(), Echo({\"Bernoulli: using zeta funcion, precision \", BuiltinPrecisionSet(), \", n = \", n}));\n        B := Floor(N(        // compute integer part of B\n                If(        // use different methods to compute Zeta function\n                        n>?250,        // threshold is roughly right for internal math\n                        Internal'ZetaNum2(n, n/17+1),        // with this method, a single Bernoulli number n is computed in O(n*M(P)) operations where P = O(n*Ln(n)) is the required precision\n                        // Brent's method requires n^2*P+n*M(P)\n                        // simple array method requires\n                        Internal'ZetaNum1(n, n/17+1)        // this gives O(n*Ln(n)*M(P))\n                )\n                *N(2*n! /(2*Pi)^n)))\n                // 2*Pi*e is approx. 17, add 1 to guard precision\n                * (2*Modulo(n/2,2)-1)        // sign of B\n                + BernoulliFracPart(n);        // this already has the right sign\n        BuiltinPrecisionSet(prec);        // restore old precision\n        B;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bernou/Bernoulli1.mpw";
        scriptMap.put("Bernoulli1",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Find the fractional part of Bernoulli number with even index >=2\n/// return negative if the sign of the Bernoulli number is negative\nBernoulliFracPart(n_IsEven)_(n>=?2) <-- [\n        Local(p, sum);\n        // always 2 and 3\n        sum := 1/2+1/3;\n        // check whether n+1 and n/2+1 are prime\n        If(IsPrime(n+1), sum := sum+1/(n+1));\n        If(IsPrime(n/2+1), sum := sum+1/(n/2+1));\n        // sum over all primes p such that n / p-1 is integer\n        // enough to check up to n/3 now\n        For(p:=5, p<=?n/3+1, p:=NextPrime(p))\n                If(Modulo(n, p-1)=?0, sum := sum + 1/p);\n        // for negative Bernoulli numbers, let's change sign\n        // Modulo(n/2, 2) is 0 for negative Bernoulli numbers and 1 for positive ones\n        Quotient(Numerator(sum), Denominator(sum)) - sum\n                 + Modulo(n/2,2);        // we'll return a negative number if the Bernoulli itself is negative -- slightly against our definitions in the manual\n                //+ 1;        // this would be exactly like the manual says\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bernou/BernoulliFracPart.mpw";
        scriptMap.put("BernoulliFracPart",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Simple implementation of the recurrence relation: create an array of Bernoulli numbers\n// special cases: n=0 or n=1\n10 # Internal'BernoulliArray(n_IsInteger)_(n=?0 Or? n=?1) <-- [\n        Local(B);\n        B:=ArrayCreate(n+1,0);\n        B[1] := 1;\n        If(n=?1, B[2] := -1/2);\n        B;\n];\n/// Assume n>=?2\n20 # Internal'BernoulliArray(n_IsInteger) <-- [\n        Local(B, i, k, k2, bin);\n        If (InVerboseMode(), Echo({\"Internal'BernoulliArray: using direct recursion, n = \", n}));\n        B:=ArrayCreate(n+1, 0);        // array of B[k], k=1,2,... where B[1] is the 0th Bernoulli number\n        // it would be better not to store the odd elements but let's optimize this later\n        // we could also maintain a global cache of Bernoulli numbers computed so far, but it won't really speed up things at large n\n        // all odd elements after B[2] are zero\n        B[1] := 1;\n        B[2] := -1/2;\n        B[3] := 1/6;\n        For(i:=4, i<=?n, i := i+2)        // compute and store B[i]\n        [        // maintain binomial coefficient\n                bin := 1;        // BinomialCoefficient(i+1,0)\n                // do not sum over odd elements that are zero anyway - cuts time in half\n                B[i+1] := 1/2-1/(i+1)*(1 + Sum(k, 1, i/2-1,\n                        [\n                                bin := bin * (i+3-2*k) * (i+2-2*k)/ (2*k-1) / (2*k);\n                                B[2*k+1]*bin;        // *BinomialCoefficient(i+1, 2*k)\n                        ]\n                ) );\n        ];\n        B;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bernou/Internal'BernoulliArray.mpw";
        scriptMap.put("Internal'BernoulliArray",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// Bernoulli numbers; algorithm from: R. P. Brent, \"A FORTRAN multiple-precision arithmetic package\", ACM TOMS vol. 4, no. 1, p. 57 (1978).\n/// this may be good for floating-point (not exact) evaluation of B[n] at large n\n/// but is not good at all for exact evaluation! (too slow)\n/// Brent claims that the usual recurrence is numerically unstable\n/// but we can't check this because MathPiper internal math is fixed-point and Brent's algorithm needs real floating point (C[k] are very small and then multiplied by (2*k)! )\nInternal'BernoulliArray1(n_IsEven) _ (n>=?2) <--\n[\n        Local(C, f, k, j, denom, sum);\n        C := ArrayCreate(n+1, 0);\n        f := ArrayCreate(n/2, 0);\n        C[1] := 1;\n        C[2] := -1/2;\n        C[3] := 1/12;        // C[2*k+1] = B[2*k]/(2*k)!\n        f[1] := 2;        // f[k] = (2k)!\n        For(k:=2, k<=?n/2, k++)        // we could start with k=1 but it would be awkward to compute f[] recursively\n        [\n                // compute f[k]\n                f[k] := f[k-1] * (2*k)*(2*k-1);\n                // compute C[k]\n                C[2*k+1] := 1/(1-4^(-k))/2*(\n                        [\n                                denom := 4;        // = 4^1\n                                sum := 0;\n                                For(j:=1, j<=?k-1, j++)\n                                [\n                                        sum := sum + C[2*(k-j)+1]/denom/f[j];        // + C[k-j]/(2*j)! /4^j\n                                        denom := denom * 4;\n                                ];\n                                (2*k-1)/denom/f[k] - sum;\n                        ]\n                );\n//        Echo({n, k, denom, C[k]});\n        ];\n        // multiply C's with factorials to get B's\n        For(k:=1, k<=?n/2, k++)\n                C[2*k+1] := C[2*k+1] * f[k];\n        // return array object\n        C;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bernou/Internal'BernoulliArray1.mpw";
        scriptMap.put("Internal'BernoulliArray1",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Jonathan Leto\n\n// Seems to get about 8 digits precision for most real numbers\n// Only about 2 digits precision for complex\n// This is just a temporary implementation, I would not want to\n// expose users to it until it is much more robust\n// I am still looking for a good arbitrary precision algorithm.\nFunction(\"BesselJN0\",{x})\n[\n        Local(ax,z,xx,y,result,res1,res2);\n        Local(c1,c2,c3,c4);\n\n        // Coefficients of the rational polynomials to\n        // approx J_0  for x < 8\n        c1:={57568490574.0,-13362590354.0,651619640.7,\n                -11214424.18,77392.33017,-184.9052456};\n        c2:={57568490411.0,1029532985.0,9494680.718,\n                59272.64853,267.8532712};\n        // Coefficients of the rational polynomials to\n        // approx J_0 for x >= 8\n        c3:={-0.001098628627,0.00002734510407,-0.000002073370639,\n                0.0000002093887211};\n        c4:={-0.01562499995,0.0001430488765,-0.000006911147651,\n                0.0000007621095161,0.0000000934935152};\n        ax:=Abs(x);\n\n        If( ax <? 8.0,[\n                y:=x^2;\n                res1:=c1[1]+y*(c1[2]+y*c1[3]+y*(c1[4]+y*(c1[5]+y*(c1[6]))));\n                res2:=c1[1]+y*(c2[2]+y*c2[3]+y*(c2[4]+y*(c2[5]+y*1.0)));\n                result:=res1/res2;\n        ],[\n                z:=8/ax;\n                y:=z^2;\n                xx:=ax-0.785398164;\n                res1:=1.0+y*(c3[1]+y*(c3[2]+y*(c3[3]+y*c4[4])));\n                res2:=c4[1]+y*(c4[2]+y*(c4[3]+y*(c4[4]-y*c4[5])));\n                result:=Sqrt(2/(Pi*x))*(Cos(xx)*res1-z*Sin(xx)*res2);\n        ] );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bessel/BesselJN0.mpw";
        scriptMap.put("BesselJN0",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Jonathan Leto\n\n// When x is <=? 1, the series is monotonely decreasing from the\n// start, so we don't have to worry about loss of precision from the\n// series definition.\n// When {n} is an integer, this is fast.\n// When {n} is not, it is pretty slow due to Gamma()\n\nFunction(\"BesselNsmall\",{n,x,modified})\n[\n        Local(term,result,k);\n        Local(prec,eps,tmp);\n        prec:=BuiltinPrecisionGet();\n        BuiltinPrecisionSet(Ceil(1.2*prec)); // this is a guess\n        eps:=5*10^(-prec);\n\n        term:=1;\n        k:=0;\n        result:=0;\n        While( Abs(term) >=? eps )[\n                term:=x^(2*k+n);\n                // The only difference between BesselJ and BesselI\n                // is an alternating term\n                If( k%2=?1 And? modified=?0 , term:=term*-1 );\n                term:=N(term/(2^(2*k+n)* k! * Gamma(k+n+1) ));\n                //Echo({\"term is \",term});\n                result:=result+term;\n                k:=k+1;\n        ];\n        BuiltinPrecisionSet(prec);\n        // This should not round, only truncate\n        // some outputs will be off by one in the last digit\n        RoundTo(result,prec);\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/bessel/BesselNsmall.mpw";
        scriptMap.put("BesselNsmall",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Serge Winitzki\n\nInternal'GammaNum(z) := N(Exp(Internal'LnGammaNum(z)));\n\n/// this should not be used by applications\nInternal'GammaNum(z,a) := N(Exp(Internal'LnGammaNum(z,a)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/gamma/Internal'GammaNum.mpw";
        scriptMap.put("Internal'GammaNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/////////////////////////////////////////////////\n/// Euler's Gamma function\n/////////////////////////////////////////////////\n\n//Serge Winitzki\n\n/// This procedure computes the uniform approximation for the Gamma function\n/// due to Lanczos and Spouge (the so-called \"less precise coefficients\")\n/// evaluated at arbitrary precision by using a large number of terms\n/// See J. L. Spouge, SIAM J. of Num. Anal. 31, 931 (1994)\n/// See also Paul Godfrey 2001 (unpublished): http://winnie.fit.edu/~gabdo/gamma.txt for a discussion\n\n/// Calculate the uniform approximation to the logarithm of the Gamma function\n/// in the Re z > 0 half-plane; argument z may be symbolic or complex\n/// but current value of precision is used\n/// Note that we return LnGamma(z), not of z+1\n/// This function should not be used directly by applications\n10 # Internal'LnGammaNum(_z, _a)_(N(Re(z))<?0) <-- [\n        If (InVerboseMode(), Echo({\"Internal'LnGammaNum: using 1-z identity\"}));\n        N(Ln(Pi/Sin(Pi*z)) - Internal'LnGammaNum(1-z, a));\n];\n20 # Internal'LnGammaNum(_z, _a) <-- [\n        Local(e, k, tmpcoeff, coeff, result);\n        a := Maximum(a, 4);        // guard against low values\n        If (InVerboseMode(), Echo({\"Internal'LnGammaNum: precision parameter = \", a}));\n        e := N(Exp(1));\n        k:=Ceil(a);        // prepare k=N+1; the k=N term is probably never significant but we don't win much by excluding it\n        result := 0;        // prepare for last term\n        // use Horner scheme to prevent loss of precision\n        While(k>?1) [        // 'result' will accumulate just the sum for now\n                k:=k-1;\n                result := N( PowerN(a-k,k)/((z+k)*Sqrt(a-k))-result/(e*k) );\n        ];\n        N(Ln(1+Exp(a-1)/Sqrt(2*Pi)*result) + Ln(2*Pi)/2 -a-z+(z+1/2)*Ln(z+a) - Ln(z));\n];\n\nInternal'LnGammaNum(z) := [\n        Local(a, prec, result);\n        prec := BuiltinPrecisionGet();\n        a:= Quotient((prec-IntLog(prec,10))*659, 526) + 0.4;        // see algorithm docs\n        /// same as parameter \"g\" in Godfrey 2001.\n        /// Chosen to satisfy Spouge's error bound:\n        /// error < Sqrt(a)/Real(a+z)/(2*Pi)^(a+1/2)\n//        Echo({\"parameter a = \", a, \" setting precision to \", Ceil(prec*1.4)});\n        BuiltinPrecisionSet(Ceil(prec*1.4));        // need more precision b/c of roundoff errors but don't know exactly how many digits\n        result := Internal'LnGammaNum(z,a);\n        BuiltinPrecisionSet(prec);\n        result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/gamma/Internal'LnGammaNum.mpw";
        scriptMap.put("Internal'LnGammaNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nGammaConstNum() :=\n[\n  Local(k, n, A, B, U'old, U, V'old, V, prec, result);\n  prec:=BuiltinPrecisionGet();\n  NonN([\n    BuiltinPrecisionSet(prec+IntLog(prec,10)+3);        // 2 guard digits and 1 to compensate IntLog\n    n:= 1+Ceil(prec*0.5757+0.2862);        // n>(P*Ln(10)+Ln(Pi))/4\n    A:= -Internal'LnNum(n);\n    B:=1;\n    U:=A;\n    V:=1;\n    k:=0;\n    U'old := 0;        // these variables are for precision control\n    V'old := 0;\n    While(U'old-U !=? 0 Or? V'old-V !=? 0)\n    [\n     k++;\n     U'old:=U;\n     V'old:=V;\n     // B:=N( B*n^2/k^2 );\n     B:=MultiplyNum(B,n^2/k^2);        // slightly faster\n     // A:=N( (A*n^2/k+B)/k );\n     A:=MultiplyNum(MultiplyNum(A,n^2/k)+B, 1/k);        // slightly faster\n     U:=U+A;\n     V:=V+B;\n    ];\n    If(InVerboseMode(), Echo(\"GammaConstNum: Info: used\", k, \"iterations at working precision\", BuiltinPrecisionGet()));\n    result:=DivideN(U,V);        // N(U/V)\n  ]);\n  BuiltinPrecisionSet(prec);        // restore precision\n  RoundTo(result, prec);        // return correctly rounded result\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/gammaconst/GammaConstNum.mpw";
        scriptMap.put("GammaConstNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nInternal'ZetaNum\nInternal'ZetaNum1\nInternal'ZetaNum2\nZeta3\n*/\n\n/////////////////////////////////////////////////\n/// Riemann's Zeta function\n/////////////////////////////////////////////////\n\n//Serge Winitzki\n\n/// See: Bateman, Erdelyi: <i>Higher Transcendental Functions<i>, vol. 1;\n/// P. Borwein, <i>An efficient algorithm for Riemann Zeta function<i> (1995).\n\n/// Numerical computation of Zeta function using Borwein's \"third\" algorithm\n/// The value of $n$ must be large enough to ensure required precision\n/// Also $s$ must satisfy $Re(s)+n+1 > 0$\nInternal'ZetaNum(_s, n_IsInteger) <-- [\n        Local(result, j, sign);\n        If (InVerboseMode(), Echo({\"Internal'ZetaNum: Borwein's method, precision \", BuiltinPrecisionGet(), \", n = \", n}));\n        result := 0;\n        sign := 1;        // flipping sign\n        For(j:=0, j<=?2*n-1, j++)\n        [        // this is suboptimal b/c we can compute the coefficients a lot faster in this same loop, but ok for now\n                result := N(result + sign*Internal'ZetaNumCoeffEj(j,n)/(1+j)^s );\n                sign := -sign;\n        ];\n        N(result/(2^n)/(1-2^(1-s)));\n];\n\n/// direct method -- only good for large s\nInternal'ZetaNum1(s, limit) := [\n        Local(i, sum);\n        If (InVerboseMode(), Echo({\"Internal'ZetaNum: direct method (sum), precision \", BuiltinPrecisionGet(), \", N = \", limit}));\n        sum := 0;\n        limit := Ceil(N(limit));\n        For(i:=2, i<=?limit, i++) sum := sum+N(1/PowerN(i, s));\n//        sum := sum + ( N( 1/PowerN(limit, s-1)) + N(1/PowerN(limit+1, s-1)) )/2/(s-1);          // these extra terms don't seem to help much\n        sum+1;        // add small terms together and then add 1\n];\n/// direct method -- using infinite product. For internal math, Internal'ZetaNum2 is faster for Bernoulli numbers > 250 or so.\nInternal'ZetaNum2(s, limit) :=\n[\n        Local(i, prod);\n        If (InVerboseMode(), Echo({\"Internal'ZetaNum: direct method (product), precision \", BuiltinPrecisionGet(), \", N = \", limit}));\n        prod := N( (1-1/PowerN(2, s))*(1-1/PowerN(3,s)) );\n        limit := Ceil(N(limit));\n        For(i:=5, i<=?limit, i:= NextPrime(i))\n                prod := prod*N(1-1/PowerN(i, s));\n        1/prod;\n];\n\n/// Compute coefficients e[j] (see Borwein -- excluding (-1)^j )\nInternal'ZetaNumCoeffEj(j,n) := [\n        Local(k);\n        2^n-If(j<?n,\n                0,\n                Sum(k,0,j-n,BinomialCoefficient(n,k))        // this is suboptimal but ok for now\n        );\n];\n\n/// fast numerical calculation of Zeta(3) using a special series\n\n\n\n\nZeta3() :=\n[\n        Local(result, old'result, k, term);\n  N([\n    For(\n    [\n      k:=1;\n      result := 1;\n      old'result := -1;\n      term := 1;\n    ],\n    old'result!=?result,\n    k++\n    )\n    [\n      old'result := result;\n      term := -term * k^2 / ((2*k+1)*(2*k));\n      result := result + term/(k+1)^2;\n    ];\n    result := 5/4*result;\n  ], BuiltinPrecisionGet()+IntLog(BuiltinPrecisionGet(),10)+1);\n\n        result;\n];\n\n\n/// User interface for Internal'ZetaNum(s,n)\n10 # Internal'ZetaNum(_s) _ (N(s)=?0) <-- -0.5;\n10 # Internal'ZetaNum(_s) _ (N(s)=?1) <-- Infinity;\n20 # Internal'ZetaNum(_s) <-- [\n        Local(n, prec, result);\n        prec := BuiltinPrecisionGet();\n        If(        // use identity if s<1/2 to replace with larger s. Also must be sn!=0 or else we get infinity * zero\n                N(Re(s)) <? 0.5,\n                // call ourselves with a different argument\n                [\n                        If(InVerboseMode(), Echo({\"Internal'ZetaNum: using s->1-s identity, s=\", s, \", precision \", prec}));\n                        result :=  2*Exp(Internal'LnGammaNum(1-s)-(1-s)*Ln(2*Internal'Pi()))*Sin(Internal'Pi()*s/2) * Internal'ZetaNum(1-s);\n                ],\n                // choose between methods\n                If (N(Re(s)) >? N(1+(prec*Ln(10))/(Ln(prec)+0.1), 6),\n                        [        // use direct summation\n                                n:= N(10^(prec/(s-1)), 6)+2;        // 2 guard terms\n                                BuiltinPrecisionSet(prec+2);        // 2 guard digits\n                                result := Internal'ZetaNum1(s, n);\n                        ],\n                        [        // use Internal'ZetaNum(s, n)\n                                n := Ceil( N( prec*Ln(10)/Ln(8) + 2, 6 ) );        // add 2 digits just in case\n                                BuiltinPrecisionSet(prec+2);        // 2 guard digits\n                                result := Internal'ZetaNum(s, n);\n                        ]\n                )\n        );\n        BuiltinPrecisionSet(prec);\n        result;\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/specfunc/zeta/zeta.mpw";
        scriptMap.put("Internal'ZetaNum",scriptString);
        scriptMap.put("Internal'ZetaNum1",scriptString);
        scriptMap.put("Internal'ZetaNum2",scriptString);
        scriptMap.put("Zeta3",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nGeometricMean(list) := \n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Product(list)^(1/Length(list));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/GeometricMean.mpw";
        scriptMap.put("GeometricMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMean(list) := \n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Sum(list)/Length(list);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/Mean.mpw";
        scriptMap.put("Mean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nMedian(list) :=\n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Local(sx,n,n2); // s[orted]x\n    \n    sx := HeapSort(list,\"<?\");\n    \n    n := Length(list);\n    \n    n2 := (n>>1);\n    \n    If(Modulo(n,2) =? 1, sx[n2+1], (sx[n2]+sx[n2+1])/2);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/Median.mpw";
        scriptMap.put("Median",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nStandardDeviation(list) := \n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n\n    Sqrt(UnbiasedVariance(list));\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/StandardDeviation.mpw";
        scriptMap.put("StandardDeviation",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nUnbiasedVariance(list) := \n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n    \n    Sum((list - Mean(list))^2)/(Length(list)-1);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/UnbiasedVariance.mpw";
        scriptMap.put("UnbiasedVariance",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nVariance(list) := \n[\n    Check(IsList(list), \"Argument\", \"Argument must be a list.\");\n\n    Sum((list - Mean(list))^2)/Length(list);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/Variance.mpw";
        scriptMap.put("Variance",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nBernoulliDistribution(p_IsRationalOrNumber)_(p<?0 Or? p>?1) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/BernoulliDistribution.mpw";
        scriptMap.put("BernoulliDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nBinomialDistribution(_p, _n)_\n        (If(IsRationalOrNumber(p),p<?0 Or? p>?1, False)\n         Or? (IsConstant(n) And? Not? IsPositiveInteger(n)) )\n        <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/BinomialDistribution.mpw";
        scriptMap.put("BinomialDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nChiSquareDistribution(m_IsRationalOrNumber)_(m<=?0) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/ChiSquareDistribution.mpw";
        scriptMap.put("ChiSquareDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nContinuousUniformDistribution(a_IsRationalOrNumber, b_IsRationalOrNumber)_(a>=?b)\n   <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/ContinuousUniformDistribution.mpw";
        scriptMap.put("ContinuousUniformDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nDiscreteDistribution( dom_IsRationalOrNumber , prob_IsRationalOrNumber) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/DiscreteDistribution.mpw";
        scriptMap.put("DiscreteDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nDiscreteUniformDistribution(a_IsRationalOrNumber, b_IsRationalOrNumber)_(a>=?b)\n   <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/DiscreteUniformDistribution.mpw";
        scriptMap.put("DiscreteUniformDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nExponentialDistribution(l_IsRationalOrNumber)_(l<?0) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/ExponentialDistribution.mpw";
        scriptMap.put("ExponentialDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\n//Retract(\"FDistribution\",*);\nFDistribution(_n1, _n2) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/FDistribution.mpw";
        scriptMap.put("FDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nGeometricDistribution(p_IsRationalOrNumber)_(p<?0 Or? p>?1) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/GeometricDistribution.mpw";
        scriptMap.put("GeometricDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nHypergeometricDistribution(N_IsRationalOrNumber, M_IsRationalOrNumber, n_IsRationalOrNumber)_(M >? N Or? n >? N)\n   <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/HypergeometricDistribution.mpw";
        scriptMap.put("HypergeometricDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nNormalDistribution( _m , s2_IsRationalOrNumber)_(s2<=?0) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/NormalDistribution.mpw";
        scriptMap.put("NormalDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\nPoissonDistribution(l_IsRationalOrNumber)_(l<=?0) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/PoissonDistribution.mpw";
        scriptMap.put("PoissonDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Guard against distribution objects with senseless parameters\n   Anti-nominalism */\n\ntDistribution(m_IsRationalOrNumber)_(Not? IsPositiveInteger(m)) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/distributions/tDistribution.mpw";
        scriptMap.put("tDistribution",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* ChiSquare's CDF is computed as IncompleteGamma(x,dof/2)/Gamma(dof/2); */\n\nRetract(ChiSquareTest,*);\n\n\n10 # ChiSquareTest( observedFrequenciesMatrix_IsMatrix, expectedFrequenciesMatrix_IsMatrix) <--\n[\n\n    Local(observedFrequenciesList, expectedFrequenciesList);\n    \n    observedFrequenciesList := Flatten(observedFrequenciesMatrix,\"List\");\n    \n    expectedFrequenciesList := Flatten(expectedFrequenciesMatrix,\"List\");\n    \n    Check(Length(observedFrequenciesList) >? 0, \"Argument\", \"The first argument must be a nonempty matrix.\");\n    \n    Check(Length(expectedFrequenciesList) >? 0, \"Argument\", \"The second argument must be a nonempty matrix.\");\n    \n    Check(Length(expectedFrequenciesList) =? Length(expectedFrequenciesList), \"Argument\", \"The matrices must be of equal length.\");\n\n    Local( numerator, chi2, pValue, categoriesCount, degreesOfFreedom, resultList);\n   \n    resultList := {};\n\n    categoriesCount := Length(observedFrequenciesList);\n\n    numerator := (observedFrequenciesList - expectedFrequenciesList)^2; //threading\n\n    chi2 := Sum(i,1,categoriesCount,numerator[i]/(expectedFrequenciesList[i]));\n\n    degreesOfFreedom := (Dimensions(observedFrequenciesMatrix)[1] - 1)*(Dimensions(observedFrequenciesMatrix)[2] - 1);\n\n    pValue := 1-N(IncompleteGamma(degreesOfFreedom/2,chi2/2)/Gamma(degreesOfFreedom/2));\n\n    resultList[\"degreesOfFreedom\"] := degreesOfFreedom;\n    \n    resultList[\"pValue\"] := pValue;\n   \n    resultList[\"chiSquareScore\"] := chi2;\n    \n    N(resultList);\n];\n\n\n\n\n20 # ChiSquareTest( observedFrequenciesList_IsList, expectedFrequenciesList_IsList) <--\n[\n    Check(Length(observedFrequenciesList) >? 0, \"Argument\", \"The first argument must be a nonempty list.\");\n    \n    Check(Length(expectedFrequenciesList) >? 0, \"Argument\", \"The second argument must be a nonempty list.\");\n    \n    Check(Length(expectedFrequenciesList) =? Length(expectedFrequenciesList), \"Argument\", \"The lists must be of equal length.\");\n\n    Local( numerator, chi2, pValue, categoriesCount, degreesOfFreedom, resultList);\n   \n    resultList := {};\n\n    categoriesCount := Length(observedFrequenciesList);\n\n    numerator := (observedFrequenciesList - expectedFrequenciesList)^2; //threading\n\n    chi2 := Sum(i,1,categoriesCount,numerator[i]/(expectedFrequenciesList[i]));\n\n    degreesOfFreedom := categoriesCount - 1;\n\n    pValue := 1-N(IncompleteGamma(degreesOfFreedom/2,chi2/2)/Gamma(degreesOfFreedom/2));\n\n    resultList[\"degreesOfFreedom\"] := degreesOfFreedom;\n    \n    resultList[\"pValue\"] := pValue;\n   \n    resultList[\"chiSquareScore\"] := chi2;\n    \n    N(resultList);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/hypothesystest/ChiSquareTest.mpw";
        scriptMap.put("ChiSquareTest",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* Finds the rengression of y onto x, that is\n   y == alpha + beta * x\n\n   Example usage:\n   x := 1 .. 5;\n   y := (2.34*x+2) +(2*Random()-1);\n   ans :=Regress(x,y);\n\n   To find the residuals, we do\n   (y-alpha-beta*x) /: ans\n */\n\n\nRegress(x,y) :=\n[\n Local(xy,x2,i,mx,my);\n\n mx := Mean(x);\n my := Mean(y);\n xy := Add((x-mx)*(y-my));\n x2 := Add((x-mx)^2);\n {alpha <- (my-xy*mx/x2) , beta <-  xy/x2};\n];\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/statistics/regression/Regress.mpw";
        scriptMap.put("Regress",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ExpressionDepth(expression_IsFunction) <--\n[\n  Local(result);\n  result:=0;\n  ForEach(item,Rest(FunctionToList(expression)))\n  [\n    Local(newresult);\n    newresult:=ExpressionDepth(item);\n    result:=Maximum(result,newresult);\n  ];\n  result+1;\n];\n20 # ExpressionDepth(_expression) <-- 1;\nUnFence(\"ExpressionDepth\",1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stats/ExpressionDepth.mpw";
        scriptMap.put("ExpressionDepth",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # ArcCos(x_IsNumber)_InNumericMode() <-- Internal'Pi()/2-ArcSin(x);\n\n /* TODO check! */\n200 # ArcCos(0) <-- Pi/2;\n200 # ArcCos(1/2) <-- Pi/3;\n200 # ArcCos(Sqrt(1/2)) <-- Pi/4;\n200 # ArcCos(Sqrt(3/4)) <-- Pi/6;\n200 # ArcCos(1) <-- 0;\n200 # ArcCos(_n)_(n =? -1) <-- Pi;\n200 # ArcCos(_n)_(-n =? Sqrt(3/4)) <-- 5/6*Pi;\n200 # ArcCos(_n)_(-n =? Sqrt(1/2)) <-- 3/4*Pi;\n200 # ArcCos(_n)_(-n =? 1/2) <-- 2/3*Pi;\n\n200 # ArcCos(Undefined) <-- Undefined;\n\nArcCos(xlist_IsList) <-- MapSingle(\"ArcCos\",xlist);\n\n110 # ArcCos(Complex(_r,_i)) <--\n    (- I)*Ln(Complex(r,i) + (Complex(r,i)^2 - 1)^(1/2));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcCos.mpw";
        scriptMap.put("ArcCos",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ArcCosh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( Ln(x+Sqrt(x^2-1)) ));\n\n200 # ArcCosh(Infinity) <-- Infinity;\n200 # ArcCosh(-Infinity) <-- Infinity+I*Pi/2;\n200 # ArcCosh(Undefined) <-- Undefined;\n\nArcCosh(xlist_IsList) <-- MapSingle(\"ArcCosh\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcCosh.mpw";
        scriptMap.put("ArcCosh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # ArcSin(x_IsNumber)_(InNumericMode() And? Abs(x)<=?1) <-- ArcSinNum(x);\n/// complex ArcSin\n3 # ArcSin(x_IsNumber)_InNumericMode() <-- Sign(x)*(Pi/2+I*ArcCosh(x));\n\n110 # ArcSin(Complex(_r,_i)) <--\n    (- I) * Ln((I*Complex(r,i)) + ((1-(Complex(r,i)^2))^(1/2)));\n\n150 # ArcSin(- _x)_(Not? IsConstant(x))             <-- -ArcSin(x);\n160 # (ArcSin(x_IsConstant))_(IsNegativeNumber(N(Eval(x)))) <-- -ArcSin(-x);\n\n200 # ArcSin(0) <-- 0;\n200 # ArcSin(1/2) <-- Pi/6;\n200 # ArcSin(Sqrt(1/2)) <-- Pi/4;\n200 # ArcSin(Sqrt(3/4)) <-- Pi/3;\n200 # ArcSin(1) <-- Pi/2;\n200 # ArcSin(_n)_(n =? -1) <-- -Pi/2;\n200 # ArcSin(_n)_(-n =? Sqrt(3/4)) <-- -Pi/3;\n200 # ArcSin(_n)_(-n =? Sqrt(1/2)) <-- -Pi/4;\n200 # ArcSin(_n)_(-n =? 1/2) <-- -Pi/6;\n\nArcSin(xlist_IsList) <-- MapSingle(\"ArcSin\",xlist);\n\n200 # ArcSin(Undefined) <-- Undefined;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcSin.mpw";
        scriptMap.put("ArcSin",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ArcSinh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( Ln(x+Sqrt(x^2+1)) ));\n\n200 # ArcSinh(Infinity) <-- Infinity;\n200 # ArcSinh(-Infinity) <-- -Infinity;\n200 # ArcSinh(Undefined) <-- Undefined;\n\nArcSinh(xlist_IsList) <-- MapSingle(\"ArcSinh\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcSinh.mpw";
        scriptMap.put("ArcSinh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # (ArcTan(x_IsConstant))_(IsNegativeNumber(N(Eval(x))))   <-- -ArcTan(-x);\n\n//TODO fix! 4 # ArcTan(Tan(_x))           <-- x;\n4 # ArcTan(-Tan(_x))           <-- -ArcTan(Tan(x));\n110 # ArcTan(Complex(_r,_i)) <--\n     (- I*0.5)*Ln(Complex(1,Complex(r,i))/ Complex(1, - Complex(r,i)));\n\n150 # ArcTan(- _x)_(Not? IsConstant(x))             <-- -ArcTan(x);\n160 # (ArcTan(x_IsConstant))_(IsNegativeNumber(N(Eval(x)))) <-- -ArcTan(-x);\n\n200 # ArcTan(Sqrt(3)) <-- Pi/3;\n200 # ArcTan(-Sqrt(3)) <-- -Pi/3;\n200 # ArcTan(1) <-- Pi/4;\n200 # ArcTan(0) <-- 0;\n200 # ArcTan(_n)_(n =? -1) <-- -Pi/4;\n\n200 # ArcTan(Infinity) <-- Pi/2;\n200 # ArcTan(-Infinity) <-- -Pi/2;\n200 # ArcTan(Undefined) <-- Undefined;\n\nArcTan(xlist_IsList) <-- MapSingle(\"ArcTan\",xlist);\n\n2 # ArcTan(x_IsNumber)_InNumericMode() <-- ArcTanNum(x);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcTan.mpw";
        scriptMap.put("ArcTan",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # ArcTanh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( Ln((1+x)/(1-x))/2 ));\n\n200 # ArcTanh(Infinity) <-- Infinity+I*Pi/2;\n200 # ArcTanh(-Infinity) <-- -Infinity-I*Pi/2;        // this is a little silly b/c we don't support correct branch cuts yet\n200 # ArcTanh(Undefined) <-- Undefined;\n\nArcTanh(xlist_IsList) <-- MapSingle(\"ArcTanh\",xlist);\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/ArcTanh.mpw";
        scriptMap.put("ArcTanh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n1 # CosMap( _n )_(Not?(IsRationalOrNumber(n))) <-- ListToFunction({ToAtom(\"Cos\"),n*Pi});\n2 # CosMap( _n )_(n<?0) <-- CosMap(-n);\n2 # CosMap( _n )_(n>?2) <-- CosMap(Modulo(n,2));\n3 # CosMap( _n )_(n>?1) <-- CosMap(2-n);\n4 # CosMap( _n )_(n>?1/2) <-- -CosMap(1-n);\n\n5 # CosMap( 0 ) <-- 1;\n5 # CosMap( 1/6 ) <-- Sqrt(3)/2;\n5 # CosMap( 1/4 ) <-- Sqrt(2)/2;\n5 # CosMap( 1/3 ) <-- 1/2;\n5 # CosMap( 1/2 ) <-- 0;\n5 # CosMap( 2/5 ) <-- (Sqrt(5)-1)/4;\n\n10 # CosMap(_n) <-- ListToFunction({ToAtom(\"Cos\"),n*Pi});\n\n\n\n2 # Cos(x_IsNumber)_InNumericMode() <-- CosNum(x);\n4 # Cos(ArcCos(_x))           <-- x;\n4 # Cos(ArcSin(_x)) <-- Sqrt(1-x^2);\n4 # Cos(ArcTan(_x)) <-- 1/Sqrt(1+x^2);\n5 # Cos(- _x)_(Not? IsConstant(x))                 <-- Cos(x);\n6 # (Cos(x_IsConstant))_(IsNegativeNumber(N(Eval(x))))   <-- Cos(-x);\n// must prevent it from looping\n\n110 # Cos(Complex(_r,_i)) <--\n    (Exp(I*Complex(r,i)) + Exp(- I*Complex(r,i))) / (2) ;\n\n6 # Cos(x_IsInfinity) <-- Undefined;\n6 # Cos(Undefined) <-- Undefined;\n\n200 # Cos(v_CanBeUni(Pi))_(Not?(InNumericMode()) And? Degree(v,Pi) <? 2 And? Coef(v,Pi,0) =? 0) <--\n      CosMap(Coef(v,Pi,1));\n\n400 # Cos(x_IsRationalOrNumber) <--\n    [\n     Local(ll);\n     ll:= FloorN(N(Eval(x/Pi)));\n     If(IsEven(ll),x:=(x - Pi*ll),x:=(-x + Pi*(ll+1)));\n     ListToFunction({Cos,x});\n     ];\n\n400 # Cos(x_IsRationalOrNumber) <--\n    [\n     Local(ll);\n     ll:= FloorN(N(Eval(Abs(x)/Pi)));\n     If(IsEven(ll),x:=(Abs(x) - Pi*ll),x:=(-Abs(x) + Pi*(ll+1)));\n     ListToFunction({Cos,x});\n     ];\n\n100 # Cos(_x)*Tan(_x) <-- Sin(x);\n100 # Cos(_x)/Sin(_x) <-- (1/Tan(x));\n\nCos(xlist_IsList) <-- MapSingle(\"Cos\",xlist);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Cos.mpw";
        scriptMap.put("Cos",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5   # Cosh(- _x)        <-- Cosh(x);\n\n// this is never activated\n\n//100 # Cosh(I*_x)        <-- Cos(x);\n\n100 # Cosh(_x)*Sech(_x) <-- 1;\n\n200 # Cosh(0)                <-- 1;\n200 # Cosh(Infinity)        <-- Infinity;\n200 # Cosh(-Infinity)        <-- Infinity;\n200 # Cosh(ArcCosh(_x)) <-- x;\n200 # Cosh(ArcSinh(_x)) <-- Sqrt(1+x^2);\n200 # Cosh(ArcTanh(_x)) <-- 1/Sqrt(1-x^2);\n\n200 # Cosh(Undefined) <-- Undefined;\n\nCosh(xlist_IsList) <-- MapSingle(\"Cosh\",xlist);\n\n2 # Cosh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( (Exp(x)+Exp(-x))/2 ));\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Cosh.mpw";
        scriptMap.put("Cosh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # 1/Cot(_x) <-- Tan(x);\n\n100 # Cot(_x) <-- 1/Tan(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Cot.mpw";
        scriptMap.put("Cot",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # 1/Coth(_x)        <-- Tanh(x);\n\n100 # Coth(_x)                <-- 1/Tanh(x);\n\n100 # Coth(_x)*Sinh(_x) <-- Cosh(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Coth.mpw";
        scriptMap.put("Coth",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # 1/Csc(_x)                <-- Sin(x);\n\n100 # Csc(_x)                <-- 1/Sin(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Csc.mpw";
        scriptMap.put("Csc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # 1/Csch(_x)        <-- Sinh(x);\n\n100 # Csch(_x)                <-- 1/Sinh(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Csch.mpw";
        scriptMap.put("Csch",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # Exp(x_IsNumber)_InNumericMode() <-- ExpNum(x);\n4 # Exp(Ln(_x))           <-- x;\n110 # Exp(Complex(_r,_i)) <--  Exp(r)*(Cos(i) + I*Sin(i));\n200 # Exp(0) <-- 1;\n200 # Exp(-Infinity) <-- 0;\n200 # Exp(Infinity) <-- Infinity;\n200 # Exp(Undefined) <-- Undefined;\n\nExp(xlist_IsList) <-- MapSingle(\"Exp\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Exp.mpw";
        scriptMap.put("Exp",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # Ln(0)                    <-- -Infinity;\n2 # Ln(1)                    <-- 0;\n2 # Ln(Infinity)                    <-- Infinity;\n2 # Ln(Undefined)                   <-- Undefined;\n\n/* 2 # Ln(-Infinity)                    <-- 0; */\n2 # Ln(x_IsNegativeNumber)_InNumericMode() <-- Complex(Ln(-x), Pi);\n3 # Ln(x_IsNumber)_(InNumericMode() And? x>=?1) <-- Internal'LnNum(x);\n4 # Ln(Exp(_x))              <-- x;\n\n3 # Ln(Complex(_r,_i)) <-- Complex(Ln(Abs(Complex(r,i))), Arg(Complex(r,i)));\n4 # Ln(x_IsNegativeNumber) <-- Complex(Ln(-x), Pi);\n5 # Ln(x_IsNumber)_(InNumericMode() And? x<?1) <-- - Internal'LnNum(DivideN(1, x));\n\nLn(xlist_IsList) <-- MapSingle(\"Ln\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Ln.mpw";
        scriptMap.put("Ln",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # 1/Sec(_x)                <-- Cos(x);\n100 # Sec(_x)                <-- 1/Cos(x);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Sec.mpw";
        scriptMap.put("Sec",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n100 # Sech(_x) <-- 1/Cosh(x);\n\n100 # 1/Sech(_x) <-- Cosh(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Sech.mpw";
        scriptMap.put("Sech",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n1 # SinMap( _n )_(Not?(IsRationalOrNumber(n))) <-- ListToFunction({ToAtom(\"Sin\"),n*Pi});\n2 # SinMap( _n )_(n<?0) <-- -SinMap(-n);\n2 # SinMap( _n )_(n>?2) <-- SinMap(Modulo(n,2));\n3 # SinMap( _n )_(n>?1) <-- SinMap(n-2);\n4 # SinMap( _n )_(n>?1/2) <-- SinMap(1-n);\n\n5 # SinMap( n_IsInteger ) <-- 0;\n5 # SinMap( 1/6 ) <-- 1/2;\n5 # SinMap( 1/4 ) <-- Sqrt(2)/2;\n5 # SinMap( 1/3 ) <-- Sqrt(3)/2;\n5 # SinMap( 1/2 ) <-- 1;\n5 # SinMap( 1/10) <-- (Sqrt(5)-1)/4;\n\n10 # SinMap(_n) <-- ListToFunction({ToAtom(\"Sin\"),n*Pi});\n\n\n\n\n2 # Sin(x_IsNumber)_InNumericMode() <-- SinNum(x);\n4 # Sin(ArcSin(_x))           <-- x;\n4 # Sin(ArcCos(_x)) <-- Sqrt(1-x^2);\n4 # Sin(ArcTan(_x)) <-- x/Sqrt(1+x^2);\n5 # Sin(- _x)_(Not? IsConstant(x))                 <-- -Sin(x);\n6 # (Sin(x_IsConstant))_(IsNegativeNumber(N(Eval(x))))   <-- -Sin(-x);\n\n// must prevent it from looping\n6 # Sin(x_IsInfinity)                 <-- Undefined;\n6 # Sin(Undefined) <-- Undefined;\n\n110 # Sin(Complex(_r,_i)) <--\n    (Exp(I*Complex(r,i)) - Exp(- I*Complex(r,i))) / (I*2) ;\n\n200 # Sin(v_CanBeUni(Pi))_(Not?(InNumericMode()) And? Degree(v,Pi) <? 2 And? Coef(v,Pi,0) =? 0) <--\n[\n  SinMap(Coef(v,Pi,1));\n];\n\n100 # Sin(_x)/Tan(_x) <-- Cos(x);\n100 # Sin(_x)/Cos(_x) <-- Tan(x);\n\nSin(xlist_IsList) <-- MapSingle(\"Sin\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Sin.mpw";
        scriptMap.put("Sin",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # Sinh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( (Exp(x)-Exp(-x))/2 ));\n5   # Sinh(- _x)        <-- -Sinh(x);\n\n5   # Sinh(- _x)        <-- -Sinh(x);\n\n100 # Sinh(_x)^2-Cosh(_x)^2         <-- 1;\n100 # Sinh(_x)+Cosh(_x)                <-- Exp(x);\n100 # Sinh(_x)-Cosh(_x)                <-- Exp(-x);\n\n//100 # Sinh(I*_x)        <-- I*Sin(x);\n\n100 # Sinh(_x)/Cosh(_x) <-- Tanh(x);\n100 # Sinh(_x)*Csch(_x) <-- 1;\n\n200 # Sinh(0)                <-- 0;\n200 # Sinh(Infinity)        <-- Infinity;\n200 # Sinh(-Infinity)        <-- -Infinity;\n200 # Sinh(ArcSinh(_x)) <-- x;\n200 # Sinh(ArcCosh(_x)) <-- Sqrt((x-1)/(x+1))*(x+1);\n200 # Sinh(ArcTanh(_x)) <-- x/Sqrt(1-x^2);\n\n200 # Sinh(Undefined) <-- Undefined;\n\n/* Threading of standard analytic functions */\nSinh(xlist_IsList) <-- MapSingle(\"Sinh\",xlist);\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Sinh.mpw";
        scriptMap.put("Sinh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n1 # TanMap( _n )_(Not?(IsRationalOrNumber(n))) <-- ListToFunction({ToAtom(\"Tan\"),n*Pi});\n2 # TanMap( _n )_(n<?0) <-- -TanMap(-n);\n2 # TanMap( _n )_(n>?1) <-- TanMap(Modulo(n,1));\n4 # TanMap( _n )_(n>?1/2) <-- -TanMap(1-n);\n\n5 # TanMap( 0 ) <-- 0;\n5 # TanMap( 1/6 ) <-- 1/3*Sqrt(3);\n5 # TanMap( 1/4 ) <-- 1;\n5 # TanMap( 1/3 ) <-- Sqrt(3);\n5 # TanMap( 1/2 ) <-- Infinity;\n\n10 # TanMap(_n) <-- ListToFunction({ToAtom(\"Tan\"),n*Pi});\n\n\n\n\n2 # Tan(x_IsNumber)_InNumericMode() <-- TanNum(x);\n4 # Tan(ArcTan(_x))           <-- x;\n4 # Tan(ArcSin(_x)) <-- x/Sqrt(1-x^2);\n4 # Tan(ArcCos(_x)) <-- Sqrt(1-x^2)/x;\n5 # Tan(- _x)_(Not? IsConstant(x))                  <-- -Tan(x);\n6 # (Tan(x_IsConstant))_(IsNegativeNumber(N(Eval(x))))   <-- -Tan(-x);\n\n// must prevent it from looping\n6 # Tan(Infinity) <-- Undefined;\n6 # Tan(Undefined) <-- Undefined;\n\n110 # Tan(Complex(_r,_i)) <-- Sin(Complex(r,i))/Cos(Complex(r,i));\n\n200 # Tan(v_CanBeUni(Pi))_(Not?(InNumericMode()) And? Degree(v,Pi) <? 2 And? Coef(v,Pi,0) =? 0) <--\n      TanMap(Coef(v,Pi,1));\n\n100 # Tan(_x)/Sin(_x) <-- (1/Cos(x));\n100 # Tan(_x)*Cos(_x) <-- Sin(x);\n\nTan(xlist_IsList) <-- MapSingle(\"Tan\",xlist);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Tan.mpw";
        scriptMap.put("Tan",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n2 # Tanh(_x)_(InNumericMode() And? (IsNumber(x) Or? Type(x) =? \"Complex\")) <-- N(Eval( Sinh(x)/Cosh(x) ));\n\n100 # Tanh(_x)*Cosh(_x) <-- Sinh(x);\n\n200 # Tanh(0)           <-- 0;\n200 # Tanh(Infinity)    <-- 1;\n200 # Tanh(-Infinity)   <-- -1;\n200 # Tanh(ArcTanh(_x)) <-- x;\n200 # Tanh(ArcSinh(_x)) <-- x/Sqrt(1+x^2);\n200 # Tanh(ArcCosh(_x)) <-- Sqrt((x-1)/(x+1))*(x+1)/x;\n\n200 # Tanh(Undefined) <-- Undefined;\n\n/* Threading of standard analytic functions */\nTanh(xlist_IsList) <-- MapSingle(\"Tanh\",xlist);\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/Tanh.mpw";
        scriptMap.put("Tanh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nArcCosN(x) :=\n[\n    FastArcCos(x);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ArcCosN.mpw";
        scriptMap.put("ArcCosN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\nDefun(\"ArcSinN\",{int1})\n[\n  Local(result,eps);\n        Bind(result,FastArcSin(int1));\n  Local(x,q,s,c);\n  Bind(q,SubtractN(SinN(result),int1));\n  Bind(eps,MathIntPower(10,MathNegate(BuiltinPrecisionGet())));\n  While(IsGreaterThan(AbsN(q),eps))\n  [\n        Bind(s,SubtractN(int1,SinN(result)));\n    Bind(c,CosN(result));\n    Bind(q,DivideN(s,c));\n    Bind(result,AddN(result,q));\n  ];\n  result;\n];\n\n/*\nArcSinN(x) :=\n[\n    FastArcSin(x);\n];*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ArcSinN.mpw";
        scriptMap.put("ArcSinN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// ArcTan(x), Taylor series for ArcTan(x)/x, use only with -1/2<x<1/2\nArcTanN'Taylor(x) :=\n[\n        Local(num'terms);\n        num'terms := QuotientN(BuiltinPrecisionGet()*1068, -643*MathBitCount(x))+1;\n        // (P*Ln(10))/(-2*Ln(x)); use Ln(x)<=?B(x)*Ln(2), only good for |x|<1/2\n        // here -Ln(x) must be positive\n        x*SumTaylorNum(-MultiplyN(x,x), {{k}, 1/(2*k+1)}, num'terms);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ArcTanN'Taylor.mpw";
        scriptMap.put("ArcTanN'Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nArcTanN(x) :=\n[\n    FastArcTan(x);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ArcTanN.mpw";
        scriptMap.put("ArcTanN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n//{BisectSqrt(N)} computes the integer part of $ Sqrt(N) $ for integer $N$.\n// BisectSqrt() works only on integers\n        //sqrt(1) = 1, sqrt(0) = 0\n10 # BisectSqrt(0) <-- 0;\n10 # BisectSqrt(1) <-- 1;\n\n20 # BisectSqrt(N_IsPositiveInteger) <--\n[\n  Local(l2,u,v,u2,v2,uv2,n);\n\n  // Find highest set bit, l2\n  u  := N;\n  l2 := MathBitCount(u)-1;\n\n  // 1<<(l2/2) now would be a good under estimate\n  // for the square root. 1<<(l2/2) is definitely\n  // set in the result. Also it is the highest\n  // set bit.\n  l2 := l2>>1;\n\n  // initialize u and u2 (u2==u^2).\n  u  := 1 << l2;\n  u2 := u << l2;\n\n  // Now for each lower bit:\n  While( l2 !=? 0 )\n  [\n          l2--;\n     // Get that bit in v, and v2 == v^2.\n      v  := 1<<l2;\n      v2 := v<<l2;\n\n      // uv2 == 2*u*v, where 2==1<<1, and\n      // v==1<<l2, thus 2*u*v ==\n      // (1<<1)*u*(1<<l2) == u<<(l2+1)\n      uv2 := u<<(l2 + 1);\n\n      // n = (u+v)^2  = u^2 + 2*u*v + v^2\n      //   = u2+uv2+v2\n       n := u2 + uv2 + v2;\n\n      // if n (possible new best estimate for\n      // sqrt(N)^2 is smaller than N, then the\n      // bit l2 is set in the result, and\n      // add v to u.\n      if( n <=? N )\n      [\n        u  := u+v;  // u <- u+v\n        u2 := n;    // u^2 <- u^2 + 2*u*v + v^2\n      ];\n    ];\n    u; // return result, accumulated in u.\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/BisectSqrt.mpw";
        scriptMap.put("BisectSqrt",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// BitsToDigits(n,base) and DigitsToBits(n,base). Enough to compute at low precision.\n// this is now a call to the kernel functions, so leave as a reference implementation\nBitsToDigits(n, base) := FloorN(0.51+n*N(Ln(2)/Ln(base),10));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/BitsToDigits.mpw";
        scriptMap.put("BitsToDigits",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Identity transformation, compute 1-Cos(x) from value=1-Cos(x/2^n)\n\n//Changed CosN'Doubling1 to CosN'Doubling. Note:tk.\nCosN'Doubling(value, n) :=\n[\n        Local(shift, result);\n        shift := n;\n        result := value;\n        While (shift>?0)        // lose 'shift' bits of precision here\n        [\n                result := MultiplyN(MathMul2Exp(result, 1), 2 - result);\n                shift--;\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/CosN'Doubling.mpw";
        scriptMap.put("CosN'Doubling",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Cos(x), Taylor series\nCosN'Taylor(x) :=\n[\n        Local(num'terms, prec, Bx);\n        prec := QuotientN(BuiltinPrecisionGet()*3919, 1702); // P*Ln(10)\n        Bx := -QuotientN(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2\n        num'terms := QuotientN( QuotientN( prec-1, QuotientN( MathBitCount( prec-1)*1588, 2291)+Bx), 2)+1;\n        // (P*Ln(10)-1)/(Ln(P*Ln(10)-1)-Ln(x)-2); use Ln(x)<=?B(x)*Ln(2)\n        SumTaylorNum(MultiplyN(x,x), 1, {{k}, -1/(2*k*(2*k-1))}, num'terms);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/CosN'Taylor.mpw";
        scriptMap.put("CosN'Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// BitsToDigits(n,base) and DigitsToBits(n,base). Enough to compute at low precision.\n// this is now a call to the kernel functions, so leave as a reference implementation\nDigitsToBits(n, base) := FloorN(0.51+n*N(Ln(base)/Ln(2),10));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/DigitsToBits.mpw";
        scriptMap.put("DigitsToBits",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Identity transformation, compute Exp(x)-1 from value=Exp(x/2^n)-1\n\nExpN'Doubling1(value, n) :=\n[\n        Local(shift, result);\n        shift := n;\n        result := value;\n        While (shift>?0)        // lose 'shift' bits of precision here\n        [\n                result := MathMul2Exp(result, 1) + MultiplyN(result, result);\n                shift--;\n        ];\n        result;\n];\n\n/// Identity transformation, compute Exp(x) from value=Exp(x/2^n)\n/*\nExpN'Doubling(value, n) :=\n[\n        Local(shift, result);\n        shift := n;\n        result := value;\n        While (shift>?0)        // lose 'shift' bits of precision here\n        [\n                result := MultiplyN(result, result);\n                shift--;\n        ];\n        result;\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ExpN'Doubling.mpw";
        scriptMap.put("ExpN'Doubling",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Compute Exp(x)-1 from the Taylor series for (Exp(x)-1)/x.\n//Note:tk:changed name from ExpN'Taylor1 to ExpN'Taylor.\nExpN'Taylor(x) :=\n[\n        Local(num'terms, prec, Bx);\n        prec := QuotientN(BuiltinPrecisionGet()*3919, 1702); // P*Ln(10)\n        Bx := -QuotientN(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2\n        num'terms := QuotientN( prec-1, QuotientN( MathBitCount( prec-1)*1588, 2291)+Bx)+1;\n        // (P*Ln(10)-1)/(Ln(P*Ln(10)-1)-Ln(x)-2); use Ln(x)<=?B(x)*Ln(2)\n        x*SumTaylorNum(x, 1, {{k}, 1/(k+1)}, num'terms);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/ExpN'Taylor.mpw";
        scriptMap.put("ExpN'Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n///  MathBitCount: count number of bits in an integer or a float number.\n/*  MathBitCount is now implemented through BigNumber::BitCount() */\n/*  so this stays here as a reference implementation */\n10 # MathBitCount(0) <-- 1;\n20 # MathBitCount(_x) _ (x<?0) <-- MathBitCount(-x);\n\n30 # MathBitCount(_value) <--\n[\n        Local(nbits);\n        nbits:=0;\n          If(value<?1,\n        [        // float value <? 1, need to multiply by 2\n                nbits := 1;\n                While(value<?1)\n                [\n                        nbits--;\n                        value := MathMul2Exp(value,1);\n                ];\n        ],\n        [        // need to divide by 2\n                While(value>=?1)\n                [\n                        nbits++;\n                        value := MathMul2Exp(value, -1);\n                ];\n        ]);\n        nbits;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/MathBitCount.mpw";
        scriptMap.put("MathBitCount",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Compute Ln(x) from Ln(x^(2^(1/n)))\nMathLn'Doubling(value, n) :=\n[\n        Local(shift, result);\n        shift := n;\n        result := value;\n        While (shift>?0)        // lose 'shift' bits of precision here\n        [\n                result := MultiplyN(result, result);\n                shift--;\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/MathLn'Doubling.mpw";
        scriptMap.put("MathLn'Doubling",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Ln(x), Taylor series for Ln(1+y)/y, use only with 1/2<x<3/2\nMathLn'Taylor(x) :=\n[\n        Local(num'terms, y);\n        y := x-1;\n        num'terms := QuotientN(BuiltinPrecisionGet()*2136, -643*MathBitCount(y))+1;\n        // (P*Ln(10))/(-Ln(y)); use Ln(y)<=?B(y)*Ln(2), only good for |y|<1/2\n        // here -Ln(y) must be positive\n        y*SumTaylorNum(-y, {{k}, 1/(k+1)}, num'terms);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/MathLn'Taylor.mpw";
        scriptMap.put("MathLn'Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n// This function is *only* for float and positive A!\n// The answer is only obtained at the current precision.\nMathSqrtFloat(_A) <--\n[\n        Local(bitshift, a0, x0, x0sq, targetbits, subtargetbits, gotbits, targetprec);\n        bitshift := ShiftRight(MathBitCount(A)-1,1);\n        // this is how many bits of precision we need\n        targetprec := BuiltinPrecisionGet();\n        // argument reduction: a0 is between 1 and 4 and has the full target precision\n        a0 := MathMul2Exp(A, -bitshift*2);        // this bit shift would be wrong for integer A\n        BuiltinPrecisionSet(10);        // enough to compute at this point\n        // cannot get more target bits than 1 + (the bits in A)\n        // if this is less than the requested precision, the result will be silently less precise, but c'est la vie\n        targetbits := Minimum(DigitsToBits(targetprec, 10), 1+GetExactBitsN(A));\n        // initial approximation\n        x0 := DivideN(14+22*a0, 31+5*a0);\n        // this approximation gives at least 7 bits (relative error < 0.005) of Sqrt(a0) for 1 <= a0 <= 4\n        gotbits := 7;\n        // find the conditions for the last 2 iterations to be done in almost optimal precision\n        subtargetbits := QuotientN(targetbits+8, 9);\n        If(gotbits >=? subtargetbits, subtargetbits := QuotientN(targetbits+2, 3));\n        If(gotbits >=? subtargetbits, subtargetbits := targetbits*4);\n//        Echo(\"debug: subtargetbits=\", subtargetbits, \"a0=\", a0, \"targetbits=\", targetbits, \"bitshift=\", bitshift, \"targetprec=\", targetprec);\n        // now perform Halley iterations until we get at least subtargetbits, then start with subtargetbits and perform further Halley iterations\n        While(gotbits <? targetbits)\n        [\n                gotbits := 3*gotbits+1;        // Halley iteration; get 3n+2 bits, allow 1 bit for roundoff\n                // check for suboptimal last iterations\n                If(gotbits >=? subtargetbits,\n                [        // it could be very suboptimal to continue with our value of gotbits, so we curb precision for the last 2 iterations which dominate the calculation time at high precision\n                        gotbits := subtargetbits;\n                        subtargetbits := targetbits*4;        // make sure that the above condition never becomes true again\n                ]);\n                BuiltinPrecisionSet(BitsToDigits(gotbits, 10)+2);        // guard digits\n                x0 := SetExactBitsN(x0, gotbits+6);        // avoid roundoff\n                x0sq := MultiplyN(x0, x0);\n// this gives too much roundoff error                x0 := MultiplyN(x0, DivideN(3*a0+x0sq, a0+3*x0sq));\n// rather use this equivalent formula:\n                x0 := AddN(x0, MultiplyN(x0*2, DivideN(a0-x0sq, a0+3*x0sq)));\n//                Echo(\"debug: \", gotbits, x0, GetExactBitsN(x0), BuiltinPrecisionGet());\n        ];\n        // avoid truncating a precise result in x0 by calling BuiltinPrecisionSet() too soon\n        x0 := SetExactBitsN(MathMul2Exp(x0, bitshift), gotbits);\n        BuiltinPrecisionSet(targetprec);\n//        Echo(\"debug: answer=\", x0);\n        x0;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/MathSqrtFloat.mpw";
        scriptMap.put("MathSqrtFloat",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Compute Sin(x), Taylor series for Sin(x)/x\nSinN'Taylor(x) :=\n[\n        Local(num'terms, prec, Bx);\n        prec := QuotientN(BuiltinPrecisionGet()*3919, 1702); // P*Ln(10)\n        Bx := -QuotientN(MathBitCount(x)*1143, 1649)-2; // -Ln(x)-2\n        num'terms := QuotientN( QuotientN( prec+Bx, QuotientN( MathBitCount( prec+Bx)*1588, 2291)+Bx)+1, 2)+1;\n        // (P*Ln(10)-Ln(x)-2)/(Ln(P*Ln(10)-Ln(x)-2)-Ln(x)-2); use Ln(x)<=?B(x)*Ln(2)\n        x*SumTaylorNum(MultiplyN(x,x), 1, {{k}, -1/(2*k*(2*k+1))}, num'terms);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/SinN'Taylor.mpw";
        scriptMap.put("SinN'Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// Identity transformation, compute Sin(x) from value=Sin(x/3^n)\n\nSinN'Tripling(value, n) :=\n[\n        Local(shift, result);\n        shift := n;\n        result := value;\n        While (shift>?0)        // lose 'shift' bits of precision here\n        [        // Sin(x)*(3-4*Sin(x)^2)\n                result := MultiplyN(result, 3 - MathMul2Exp(MultiplyN(result,result), 2) );\n                shift--;\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/SinN'Tripling.mpw";
        scriptMap.put("SinN'Tripling",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** This file contains routines for numerical evaluation of elementary functions:\n *  PowerN, ExpN, SinN etc.\n *  It is assumed that the arguments are real (not complex) floating-point or integer numbers. (The {InNumericMode()} flag does not have to be set.)\n *  The result is an exact integer or a floating-point number correct to BuiltinPrecisionGet() digits.\n *\n *  If a better optimized version of these functions is available through the kernel,\n *  then the kernel version will automatically shadow these functions.\n *  These implementations are not necessarily the best optimized versions.\n */\n\n/// SqrtN(x).\nSqrtN(x) := MathSqrt1(x);        // to have another function is easier for debugging\n\n/// Compute square root(x) with nonnegative x. FIXME: No precision tracking yet.\n10 # MathSqrt1(0) <-- 0;\n/// negative or non-numeric arguments give error message\n100 # MathSqrt1(_x) <-- [ Echo(\"SqrtN: invalid argument: \", x); False;];\n\n// this is too slow at the moment\n30 # MathSqrt1(x_IsPositiveNumber) <-- x*NewtonNum({{r}, r+r*(1-x*r^2)/2}, FastPower(x,-0.5), 4, 2);\n\n30 # MathSqrt1(x_IsPositiveNumber) <-- MathSqrtFloat(x);\n\n// for integers, we need to compute Sqrt(x) to (the number of bits in x) + 1 bits to figure out whether Sqrt(x) is itself an integer. If Sqrt(x) for integer x is exactly equal to an integer, we should return the integer answer rather than the float answer. For this answer, the current precision might be insufficient, therefore we compute with potentially more digits. This is slower but we assume this is what the user wants when calling SqrtN() on an integer.\n20 # MathSqrt1(x_IsInteger) _ (IsGreaterThan(x,0)) <--\n[\n        Local(result);\n        If(ModuloN(x,4)<?2 And? ModuloN(x,3)<?2 And? ModuloN(x+1,5)<?3,\n                // now the number x has a nonzero chance of being an exact square\n                [\n                        // check whether increased precision would be at all necessary\n//                        Echo(\"checking integer case\");\n                        GlobalPush(BuiltinPrecisionGet());\n                        If(MathBitCount(x)+3>?DigitsToBits(BuiltinPrecisionGet(), 10),\n                          BuiltinPrecisionSet(BitsToDigits(MathBitCount(x), 10)+1));\n                                // need one more digit to decide whether Sqrt(x) is integer\n                        // otherwise the current precision is sufficient\n\n                        // convert x to float and use the float routine\n                        result := MathSqrtFloat(x+0.);\n                        // decide whether result is integer: decrease precision and compare\n                        If(FloatIsInt(SetExactBitsN(result, GetExactBitsN(result)-3)), result:= Floor(result+0.5));\n                        BuiltinPrecisionSet(GlobalPop());\n                ],\n                // now the number x cannot be an exact square; current precision is sufficient\n                result := MathSqrtFloat(x+0.)\n        );\n        // need to set the correct precision on the result - will have no effect on integer answers\n        SetExactBitsN(result, DigitsToBits(BuiltinPrecisionGet(),10));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/elemfuncs/SqrtN.mpw";
        scriptMap.put("SqrtN",scriptString);
        scriptMap.put("MathSqrt1",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\nArcSinNum(x) :=\n[\n        // need to be careful when |x| close to 1\n        If(\n                239*Abs(x) >=? 169,        // 169/239 is a good enough approximation of 1/Sqrt(2)\n                // use trigonometric identity to avoid |x| close to 1\n                Sign(x)*(Internal'Pi()/2-ArcSinN(Sqrt(1-x^2))),\n                ArcSinN(x)\n        );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/ArcSinNum.mpw";
        scriptMap.put("ArcSinNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\nArcTanNum(x) :=\n[\n        // using trigonometric identities is faster for now\n        If(\n                Abs(x)>?1,\n                Sign(x)*(Internal'Pi()/2-ArcSin(1/Sqrt(x^2+1))),\n                ArcSin(x/Sqrt(x^2+1))\n        );\n];\n\n\n\n\n\n/* old methods -- slower for now\n/// numerical evaluation of ArcTan using continued fractions: top level\n2 # ArcTan(x_IsNumber)_InNumericMode() <--\nSign(x) *\n// now we need to compute ArcTan of a nonnegative number Abs(x)\n[\n        Local(nterms, y);\n        y := Abs(x);\n        // use identities to improve convergence -- see essays book\n        If(\n                y>?1,\n                y:=1/y        // now y <=? 1\n        // we shall know that the first identity was used because Abs(x) > 1 still\n        );\n        // use the second identity\n        y := y/(1+Sqrt(1+y^2));        // now y <=? Sqrt(2)-1\n        // find the required number of terms in the continued fraction\n        nterms := 1/y;        // this needs to be calculated at full precision\n        // see essays book on the choice of the number of terms (added 2 \"guard terms\").\n        // we need Hold() because otherwise, if InNumericMode() returns True, N(..., 5) will not avoid the full precision calculation of Ln().\n        // the value of x should not be greater than 1 here!\n        nterms := 2 + Ceil( N(Hold(Ln(10)/(Ln(4)+2*Ln(nterms))), 5) * BuiltinPrecisionGet() );\n        If(        // call the actual routine\n                Abs(x)>?1,\n                Pi/2-2*MyArcTan(y, nterms),        // this is for |x|>1\n                2*MyArcTan(y, nterms)\n                // MyArcTan(x, nterms)\n        );\n];\n*/\n\n\n\n/// numerical evaluation of ArcTan using continued fractions: low level\n\n// evaluation using recursion -- slightly faster but lose some digits to roundoff errors and needs large recursion depth\n/*\n10 # ContArcTan(_x,_n,_n) <-- (2*n-1);\n20 # ContArcTan(_x,_n,_m) <--\n[\n  (2*n-1) + (n*x)^2/ContArcTan(x,n+1,m);\n];\n\nMyArcTan(x,n) :=\n[\n  x/ContArcTan(x,1,n);\n];\n*/\n/*\n/// evaluate n terms of the continued fraction for ArcTan(x) without recursion.\n/// better control of roundoff errors\nMyArcTan(x, n) :=\n[\n        Local(i, p, q, t);\n        // initial numerator and denominator\n        p:=1;\n        q:=1;\n        // start evaluating from the last term upwards\n        For(i:=n, i>=?1, i--)\n        [\n                //{p,q} := {p + q*(i*x)^2/(4*i^2-1), p};\n        //        t := p*(2*i-1) + q*(i*x)^2; then have to start with p:=2*n+1\n                t := p + q*(i*x)^2/(4*i^2-1);\n                q := p;\n                p := t;\n        ];\n        // answer is x/(p/q)\n        x*q/p;\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/ArcTanNum.mpw";
        scriptMap.put("ArcTanNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n/* The BrentLn() algorithm is currently slower in internal math but should be asymptotically faster. */\n\nLocalSymbols(BrentCacheOfConstantsN)\n[\n    CachedConstant(BrentCacheOfConstantsN, Ln2, Internal'LnNum(2));        // this is only useful for BrentLn\n];\n\n// compute Ln(x_IsInteger) using the AGM sequence. See: Brent paper rpb028 (1975).\n// this is currently faster than LogN(n) for precision > 40 digits\n10 # BrentLn(x_IsInteger)_(BuiltinPrecisionGet()>?40) <--\n[\n        Local(y, n, k, eps);\n        n := BuiltinPrecisionGet();        // decimal digits\n        // initial power of x\n        k := 1 + Quotient(IntLog(4*10^n, x), 2);        // now x^(2*k)>4*10^n\n        BuiltinPrecisionSet(n+5);        // guard digits\n        eps := DivideN(1, 10^n);        // precision\n        y := PowerN(x, k);        // not yet divided by 4\n        // this is Brent's AGM times y. This way we work around the MathPiper limitation of fixed precision, at cost of slightly slower initial iterations\n        y := DivideN(Internal'Pi()*y, (2*k)*ArithmeticGeometricMean(4, y, eps));\n        BuiltinPrecisionSet(n);\n        RoundTo(y, n);        // do not return a more precise number than we really have\n];\n\n15 # BrentLn(x_IsInteger)  <-- LogN(x);\n\n/// calculation of Ln(x) using Brent's AGM sequence - use precomputed Pi and Ln2.\n20 # BrentLn(_x)_(x<?1) <-- -BrentLn(1/x);\n\n// this is currently faster than LogN() for precision > 85 digits and numbers >2\n30 # BrentLn(_x)_(BuiltinPrecisionGet()>?85) <--\n[\n        Local(y, n, n1, k, eps);\n  N([\n    n := BuiltinPrecisionGet();        // decimal digits\n    // effective precision is n+Ln(n)/Ln(10)\n    n1 := n + IntLog(n,10);        // Ln(2) < 7050/10171\n    // initial power of 2\n    k := 2 + Quotient(n1*28738, 2*8651)        // Ln(10)/Ln(2) < 28738/8651; now 2^(2*k)>4*10^n1\n    // find how many binary digits we already have in x, and multiply by a sufficiently large power of 2 so that y=x*2^k is larger than 2*10^(n1/2)\n    - IntLog(Floor(x), 2);\n    // now we need k*Ln(2)/Ln(10) additional digits to compensate for cancellation at the final subtraction\n    BuiltinPrecisionSet(n1+2+Quotient(k*3361, 11165));        // Ln(2)/Ln(10) < 3361/11165\n    eps := DivideN(1, 10^(n1+1));        // precision\n    y := x*2^(k-2);        // divided already by 4\n    // initial values for AGM\n    // this is Brent's AGM times y. This way we work around the MathPiper limitation of fixed precision, at cost of slightly slower initial iterations\n    y:=Internal'Pi()*y/(2*ArithmeticGeometricMean(1,y,eps)) - k*Ln2();\n    BuiltinPrecisionSet(n);\n  ]);\n        y;        // do not return a more precise number than we really have\n];\n\n40 # BrentLn(x_IsNumber) <-- LogN(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/BrentLn.mpw";
        scriptMap.put("BrentLn",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\nCosNum(x) :=\n[\n  If(x<?0 Or? 113*x>?710, x:=TruncRadian(x));\n  CosN(x);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/CosNum.mpw";
        scriptMap.put("CosNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n// large positive x\n10 # ExpNum(x_IsNumber) _ (x >? MathExpThreshold()) <-- [\n        Local(i, y);\n        i:=0;\n        For(i:=0, x >? MathExpThreshold(), i++)\n                x := DivideN(x, 2.);\n        For(y:= ExpN(x), i>?0, i--)\n                y := MultiplyN(y, y);\n        y;\n\n];\n// large negative x\n20 # ExpNum(x_IsNumber) _ (2*x <? -MathExpThreshold()) <-- DivideN(1, ExpNum(-x));\n// other values of x\n30 # ExpNum(x_IsNumber) <-- ExpN(x);\n\n\n//CachedConstant(Exp1, ExpN(1));        // Exp1 is useless so far\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/ExpNum.mpw";
        scriptMap.put("ExpNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n// natural logarithm: this should be called only for real x>1\n//Internal'LnNum(x) := LogN(x);\n// right now the fastest algorithm is Halley's method for Exp(x)=a\n// when internal math is fixed, we may want to use Brent's method (below)\n// this method is using a cubically convergent Newton iteration for Exp(x/2)-a*Exp(-x/2)=0:\n// x' := x - 2 * (Exp(x)-a) / (Exp(x)+a) = x-2+4*a/(Exp(x)+a)\nInternal'LnNum(x_IsNumber)_(x>=?1) <-- NewtonLn(x);\n\nInternal'LnNum(x_IsNumber)_(0<?x And? x<?1) <-- - Internal'LnNum(DivideN(1,x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/Internal'LnNum.mpw";
        scriptMap.put("Internal'LnNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n//  LogN in the original C++ code hangs! Scripted implementation is much better\nLogN(x) := Internal'LnNum(x);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/LogN.mpw";
        scriptMap.put("LogN",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\nNewtonLn(x) :=\n        LocalSymbols(y)\n[\n// we need ExpN instead of Exp to avoid N() which is used in the definition of Exp.\n// and we need ExpNum() instead of ExpN so that it is faster for large arguments and to avoid the error generated when core functions like ExpN are called on symbolic arguments.\n        NewtonNum({{y}, 4*x/(ExpNum(y)+x)-2+y},\n        // initial guess is obtained as Ln(x^2)/Ln(2) * (Ln(2)/2)\n                DivideN(794*IntLog(Floor(x*x), 2), 2291), 10, 3);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/NewtonLn.mpw";
        scriptMap.put("NewtonLn",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\nSinNum(x) :=\n[\n  If(x<?0 Or? 113*x>?710, x:=TruncRadian(x));        // 710/113 is close to 2*Pi\n  SinN(x);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/SinNum.mpw";
        scriptMap.put("SinNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "TanNum(x) :=\n[\n  If(x<?0 Or? 113*x>?710, x:=TruncRadian(x));\n  TanN(x);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/TanNum.mpw";
        scriptMap.put("TanNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n/* TruncRadian truncates the radian r so it is between 0 and 2*Pi.\n * It calculates r mod 2*Pi using the required precision.\n */\nTruncRadian(_r) <--\n[\n  Local(twopi);\n  // increase precision by the number of digits of r before decimal point; enough to evaluate Abs(r) with 1 digit of precision\n  N([\n    r:=Eval(r);\n    twopi:=2*Internal'Pi();\n    r:=r-FloorN(r/twopi)*twopi;\n  ], BuiltinPrecisionGet() + IntLog(Ceil(Abs(N(Eval(r), 1))), 10));\n  r;\n];\nHoldArgument(\"TruncRadian\",r);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/TruncRadian.mpw";
        scriptMap.put("TruncRadian",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\nMathExpThreshold\nSetMathExpThreshold\n*/\n\n/// low-level numerical calculations of elementary functions.\n/// These are only called if InNumericMode() returns True\n\n//////////////////////////////////////////////////\n/// Exponent\n//////////////////////////////////////////////////\n\nLocalSymbols(mathExpThreshold) [\n  // improve convergence of Exp(x) for large x\n  mathExpThreshold := If(Not? IsBound(mathExpThreshold), 500);\n\n  MathExpThreshold() := mathExpThreshold;\n  SetMathExpThreshold(threshold) := [mathExpThreshold:= threshold; ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/numerical/expthreshold.mpw";
        scriptMap.put("MathExpThreshold",scriptString);
        scriptMap.put("SetMathExpThreshold",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: AGM sequence\n//////////////////////////////////////////////////\n\n/// compute the AGM sequence up to a given precision\nArithmeticGeometricMean(a, b, eps) :=\n[\n    Check(IsPositiveReal(a) And? IsPositiveReal(b), \"Argument\", \"The first two arguments must be positive real numbers.\");\n    \n    Check(IsPositiveInteger(eps), \"Argument\", \"The precision argument must be a positive integer.\");\n    \n    a := N(a, eps);\n    \n    b := N(b, eps);\n    \n        Local(a1, b1);\n        \n        If(InVerboseMode(), Echo(\"ArithmeticGeometricMean: Info: at prec. \", BuiltinPrecisionGet()));\n        \n        // AGM main loop\n        While(Abs(a-b)>=?eps)\n        [\n                a1 := DivideN(a+b, 2);\n                b1 := SqrtN(MultiplyN(a, b));        // avoid Sqrt() which uses N() inside it\n                a := a1;\n                b := b1;\n        ];\n        \n        DivideN(a+b, 2);\n];\n//UnFence(ArithmeticGeometricMean, 3);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/ArithmeticGeometricMean.mpw";
        scriptMap.put("ArithmeticGeometricMean",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: integer powers by binary reduction\n//////////////////////////////////////////////////\n\n/// generalized integer Power function using the classic binary method.\n5 # IntPowerNum(_x, 0, _func, _unity) <-- unity;\n10 # IntPowerNum(_x, n_IsInteger, _func, _unity) <--\n[\n        // use binary method\n        Local(result);\n        // unity might be of non-scalar type, avoid assignment\n        While(n >? 0)\n        [\n                If(\n                        (n&1) =? 1,\n                        If(\n                                IsBound(result), // if result is already assigned\n                                result := Apply(func, {result,x}),\n                                result := x, // avoid multiplication\n                        )\n                );\n                x := Apply(func, {x,x});\n                n := n>>1;\n        ];\n        result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/IntPowerNum.mpw";
        scriptMap.put("IntPowerNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: multiply floats by rationals\n//////////////////////////////////////////////////\n\n/// aux function: optimized numerical multiplication. Use MultiplyN() and DivideN().\n/// optimization consists of multiplying or dividing by integers if one of the arguments is a rational number. This is presumably always better than floating-point calculations, except if we use Rationalize() on everything.\n/// note that currently this is not a big optimization b/c of slow arithmetic but it already helps for rational numbers under InNumericMode() returns True and it will help even more when faster math is done\n\nFunction() MultiplyNum(x, y, ...);\nFunction() MultiplyNum(x);\n\n10 # MultiplyNum(x_IsList)_(Length(x)>?1) <-- MultiplyNum(First(x), Rest(x));\n\n10 # MultiplyNum(x_IsRational, y_IsRationalOrNumber) <--\n[\n        If(\n        Type(y) =? \"/\",  // IsRational(y), changed by Nobbi before redefinition of IsRational\n                DivideN(Numerator(x)*Numerator(y), Denominator(x)*Denominator(y)),\n                // y is floating-point\n                // avoid multiplication or division by 1\n                If(\n                        Numerator(x)=?1,\n                        DivideN(y, Denominator(x)),\n                        If(\n                                Denominator(x)=?1,\n                                MultiplyN(y, Numerator(x)),\n                                DivideN(MultiplyN(y, Numerator(x)), Denominator(x))\n                        )\n                )\n        );\n];\n\n20 # MultiplyNum(x_IsNumber, y_IsRational) <-- MultiplyNum(y, x);\n\n25 # MultiplyNum(x_IsNumber, y_IsNumber) <-- MultiplyN(x,y);\n\n30 # MultiplyNum(Complex(r_IsNumber, i_IsNumber), y_IsRationalOrNumber) <-- Complex(MultiplyNum(r, y), MultiplyNum(i, y));\n\n35 # MultiplyNum(y_IsNumber, Complex(r_IsNumber, i_IsRationalOrNumber)) <-- MultiplyNum(Complex(r, i), y);\n\n40 # MultiplyNum(Complex(r1_IsNumber, i1_IsNumber), Complex(r2_IsNumber, i2_IsNumber)) <-- Complex(MultiplyNum(r1,r2)-MultiplyNum(i1,i2), MultiplyNum(r1,i2)+MultiplyNum(i1,r2));\n\n/// more than 2 operands\n30 # MultiplyNum(x_IsRationalOrNumber, y_IsNumericList)_(Length(y)>?1) <-- MultiplyNum(MultiplyNum(x, First(y)), Rest(y));\n40 # MultiplyNum(x_IsRationalOrNumber, y_IsNumericList)_(Length(y)=?1) <-- MultiplyNum(x, First(y));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/MultiplyNum.mpw";
        scriptMap.put("MultiplyNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: Newton-like superconvergent iteration\n//////////////////////////////////////////////////\n\n// Newton's method, generalized, with precision control and diagnostics\n\n/// auxiliary utility: compute the number of common decimal digits of x and y (using relative precision)\nCommon'digits(x,y) :=\n[\n        Local(diff);\n        diff := Abs(x-y);\n        If(\n                diff=?0,\n                Infinity,\n                // use approximation Ln(2)/Ln(10) >? 351/1166\n                Quotient(IntLog(FloorN(DivideN(Maximum(Abs(x), Abs(y)), diff)), 2)*351, 1166)\n        );         // this many decimal digits in common\n];\n\n///interface\nNewtonNum(_func, _x0) <-- NewtonNum(func, x0, 5);        // default prec0\nNewtonNum(_func, _x0, _prec0) <-- NewtonNum(func, x0, prec0, 2);\n\n// func is the function to iterate, i.e. x' = func(x).\n// prec0 is the initial precision necessary to get convergence started.\n// order is the order of convergence of the given sequence (e.g. 2 or 3).\n// x0 must be close enough so that x1 has a few common digits with x0 after at most 5 iterations.\nNewtonNum(_func, _x'init, _prec0, _order) <--\n[\n        Check(prec0>=?4, \"Argument\", \"NewtonNum: Error: initial precision must be at least 4\");\n        Check(IsInteger(order) And? order>?1, \"Argument\", \"NewtonNum: Error: convergence order must be an integer and at least 2\");\n        Local(x0, x1, prec, exact'digits, int'part, initial'tries);\n  N([\n    x0 := x'init;\n    prec := BuiltinPrecisionGet();\n    int'part := IntLog(Ceil(Abs(x0)), 10);        // how many extra digits for numbers like 100.2223\n    // int'part must be set to 0 if we have true floating-point semantics of BuiltinPrecisionSet()\n    BuiltinPrecisionSet(2+prec0-int'part);        // 2 guard digits\n    x1 := (func @ x0);        // let's run one more iteration by hand\n    // first, we get prec0 exact digits\n    exact'digits := 0;\n    initial'tries := 5;        // stop the loop the the initial value is not good\n    While(exact'digits*order <? prec0 And? initial'tries>?0)\n    [\n      initial'tries--;\n      x0 := x1;\n      x1 := (func @ x0);\n      exact'digits := Common'digits(x0, x1);\n  //                If(InVerboseMode(), Echo(\"NewtonNum: Info: got\", exact'digits, \"exact digits at prec. \", BuiltinPrecisionGet()));\n    ];\n    // need to check that the initial precision is achieved\n    If(\n      Assert(\"value\", {\"NewtonNum: Error: need a more accurate initial value than\", x'init})\n        exact'digits >=? 1,\n    [\n    exact'digits :=Minimum(exact'digits, prec0+2);\n    // run until get prec/order exact digits\n    int'part := IntLog(Ceil(Abs(x1)), 10);        // how many extra digits for numbers like 100.2223\n    While(exact'digits*order <=? prec)\n    [\n      exact'digits := exact'digits*order;\n      BuiltinPrecisionSet(2+Minimum(exact'digits, Quotient(prec,order)+1)-int'part);\n      x0 := x1;\n      x1 := (func @ x0);\n  //                If(InVerboseMode(), Echo(\"NewtonNum: Info: got\", Common'digits(x0, x1), \"exact digits at prec. \", BuiltinPrecisionGet()));\n    ];\n    // last iteration by hand\n    BuiltinPrecisionSet(2+prec);\n    x1 := RoundTo( (func @ x1), prec);\n    ],\n    // did not get a good initial value, so return what we were given\n    x1 := x'init\n    );\n    BuiltinPrecisionSet(prec);\n  ]);\n        x1;\n];\n\n\n/*\nexample: logarithm function using cubically convergent Newton iteration for\nExp(x/2)-a*Exp(-x/2)=0:\n\nx' := x - 2 * (Exp(x)-a) / (Exp(x)+a)\n\nLN(x_IsNumber)_(x>?1 ) <--\n        LocalSymbols(y)\n[\n// initial guess is obtained as Ln(x^2)/Ln(2) * (Ln(2)/2)\n        NewtonNum({{y},4*x/(Exp(y)+x)-2+y}, N(794/2291*IntLog(Floor(x*x),2),5), 10, 3);\n];\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/NewtonNum.mpw";
        scriptMap.put("NewtonNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: Taylor series, rectangular summation\n//////////////////////////////////////////////////\n\n/// Fast summation of Taylor series using a rectangular scheme.\n/// SumTaylorNum(x, nth'term'func, n'terms) = Sum(k, 0, n'terms, nth'term'func(k)*x^k)\n/// Note that sufficient precision must be preset to avoid roundoff errors (these methods do not modify precision).\n/// The only reason to try making these functions HoldArgument is to make sure that the closures nth'term'func and next'term'factor are passed intact. But it's probably not desired in most cases because a closure might contain parameters that should be evaluated.\n\n/// The short form is used when only the nth term is known but no simple relation between a term and the next term.\n/// The long form is used when there is a simple relation between consecutive terms. In that case, the n'th term function is not needed, only the 0th term value.\n\n/// SumTaylorNum0 is summing the terms with direct methods (Horner's scheme or simple summation). SumTaylorNum1 is for the rectangular method.\n\n/// nth'term'func and next'term'func must be functions applicable to one argument.\n\n/// interface\nSumTaylorNum0(_x, _nth'term'func, _n'terms) <-- SumTaylorNum0(x, nth'term'func, {}, n'terms);\n\nSumTaylorNum1(_x, _nth'term'func, _n'terms) <-- SumTaylorNum1(x, nth'term'func, {}, n'terms);\n\n/// interface\nSumTaylorNum(_x, _nth'term'func, _n'terms) <--\nIf(\n        n'terms >=? 30,        // threshold for calculation with next'term'factor\n        // use the rectangular algorithm for large enough number of terms\n        SumTaylorNum1(x, nth'term'func, n'terms),\n        SumTaylorNum0(x, nth'term'func, n'terms)\n);\n\nSumTaylorNum(_x, _nth'term'func, _next'term'factor, _n'terms) <--\nIf(\n        n'terms >=? 5,        // threshold for calculation with next'term'factor\n        SumTaylorNum1(x, nth'term'func, next'term'factor, n'terms),\n        SumTaylorNum0(x, nth'term'func, next'term'factor, n'terms)\n);\n//HoldArgumentNumber(SumTaylorNum, 3, 2);\n\n/// straightforward algorithms for a small number of terms\n1# SumTaylorNum0(_x, _nth'term'func, {}, _n'terms) <--\n[\n        Local(sum, k);\n  N([\n    // use Horner scheme starting from the last term\n    x:=Eval(x);\n    sum := 0;\n    For(k:=n'terms, k>=?0, k--)\n      sum := AddN(sum*x, nth'term'func @ k);\n  ]);\n        sum;\n];\n\n//HoldArgumentNumber(SumTaylorNum0, 3, 2);\n\n2# SumTaylorNum0(_x, _nth'term'func, _next'term'factor, _n'terms) <--\n[\n        Local(sum, k, term, delta);\n  N([\n    x:=Eval(x);        // x must be floating-point\n    If (IsConstant(nth'term'func),\n      term := nth'term'func,\n      term := (nth'term'func @ {0}),\n    );\n    sum := term;        // sum must be floating-point\n  ]);\n  NonN([\n    delta := 1;\n    For(k:=1, k<=?n'terms And? delta !=? 0, k++)\n    [\n      term := MultiplyNum(term, next'term'factor @ {k}, x);        // want to keep exact fractions here, but the result is floating-point\n      delta := sum;\n      sum := sum + term;        // term must be floating-point\n      delta := Abs(sum-delta);        // check for underflow\n    ];\n  ]);\n        sum;\n];\n\n/// interface\nSumTaylorNum0(_x, _nth'term'func, _n'terms) <-- SumTaylorNum0(x, nth'term'func, {}, n'terms);\n\n//HoldArgumentNumber(SumTaylorNum0, 4, 2);\n//HoldArgumentNumber(SumTaylorNum0, 4, 3);\n\n/// this is to be used when a simple relation between a term and the next term is known.\n/// next'term'factor must be a function applicable to one argument, so that if term = nth'term'func(k-1), then nth'term'func(k) = term / next'term'factor(k). (This is optimized for Taylor series of elementary functions.) In this case, nth'term'func is either a number, value of the 0th term, or a function.\n/// A special case: when next'term'factor is an empty list; then we act as if there is no next'term'factor available.\n/// In this case, nth'term'func must be a function applicable to one argument.\n/// Need IntLog(n'terms, 10) + 1 guard digits due to accumulated roundoff error.\nSumTaylorNum1(x, nth'term'func, next'term'factor, n'terms) :=\n[\n        // need Sqrt(n'terms/2) units of storage (rows) and Sqrt(n'terms*2) columns. Let's underestimate the storage.\n        Local(sum, rows, cols, rows'tmp, last'power, i, j, x'power, term'tmp);\n  N([ // want to keep exact fractions\n    x:=Eval(x);        // x must be floating-point\n    rows := IntNthRoot(n'terms+1, 2);\n    cols := Quotient(n'terms+rows, rows);        // now: rows*cols >=? n'terms+1\n    Check(rows>?1 And? cols>?1, \"Argument\", \"SumTaylorNum1: Internal error: number of Taylor sum terms must be at least 4\");\n    rows'tmp := ArrayCreate(rows, 0);\n    x'power := x ^ rows;        // do not use PowerN b/c x might be complex\n    // initialize partial sums (array rows'tmp) - the 0th column (i:=0)\n    // prepare term'tmp for the first element\n    // if we are using next'term'factor, then term'tmp is x^(rows*i)*a[rows*i]\n    // if we are not using it, then term'tmp is x^(rows*i)\n    If(\n      next'term'factor =? {},\n      term'tmp := 1,\n  //                term'tmp := (nth'term'func @ 0)        // floating-point\n      If (IsConstant(nth'term'func),\n        term'tmp := nth'term'func,\n        term'tmp := (nth'term'func @ {0}),\n      )\n    );\n  ]);\n  NonN([ // want to keep exact fractions below\n    // do horizontal summation using term'tmp to get the first element\n    For(i:=0, i<?cols, i++)\n    [\n      // add i'th term to each row\n      For(j:=0, j<?rows And? (i<?cols-1 Or? i*rows+j<=?n'terms), j++)        // do this unless we are beyond the last term in the last column\n      [\n        // if we are using next'term'factor, then term'tmp is x^(rows*i)*a[rows*i]\n        // if we are not using it, then term'tmp is x^(rows*i)\n        If(\n          next'term'factor =? {},        // no next'term'factor, so nth'term'func must be given\n          [\n            rows'tmp[j+1] := rows'tmp[j+1] + MultiplyNum(term'tmp, nth'term'func @ {i*rows+j});\n          ],\n          [\n            rows'tmp[j+1] := rows'tmp[j+1] + term'tmp;        // floating-point\n            term'tmp := MultiplyNum(term'tmp, next'term'factor @ {i*rows+j+1});        // arguments may be rational but the result is floating-point\n          ]\n        );\n      ];\n      // update term'tmp for the next column\n      term'tmp := term'tmp*x'power;        // both floating-point\n    ];\n    // do vertical summation using Horner's scheme\n    // now x'power = x^cols\n    For([j:=rows; sum:=0;], j>?0, j--)\n      sum := sum*x + rows'tmp[j];\n  ]);\n        sum;\n];\n\n//HoldArgumentNumber(SumTaylorNum, 4, 2);\n//HoldArgumentNumber(SumTaylorNum, 4, 3);\n\n/*\nExamples:\nIn> SumTaylorNum(1,{{k}, 1/k!},{{k}, 1/k}, 10 )\nResult: 2.7182818006;\nIn> SumTaylorNum(1,{{k},1/k!}, 10 )\nResult: 2.7182818007;\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/SumTaylorNum.mpw";
        scriptMap.put("SumTaylorNum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\ndef file definitions\nBinSplitNum\nBinSplitData\nBinSplitFinal\n*/\n\n/// coded by Serge Winitzki. See essays documentation for algorithms.\n\n//////////////////////////////////////////////////\n/// Numerical method: binary splitting technique for simple series\n//////////////////////////////////////////////////\n\n/// Binary splitting for series of the form\n/// S(m,n) = Sum(k,m,n, a(k)/b(k)*(p(0)*...*p(k))/(q(0)*...*q(k)))\n\n\n/// High-level interface routine\nBinSplitNum(m,n,a,b,p,q) := BinSplitFinal(BinSplitData(m,n,a,b,p,q));\n\n/// Low-level routine: compute the floating-point answer from P, Q, B, T data\nBinSplitFinal({_P,_Q,_B,_T}) <-- DivideN(T, MultiplyN(B, Q));\n\n/// Low-level routine: combine two binary-split intermediate results\nBinSplitCombine({_P1, _Q1, _B1, _T1}, {_P2, _Q2, _B2, _T2}) <-- {P1*P2, Q1*Q2, B1*B2, B1*P1*T2+B2*Q2*T1};\n\n/// Low-level routine: compute the list of four integers P, Q, B, T. (T=BQS)\n/// Input: m, n and four functions a,b,p,q of one integer argument.\n\n// base of recursion\n10 # BinSplitData(_m, _n, _a, _b, _p, _q)_(m>?n) <-- {1,1,1,0};\n\n10 # BinSplitData(_m, _n, _a, _b, _p, _q)_(m=?n) <-- {p@m, q@m, b@m, (a@m)*(p@m)};\n\n10 # BinSplitData(_m, _n, _a, _b, _p, _q)_(m+1=?n) <-- {(p@m)*(p@n), (q@m)*(q@n), (b@m)*(b@n), (p@m)*((a@m)*(b@n)*(q@n)+(a@n)*(b@m)*(p@n))};\n\n// could implement some more cases of recursion base, to improve speed\n\n// main recursion step\n20 # BinSplitData(_m, _n, _a, _b, _p, _q) <--\n[\n        BinSplitCombine(BinSplitData(m,(m+n)>>1, a,b,p,q), BinSplitData(1+((m+n)>>1),n, a,b,p,q));\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stdfuncs/nummethods/binsplit.mpw";
        scriptMap.put("BinSplitNum",scriptString);
        scriptMap.put("BinSplitData",scriptString);
        scriptMap.put("BinSplitFinal",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Abs(Infinity)         <-- Infinity; //Note:tk:moved here from stdfuncts.\n\n10 # Abs(n_IsNumber) <-- AbsN(n);\n10 # Abs(n_IsPositiveNumber/m_IsPositiveNumber) <-- n/m;\n10 # Abs(n_IsNegativeNumber/m_IsPositiveNumber) <-- (-n)/m;\n10 # Abs(n_IsPositiveNumber/m_IsNegativeNumber) <-- n/(-m);\n10 # Abs( Sqrt(_x)) <-- Sqrt(x);\n10 # Abs(-Sqrt(_x)) <-- Sqrt(x);\n10 # Abs(Complex(_r,_i)) <-- Sqrt(r^2 + i^2);\n10 # Abs(n_IsInfinity) <-- Infinity;\n10 # Abs(Undefined) <-- Undefined;\n20 # Abs(n_IsList) <-- MapSingle(\"Abs\",n);\n\n100 # Abs(_a^_n) <-- Abs(a)^n;\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Abs.mpw";
        scriptMap.put("Abs",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Canonicalise an expression so its terms are grouped to the right\n// ie a+(b+(c+d))\n// This doesn't preserve order of terms, when doing this would cause more\n// subtractions and nested parentheses than necessary.\n1 # CanonicalAdd((_a+_b)+_c) <-- CanonicalAdd(CanonicalAdd(a)+\n                                              CanonicalAdd(CanonicalAdd(b)+\n                                                           CanonicalAdd(c)));\n1 # CanonicalAdd((_a-_b)+_c) <-- CanonicalAdd(CanonicalAdd(a)+\n                                              CanonicalAdd(CanonicalAdd(c)-\n                                                           CanonicalAdd(b)));\n1 # CanonicalAdd((_a+_b)-_c) <-- CanonicalAdd(CanonicalAdd(a)+\n                                              CanonicalAdd(CanonicalAdd(b)-\n                                                           CanonicalAdd(c)));\n1 # CanonicalAdd((_a-_b)-_c) <-- CanonicalAdd(CanonicalAdd(a)-\n                                              CanonicalAdd(CanonicalAdd(b)+\n                                                           CanonicalAdd(c)));\n2 # CanonicalAdd(_a)         <-- a;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/CanonicalAdd.mpw";
        scriptMap.put("CanonicalAdd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # Ceil(Infinity) <-- Infinity;\n5 # Ceil(-Infinity) <-- -Infinity;\n5 # Ceil(Undefined) <-- Undefined;\n\n10 # Ceil(x_IsRationalOrNumber)\n   <--\n   [\n     x:=N(x);\n     Local(prec,result,n);\n     Bind(prec,BuiltinPrecisionGet());\n     If(IsZero(x),Bind(n,2),\n     If(x>?0,\n       Bind(n,2+FloorN(N(FastLog(x)/FastLog(10)))),\n       Bind(n,2+FloorN(N(FastLog(-x)/FastLog(10))))\n       ));\n     If(n>?prec,BuiltinPrecisionSet(n));\n     Bind(result,CeilN(x));\n     BuiltinPrecisionSet(prec);\n     result;\n   ];\n//   CeilN (N(x));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Ceil.mpw";
        scriptMap.put("Ceil",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Expand expands polynomials.\n */\n10 # Expand(expr_CanBeUni) <-- NormalForm(MakeUni(expr));\n20 # Expand(_expr) <-- expr;\n\n10 # Expand(expr_CanBeUni(var),_var) <-- NormalForm(MakeUni(expr,var));\n20 # Expand(_expr,_var) <-- expr;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Expand.mpw";
        scriptMap.put("Expand",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # Floor(Infinity) <-- Infinity;\n5 # Floor(-Infinity) <-- -Infinity;\n5 # Floor(Undefined) <-- Undefined;\n\n\n10 # Floor(x_IsRationalOrNumber)\n   <--\n   [\n     x:=N(Eval(x));\n//Echo(\"x = \",x);\n     Local(prec,result,n);\n     Bind(prec,BuiltinPrecisionGet());\n     If(IsZero(x),\n       Bind(n,2),\n       If(x>?0,\n         Bind(n,2+FloorN(N(FastLog(x)/FastLog(10)))),\n         Bind(n,2+FloorN(N(FastLog(-x)/FastLog(10))))\n       ));\n     If(n>?prec,BuiltinPrecisionSet(n));\n//Echo(\"Before\");\n     Bind(result,FloorN(x));\n//Echo(\"After\");\n     BuiltinPrecisionSet(prec);\n     result;\n   ];\n\n//     FloorN(N(x));\n\n\n//todo:tk:should this be removed because it is no longer needed?\n/* Changed by Nobbi before redefinition of Rational\n10 # Floor(x_IsNumber) <-- FloorN(x);\n10 # Ceil (x_IsNumber) <-- CeilN (x);\n10 # Round(x_IsNumber) <-- FloorN(x+0.5);\n\n20 # Floor(x_IsRational) _ (IsNumber(Numerator(x)) And? IsNumber(Denominator(x))) <-- FloorN(N(x));\n20 # Ceil (x_IsRational) _ (IsNumber(Numerator(x)) And? IsNumber(Denominator(x))) <-- CeilN (N(x));\n20 # Round(x_IsRational) _ (IsNumber(Numerator(x)) And? IsNumber(Denominator(x))) <-- FloorN(N(x+0.5));\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Floor.mpw";
        scriptMap.put("Floor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n0 # Gcd(0,0) <-- 1;\n1 # Gcd(0,_m) <-- Abs(m);\n1 # Gcd(_n,0) <-- Abs(n);\n1 # Gcd(_m,_m) <-- Abs(m);\n2 # Gcd(_n,1) <-- 1;\n2 # Gcd(1,_m) <-- 1;\n2 # Gcd(n_IsInteger,m_IsInteger) <-- GcdN(n,m);\n3 # Gcd(_n,_m)_(IsGaussianInteger(m) And? IsGaussianInteger(n) )<-- GaussianGcd(n,m);\n\n4 # Gcd(-(_n), (_m)) <-- Gcd(n,m);\n4 # Gcd( (_n),-(_m)) <-- Gcd(n,m);\n4 # Gcd(Sqrt(n_IsInteger),Sqrt(m_IsInteger)) <-- Sqrt(Gcd(n,m));\n4 # Gcd(Sqrt(n_IsInteger),m_IsInteger) <-- Sqrt(Gcd(n,m^2));\n4 # Gcd(n_IsInteger,Sqrt(m_IsInteger)) <-- Sqrt(Gcd(n^2,m));\n\n5 # Gcd(n_IsRational,m_IsRational) <--\n[\n  Gcd(Numerator(n),Numerator(m))/Lcm(Denominator(n),Denominator(m));\n];\n\n\n10 # Gcd(list_IsList)_(Length(list)>?2) <--\n    [\n      Local(first);\n      first:=Gcd(list[1],list[2]);\n      Gcd(first:Rest(Rest(list)));\n    ];\n14 # Gcd({0}) <-- 1;\n15 # Gcd({_head}) <-- head;\n\n20 # Gcd(list_IsList)_(Length(list)=?2) <-- Gcd(list[1],list[2]);\n\n30 # Gcd(n_CanBeUni,m_CanBeUni)_(Length(VarList(n*m))=?1) <--\n[\n  Local(vars);\n  vars:=VarList(n+m);\n  NormalForm(Gcd(MakeUni(n,vars),MakeUni(m,vars)));\n];\n\n100 # Gcd(n_IsConstant,m_IsConstant) <-- 1;\n110 # Gcd(_m,_n) <--\n[\n  Echo(\"Not simplified\");\n];\n\n\n//Note:tk:moved here from univar.rep.\n0 # Gcd(n_IsUniVar,m_IsUniVar)_\n    (n[1] =? m[1] And? Degree(n) <? Degree(m)) <-- Gcd(m,n);\n\n1 # Gcd(nn_IsUniVar,mm_IsUniVar)_\n    (nn[1] =? mm[1] And? Degree(nn) >=? Degree(mm)) <--\n[\n   UniVariate(nn[1],0,\n                UniGcd(Concat(ZeroVector(nn[2]),nn[3]),\n                       Concat(ZeroVector(mm[2]),mm[3])));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Gcd.mpw";
        scriptMap.put("Gcd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Least common multiple */\n5  # Lcm(a_IsInteger,b_IsInteger) <-- Quotient(a*b,Gcd(a,b));\n\n10 # Lcm(list_IsList)_(Length(list)>?2) <--\n[\n        Local(first);\n        first:=Lcm(list[1],list[2]);\n        Lcm(first:Rest(Rest(list)));\n];\n\n10 # Lcm(list_IsList)_(Length(list)=?2) <-- Lcm(list[1],list[2]);\n\n// We handle lists with just one element to avoid special-casing \n// all the calls. \n10 # Lcm(list_IsList)_(Length(list)=?1) <-- Lcm(list[1],1);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Lcm.mpw";
        scriptMap.put("Lcm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n////////////////////// Log rules stuff //////////////////////\n\n// LnCombine is nice and simple now\nLnCombine(_a) <-- DoLnCombine(CanonicalAdd(a));\n\n// Combine single terms.  This can always be done without a recursive call.\n1 # DoLnCombine(Ln(_a))              <-- Ln(a);\n1 # DoLnCombine(Ln(_a)*_b)           <-- Ln(a^b);\n1 # DoLnCombine(_b*Ln(_a))           <-- Ln(a^b);\n\n// Deal with the first two terms so they are both simple logs if at all\n// possible.  This involves converting a*Ln(b) to Ln(b^a) and moving log terms\n// to the start of expressions.  One of either of these operations always takes\n// us to a strictly simpler form than we started in, so we can get away with\n// calling DoLnCombine again with the partly simplified argument.\n\n// TODO: Make this deal with division everywhere it deals with multiplication\n\n// first term is a log multiplied by something\n2 # DoLnCombine(Ln(_a)*_b+_c)        <-- DoLnCombine(Ln(a^b)+c);\n2 # DoLnCombine(Ln(_a)*_b-_c)        <-- DoLnCombine(Ln(a^b)-c);\n2 # DoLnCombine(_b*Ln(_a)+_c)        <-- DoLnCombine(Ln(a^b)+c);\n2 # DoLnCombine(_b*Ln(_a)-_c)        <-- DoLnCombine(Ln(a^b)-c);\n\n// second term of a two-term expression is a log multiplied by something\n2 # DoLnCombine(_a+(_c*Ln(_b)))      <-- DoLnCombine(a+Ln(b^c));\n2 # DoLnCombine(_a-(_c*Ln(_b)))      <-- DoLnCombine(a-Ln(b^c));\n2 # DoLnCombine(_a+(Ln(_b)*_c))      <-- DoLnCombine(a+Ln(b^c));\n2 # DoLnCombine(_a-(Ln(_b)*_c))      <-- DoLnCombine(a-Ln(b^c));\n\n// second term of a three-term expression is a log multiplied by something\n2 # DoLnCombine(_a+((Ln(_b)*_c)+_d)) <-- DoLnCombine(a+(Ln(b^c)+d));\n2 # DoLnCombine(_a+((Ln(_b)*_c)-_d)) <-- DoLnCombine(a+(Ln(b^c)-d));\n2 # DoLnCombine(_a-((Ln(_b)*_c)+_d)) <-- DoLnCombine(a-(Ln(b^c)+d));\n2 # DoLnCombine(_a-((Ln(_b)*_c)-_d)) <-- DoLnCombine(a-(Ln(b^c)-d));\n\n2 # DoLnCombine(_a+((_c*Ln(_b))+_d)) <-- DoLnCombine(a+(Ln(b^c)+d));\n2 # DoLnCombine(_a+((_c*Ln(_b))-_d)) <-- DoLnCombine(a+(Ln(b^c)-d));\n2 # DoLnCombine(_a-((_c*Ln(_b))+_d)) <-- DoLnCombine(a-(Ln(b^c)+d));\n2 # DoLnCombine(_a-((_c*Ln(_b))-_d)) <-- DoLnCombine(a-(Ln(b^c)-d));\n\n// Combine the first two terms if they are logs, otherwise move one or both to\n// the front, then recurse on the remaining possibly-log-containing portion.\n// (the code makes more sense than this comment)\n3 # DoLnCombine(Ln(_a)+Ln(_b))       <-- Ln(a*b);\n3 # DoLnCombine(Ln(_a)-Ln(_b))       <-- Ln(a/b);\n3 # DoLnCombine(Ln(_a)+(Ln(_b)+_c))  <-- DoLnCombine(Ln(a*b)+c);\n3 # DoLnCombine(Ln(_a)+(Ln(_b)-_c))  <-- DoLnCombine(Ln(a*b)-c);\n3 # DoLnCombine(Ln(_a)-(Ln(_b)+_c))  <-- DoLnCombine(Ln(a/b)-c);\n3 # DoLnCombine(Ln(_a)-(Ln(_b)-_c))  <-- DoLnCombine(Ln(a/b)+c);\n\n// We know that at least one of the first two terms isn't a log\n4 # DoLnCombine(Ln(_a)+(_b+_c))      <-- b+DoLnCombine(Ln(a)+c);\n4 # DoLnCombine(Ln(_a)+(_b-_c))      <-- b+DoLnCombine(Ln(a)-c);\n4 # DoLnCombine(Ln(_a)-(_b+_c))      <-- DoLnCombine(Ln(a)-c)-b;\n4 # DoLnCombine(Ln(_a)-(_b-_c))      <-- DoLnCombine(Ln(a)+c)-b;\n\n4 # DoLnCombine(_a+(Ln(_b)+_c))      <-- a+DoLnCombine(Ln(b)+c);\n4 # DoLnCombine(_a+(Ln(_b)-_c))      <-- a+DoLnCombine(Ln(b)-c);\n4 # DoLnCombine(_a-(Ln(_b)+_c))      <-- a-DoLnCombine(Ln(b)+c);\n4 # DoLnCombine(_a-(Ln(_b)-_c))      <-- a-DoLnCombine(Ln(b)-c);\n\n// If we get here we know that neither of the first two terms is a log\n5 # DoLnCombine(_a+(_b+_c))          <-- a+(b+DoLnCombine(c));\n\n// Finished\n6 # DoLnCombine(_a)                  <-- a;\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/LnCombine.mpw";
        scriptMap.put("LnCombine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n////////////////////// Log rules stuff //////////////////////\n\n// LnExpand\n1 # LnExpand(Ln(x_IsInteger))\n                            <-- Add(Map({{n,m},m*Ln(n)},Transpose(Factors(x))));\n1 # LnExpand(Ln(_a*_b))     <-- LnExpand(Ln(a))+LnExpand(Ln(b));\n1 # LnExpand(Ln(_a/_b))     <-- LnExpand(Ln(a))-LnExpand(Ln(b));\n1 # LnExpand(Ln(_a^_n))     <-- LnExpand(Ln(a))*n;\n2 # LnExpand(_a)            <-- a;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/LnExpand.mpw";
        scriptMap.put("LnExpand",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Modulo\",*);\n\n0 # Modulo(_n,m_IsRationalOrNumber)_(m<?0) <-- `Hold(Modulo(@n,@m));\n\n1 # Modulo(n_IsNegativeInteger,m_IsPositiveInteger) <--\n[\n  Local(result);\n  result := ModuloN(n,m);\n  If (result <? 0,result := result + m);\n  result;\n];\n1 # Modulo(n_IsPositiveInteger,m_IsPositiveInteger) <-- ModuloN(n,m);\n2 # Modulo(0,_m) <-- 0;\n2 # Modulo(n_IsPositiveInteger,Infinity) <-- n;\n3 # Modulo(n_IsInteger,m_IsInteger) <-- ModuloN(n,m);\n4 # Modulo(n_IsNumber,m_IsNumber) <-- NonN(Modulo(Rationalize(n),Rationalize(m)));\n\n5 # Modulo(n_IsRationalOrNumber,m_IsRationalOrNumber)/*_(n>?0 And? m>?0)*/ <--\n[\n  Local(n1,n2,m1,m2);\n  n1:=Numerator(n);\n  n2:=Denominator(n);\n  m1:=Numerator(m);\n  m2:=Denominator(m);\n  Modulo(n1*m2,m1*n2)/(n2*m2);\n];\n\n6 # Modulo(n_IsList,m_IsList) <-- Map(\"Modulo\",{n,m});\n7 # Modulo(n_IsList,_m) <-- Map(\"Modulo\",{n,FillList(m,Length(n))});\n\n\n30 # Modulo(n_CanBeUni,m_CanBeUni) <--\n[\n  Local(vars);\n  vars:=VarList(n+m);\n  NormalForm(Modulo(MakeUni(n,vars),MakeUni(m,vars)));\n];\n\n\n//Note:tk:moved here from univariate.rep.\n0 # Modulo(n_IsUniVar,m_IsUniVar)_(Degree(n) <? Degree(m)) <-- n;\n1 # Modulo(n_IsUniVar,m_IsUniVar)_\n    (n[1] =? m[1] And? Degree(n) >=? Degree(m)) <--\n[\n    UniVariate(n[1],0,\n               UniDivide(Concat(ZeroVector(n[2]),n[3]),\n                         Concat(ZeroVector(m[2]),m[3]))[2]);\n];\n\n10 # Modulo(n_CanBeUni, m_CanBeUni, vars_IsList)_(Length(vars)=?1) <--\n[\n    NormalForm(Modulo(MakeUni(n,vars),MakeUni(m,vars)));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Modulo.mpw";
        scriptMap.put("Modulo",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"Object\",{pred,x});\nRule(\"Object\",2,0,Apply(pred,{x})=?True) x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Object.mpw";
        scriptMap.put("Object",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Integer divisions */\n0 # Quotient(n_IsInteger,m_IsInteger) <-- QuotientN(n,m);\n1 # Quotient(0  ,_m) <-- 0;\n2 # Quotient(n_IsRationalOrNumber,m_IsRationalOrNumber) <--\n[\n  Local(n1,n2,m1,m2,sgn1,sgn2);\n  n1:=Numerator(n);\n  n2:=Denominator(n);\n  m1:=Numerator(m);\n  m2:=Denominator(m);\n  sgn1 := Sign(n1*m2);\n  sgn2 := Sign(m1*n2);\n  sgn1*sgn2*Floor(DivideN(sgn1*n1*m2,sgn2*m1*n2));\n];\n30 # Quotient(n_CanBeUni,m_CanBeUni)_(Length(VarList(n*m))=?1) <--\n[\n\n  Local(vars,nl,ml);\n  vars:=VarList(n*m);\n  nl := MakeUni(n,vars);\n  ml := MakeUni(m,vars);\n  NormalForm(Quotient(nl,ml));\n];\n\n\n//Note:tk:moved here from univariate.rep.\n0 # Quotient(n_IsUniVar,m_IsUniVar)_(Degree(n) <? Degree(m)) <-- 0;\n1 # Quotient(n_IsUniVar,m_IsUniVar)_\n    (n[1] =? m[1] And? Degree(n) >=? Degree(m)) <--\n[\n    UniVariate(n[1],0,\n               UniDivide(Concat(ZeroVector(n[2]),n[3]),\n                         Concat(ZeroVector(m[2]),m[3]))[1]);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Quotient.mpw";
        scriptMap.put("Quotient",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Note:tk:this was not listed in the def file.\n0 # Rem(n_IsNumber,m_IsNumber) <-- n-m*Quotient(n,m);\n30 # Rem(n_CanBeUni,m_CanBeUni) <-- Modulo(n,m);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Rem.mpw";
        scriptMap.put("Rem",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # Round(Infinity) <-- Infinity;\n5 # Round(-Infinity) <-- -Infinity;\n5 # Round(Undefined) <-- Undefined;\n\n10 # Round(x_IsRationalOrNumber) <-- FloorN(N(x+0.5));\n10 # Round(x_IsList) <-- MapSingle(\"Round\",x);\n\n20 # Round(x_IsComplex)  _ (IsRationalOrNumber(Re(x)) And? IsRationalOrNumber(Im(x)) )\n                <-- FloorN(N(Re(x)+0.5)) + FloorN(N(Im(x)+0.5))*I;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Round.mpw";
        scriptMap.put("Round",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Sign(n_IsPositiveNumber) <-- 1;\n10 # Sign(n_IsZero) <-- 0;\n20 # Sign(n_IsNumber) <-- -1;\n15 # Sign(n_IsInfinity)_(n <? 0) <-- -1;\n15 # Sign(n_IsInfinity)_(n >? 0) <-- 1;\n15 # Sign(n_IsNumber/m_IsNumber) <-- Sign(n)*Sign(m);\n20 # Sign(n_IsList) <-- MapSingle(\"Sign\",n);\n\n100 # Sign(_a)^n_IsEven <-- 1;\n100 # Sign(_a)^n_IsOdd <-- Sign(a);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Sign.mpw";
        scriptMap.put("Sign",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n0 # Sqrt(0) <-- 0;\n0 # Sqrt(Infinity) <--  Infinity;\n0 # Sqrt(-Infinity) <-- Complex(0,Infinity);\n0 # Sqrt(Undefined) <--  Undefined;\n1 # Sqrt(x_IsPositiveInteger)_(IsInteger(SqrtN(x))) <-- SqrtN(x);\n2 # Sqrt(x_IsPositiveNumber)_InNumericMode() <-- SqrtN(x);\n2 # Sqrt(x_IsNegativeNumber) <-- Complex(0,Sqrt(-x));\n/* 3 # Sqrt(x_IsNumber/y_IsNumber) <-- Sqrt(x)/Sqrt(y); */\n3 # Sqrt(x_IsComplex)_InNumericMode() <-- x^(1/2);\n/* Threading  */\nSqrt(xlist_IsList) <-- MapSingle(\"Sqrt\",xlist);\n\n90 # (Sqrt(x_IsConstant))_(IsNegativeNumber(N(x))) <-- Complex(0,Sqrt(-x));\n\n400 # x_IsRationalOrNumber * Sqrt(y_IsRationalOrNumber)  <-- Sign(x)*Sqrt(x^2*y);\n400 # Sqrt(y_IsRationalOrNumber) * x_IsRationalOrNumber  <-- Sign(x)*Sqrt(x^2*y);\n400 # x_IsRationalOrNumber / Sqrt(y_IsRationalOrNumber)  <-- Sign(x)*Sqrt(x^2/y);\n400 # Sqrt(y_IsRationalOrNumber) / x_IsRationalOrNumber  <-- Sign(x)*Sqrt(y/(x^2));\n400 # Sqrt(y_IsRationalOrNumber) / Sqrt(x_IsRationalOrNumber)  <-- Sqrt(y/x);\n400 # Sqrt(y_IsRationalOrNumber) * Sqrt(x_IsRationalOrNumber)  <-- Sqrt(y*x);\n400 # Sqrt(x_IsInteger)_IsInteger(SqrtN(x)) <-- SqrtN(x);\n400 # Sqrt(x_IsInteger/y_IsInteger)_(IsInteger(SqrtN(x)) And? IsInteger(SqrtN(y))) <-- SqrtN(x)/SqrtN(y);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/Sqrt.mpw";
        scriptMap.put("Sqrt",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\n=\n<?\n>?\n<=?\n>=?\n!=?\n\n*/\n\n/* Comparison operators. They call the internal comparison routines when\n * both arguments are numbers. The value Infinity is also understood.\n*/\n\n// Undefined is a very special case as we return False for everything\n1 # Undefined <?  _x  <--  False;\n1 # Undefined <=? _x  <--  False;\n1 # Undefined >?  _x  <--  False;\n1 # Undefined >=? _x  <--  False;\n1 # _x <?  Undefined  <--  False;\n1 # _x <=? Undefined  <--  False;\n1 # _x >?  Undefined  <--  False;\n1 # _x >=? Undefined  <--  False;\n\n\n// If n and m are numbers, use the standard LessThan function immediately\n5 # (n_IsNumber <? m_IsNumber) <-- IsLessThan(n-m,0);\n\n\n// If n and m are symbolic after a single evaluation, see if they can be coerced in to a real-valued number.\nLocalSymbols(nNum,mNum)\n[\n  10 # (_n <? _m)_[nNum:=N(Eval(n)); mNum:=N(Eval(m));IsNumber(nNum) And? IsNumber(mNum);] <-- IsLessThan(nNum-mNum,0);\n];\n\n// Deal with Infinity\n20 #  (Infinity <? _n)_(Not?(IsInfinity(n)))  <-- False;\n20 #  (-Infinity <? _n)_(Not?(IsInfinity(n))) <-- True;\n20 #  (_n <? Infinity)_(Not?(IsInfinity(n)))  <-- True;\n20 #  (_n <? -Infinity)_(Not?(IsInfinity(n))) <-- False;\n\n// Lots of known identities go here\n30 # (_n1/_n2) <? 0  <--  (n1 <? 0) !=? (n2 <? 0);\n30 # (_n1*_n2) <? 0  <--  (n1 <? 0) !=? (n2 <? 0);\n\n// This doesn't sadly cover the case where a and b have opposite signs\n30 # ((_n1+_n2) <? 0)_((n1 <? 0) And? (n2 <? 0))  <--  True;\n30 # ((_n1+_n2) <? 0)_((n1 >? 0) And? (n2 >? 0))  <--  False;\n30 #  _x^a_IsOdd  <? 0  <--  x <? 0;\n30 #  _x^a_IsEven <? 0  <--  False; // This is wrong for complex x\n\n// Add other functions here!  Everything we can compare to 0 should be here.\n40 # (Sqrt(_x))_(x >? 0) <? 0          <--  False;\n\n40 # (Sin(_x) <? 0)_(Not?(IsEven(N(x/Pi))) And? IsEven(N(Floor(x/Pi)))) <-- False;\n40 # (Sin(_x) <? 0)_(Not?(IsOdd (N(x/Pi))) And? IsOdd (N(Floor(x/Pi)))) <-- True;\n\n40 # Cos(_x) <? 0 <-- Sin(Pi/2-x) <? 0;\n\n40 # (Tan(_x) <? 0)_(Not?(IsEven(N(2*x/Pi))) And? IsEven(N(Floor(2*x/Pi)))) <-- False;\n40 # (Tan(_x) <? 0)_(Not?(IsOdd (N(2*x/Pi))) And? IsOdd (N(Floor(2*x/Pi)))) <-- True;\n\n// Functions that need special treatment with more than one of the comparison\n// operators as they always return true or false.  For these we must define\n// both the `<?' and `>=?' operators.\n40 # (Complex(_a,_b) <?  0)_(b!=?0) <--  False;\n40 # (Complex(_a,_b) >=? 0)_(b!=?0) <--  False;\n40 # (Sqrt(_x))_(x <? 0) <?  0      <--  False;\n40 # (Sqrt(_x))_(x <? 0) >=? 0      <--  False;\n\n// Deal with negated terms\n50 # -(_x) <? 0 <-- Not?((x<?0) Or? (x=?0));\n\n// Define each of {>?,<=?,>=?} in terms of <?\n50 # _n >?  _m <-- m <? n;\n50 # _n <=? _m <-- m >=? n;\n50 # _n >=? _m <-- Not?(n<?m);\n\n\nFunction(\"!=?\",{aLeft,aRight}) Not?(aLeft=?aRight);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/comparison_operators.mpw";
        scriptMap.put("<?",scriptString);
        scriptMap.put(">?",scriptString);
        scriptMap.put("<=?",scriptString);
        scriptMap.put(">=?",scriptString);
        scriptMap.put("!=?",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRulebase(\"->\",{left,right});\n\nHoldArgument(\"->\",left);\n\n//HoldArgument(\"->\",right);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/minus_greaterthan_operator.mpw";
        scriptMap.put("->",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* def file definitions\n<<\n>>\n*/\n\n/* Shifting operators */\n\nn_IsInteger << m_IsInteger <-- ShiftLeft(n,m);\nn_IsInteger >> m_IsInteger <-- ShiftRight(n,m);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/stubs/shifting_operators.mpw";
        scriptMap.put("<<",scriptString);
        scriptMap.put(">>",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*Extremely hacky workaround, MacroSubstitute is actually the same as Substitute,\n  but without re-evaluating its arguments. I could not just change Substitute, as\n  it changed behaviour such that tests started to break.\n */\nFunction(\"MacroSubstitute\",{body,predicate,change})\n[\n  `MacroSubstitute((Hold(@body)));\n];\nHoldArgument(\"MacroSubstitute\",predicate);\nHoldArgument(\"MacroSubstitute\",change);\nUnFence(\"MacroSubstitute\",3);\nRulebase(\"MacroSubstitute\",{body});\nUnFence(\"MacroSubstitute\",1);\n\nRule(\"MacroSubstitute\",1,1,`ApplyFast(predicate,{Hold(Hold(@body))}) =? True)\n[\n  `ApplyFast(change,{Hold(Hold(@body))});\n];\nRule(\"MacroSubstitute\",1,2,`IsFunction(Hold(@body)))\n[\n  `ApplyFast(\"MacroMapArgs\",{Hold(Hold(@body)),\"MacroSubstitute\"});\n];\nRule(\"MacroSubstitute\",1,3,True)\n[\n `Hold(@body);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/substitute/MacroSubstitute.mpw";
        scriptMap.put("MacroSubstitute",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Substitute\",{body,predicate,change})\n[\n  Substitute(body);\n];\nHoldArgument(\"Substitute\",predicate);\nHoldArgument(\"Substitute\",change);\nUnFence(\"Substitute\",3);\nRulebase(\"Substitute\",{body});\nUnFence(\"Substitute\",1);\n\nRule(\"Substitute\",1,1,Apply(predicate,{body}) =? True)\n[\n  Apply(change,{body});\n];\nRule(\"Substitute\",1,2,IsFunction(body))\n[\n  Apply(\"MapArgs\",{body,\"Substitute\"});\n];\nRule(\"Substitute\",1,3,True) body;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/substitute/Substitute.mpw";
        scriptMap.put("Substitute",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction() Add(val, ...);\n\n10 # Add({}) <-- 0;\n20 # Add(values_IsList) <--\n[\n   Local(i, sum);\n   sum:=0;\n   ForEach(i, values) [ sum := sum + i; ];\n   sum;\n];\n\n// Add(1) should return 1\n30 # Add(_value) <-- value;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Add.mpw";
        scriptMap.put("Add",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*  this is disabled because some functions seem to implicitly define Min / Max with a different number of args, and then MathPiper is confused if it hasn't loaded all the Function() declarations beforehand.\nFIXME\n/// Min, Max with many arguments\n*/\n\n//Retract(\"Maximum\", 1);\n//Retract(\"Maximum\", 2);\n//Retract(\"Maximum\", 3);\n\n//Function() Maximum(list);\n\n//Function() Maximum(l1, l2);\n\nFunction() Maximum(l1, l2, l3, ...);\n\n\n\n10 # Maximum(_l1, _l2, l3_IsList) <-- Maximum(Concat({l1, l2}, l3));\n20 # Maximum(_l1, _l2, _l3) <-- Maximum({l1, l2, l3});\n/**/\n\n10 # Maximum(l1_IsList,l2_IsList) <-- Map(\"Maximum\",{l1,l2});\n\n\n20 # Maximum(l1_IsRationalOrNumber,l2_IsRationalOrNumber) <-- If(l1>?l2,l1,l2);\n\n\n30 # Maximum(l1_IsConstant,l2_IsConstant) <-- If(N(Eval(l1-l2))>?0,l1,l2);\n\n// Max on empty lists\n10 # Maximum({}) <-- Undefined;\n\n\n20 # Maximum(list_IsList) <--\n[\n  Local(result);\n  result:= list[1];\n  ForEach(item,Rest(list)) result:=Maximum(result,item);\n  result;\n];\n\n\n30 # Maximum(_x) <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Maximum.mpw";
        scriptMap.put("Maximum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*  this is disabled because some functions seem to implicitly define Min / Max with a different number of args, \nand then MathPiper is confused if it hasn't loaded all the Function() declarations beforehand.\nFIXME\n/// Min, Max with many arguments\n*/\n\n//Retract(\"Minimum\", 1);\n//Retract(\"Minimum\", 2);\n//Retract(\"Minimum\", 3);\n\n//Function() Minimum(list);\n\n//Function() Minimum(l1, l2)\n\nFunction() Minimum(l1, l2, l3, ...);\n\n10 # Minimum(_l1, _l2, l3_IsList) <-- Minimum(Concat({l1, l2}, l3));\n20 # Minimum(_l1, _l2, _l3) <-- Minimum({l1, l2, l3});\n\n10 # Minimum(l1_IsList,l2_IsList) <-- Map(\"Minimum\",{l1,l2});\n\n20 # Minimum(l1_IsRationalOrNumber,l2_IsRationalOrNumber) <-- If(l1<?l2,l1,l2);\n\n30 # Minimum(l1_IsConstant,l2_IsConstant) <-- If(N(Eval(l1-l2))<?0,l1,l2);\n\n//Min on an empty list.\n10 # Minimum({}) <-- Undefined;\n\n20 # Minimum(list_IsList) <--\n[\n  Local(result);\n  result:= list[1];\n  ForEach(item,Rest(list)) result:=Minimum(result,item);\n  result;\n];\n\n30 # Minimum(_x) <-- x;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Minimum.mpw";
        scriptMap.put("Minimum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Product\",{sumvar,sumfrom,sumto,sumbody})\n[\n   Local(sumi,sumsum);\n   sumsum:=1;\n   For(sumi:=sumfrom,sumi<=?sumto And? sumsum!=?0,sumi++)\n       [\n        MacroLocal(sumvar);\n        MacroBind(sumvar,sumi);\n        sumsum:=sumsum*Eval(sumbody);\n       ];\n   sumsum;\n];\nUnFence(\"Product\",4);\nHoldArgument(\"Product\",sumvar);\nHoldArgument(\"Product\",sumbody);\n\nProduct(sumlist_IsList) <--\n[\n   Local(sumi,sumsum);\n   sumsum:=1;\n   ForEach(sumi,sumlist)\n   [\n     sumsum:=sumsum*sumi;\n   ];\n   sumsum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Product.mpw";
        scriptMap.put("Product",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Subfactorial\",{n})\n[\n        n! * Sum(k,0,n,(-1)^(k)/k!);\n];\n\n30 # Subfactorial(n_IsList) <-- MapSingle(\"Subfactorial\",n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Subfactorial.mpw";
        scriptMap.put("Subfactorial",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Sums */\n\n\nRulebase(\"Sum\",{sumvar'arg,sumfrom'arg,sumto'arg,sumbody'arg});\n\n\n\n\n10  # Sum(_sumvar,sumfrom_IsNumber,sumto_IsNumber,_sumbody)_(sumfrom>?sumto) <-- 0;\n\n20 # Sum(_sumvar,sumfrom_IsNumber,sumto_IsNumber,_sumbody)_(sumto<?sumfrom) <--\n     ApplyFast(\"Sum\",{sumvar,sumto,sumfrom,sumbody});\n30 # Sum(_sumvar,sumfrom_IsNumber,sumto_IsNumber,_sumbody) <--\nLocalSymbols(sumi,sumsum)[\n   Local(sumi,sumsum);\n   sumsum:=0;\n   For(sumi:=sumfrom,sumi<=?sumto,sumi++)\n       [\n        MacroLocal(sumvar);\n        MacroBind(sumvar,sumi);\n        sumsum:=sumsum+Eval(sumbody);\n       ];\n   sumsum;\n];\n\nUnFence(\"Sum\",4);\nHoldArgument(\"Sum\",sumvar'arg);\nHoldArgument(\"Sum\",sumbody'arg);\n\n\n\n40 # Sum({}) <-- 0;\n\n50 # Sum(values_IsList) <--\n[\n   Local(i, sum);\n   sum:=0;\n   ForEach(i, values) [ sum := sum + i; ];\n   sum;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Sum.mpw";
        scriptMap.put("Sum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(c,d,expr,from,to,summand,sum,predicate,n,r,var,x) [\n\n// Attempt to Sum series\n\nFunction() SumFunc(k,from,to,summand, sum, predicate );\nFunction() SumFunc(k,from,to,summand, sum);\nHoldArgument(SumFunc,predicate);\nHoldArgument(SumFunc,sum);\nHoldArgument(SumFunc,summand);\n\n// Difference code does not work\nSumFunc(_sumvar,sumfrom_IsInteger,_sumto,_sumbody,_sum) <--\n[\n        // Take the given answer and create 2 rules, one for an exact match\n        // for sumfrom, and one which will catch sums starting at a different\n        // index and subtract off the difference\n\n        `(40 # Sum(@sumvar,@sumfrom,@sumto,@sumbody )        <-- Eval(@sum) );\n        `(41 # Sum(@sumvar,p_IsInteger,@sumto,@sumbody)_(p >? @sumfrom)\n             <--\n             [\n                  Local(sub);\n                  (sub := Eval(ListToFunction({Sum,sumvar'arg,@sumfrom,p-1,sumbody'arg})));\n                  Simplify(Eval(@sum) - sub );\n             ]);\n];\n\nSumFunc(_sumvar,sumfrom_IsInteger,_sumto,_sumbody,_sum,_condition) <--\n[\n\n        `(40 # Sum(@sumvar,@sumfrom,@sumto,@sumbody)_(@condition)    <-- Eval(@sum) );\n        `(41 # Sum(@sumvar,p_IsInteger,@sumto,@sumbody )_(@condition And? p >? @sumfrom)\n             <--\n             [\n                  Local(sub);\n                  `(sub := Eval(ListToFunction({Sum,sumvar'arg,@sumfrom,p-1,sumbody'arg})));\n                  Simplify(Eval(@sum) - sub );\n             ]);\n];\n\n// Some type of canonical form is needed so that these match when\n// given in a different order, like x^k/k! vs. (1/k!)*x^k\n// works !\nSumFunc(_k,1,_n,_c + _d,\n  Eval(ListToFunction({Sum,sumvar'arg,1,n,c})) +\n  Eval(ListToFunction({Sum,sumvar'arg,1,n,d}))\n);\nSumFunc(_k,1,_n,_c*_expr,Eval(c*ListToFunction({Sum,sumvar'arg,1,n,expr})), IsFreeOf(k,c) );\nSumFunc(_k,1,_n,_expr/_c,Eval(ListToFunction({Sum,sumvar'arg,1,n,expr})/c), IsFreeOf(k,c) );\n\n// this only works when the index=1\n// If the limit of the general term is not zero, then the series diverges\n// We need something like IsUndefined(term), because this croaks when limit return Undefined\n//SumFunc(_k,1,Infinity,_expr,Infinity,Eval(Abs(ListToFunction({Limit,sumvar'arg,Infinity,expr})) >? 0));\nSumFunc(_k,1,Infinity,1/_k,Infinity);\n\nSumFunc(_k,1,_n,_c,c*n,IsFreeOf(k,c) );\nSumFunc(_k,1,_n,_k, n*(n+1)/2 );\n//SumFunc(_k,1,_n,_k^2, n*(n+1)*(2*n+1)/6 );\n//SumFunc(_k,1,_n,_k^3, (n*(n+1))^2 / 4 );\nSumFunc(_k,1,_n,_k^_p,(Bernoulli(p+1,n+1) - Bernoulli(p+1))/(p+1), IsInteger(p) );\nSumFunc(_k,1,_n,2*_k-1, n^2 );\nSumFunc(_k,1,_n,HarmonicNumber(_k),(n+1)*HarmonicNumber(n) - n );\n\n// Geometric series! The simplest of them all ;-)\nSumFunc(_k,0,_n,(r_IsFreeOf(k))^(_k), (1-r^(n+1))/(1-r) );\n\n// Infinite Series\n// this allows Zeta a complex argument, which is not supported yet\nSumFunc(_k,1,Infinity,1/(_k^_d), Zeta(d), IsFreeOf(k,d) );\nSumFunc(_k,1,Infinity,_k^(-_d), Zeta(d), IsFreeOf(k,d) );\n\nSumFunc(_k,0,Infinity,_x^(2*_k+1)/(2*_k+1)!,Sinh(x) );\nSumFunc(_k,0,Infinity,(-1)^k*_x^(2*_k+1)/(2*_k+1)!,Sin(x) );\nSumFunc(_k,0,Infinity,_x^(2*_k)/(2*_k)!,Cosh(x) );\nSumFunc(_k,0,Infinity,(-1)^k*_x^(2*_k)/(2*_k)!,Cos(x) );\nSumFunc(_k,0,Infinity,_x^(2*_k+1)/(2*_k+1),ArcTanh(x) );\nSumFunc(_k,0,Infinity,1/(_k)!,Exp(1) );\nSumFunc(_k,0,Infinity,_x^_k/(_k)!,Exp(x) );\n40 # Sum(_var,_from,Infinity,_expr)_( `(Limit(@var,Infinity)(@expr)) =? Infinity) <-- Infinity;\n\nSumFunc(_k,1,Infinity,1/BinomialCoefficient(2*_k,_k), (2*Pi*Sqrt(3)+9)/27 );\nSumFunc(_k,1,Infinity,1/(_k*BinomialCoefficient(2*_k,_k)), (Pi*Sqrt(3))/9 );\nSumFunc(_k,1,Infinity,1/(_k^2*BinomialCoefficient(2*_k,_k)), Zeta(2)/3 );\nSumFunc(_k,1,Infinity,1/(_k^3*BinomialCoefficient(2*_k,_k)), 17*Zeta(4)/36 );\nSumFunc(_k,1,Infinity,(-1)^(_k-1)/_k, Ln(2) );\n\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/SumFunc.mpw";
        scriptMap.put("SumFunc",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*COMMENT FROM AYAL: Jitse, I added some code to make Taylor2 work in the most general case too I believe.\n  Could you check to see if you agree with my changes? If that is correct, perhaps we can start calling Taylor2\n  by default in stead of Taylor1.\n */\nFunction(\"Taylor\",{taylorvariable,taylorat,taylororder,taylorfunction})\n  Taylor1(taylorvariable,taylorat,taylororder)(taylorfunction);\n\n/*COMMENT FROM AYAL: this is the old slow but working version of Taylor series expansion. Jitse wrote a\n * faster version which resides in taylor.mpi, and uses lazy power series. This slow but correct version is still\n * useful for tests (the old and the new routine should yield identical results).\n */\nFunction(\"Taylor1\",{taylorvariable,taylorat,taylororder,taylorfunction})\n[\n  Local(n,result,dif,polf);\n  [\n    MacroLocal(taylorvariable);\n    [\n      MacroLocal(taylorvariable);\n      MacroBind(taylorvariable, taylorat);\n      result:=Eval(taylorfunction);\n    ];\n    If(result=?Undefined,\n    [\n      result:=Apply(\"Limit\",{taylorvariable,taylorat,taylorfunction});\n    ]);\n/*\n    MacroBind(taylorvariable,taylorat);\n    result:=Eval(taylorfunction);\n*/\n  ];\n  dif:=taylorfunction;\n  polf:=(taylorvariable-taylorat);\n  For(n:=1,result !=? Undefined And? n<=?taylororder,n++)\n  [\n    dif:= Deriv(taylorvariable) dif;\n    Local(term);\n    MacroLocal(taylorvariable);\n    [\n      MacroLocal(taylorvariable);\n      MacroBind(taylorvariable, taylorat);\n      term:=Eval(dif);\n    ];\n    If(term=?Undefined,\n    [\n      term:=Apply(\"Limit\",{taylorvariable,taylorat,dif});\n    ]);\n\n    result:=result+(term/(n!))*(polf^n);\n/*    result:=result+Apply(\"Limit\",{taylorvariable,taylorat,(dif/(n!))})*(polf^n); */\n/*\n    MacroBind(taylorvariable,taylorat);\n    result:=result+(Eval(dif)/(n!))*(polf^n);\n*/\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Taylor.mpw";
        scriptMap.put("Taylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\n * Taylor(x,a,n) y  ---  ENTRY POINT\n * ~~~~~~~~~~~~~~~\n * The n-th degree Taylor polynomial of y around x=a\n *\n * This function is implemented by doing calculus on power series.  For\n * instance, the Taylor series of Sin(x)^2 around x=0 is computed as\n * follows. First, we look up the series for Sin(x)\n *    Sin(x) = x - 1/6 x^3 + 1/120 x^5 - 1/5040 x^7 + ...\n * and then we compute the square of this series\n *    Sin(x)^2 = x^2 - x^4/3 + 2/45 x^6 - 1/315 x^8 + ...\n *\n * An alternative method is to use the formula\n *    Taylor(x,a,n) y = \\sum_{k=0}^n 1/k! a_k x^k,\n * where a_k is the k-th order derivative of y with respect to x,\n * evaluated at x=a. In fact, the old implementation of \"Taylor\", which\n * is retained in obsolete.mpi, uses this method. However, we found out\n * that the expressions for the derivatives often grow very large, which\n * makes the computation too slow.\n *\n * The power series are implemented as lazy power series, which means\n * that the coefficients are computed on demand. Lazy power series are\n * encapsulated in expressions of the formAnalyzeScripts.java:64\n *    Taylor'LPS(order, coeffs, var, expr).\n * This represent the power series of \"expr\", seen as a function of\n * \"var\". \"coeffs\" is list of coefficients that have been computed thus\n * far. The integer \"order\" is the order of the first coefficient.\n *\n * For instance, the expression\n *    Taylor'LPS(1, {1,0,-1/6,0}, x, Sin(x))\n * contains the power series of Sin(x), viewed as a function of x, where\n * the four coefficients corresponding to x, x^2, x^3, and x^4 have been\n * computed. One can view this expression as x - 1/6 x^3 + O(x^5).\n *\n * \"coeffs\" is the empty list in the following special cases:\n * 1) order = Infinity represents the zero power series\n * 2) order = Undefined represents a power series of which no\n *    coefficients have yet been computed.\n * 3) order = n represents a power series of order at least n,\n *    of which no coefficients have yet been computed.\n *\n * \"expr\" may contain subexpressions of the form\n *    Taylor'LPS'Add(lps1, lps2)       = lps1)x) + lps2(x)\n *    Taylor'LPS'ScalarMult(a, lps)    = a*lps(x)  (a is scalar)\n *    Taylor'LPS'Multiply(lps1, lps2)  = lps1(x) * lps2(x)\n *    Taylor'LPS'Inverse(lps)          = 1/lps(x)\n *    Taylor'LPS'Power(lps, n)         = lps(x)^n  (n is natural number)\n *    Taylor'LPS'Compose(lps1, lps2)   = lps1(lps2(x))\n *\n * A well-formed LPS is an expression of the form\n *    Taylor'LPS(order, coeffs, var, expr)\n * satisfying the following conditions:\n * 1) order is an integer, Infinity, or Undefined;\n * 2) coeffs is a list;\n * 3) if order is Infinity or Undefined, then coeffs is {};\n * 4) if order is an integer, then coeffs is empty\n *    or its first entry is nonzero;\n * 5) var does not appear in coeffs;\n * 6) expr is normalized with Taylor'LPS'NormalizeExpr.\n *\n */\n\nRulebase(\"Taylor'LPS\",{order, coeffs, var, expr});\nRulebase(\"Taylor'LPS'Inverse\",{lps});\nRulebase(\"Taylor'LPS'Add\",{lps1,lps2});\nRulebase(\"Taylor'LPS'Multiply\",{lps1,lps2});\nRulebase(\"Taylor'LPS'ScalarMult\",{a,lps});\nRulebase(\"Taylor'LPS'Compose\",{lps1,lps2});\n\n/* For the moment, the function is called Taylor2. */\n\n/* HELP: Is this the correct mechanism to signal incorrect input? */\n/*COMMENT FROM AYAL: Formally, I would do it the other way around, although this is more efficient. This\n  scheme says: all following rules hold if n>=0. Ideally you'd have a rule \"this transformation rule holds\n  if n>=0\". But then you would end up checking that n>=0 for each transformation rule, making things a little\n  bit slower (but more correct, more elegant).\n  */\n10 # (Taylor2(_x, _a, _n) _y)\n   _ (Not?(IsPositiveInteger(n) Or? IsZero(n)))\n   <-- Check(False, \"Argument\", \"Third argument to Taylor should be a nonnegative integer\");\n\n20 # (Taylor2(_x, 0, _n) _y) <--\n[\n   Local(res);\n   res := Taylor'LPS'PowerSeries(Taylor'LPS'Construct(x, y), n, x);\n   If (ClearError(\"singularity\"),\n       Echo(y, \"has a singularity at\", x, \"= 0.\"));\n   If (ClearError(\"dunno\"),\n       Echo(\"Cannot determine power series of\", y));\n   res;\n];\n\n30 # (Taylor2(_x, _a, _n) _y)\n   <-- Subst(x,x-a) Taylor2(x,0,n) Subst(x,x+a) y;\n\n/**********************************************************************\n *\n * Parameters\n * ~~~~~~~~~~\n * The number of coefficients to be computed before concluding that a\n * given power series is zero */\n\n\n\n/*TODO COMMENT FROM AYAL: This parameter, 15, seems to be a bit arbitrary. This implies that there is an input\n   with more than 15 zeroes, and then a non-zero coefficient, that this would fail on. Correct? Is there not\n   a more accurate estimation of this parameter?\n */\nTaylor'LPS'Param1() := 15;\n\n/**********************************************************************\n *\n * Taylor'LPS'Construct(var, expr)\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * construct a LPS\n * PRE:  var is a name\n * POST: returns a well-formed LPS\n */\n\n10 # Taylor'LPS'Construct(_var, _expr)\n   <-- Taylor'LPS(Undefined, {}, var, Taylor'LPS'NormalizeExpr(var, expr));\n\n/**********************************************************************\n *\n * Taylor'LPS'Coeffs(lps, n1, n2)\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * List of coefficients of order n1 up to n2\n * PRE:  lps is a well-formed LPS, n1 in Z, n2 in Z, n2 >= n1\n * POST: returns list of length n2-n1+1,\n *       or raises \"dunno\", \"div-by-zero\", or \"maybe-div-by-zero\"\n *       lps may be changed, but it's still a well-formed LPS\n */\n\nTaylor'LPS'Coeffs(_lps, _n1, _n2) <--\n[\n   Local(res, finished, order, j, k, n, tmp, c1, c2);\n   finished := False;\n\n   /* Case 1: Zero power series */\n\n   If (lps[1] =? Infinity,\n   [\n      res := FillList(0, n2-n1+1);\n      finished := True;\n   ]);\n\n   /* Case 2: Coefficients are already computed */\n\n   If (Not? finished And? lps[1] !=? Undefined And? n2 <? lps[1]+Length(lps[2]),\n   [\n      If (n1 >=? lps[1],\n          res := Take(lps[2], {n1-lps[1]+1, n2-lps[1]+1}),\n          If (n2 >=? lps[1],\n              res := Concat(FillList(0, lps[1]-n1),\n                             Take(lps[2], n2-lps[1]+1)),\n              res := FillList(0, n2-n1+1)));\n      finished := True;\n   ]);\n\n   /* Case 3: We need to compute the coefficients */\n\n   If (Not? finished,\n   [\n      /* Subcase 3a: Expression is recognized by Taylor'LPS'CompOrder */\n\n      order := Taylor'LPS'CompOrder(lps[3], lps[4]);\n      If (Not? ClearError(\"dunno\"),\n      [\n         If (lps[1] =? Undefined,\n         [\n            lps[1] := order;\n            If (order <=? n2,\n            [\n               lps[2] := Table(Taylor'LPS'CompCoeff(lps[3], lps[4], n),\n                               n, order, n2, 1);\n            ]);\n         ],[\n            tmp := Table(Taylor'LPS'CompCoeff(lps[3], lps[4], n),\n                         n, lps[1]+Length(lps[2]), n2, 1);\n            lps[2] := Concat(lps[2], tmp);\n         ]);\n         finished := True;\n      ]);\n\n      /* Subcase 3b: Addition */\n\n      If (Not? finished And? lps[4][0] =? Taylor'LPS'Add,\n      [\n         lps[1] := Minimum(Taylor'LPS'GetOrder(lps[4][1])[1],\n                       Taylor'LPS'GetOrder(lps[4][2])[1], n2);\n         If (IsError(\"dunno\"),\n         [\n            ClearError(\"dunno\");\n            ClearError(\"dunno\");\n         ],[\n               If (lps[1] <=? n2,\n            [\n               c1 := Taylor'LPS'Coeffs(lps[4][1], lps[1] + Length(lps[2]), n2);\n               c2 := Taylor'LPS'Coeffs(lps[4][2], lps[1] + Length(lps[2]), n2);\n                  lps[2] := Concat(lps[2], c1 + c2);\n            ]);\n               finished := True;\n         ]);\n      ]);\n\n      /* Subcase 3c: Scalar multiplication */\n\n      If (Not? finished And? lps[4][0] =? Taylor'LPS'ScalarMult,\n      [\n         lps[1] := Minimum(Taylor'LPS'GetOrder(lps[4][2])[1], n2);\n         If (Not? ClearError(\"dunno\"),\n         [\n               If (lps[1] <=? n2,\n            [\n               tmp := Taylor'LPS'Coeffs(lps[4][2],\n                                        lps[1] + Length(lps[2]), n2);\n               tmp := lps[4][1] * tmp;\n               lps[2] := Concat(lps[2], tmp);\n            ]);\n               finished := True;\n         ]);\n      ]);\n\n      /* Subcase 3d: Multiplication */\n\n      If (Not? finished And? lps[4][0] =? Taylor'LPS'Multiply,\n      [\n         lps[1] := Taylor'LPS'GetOrder(lps[4][1])[1]\n                   + Taylor'LPS'GetOrder(lps[4][2])[1];\n         If (IsError(\"dunno\"),\n         [\n            ClearError(\"dunno\");\n            ClearError(\"dunno\");\n         ],[\n               If (lps[1] <=? n2,\n            [\n               c1 := Taylor'LPS'Coeffs(lps[4][1], lps[4][1][1],\n                                       n2 - lps[4][2][1]);\n               c2 := Taylor'LPS'Coeffs(lps[4][2], lps[4][2][1],\n                                       n2 - lps[4][1][1]);\n               tmp := lps[2];\n               ForEach(k, (Length(lps[2])+1) .. Length(c1))\n                  tmp := Append(tmp, Sum(j, 1, k, c1[j]*c2[k+1-j]));\n               lps[2] := tmp;\n            ]);\n               finished := True;\n         ]);\n      ]);\n\n      /* Subcase 3e: Inversion */\n\n      If (Not? finished And? lps[4][0] =? Taylor'LPS'Inverse,\n      [\n         If (lps[4][1][1] =? Infinity,\n         [\n            Assert(\"div-by-zero\") False;\n            finished := True;\n         ]);\n         If (Not? finished And? lps[2] =? {},\n         [\n            order := Taylor'LPS'GetOrder(lps[4][1])[1];\n            n := order;\n            c1 := Taylor'LPS'Coeffs(lps[4][1], n, n)[1];\n            While (c1 =? 0 And? n <? order + Taylor'LPS'Param1())\n            [\n               n := n + 1;\n                c1 := Taylor'LPS'Coeffs(lps[4][1], n, n)[1];\n            ];\n            If (c1 =? 0,\n            [\n               Assert(\"maybe-div-by-zero\") False;\n               finished := True;\n            ]);\n         ]);\n         If (Not? finished,\n         [\n            lps[1] := -lps[4][1][1];\n            c1 := Taylor'LPS'Coeffs(lps[4][1], lps[4][1][1],\n                                    lps[4][1][1]+n2-lps[1]);\n            tmp := lps[2];\n            If (tmp =? {}, tmp := {1/c1[1]});\n            If (Length(c1)>?1,\n            [\n               ForEach(k, (Length(tmp)+1) .. Length(c1))\n               [\n                  n := -Sum(j, 1, k-1, c1[k+1-j]*tmp[j]) / c1[1];\n                  tmp := Append(tmp, n);\n               ];\n            ]);\n            lps[2] := tmp;\n            finished := True;\n         ]);\n      ]);\n\n      /* Subcase 3f: Composition */\n\n      If (Not? finished And? lps[4][0] =? Taylor'LPS'Compose,\n      [\n         j := Taylor'LPS'GetOrder(lps[4][1])[1];\n         Check(j >=? 0, \"Math\", \"Expansion of f(g(x)) where f has a\"\n                       : \"singularity is not implemented\");\n         k := Taylor'LPS'GetOrder(lps[4][2])[1];\n         c1 := {j, Taylor'LPS'Coeffs(lps[4][1], j, n2)};\n         c2 := {k, Taylor'LPS'Coeffs(lps[4][2], k, n2)};\n         c1 := Taylor'TPS'Compose(c1, c2);\n         lps[1] := c1[1];\n         lps[2] := c1[2];\n         finished := True;\n      ]);\n\n      /* Case 3: The end */\n\n      If (finished,\n      [\n         /* normalization: remove initial zeros from lps[2] */\n\n         While (lps[2] !=? {} And? lps[2][1] =? 0)\n         [\n            lps[1] := lps[1] + 1;\n            lps[2] := Rest(lps[2]);\n         ];\n\n         /* get result */\n\n         If (Not? IsError(\"dunno\") And? Not? IsError(\"div-by-zero\")\n             And? Not? IsError(\"maybe-div-by-zero\"),\n         [\n            If (lps[1] <=? n1,\n                res := Take(lps[2], {n1-lps[1]+1, n2-lps[1]+1}),\n                If (lps[1] <=? n2,\n                    res := Concat(FillList(0, lps[1]-n1), lps[2]),\n                    res := FillList(0, n2-n1+1)));\n         ]);\n      ],[\n         Assert(\"dunno\") False;\n         res := False;\n      ]);\n   ]);\n\n   /* Return res */\n\n   res;\n];\n\n\n/**********************************************************************\n *\n * Truncated power series\n * ~~~~~~~~~~~~~~~~~~~~~~\n * Here is the start of an implementation of truncated power series.\n * This should be cleaned up.\n *\n * {n, {a0,a1,a2,a3,...}} represents\n * a0 x^n + a1 x^(n+1) + a2 x^(n+2) + a3 x^(n+3) + ...\n *\n * The function Taylor'TPS'Add(tps1, tps2) adds two of such beasts,\n * and returns the sum in the same truncated power series form.\n * Similar for the other functions.\n */\n\n10 # Taylor'TPS'GetCoeff({_n,_c}, _k) _ (k <? n) <-- 0;\n10 # Taylor'TPS'GetCoeff({_n,_c}, _k) _ (k >=? n+Length(c)) <-- Undefined;\n20 # Taylor'TPS'GetCoeff({_n,_c}, _k) <-- c[k-n+1];\n\n\n10 # Taylor'TPS'Add({_n1,_c1}, {_n2,_c2}) <--\n[\n   Local(n, len, c1b, c2b);\n   n := Minimum(n1,n2);\n   len := Minimum(n1+Length(c1), n2+Length(c2)) - n;\n   c1b := Take(Concat(FillList(0, n1-n), c1), len);\n   c2b := Take(Concat(FillList(0, n2-n), c2), len);\n   {n, c1b+c2b};\n];\n\n10 # Taylor'TPS'ScalarMult(_a, {_n2,_c2}) <-- {n2, a*c2};\n\n10 # Taylor'TPS'Multiply({_n1,_c1}, {_n2,_c2}) <--\n[\n   Local(j,k,c);\n   c := {};\n   For (k:=1, k<=?Minimum(Length(c1), Length(c2)), k++)\n   [\n      c := c : Sum(j, 1, k, c1[j]*c2[k+1-j]);\n   ];\n   {n1+n2, c};\n];\n\n10 # Taylor'TPS'Compose({_n1,_c1}, {_n2,_c2}) <--\n[\n   Local(res, tps, tps2, k, n);\n   n := Minimum(n1+Length(c1)-1, n2+Length(c2)-1);\n   tps := {0, 1 : FillList(0, n)}; // tps =? {n2,c2} ^ k\n   res := Taylor'TPS'ScalarMult(Taylor'TPS'GetCoeff({n1,c1}, 0), tps);\n   For (k:=1, k<=?n, k++)\n   [\n      tps := Taylor'TPS'Multiply(tps, {n2,c2});\n      tps2 := Taylor'TPS'ScalarMult(Taylor'TPS'GetCoeff({n1,c1}, k), tps);\n      res := Taylor'TPS'Add(res, tps2);\n   ];\n   res;\n];\n\n\n\n/**********************************************************************\n *\n * Taylor'LPS'NormalizeExpr(var, expr)\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * Return expr, with \"+\" replaced by Taylor'LPS'Add, etc.\n * PRE:  var is a name\n */\n\n5 # Taylor'LPS'NormalizeExpr(_var, _e1)\n  _ [Taylor'LPS'CompOrder(var,e1); Not? ClearError(\"dunno\");]\n  <-- e1;\n\n10 # Taylor'LPS'NormalizeExpr(_var, _e1 + _e2)\n   <-- Taylor'LPS'Add(Taylor'LPS'Construct(var, e1),\n                      Taylor'LPS'Construct(var, e2));\n\n10 # Taylor'LPS'NormalizeExpr(_var, - _e1)\n   <-- Taylor'LPS'ScalarMult(-1, Taylor'LPS'Construct(var, e1));\n\n10 # Taylor'LPS'NormalizeExpr(_var, _e1 - _e2)\n   <-- (Taylor'LPS'Add(Taylor'LPS'Construct(var, e1),\n                       Taylor'LPS'Construct(var, e3))\n        Where e3 == Taylor'LPS'ScalarMult(-1, Taylor'LPS'Construct(var, e2)));\n\n10 # Taylor'LPS'NormalizeExpr(_var, e1_IsFreeOf(var) * _e2)\n   <-- Taylor'LPS'ScalarMult(e1, Taylor'LPS'Construct(var, e2));\n\n10 # Taylor'LPS'NormalizeExpr(_var, _e1 * e2_IsFreeOf(var))\n   <-- Taylor'LPS'ScalarMult(e2, Taylor'LPS'Construct(var, e1));\n\n20 # Taylor'LPS'NormalizeExpr(_var, _e1 * _e2)\n   <-- Taylor'LPS'Multiply(Taylor'LPS'Construct(var, e1),\n                           Taylor'LPS'Construct(var, e2));\n\n10 # Taylor'LPS'NormalizeExpr(_var, _e1 / e2_IsFreeOf(var))\n   <-- Taylor'LPS'ScalarMult(1/e2, Taylor'LPS'Construct(var, e1));\n\n20 # Taylor'LPS'NormalizeExpr(_var, 1 / _e1)\n   <-- Taylor'LPS'Inverse(Taylor'LPS'Construct(var, e1));\n\n30 # Taylor'LPS'NormalizeExpr(_var, _e1 / _e2)\n   <-- (Taylor'LPS'Multiply(Taylor'LPS'Construct(var, e1),\n                            Taylor'LPS'Construct(var, e3))\n        Where e3 == Taylor'LPS'Inverse(Taylor'LPS'Construct(var, e2)));\n\n/* Implement powers as repeated multiplication,\n * which is seriously inefficient.\n */\n10 # Taylor'LPS'NormalizeExpr(_var, _e1 ^ (n_IsPositiveInteger))\n   _ (e1 !=? var)\n   <-- Taylor'LPS'Multiply(Taylor'LPS'Construct(var, e1),\n                           Taylor'LPS'Construct(var, e1^(n-1)));\n\n10 # Taylor'LPS'NormalizeExpr(_var, Tan(_x))\n   <-- (Taylor'LPS'Multiply(Taylor'LPS'Construct(var, Sin(x)),\n                            Taylor'LPS'Construct(var, e3))\n        Where e3 == Taylor'LPS'Inverse(Taylor'LPS'Construct(var, Cos(x))));\n\nLocalSymbols(res)\n[\n50 # Taylor'LPS'NormalizeExpr(_var, _e1)\n_[\n    Local(c, lps1, lps2, lps3, success);\n    success := True;\n    If (IsAtom(e1), success := False);\n    If (success And? Length(e1) !=? 1, success := False);\n    If (success And? IsAtom(e1[1]), success := False);\n    If (success And? CanBeUni(var, e1[1]) And? Degree(e1[1], var) =? 1,\n    [\n       success := False;\n    ]);\n    If (success,\n    [\n       lps2 := Taylor'LPS'Construct(var, e1[1]);\n       c := Taylor'LPS'Coeffs(lps2, 0, 0)[1];\n       If (IsError(),\n       [\n          ClearErrors();\n          success := False;\n       ]);\n       If (success And? Taylor'LPS'GetOrder(lps2)[1] <? 0,\n       [\n          success := False;\n       ],[\n          If (c =? 0,\n          [\n             lps1 := Taylor'LPS'Construct(var, Apply(e1[0], {var}));\n             res := Taylor'LPS'Compose(lps1, lps2);\n          ],[\n             lps1 := Taylor'LPS'Construct(var, Apply(e1[0], {var+c}));\n             lps3 := Taylor'LPS'Construct(var, -c);\n             lps2 := Taylor'LPS'Construct(var, Taylor'LPS'Add(lps2, lps3));\n             res := Taylor'LPS'Compose(lps1, lps2);\n          ]);\n       ]);\n    ]);\n    success;\n ] <-- res;\n];\n\n60000 # Taylor'LPS'NormalizeExpr(_var, _e1) <-- e1;\n\n\n/**********************************************************************\n *\n * Taylor'LPS'CompOrder(var, expr)  ---  HOOK\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * Compute order of expr as a power series in var\n * PRE:  var is a name\n * POST: returns an integer, or raises \"dunno\"\n *\n * Taylor'LPS'CompCoeff(var, expr, n)  ---  HOOK\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * Compute n-th coefficient of expr as a power series in var\n * PRE:  var is a name, n is an integer,\n *       Taylor'LPS'CompOrder(var, expr) does not raise \"dunno\"\n * POST: returns an expression not containing var\n */\n\n5  # Taylor'LPS'CompCoeff(_var, _expr, _n)\n   _ (n <? Taylor'LPS'CompOrder(var, expr))\n   <-- 0;\n\n/* Zero */\n\n10 # Taylor'LPS'CompOrder(_x, 0) <-- Infinity;\n\n/* Constant */\n\n20 # Taylor'LPS'CompOrder(_x, e_IsFreeOf(x))     <-- 0;\n20 # Taylor'LPS'CompCoeff(_x, e_IsFreeOf(x), 0)  <-- e;\n21 # Taylor'LPS'CompCoeff(_x, e_IsFreeOf(x), _n) <-- 0;\n\n/* Identity */\n\n30 # Taylor'LPS'CompOrder(_x, _x)     <-- 1;\n30 # Taylor'LPS'CompCoeff(_x, _x, 1)  <-- 1;\n31 # Taylor'LPS'CompCoeff(_x, _x, _n) <-- 0;\n\n/* Powers */\n\n40 # Taylor'LPS'CompOrder(_x, _x^(k_IsPositiveInteger))     <-- k;\n40 # Taylor'LPS'CompCoeff(_x, _x^(k_IsPositiveInteger), _k) <-- 1;\n41 # Taylor'LPS'CompCoeff(_x, _x^(k_IsPositiveInteger), _n) <-- 0;\n\n/* Sqrt */\n\n50 # Taylor'LPS'CompOrder(_x, Sqrt(_y))\n   _ (CanBeUni(x,y) And? Degree(y,x) =? 1 And? Coef(y,x,0) !=? 0)\n   <-- 0;\n\n50 # Taylor'LPS'CompCoeff(_x, Sqrt(_y), 0)\n   _ (CanBeUni(x,y) And? Degree(y,x) =? 1 And? Coef(y,x,0) !=? 0)\n   <-- Sqrt(Coef(y,x,0));\n\n51 # Taylor'LPS'CompCoeff(_x, Sqrt(_y), _n)\n   _ (CanBeUni(x,y) And? Degree(y,x) =? 1 And? Coef(y,x,0) !=? 0) <--\n[\n   Local(j);\n   Coef(y,x,0)^(1/2-n) * Product(j,0,n-1,1/2-j) * Coef(y,x,1)^n/n!;\n];\n\n/* Exp */\n\n60 # Taylor'LPS'CompOrder(_x, Exp(_x))     <-- 0;\n60 # Taylor'LPS'CompCoeff(_x, Exp(_x), _n) <-- 1/n!;\n\n70 # Taylor'LPS'CompOrder(_x, Exp(_y))_(CanBeUni(x,y) And? Degree(y,x) =? 1)\n   <-- 0;\n\n70 # Taylor'LPS'CompCoeff(_x, Exp(_y), _n)_(CanBeUni(x,y) And? Degree(y,x) =? 1)\n   <-- Exp(Coef(y,x,0)) * Coef(y,x,1)^n / n!;\n\n/* Ln */\n\n80 # Taylor'LPS'CompOrder(_x, Ln(_x+1))     <-- 1;\n80 # Taylor'LPS'CompCoeff(_x, Ln(_x+1), _n) <-- (-1)^(n+1)/n;\n\n/* Sin */\n\n90 # Taylor'LPS'CompOrder(_x, Sin(_x))           <-- 1;\n90 # Taylor'LPS'CompCoeff(_x, Sin(_x), n_IsOdd)  <-- (-1)^((n-1)/2) / n!;\n90 # Taylor'LPS'CompCoeff(_x, Sin(_x), n_IsEven) <-- 0;\n\n/* Cos */\n\n100 # Taylor'LPS'CompOrder(_x, Cos(_x))           <-- 0;\n100 # Taylor'LPS'CompCoeff(_x, Cos(_x), n_IsOdd)  <-- 0;\n100 # Taylor'LPS'CompCoeff(_x, Cos(_x), n_IsEven) <-- (-1)^(n/2) / n!;\n\n/* Inverse (not needed but speeds things up) */\n\n110 # Taylor'LPS'CompOrder(_x, 1/_x)     <-- -1;\n110 # Taylor'LPS'CompCoeff(_x, 1/_x, -1) <-- 1;\n111 # Taylor'LPS'CompCoeff(_x, 1/_x, _n) <-- 0;\n\n\n/*COMMENT FROM AYAL: Jitse, what do you think, fall-through defaulting to calculating the coefficient\n  the hard way? Worst-case, if people define a taylor series in this module it is faster, otherwise it uses\n  the old scheme that does explicit derivatives, which is slower, but still better than not returning a result\n  at all? With this change the new taylor code is at least as good as the old code?\n\n  The ugly part is obvious: instead of having a rule here that says \"I work for the following input\" I had to\n  find out empirically what the \"exclude list\" is, eg. the input it will not work on. This because the system\n  as it works currently yields \"dunno\", at which moment some other routine picks up.\n\n  I think we can refactor this.\n */\n\n\n\n\nTaylor'LPS'AcceptDeriv(_expr) <--\n        (Contains({\"ArcTan\"},Type(expr)));\n/*\n        ( Type(Deriv(x)(expr)) !=? \"Deriv\"\n         And? Not? Contains({\n          \"/\",\"+\",\"*\",\"^\",\"-\",\"Sin\",\"Cos\",\"Sqrt\",\"Ln\",\"Exp\",\"Tan\"\n          },Type(expr)));\n*/\n\n200 # Taylor'LPS'CompOrder(_x, (_expr))_(Taylor'LPS'AcceptDeriv(expr))\n    <--\n    [\n//Echo(\"CompOrder for \",expr);\n//      0; //generic case, assume zeroeth coefficient is non-zero.\n      Local(n);\n      n:=0;\n      While ((Limit(x,0)expr) =? 0 And? n<?Taylor'LPS'Param1())\n      [\n        expr := Deriv(x)expr;\n        n++;\n      ];\n//Echo(\" is \",n);\n      n;\n    ];\n200 # Taylor'LPS'CompCoeff(_x, (_expr), _n)_\n      (Taylor'LPS'AcceptDeriv(expr) And? n>=?0 ) <--\n    [\n    // This routine is written out for debugging purposes\n      Local(result);\n      result:=(Limit(x,0)(Deriv(x,n)expr))/(n!);\nEcho(expr,\" \",n,\" \",result);\n      result;\n    ];\n\n/* Default */\n\n60000 # Taylor'LPS'CompOrder(_var, _expr)\n      <-- Assert(\"dunno\") False;\n\n60000 # Taylor'LPS'CompCoeff(_var, _expr, _n)\n      <-- Check(False, \"Argument\", \"Taylor'LPS'CompCoeff'FallThrough\"\n                       : PipeToString() Write({var,expr,n}));\n\n/**********************************************************************\n *\n * Taylor'LPS'GetOrder(lps)\n * ~~~~~~~~~~~~~~~~~~~~~~~~\n * Returns a pair {n,flag}. If flag is True, then n is the order of\n * the LPS. If flag is False, then n is a lower bound on the order.\n * PRE:  lps is a well-formed LPS\n * POST: returns a pair {n,flag}, where n is an integer or Infinity,\n *       and flag is True or False, or raises \"dunno\";\n *       may update lps.\n */\n\n20 # Taylor'LPS'GetOrder(Taylor'LPS(_order, _coeffs, _var, _expr))\n   _ (order !=? Undefined)\n   <-- {order, coeffs !=? {}};\n\n40 # Taylor'LPS'GetOrder(_lps) <--\n[\n   Local(res, computed, exact, res1, res2);\n   computed := False;\n\n   res := Taylor'LPS'CompOrder(lps[3], lps[4]);\n   If (Not? ClearError(\"dunno\"),\n   [\n      res := {res, True};\n      computed := True;\n   ]);\n\n   If (Not? computed And? lps[4][0] =? Taylor'LPS'Add,\n   [\n      res1 := Taylor'LPS'GetOrder(lps[4][1]);\n      If (Not? ClearError(\"dunno\"),\n      [\n         res2 := Taylor'LPS'GetOrder(lps[4][2]);\n         If (Not? ClearError(\"dunno\"),\n         [\n            res := {Minimum(res1[1],res2[1]), False};\n            /* flag = False, since terms may cancel */\n            computed := True;\n         ]);\n      ]);\n   ]);\n\n   If (Not? computed And? lps[4][0] =? Taylor'LPS'ScalarMult,\n   [\n      res := Taylor'LPS'GetOrder(lps[4][2]);\n      If (Not? ClearError(\"dunno\"), computed := True);\n   ]);\n\n   If (Not? computed And? lps[4][0] =? Taylor'LPS'Multiply,\n   [\n      res1 := Taylor'LPS'GetOrder(lps[4][1]);\n      If (Not? ClearError(\"dunno\"),\n      [\n         res2 := Taylor'LPS'GetOrder(lps[4][2]);\n         If (Not? ClearError(\"dunno\"),\n         [\n            res := {res1[1]+res2[1], res1[1] And? res2[1]};\n            computed := True;\n         ]);\n      ]);\n   ]);\n\n   If (Not? computed And? lps[4][0] =? Taylor'LPS'Inverse,\n   [\n      res := Taylor'LPS'GetOrder(lps[4][1]);\n      If (Not? ClearError(\"dunno\"),\n      [\n         If (res[1] =? Infinity,\n         [\n            res[1] =? Undefined;\n            Assert(\"div-by-zero\") False;\n            computed := True;\n         ]);\n         If (Not? computed And? res[2] =? False,\n         [\n            Local(c, n);\n            n := res[1];\n            c := Taylor'LPS'Coeffs(lps[4][1], res[1], res[1])[1];\n            While (c =? 0 And? res[1] <? n + Taylor'LPS'Param1())\n            [\n               res[1] := res[1] + 1;\n                c := Taylor'LPS'Coeffs(lps[4][1], res[1], res[1])[1];\n            ];\n            If (c =? 0,\n            [\n               res[1] := Undefined;\n               Assert(\"maybe-div-by-zero\") False;\n               computed := True;\n            ]);\n         ]);\n         If (Not? computed,\n         [\n            res := {-res[1], True};\n            computed := True;\n         ]);\n      ]);\n   ]);\n\n   If (Not? computed And? lps[4][0] =? Taylor'LPS'Compose,\n   [\n      res1 := Taylor'LPS'GetOrder(lps[4][1]);\n      If (Not? ClearError(\"dunno\"),\n      [\n         res2 := Taylor'LPS'GetOrder(lps[4][2]);\n         If (Not? ClearError(\"dunno\"),\n         [\n            res := {res1[1]*res2[1], res1[1] And? res2[1]};\n            computed := True;\n         ]);\n      ]);\n   ]);\n\n   If (computed, lps[1] := res[1]);\n   Assert(\"dunno\") computed;\n   res;\n];\n\n/**********************************************************************\n *\n * Taylor'LPS'PowerSeries(lps, n, var)\n * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n * Convert the LPS in a power series in var up to order n\n * PRE:  lps is a well-formed LPS, n is a natural number\n * POST: returns an expression, or raises \"singularity\" or \"dunno\"\n */\n\n10 # Taylor'LPS'PowerSeries(_lps, _n, _var) <--\n[\n   Local(ord, k, coeffs);\n   coeffs := Taylor'LPS'Coeffs(lps, 0, n);\n   If (IsError(\"dunno\"),\n   [\n      False;\n   ],[\n      If (lps[1] <? 0,\n      [\n         Assert(\"singularity\") False;\n         Undefined;\n      ],[\n         Sum(k, 0, n, coeffs[k+1]*var^k);\n      ]);\n   ]);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Taylor2.mpw";
        scriptMap.put("Taylor2",scriptString);
        scriptMap.put("Taylor'LPS",scriptString);
        scriptMap.put("Taylor'LPS'NormalizeExpr",scriptString);
        scriptMap.put("Taylor'LPS'Construct",scriptString);
        scriptMap.put("Taylor'LPS'PowerSeries",scriptString);
        scriptMap.put("Taylor'LPS'Coeffs",scriptString);
        scriptMap.put("Taylor'LPS'Inverse",scriptString);
        scriptMap.put("Taylor'LPS'Add",scriptString);
        scriptMap.put("Taylor'LPS'Multiply",scriptString);
        scriptMap.put("Taylor'LPS'ScalarMult",scriptString);
        scriptMap.put("Taylor'LPS'Compose",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n\n/* Taylor3, implementation of Taylor series expansion by doing calculation on series directly.\n */\n\nDefun(\"Taylor3'MultiplyCoefs\",{coefs1,coefs2,degree})\n[\n  Local(result,i,j,jset,ilimit,jlimit);\n  Bind(result, ArrayCreate(AddN(degree,1),0));\n  Bind(i,1);\n  Bind(ilimit,AddN(degree,2));\n  While (Not? IsEqual(i,ilimit))\n  [\n//Echo(coefs1,coefs2);\n    Bind(j,1);\n    Bind(jlimit,AddN(degree,SubtractN(3,i)));\n    While (Not? IsEqual(j,jlimit))\n    [\n      Bind(jset,AddN(i,SubtractN(j,1)));\n//Echo(\"index = \",i+j-1);\n      ArraySet(result,jset,ArrayGet(result,jset) + ArrayGet(coefs1,i)*ArrayGet(coefs2,j));\n      Bind(j,AddN(j,1));\n    ];\n    Bind(i,AddN(i,1));\n  ];\n  result;\n];\n\n\n10 # (Taylor3'TaylorCoefs(_var,_degree)(_var)) <--\n[\n  Local(result);\n  Bind(result,ArrayCreate(degree+1,0));\n  ArraySet(result,2, 1);\n  result;\n//Echo(\"degree = \",degree);\n//  BaseVector(2,degree+1);\n];\n20 # (Taylor3'TaylorCoefs(_var,_degree)(_atom))_(IsFreeOf(var,atom))\n   <--\n   [\n    Local(result);\n    Bind(result,ArrayCreate(degree+1,0));\n    ArraySet(result,1, atom);\n    result;\n//     atom*BaseVector(1,degree+1);\n   ];\n30 # (Taylor3'TaylorCoefs(_var,_degree)(_X + _Y))\n   <--\n   [\n     Local(result,add,i);\n     Bind(result,Taylor3'TaylorCoefs(var,degree)(X));\n     Bind(add, Taylor3'TaylorCoefs(var,degree)(Y));\n     For(i:=1,i<=?degree+1,i++)\n     [\n       ArraySet(result,i,ArrayGet(result,i)+ArrayGet(add,i));\n     ];\n     result;\n   ];\n\n30 # (Taylor3'TaylorCoefs(_var,_degree)(_X - _Y))\n   <--\n   [\n     Local(result,add,i);\n     Bind(result,Taylor3'TaylorCoefs(var,degree)(X));\n     Bind(add, Taylor3'TaylorCoefs(var,degree)(Y));\n     For(i:=1,i<=?degree+1,i++)\n     [\n       ArraySet(result,i,ArrayGet(result,i)-ArrayGet(add,i));\n     ];\n     result;\n   ];\n\n30 # (Taylor3'TaylorCoefs(_var,_degree)(   - _Y))\n   <--\n   [\n     Local(result,add,i);\n     Bind(result,Taylor3'TaylorCoefs(var,degree)(Y));\n     For(i:=1,i<=?degree+1,i++)\n     [\n       ArraySet(result,i,-ArrayGet(result,i));\n     ];\n     result;\n   ];\n\n30 # (Taylor3'TaylorCoefs(_var,_degree)(_X * _Y))\n   <-- Taylor3'MultiplyCoefs(\n         Taylor3'TaylorCoefs(var,degree)(X),\n         Taylor3'TaylorCoefs(var,degree)(Y),\n         degree);\n\n30 # (Taylor3'TaylorCoefs(_var,_degree)((_X) ^ N_IsPositiveInteger))\n  <--\n[\n  Local(result,factor);\n  factor:=Taylor3'TaylorCoefs(var,degree)(X);\n  result:=ArrayCreate(degree+1,0);\n  result[1] := 1;\n  //TODO@@@ optimize\n  While(N>?0)\n  [\n    result:=Taylor3'MultiplyCoefs(result,factor,degree);\n    N--;\n  ];\n  result;\n];\n\n60 # Taylor3'UniFunction(\"Exp\")     <-- True;\n60 # Taylor3'CompCoeff(\"Exp\", _n) <-- 1/n!;\n\n80 # Taylor3'UniFunction(\"Ln\")     <-- False; // False because this rule is only applicable for Ln(x+1)\n80 # Taylor3'CompCoeff(\"Ln\", 0) <-- 0;\n81 # Taylor3'CompCoeff(\"Ln\", _n) <-- (-1)^(n+1)/n;\n\n90 # Taylor3'UniFunction(\"Sin\")           <-- True;\n90 # Taylor3'CompCoeff(\"Sin\", n_IsOdd)  <-- (-1)^((n-1)/2) / n!;\n90 # Taylor3'CompCoeff(\"Sin\", n_IsEven) <-- 0;\n\n100 # Taylor3'UniFunction(\"Cos\")           <-- True;\n100 # Taylor3'CompCoeff(\"Cos\", n_IsOdd)  <-- 0;\n100 # Taylor3'CompCoeff(\"Cos\", n_IsEven) <-- (-1)^(n/2) / n!;\n\n\n210 # Taylor3'UniFunction(_any)_\n      (\n        [\n          Local(result);\n          result:= Deriv(var)ListToFunction({ToAtom(any),var});\n          Type(result) !=? \"Deriv\";\n        ]\n      )           <--\n      [\n        True;\n      ];\n210 # Taylor3'CompCoeff(_any, n_IsInteger)\n    <--\n    [\n      Limit(var,0)(Deriv(var,n)(ListToFunction({ToAtom(any),var}))/n!);\n    ];\n\n\n\n60000 # Taylor3'UniFunction(_any) <-- False;\n\n\nTaylor3'FuncCoefs(_fname,_degree) <--\n[\n  Local(sins,i);\n  Bind(sins, ArrayCreate(degree+1,0));\n  For (i:=0,i<=?degree,Bind(i,i+1))\n  [\n    ArraySet(sins,i+1, Taylor3'CompCoeff(fname,i));\n  ];\n  sins;\n];\n\n\n100 # (Taylor3'TaylorCoefs(_var,_degree)(Ln(_f)))_(Simplify(f-1) =? var) <-- Taylor3'FuncCoefs(\"Ln\",degree);\n\n\n110 # (Taylor3'TaylorCoefs(_var,_degree)(f_IsFunction))_(ArgumentsCount(f) =? 1 And? (Taylor3'UniFunction(Type(f)))) <--\n[\n  Local(sins,i,j,result,xx,expr,sinfact);\n  expr := f[1];\n  sins:=Taylor3'FuncCoefs(Type(f),degree);\n//Echo(\"sins = \",sins);\n  expr:=Taylor3'TaylorCoefs(var,degree)expr;\n  result:=ArrayCreate(degree+1,0);\n  ArraySet(result,1, ArrayGet(sins,1));\n  xx:=expr;\n//Echo(\"8...\",sins,expr);\n  For (i:=2,i<=?degree+1,i++)\n  [\n    Bind(sinfact,sins[i]);\n//Echo(\"8.1..\",i,\" \",j);\n    For (j:=1,j<=?degree+1,j++)\n    [\n      ArraySet(result,j,ArrayGet(result,j) + (ArrayGet(xx,j) * sinfact));\n    ];\n//Echo(\"8.2..\");\n    Bind(xx,Taylor3'MultiplyCoefs(xx,expr,degree));\n//Echo(\"8.3..\");\n  ];\n  result;\n];\n\n\n(Taylor3(_var,_degree)(_expr)) <-- Add((Taylor3'TaylorCoefs(var,degree)(expr))[1 .. degree+1]*var^(0 .. degree));\n10 # (Taylor3(_x,  0, _n) _y) <--              Taylor3(x,n)              y;\n20 # (Taylor3(_x, _a, _n) _y) <-- Subst(x,x-a) Taylor3(x,n) Subst(x,x+a) y;\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/Taylor3.mpw";
        scriptMap.put("Taylor3",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// partial factorial\nn1_IsRationalOrNumber *** n2_IsRationalOrNumber <--\n[\n        Check(n2-n1 <=? 65535, \"Argument\", \"Partial factorial: Error: the range \" : ( PipeToString() Write(n2-n1) ) : \" is too large, you may want to avoid exact calculation\");\n        If(n2-n1<?0,\n                1,\n                Factorial'partial(n1, n2)\n        );\n];\n\n/// recursive routine to evaluate \"partial factorial\" a*(a+1)*...*b\n// TODO lets document why the >>1 as used here is allowed (rounding down? What is the idea behind this algorithm?)\n2# Factorial'partial(_a, _b) _ (b-a>=?4) <-- Factorial'partial(a, a+((b-a)>>1)) * Factorial'partial(a+((b-a)>>1)+1, b);\n3# Factorial'partial(_a, _b) _ (b-a>=?3) <-- a*(a+1)*(a+2)*(a+3);\n4# Factorial'partial(_a, _b) _ (b-a>=?2) <-- a*(a+1)*(a+2);\n5# Factorial'partial(_a, _b) _ (b-a>=?1) <-- a*(a+1);\n6# Factorial'partial(_a, _b) _ (b-a>=?0) <-- a;\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/asterisk_asterisk_asterisk_operator.mpw";
        scriptMap.put("***",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/// even/odd double factorial: product of even or odd integers up to n\n1# (n_IsPositiveInteger)!! _ (n<=?3) <-- n;\n2# (n_IsPositiveInteger)!! <--\n[\n        Check(n<=?65535, \"Argument\", \"Double factorial: Error: the argument \" : ( PipeToString() Write(n) ) : \" is too large, you may want to avoid exact calculation\");\n        Factorial'double(2+Modulo(n, 2), n);\n];\n// special cases\n3# (_n)!! _ (n=? -1 Or? n=?0)<-- 1;\n\n// the purpose of this mess \"Quotient(a+b,2)+1+Modulo(Quotient(a+b,2)+1-a, 2)\" is to obtain the smallest integer which is >= Quotient(a+b,2)+1 and is also odd or even when a is odd or even; we need to add at most 1 to (Quotient(a+b,2)+1)\n2# Factorial'double(_a, _b) _ (b-a>=?6) <-- Factorial'double(a, Quotient(a+b,2)) * Factorial'double(Quotient(a+b,2)+1+Modulo(Quotient(a+b,2)+1-a, 2), b);\n3# Factorial'double(_a, _b) _ (b-a>=?4) <-- a*(a+2)*(a+4);\n4# Factorial'double(_a, _b) _ (b-a>=?2) <-- a*(a+2);\n5# Factorial'double(_a, _b) <-- a;\n\n/// double factorial for lists is threaded\n30 # (n_IsList)!! <-- MapSingle(\"!!\",n);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/exclamationpoint_exclamationpoint_operator.mpw";
        scriptMap.put("!!",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Factorials */\n\n10 # 0! <-- 1;\n10 # (Infinity)! <-- Infinity;\n20 # ((n_IsPositiveInteger)!) <-- [\n        Check(n <=? 65535, \"Argument\", \"Factorial: Error: the argument \" : ( PipeToString() Write(n) ) : \" is too large, you may want to avoid exact calculation\");\n        MathFac(n);\n];\n\n25 # ((x_IsConstant)!)_(FloatIsInt(x) And? x>?0) <-- (Round(x)!);\n\n30 # ((x_IsNumber)!)_InNumericMode() <-- Internal'GammaNum(x+1);\n\n40 # (n_IsList)! <-- MapSingle(\"!\",n);\n\n/* formulae for half-integer factorials:\n\n(+(2*z+1)/2)! = Sqrt(Pi)*(2*z+1)! / (2^(2*z+1)*z!) for z >= 0\n(-(2*z+1)/2)! = Sqrt(Pi)*(-1)^z*z!*2^(2*z) / (2*z)! for z >= 0\n\nDouble factorials are more efficient:\n        (2*n-1)!! := 1*3*...*(2*n-1) = (2*n)! / (2^n*n!)\n        (2*n)!! := 2*4*...*(2*n) = 2^n*n!\n\n*/\n/* // old version - not using double factorials\nHalfIntegerFactorial(n_IsOdd) _ (n>?0) <--\n        Sqrt(Pi) * ( n! / ( 2^n*((n-1)/2)! ) );\nHalfIntegerFactorial(n_IsOdd) _ (n<?0)  <--\n        Sqrt(Pi) * ( (-1)^((-n-1)/2)*2^(-n-1)*((-n-1)/2)! / (-n-1)! );\n*/\n// new version using double factorials\nHalfIntegerFactorial(n_IsOdd) _ (n>?0) <--\n        Sqrt(Pi) * ( n!! / 2^((n+1)/2) );\nHalfIntegerFactorial(n_IsOdd) _ (n<?0)  <--\n        Sqrt(Pi) * ( (-1)^((-n-1)/2)*2^((-n-1)/2) / (-n-2)!! );\n//HalfIntegerFactorial(n_IsOdd) _ (n= -1)  <-- Sqrt(Pi);\n\n/* Want to also compute (2.5)! */\n40 # (n_IsRationalOrNumber)! _(Denominator(Rationalize(n))=?2) <-- HalfIntegerFactorial(Numerator(Rationalize(n)));\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/sums/exclamationpoint_operator.mpw";
        scriptMap.put("!",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n10  # ApplyDelta(_result,Delta(_i,_j)) <--\n    DestructiveInsert(result,1,Delta(i,j));\n20 # ApplyDelta(_result,(_x) ^ (n_IsInteger))_(n>?0) <--\n    [\n      Local(i);\n      For(i:=1,i<=?n,i++)\n      [\n        ApplyDelta(result,x);\n      ];\n    ];\n100 # ApplyDelta(_result,_term) <--\n    DestructiveAppend(result,term);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/ApplyDelta.mpw";
        scriptMap.put("ApplyDelta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n/* functions internal to tensors */\nRulebase(\"Delta\",{ind1,ind2});\n\n//Not defined in the scripts. todo:tk.\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/Delta.mpw";
        scriptMap.put("Delta",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n/* Move the delta factors to the front, so they can be simplified\n   away. It uses ApplyDelta to move a factor either to the front\n   or to the back of the list. Input is a list of factors, as\n   returned by Flatten(expressions,\"*\")\n   */\nMoveDeltas(_list) <--\n[\n  Local(result,i,nr);\n  result:={};\n  nr:=Length(list);\n  For(i:=1,i<=?nr,i++)\n  [\n    ApplyDelta(result,list[i]);\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/MoveDeltas.mpw";
        scriptMap.put("MoveDeltas",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\nRulebase(\"TD\",{ind});\n\n/* And the simplificaiton rules for X, addition, subtraction\n   and multiplication */\n10 # (TD(_i)X(_j)) <-- Delta(i,j);\n10 # (TD(_i) ( (_f) + (_g) ) ) <-- (TD(i)f) + (TD(i)g);\n10 # (TD(_i) ( (_f) - (_g) ) ) <-- (TD(i)f) - (TD(i)g);\n10 # (TD(_i) (      - (_g) ) ) <--          -  TD(i)g;\n10 # (TD(_i) ( (_f) * (_g) ) ) <-- (TD(i)f)*g + f*(TD(i)g);\n10 # (TD(_i) ( (_f) ^ (n_IsPositiveInteger) ) ) <-- n*(TD(i)f)*f^(n-1);\n10 # (TD(_i)Delta(_j,_k)) <-- 0;\n10 # (TD(_i)f_IsNumber) <-- 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TD.mpw";
        scriptMap.put("TD",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n/* TExplicitSum sets the dimension of the space under consideration,\n   so summation can proceed */\n(TExplicitSum(Ndim_IsInteger)(_body)) <-- Eval(body);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TExplicitSum.mpw";
        scriptMap.put("TExplicitSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\nRulebase(\"TList\",{head,tail});\n\n//Not defined in the scripts. todo:tk.\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TList.mpw";
        scriptMap.put("TList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n/* TSimplify : expand brackets, and send the expression of addition\n   of terms to TSimplifyAux */\nTSimplify(TSum(_indices)(_f)) <--\n[\n  TSimplifyAux(TSum(indices)ExpandBrackets(f));\n];\n\n\n/* TSimplifyAux : simplify each term independently */\n10 # TSimplifyAux(TSum(_indices)((_f) + (_g))) <--\n     TSimplifyAux(TSum(FlatCopy(indices))(f)) +\n     TSimplifyAux(TSum(FlatCopy(indices))(g));\n10 # TSimplifyAux(TSum(_indices)((_f) - (_g))) <--\n     TSimplifyAux(TSum(FlatCopy(indices))(f)) -\n     TSimplifyAux(TSum(FlatCopy(indices))(g));\n10 # TSimplifyAux(TSum(_indices)(   - (_g))) <--\n                                    -  TSimplifyAux(TSum(indices)(g));\n\n40 # TSimplifyAux(TSum(_indices)_body) <--\n[\n  Local(flat);\n\n  /* Convert expressions of the form (a*b*c) to {a,b,c} */\n  flat:=Flatten(body,\"*\");\n\n  /* Move the deltas to the front. */\n  flat:=MoveDeltas(flat);\n\n  /* Simplify the deltas away (removing the required indices) */\n  flat:=TSumRest(flat);\n\n  /* Determine if there are indices the summand still depends on */\n  Local(varlist,independ,nrdims);\n  varlist:=VarList(flat);\n  independ:=Intersection(indices,varlist);\n  nrdims:=Length(indices)-Length(independ);\n\n  /* Return result, still summing over the indices not removed by deltas */\n  Ndim^nrdims*TSum(independ)flat;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TSimplify.mpw";
        scriptMap.put("TSimplify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\nRulebase(\"TSum\",{indices,body});\n\n/* The only TSum summation simplification: summing over no indices\n   means no summation. */\n10 # (TSum({})(_body)) <-- body;\n\n/* Explicit summation when Ndim is defined. This summation will\n   be invoked when using TExplicitSum. */\n20 # (TSum(_indices)(_body))_(IsInteger(Ndim)) <--\n    LocalSymbols(index,i,sum)\n    [\n      Local(index,i,sum);\n      index:=indices[1];\n      sum:=0;\n      MacroLocal(index);\n      For(i:=1,i<=?Ndim,i++)\n      [\n        MacroBind(index,i);\n        sum:=sum+Eval(TSum(Rest(indices))body);\n      ];\n      sum;\n    ];\n\nUnFence(\"TSum\",2);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TSum.mpw";
        scriptMap.put("TSum",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Tensor package. This code intends to simplify tensorial expressions.\n */\n\n10 # TSumRest({}) <-- 1;\n20 # TSumRest(_list) <--\n[\n   TSumSimplify(TList(First(list),Rest(list)));\n];\n\nUnFence(\"TSumRest\",1); \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TSumRest.mpw";
        scriptMap.put("TSumRest",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Terminating condition for the tensorial simplification */\n\n10 # TSumSimplify(TList(Delta(_ind,_ind),_list))_Contains(indices,ind) <--\n\n[\n  /* Remove the index from the list of indices to sum over, since\n     it is now implicitly summed over by simplifying the delta */\n  DestructiveDelete(indices,Find(indices,ind));\n\n/* Return result simplified for this delta */\n  Ndim*TSumRest(list);\n];\n\n11 # TSumSimplify(TList(Delta(_ind1,_ind2),_list))_\n     Contains(indices,ind2) <--\n[\n  /* Remove the index from the list of indices to sum over, since\n     it is now implicitly summed over by simplifying the delta */\n  DestructiveDelete(indices,Find(indices,ind2));\n\n  /* Return result simplified for this delta */\n  TSumRest( Subst(ind2,ind1)list );\n];\n11 # TSumSimplify(TList(Delta(_ind1,_ind2),_list))_\n     Contains(indices,ind1) <--\n[\n  /* Remove the index from the list of indices to sum over, since\n     it is now implicitly summed over by simplifying the delta */\n  DestructiveDelete(indices,Find(indices,ind1));\n\n  /* Return result simplified for this delta */\n  TSumRest( Subst(ind1,ind2)list );\n];\n\n\n\n1010 # TSumSimplify(TList(_term,_list)) <--\n[\n  term*TSumRest(list);\n];\n\nUnFence(\"TSumSimplify\",1); \n\n";
        scriptString[2] = "/org/mathpiper/scripts4/tensor/TSumSimplify.mpw";
        scriptMap.put("TSumSimplify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"BenchCall\",{expr})\n[\n  Echo(\"In&gt \",expr);\n  WriteString(\"<font color=ff0000>\");\n  Eval(expr);\n  WriteString(\"</font>\");\n  True;\n];\nHoldArgument(\"BenchCall\",expr);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/BenchCall.mpw";
        scriptMap.put("BenchCall",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"BenchShow\",{expr})\n[\n  Echo(\"In&gt \",expr);\n  WriteString(\"<font color=ff0000> \");\n  Echo(\"Out&gt \",Eval(expr),\"</font>\");\n  True;\n];\nHoldArgument(\"BenchShow\",expr);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/BenchShow.mpw";
        scriptMap.put("BenchShow",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"EqualAsSets\",*);\n\n10 # EqualAsSets( A_IsList, B_IsList )_(Length(A)=?Length(B)) <--\n[\n    Local(Acopy,b,nba,result);\n    Acopy  := FlatCopy(A);\n    result := True;\n    ForEach(b,B)\n     [\n         nba := Find(Acopy,b);\n         If( nba <? 0, [ result := False; Break(); ] );\n         DestructiveDelete(Acopy,nba);\n     ];\n     If( Not? result, result := Length(Acopy)=?0 );\n     result;\n];\n\n20 # EqualAsSets( _A, _B ) <-- False;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/EqualAsSets.mpw";
        scriptMap.put("EqualAsSets",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"KnownFailure\",{expr})\n[\n  Local(rfail);\n  Echo(\"Known failure: \", expr);\n  Bind(rfail,Eval(expr));\n  If(rfail,Echo({\"Failure resolved!\"}));\n];\nHoldArgument(\"KnownFailure\",expr);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/KnownFailure.mpw";
        scriptMap.put("KnownFailure",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* LogicTest compares the truth tables of two expressions. */\nLocalSymbols(TrueFalse)\n[\n  MacroRulebase(TrueFalse,{var,expr});\n  10 # TrueFalse(var_IsAtom,_expr) <-- `{(@expr) Where (@var)==False,(@expr) Where (@var)==True};\n  20 # TrueFalse({},_expr) <-- `(@expr);\n  30 # TrueFalse(var_IsList,_expr) <--\n  `[\n    Local(t,h);\n    Bind(h,First(@var));\n    Bind(t,Rest(@var));\n    TrueFalse(h,TrueFalse(t,@expr));\n  ];\n\n  Macro(LogicTest,{vars,expr1,expr2}) Verify(TrueFalse((@vars),(@expr1)), TrueFalse((@vars),(@expr2)));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/LogicTest.mpw";
        scriptMap.put("LogicTest",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"LogicVerify\",{aLeft,aRight})\n[\n  If(aLeft !=? aRight,\n    Verify(CanProve(aLeft => aRight),True)\n  );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/LogicVerify.mpw";
        scriptMap.put("LogicVerify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"NextTest\",{aLeft})\n[\n// curline++;\nWriteString(\"\nTest suite for \":aLeft:\" : \"\n           );\n  NewLine();\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/NextTest.mpw";
        scriptMap.put("NextTest",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"NumericEqual\",*);\n\n10 # NumericEqual(left_IsDecimal, right_IsDecimal, precision_IsPositiveInteger) <--\n[\n    If(InVerboseMode(),Tell(\"NumericEqual\",{left,right}));\n    Local(repL,repR,precL,precR,newL,newR,plo,phi,replo,rephi);\n    Local(newhi,newrepL,newlo,newrepR,ans);\n    repL     := NumberToRep(left);\n    repR     := NumberToRep(right);\n    precL    := repL[2];\n    precR    := repR[2];\n    If(InVerboseMode(),Tell(\"  \",{precL,precR,precision}));\n    newL     := RoundToPrecision(left,  precision );\n    newR     := RoundToPrecision(right, precision );\n    If(InVerboseMode(),Tell(\"  \",{newL,newR}));\n    newrepL  := NumberToRep( newL );\n    newrepR  := NumberToRep( newR );\n    If(InVerboseMode(),Tell(\"  \",{newrepL,newrepR}));\n    ans      := Verify( newrepL[1] - newrepR[1], 0 );\n    If(InVerboseMode(),Tell(\"        \",ans));\n    ans;\n];\n\n\n15 # NumericEqual(left_IsInteger, right_IsInteger, precision_IsPositiveInteger) <--\n[\n    If(InVerboseMode(),Tell(\"NumericEqualInt\",{left,right}));\n    left =? right;\n];\n\n\n20 # NumericEqual(left_IsNumber, right_IsNumber, precision_IsPositiveInteger) <--\n[\n    If(InVerboseMode(),Tell(\"NumericEqualNum\",{left,right}));\n    Local(nI,nD,repI,repD,precI,precD,intAsDec,newDec,newrepI,newrepD,ans);\n    If( IsInteger(left), [nI:=left; nD:=right;], [nI:=right; nD:=left;]);\n    // the integer can be converted to the equivalent decimal at any precision\n    repI  := NumberToRep(nI);\n    repD  := NumberToRep(nD);\n    precI := repI[2];\n    precD := repD[2];\n    intAsDec := RoundToPrecision(1.0*nI,precision);\n    newDec   := RoundToPrecision( nD,   precision );\n    newrepI  := NumberToRep( intAsDec );\n    newrepD  := NumberToRep( newDec   );\n    If(InVerboseMode(),\n      [\n          Tell(\"        \",{nI,nD});\n          Tell(\"    \",{repI,repD});\n          Tell(\"  \",{precI,precD});\n          Tell(\"       \",{intAsDec,newDec});\n          Tell(\"       \",{newrepI,newrepD});\n       ]\n    );\n    ans      := Verify( newrepI[1] - newrepD[1], 0 );\n    If(InVerboseMode(),Tell(\"        \",ans));\n    ans;\n];\n\n\n25 # NumericEqual(left_IsComplex, right_IsComplex, precision_IsPositiveInteger) <--\n[\n    If(InVerboseMode(),Tell(\"NumericEqualC\",{left,right}));\n    Local(rrL,iiL,rrR,iiR,ans);\n    rrL := Re(left);\n    iiL := Im(left);\n    rrR := Re(right);\n    iiR := Im(right);\n    If(InVerboseMode(),\n      [\n         Tell(\"  \",{left,right});\n         Tell(\"  \",{rrL,rrR});\n         Tell(\"  \",{iiL,iiR});\n      ]\n    );\n    ans := (NumericEqual(rrL,rrR,precision) And? NumericEqual(iiL,iiR,precision));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/NumericEqual.mpw";
        scriptMap.put("NumericEqual",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRandVerifyArithmetic(_n)<--\n[\n While(n>?0)\n [\n   n--;\n   VerifyArithmetic(FloorN(300*Random()),FloorN(80*Random()),FloorN(90*Random()));\n ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/RandVerifyArithmetic.mpw";
        scriptMap.put("RandVerifyArithmetic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Functions that aid in testing */\n\n/* Round to specified number of digits */\n10 # RoundTo(x_IsNumber, precision_IsPositiveInteger) <--\n[\n  Local(oldPrec,result);\n\n  oldPrec:=BuiltinPrecisionGet();\n\n  BuiltinPrecisionSet(precision);\n\n  Bind(result,DivideN( Round( MultiplyN(x, 10^precision) ), 10^precision ));\n\n  BuiltinPrecisionSet(oldPrec);\n\n  result;\n];\n\n\n\n// complex numbers too\n10 # RoundTo(Complex(r_IsNumber, i_IsNumber), precision_IsPositiveInteger) <-- Complex(RoundTo(r, precision), RoundTo(i, precision));\n\n\n\n\n// Infinities, rounding does not apply.\n20 # RoundTo( Infinity,precision_IsPositiveInteger) <--  Infinity;\n\n20 # RoundTo(-Infinity,precision_IsPositiveInteger) <-- -Infinity;\n\n\n\n/* ------   moved to separate file (already present but empty!) ---\n\nMacro(NumericEqual,{left,right,precision})\n[\n  Verify(RoundTo((@left)-(@right),@precision),0);\n];\n\n*/\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/RoundTo.mpw";
        scriptMap.put("RoundTo",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// print current file and line\nShowLine() :=\n[\n    Echo(\"File: \", CurrentFile(),\", Line: \", CurrentLine());\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/ShowLine.mpw";
        scriptMap.put("ShowLine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"TestEquivalent\",*);\n//Retract(\"TestTwoLists\",*);\n\nMacro(\"TestEquivalent\",{left,right})\n[\n    Local(leftEval,rightEval,diff,vars,isEquiv);\n    If(InVerboseMode(),[Tell(TestEquivalent,{left,right});]);\n    leftEval  := @left;\n    rightEval := @right;\n    If(InVerboseMode(),\n      [ NewLine(); Tell(\"    \",leftEval); Tell(\"   \",rightEval); ]);\n    If( IsList(leftEval),\n      [\n          If( IsList(rightEval),\n            [\n                // both are lists\n                If(InVerboseMode(),Tell(\"     both are lists \"));\n                isEquiv := TestTwoLists(leftEval,rightEval);\n            ],\n            isEquiv := False\n          );\n      ],\n      [\n          If( IsList(rightEval), \n            isEquiv := False,\n            [\n                // neither is a list, so check equality of diff\n                If(InVerboseMode(),Tell(\"     neither is list \"));\n                If(IsEquation(leftEval),\n                  [\n                      If(IsEquation(rightEval),\n                        [\n                            If(InVerboseMode(),Tell(\"      both are equations\"));\n                            Local(dLHs,dRHS);\n                            dLHS := Simplify(EquationLeft(leftEval) - EquationLeft(rightEval));\n                            dRHS := Simplify(EquationRight(leftEval) - EquationRight(rightEval));\n                            If(InVerboseMode(),Tell(\"      \",{dLHS,dRHS}));\n                            isEquiv := dLHS=?0 And? dRHS=?0;\n                        ],\n                        isEquiv := False\n                      );\n                  ],\n                  [\n                     If(IsEquation(rightEval),\n                        isEquiv := False,\n                        [\n                            If(InVerboseMode(),Tell(\"      neither is equation\"));\n                            diff := Simplify(leftEval - rightEval);\n                            vars := VarList(diff);\n                            If(InVerboseMode(),\n                              [\n                                 Tell(\"    \",{leftEval,rightEval});\n                                 Tell(\"    \",vars);\n                                 Tell(\"    \",diff);\n                              ]\n                            );\n                            isEquiv   := ( IsZero(diff) Or? IsZeroVector(diff) );\n                        ]\n                      );\n                   ]\n                );\n            ]\n          );\n      ]\n    );\n    If(InVerboseMode(),Tell(\"     Equivalence = \",isEquiv));\n    If ( Not? isEquiv,\n      [\n                  WriteString(\"******************\");          NewLine();\n                  WriteString(\"L.H.S. evaluates to: \");\n                  Write(leftEval);                            NewLine();\n                  WriteString(\"which differs from   \");\n                  Write(rightEval);                           NewLine();\n                  WriteString(\" by                  \"); \n                  Write(diff);                                NewLine();\n                  WriteString(\"******************\");          NewLine();\n      ]\n    );\n    isEquiv;\n];\n\n\n10 # TestTwoLists( L1_IsList, L2_IsList ) <--\n[\n    If(InVerboseMode(),[Tell(\"   TestTwoLists\");Tell(\"     \",L1);Tell(\"     \",L2);]);\n    If(Length(L1)=?1 And? Length(L2)=?1,\n      [\n          TestEquivalent(L1[1],L2[1]);\n      ],\n      [\n          EqualAsSets(L1,L2);\n      ]\n    );\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/TestEquivalent.mpw";
        scriptMap.put("TestEquivalent",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Testing MathPiper functionality by checking expressions against correct\n   answer.\n   Use with algebraic expressions only, since we need Simplify() for that to work.\n */\n\n/*\nMacro (\"TestMathPiper\", {expr, ans})\n[\n        Local(diff,exprEval, ansEval);\n  exprEval:= @expr;\n  ansEval:= @ans;\n\n        diff := Simplify(exprEval - ansEval);\n                If (Simplify(diff)=0, True,\n                        [\n                          WriteString(\"******************\");\n                          NewLine();\n                          ShowLine();\n                          Write(Hold(@expr));\n                          WriteString(\" evaluates to \");\n                          NewLine();\n                          Write(exprEval);\n                          NewLine();\n                          WriteString(\" which differs from \");\n                          NewLine();\n                          Write(ansEval);\n                          NewLine();\n                          WriteString(\" by \");\n                          NewLine();\n                          Write(diff);\n                          NewLine();\n                          WriteString(\"******************\");\n                          NewLine();\n                          False;\n                         ]\n                        );\n];\n*/\n\n\n\nFunction (\"TestMathPiper\", {expr, ans})\n[\n        Local(diff);\n        diff := Simplify(Eval(expr)-Eval(ans));\n                If (Simplify(diff)=?0, True,\n                        [\n                          WriteString(\"******************\");\n                          NewLine();\n                          ShowLine();\n                          Write(expr);\n                          WriteString(\" evaluates to \");\n                          NewLine();\n                          Write(Eval(expr));\n                          NewLine();\n                          WriteString(\" which differs from \");\n                          NewLine();\n                          Write(Eval(ans));\n                          NewLine();\n                          WriteString(\" by \");\n                          NewLine();\n                          Write(diff);\n                          NewLine();\n                          WriteString(\"******************\");\n                          NewLine();\n                          False;\n                         ]\n                        );\n];\n\nHoldArgument(\"TestMathPiper\", expr);\nHoldArgument(\"TestMathPiper\", ans);\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/TestMathPiper.mpw";
        scriptMap.put("TestMathPiper",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"Testing\",{aLeft})\n[\n    WriteString(\"--\");\n    WriteString(aLeft);\n    NewLine();\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/Testing.mpw";
        scriptMap.put("Testing",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nMacro(\"Verify\",{aLeft,aRight})\n[\n\n        Local(result);\n        result := @aLeft;        // to save time\n  If (Not?(IsEqual(result,@aRight)),\n    [\n      WriteString(\"******************\");\n      NewLine();\n      ShowLine();\n      NewLine();\n      Write(Hold(@aLeft));\n      NewLine();\n      WriteString(\" evaluates to \");\n      NewLine();\n          Write(result);\n          WriteString(\" which differs from \");\n      NewLine();\n      Write(Hold(@aRight));\n      NewLine();\n      WriteString(\"******************\");\n      NewLine();\n      False;\n    ],\n    True\n  );\n];\n*/\n\n\nFunction(\"Verify\",{aLeft,aRight})\n[\n\n        Local(result);\n        result := Eval(aLeft);        // to save time\n  If (Not?(IsEqual(result,aRight)),\n    [\n      WriteString(\"******************\");\n      NewLine();\n      ShowLine();\n      NewLine();\n      Write(aLeft);\n      NewLine();\n      WriteString(\" evaluates to \");\n      NewLine();\n          Write(result);\n      NewLine();\n          WriteString(\" which differs from \");\n      NewLine();\n      Write(aRight);\n      NewLine();\n      WriteString(\"******************\");\n      NewLine();\n      False;\n    ],\n    True\n  );\n];\nHoldArgument(\"Verify\",aLeft);\nUnFence(\"Verify\",2);\n/*\nHoldArgument(\"Verify\",aRight);\n*/\n\nMacro(\"Verify\", {a,b,message})\n[\n        Echo(\"test \", @message);\n        Verify(@a, @b);\n];\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/Verify.mpw";
        scriptMap.put("Verify",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nLocalSymbols(f1,f2)\n[\n  // f1 and f2 are used inside VerifyArithmetic\n  f1(x,n,m):=(x^n-1)*(x^m-1);\n  f2(x,n,m):=x^(n+m)-(x^n)-(x^m)+1;\n\n  VerifyArithmetic(x,n,m):=\n  [\n    Verify(f1(x,n,m),f2(x,n,m));\n  ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/VerifyArithmetic.mpw";
        scriptMap.put("VerifyArithmetic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nVerifyDiv(_u,_v) <--\n[\n  Local(q,r);\n  q:=Quotient(u,v);\n  r:=Rem(u,v);\n\n  Verify(Expand(u),Expand(q*v+r));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/VerifyDiv.mpw";
        scriptMap.put("VerifyDiv",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"VerifySolve\",*);\n//Retract(\"VerifySolve'Equal\",*);\n\nVerifySolve(_e1, _e2) <--\nIf (VerifySolve'Equal(Eval(e1), Eval(e2)), \n    True,\n    [ \n      WriteString(\"******************\");    NewLine();\n      ShowLine();                           NewLine();\n      Write(e1);                            NewLine();\n      WriteString(\" evaluates to \");        NewLine();\n      Write(Eval(e1));                      NewLine();\n      WriteString(\" which differs from \");  NewLine();\n      Write(e2);                            NewLine();\n      WriteString(\"******************\");    NewLine();\n      False; \n    ]); \nHoldArgumentNumber(\"VerifySolve\", 2, 1);\n\n10 # VerifySolve'Equal({}, {}) <-- True;\n\n20 # VerifySolve'Equal({}, e2_IsList) <-- False;\n\n30 # VerifySolve'Equal(e1_IsList, e2_IsList) <--\n[\n  Local(i, found);\n  found := False;\n  i := 0;\n  While(i <? Length(e2) And? Not? found) [\n    i++;\n    found := VerifySolve'Equal(First(e1), e2[i]);\n  ];\n  If (found, VerifySolve'Equal(Rest(e1), Delete(e2, i)), False);\n];\n\n40 # VerifySolve'Equal(_l1 == _r1, _l2 == _r2) \n<-- IsEqual(l1,l2) And? Simplify(r1-r2)=?0;\n\n50 # VerifySolve'Equal(_e1, _e2) <-- Simplify(e1-e2) =? 0;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/testers/VerifySolve.mpw";
        scriptMap.put("VerifySolve",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # LaplaceTransform(_var1,_var2, _expr )        <-- LapTran(var1,var2,expr);\n\n// Linearity properties\n10 # LapTran(_var1,_var2,_x + _y)                      <-- LapTran(var1,var2,x) + LapTran(var1,var2,y);\n10 # LapTran(_var1,_var2,_x - _y)                <-- LapTran(var1,var2,x) - LapTran(var1,var2,y);\n10 # LapTran(_var1,_var2,    - _y)               <-- LapTran(var1,var2,y);\n10 # LapTran(_var1,_var2, c_IsConstant*_y)        <-- c*LapTran(var1,var2,y);\n10 # LapTran(_var1,_var2, _y*c_IsConstant)        <-- c*LapTran(var1,var2,y);\n10 # LapTran(_var1,_var2, _y/c_IsConstant)         <-- LapTran(var1,var2,y)/c;\n\n// Shift properties\n10 # LapTran(_var1,_var2, Exp(c_IsConstant*_var1)*_expr  ) <-- LapTran(var1,var2-c,expr);\n10 # LapTran(_var1,_var2, Exp(-c_IsConstant*_var1)*_expr ) <-- LapTran(var1,var2+c,expr);\n10 # LapTran(_var1,_var2, _expr*Exp(c_IsConstant*_var1)  ) <-- LapTran(var1,var2-c,expr);\n10 # LapTran(_var1,_var2, _expr*Exp(-c_IsConstant*_var1) ) <-- LapTran(var1,var2+c,expr);\n\n// Other operational properties\n10 # LapTran(_var1,_var2, _expr/_var1 )                <-- Integrate(var2,var2,Infinity) LapTran(var1,var2,expr) ;\n10 # LapTran(_var1,_var2, _var1*_expr )                <-- - Deriv(var2) LapTran(var1,var2,expr);\n10 # LapTran(_var1,_var2, _var1^(n_IsInteger)*_expr )  <-- (-1)^n * Deriv(var2,n) LapTran(var1,var2,expr);\n10 # LapTran(_var1,_var2, _expr*_var1 )                <-- - Deriv(var2) LapTran(var1,var2,expr);\n10 # LapTran(_var1,_var2, _expr*_var1^(n_IsInteger)  ) <-- (-1)^n * Deriv(var2,n) LapTran(var1,var2,expr);\n\n// didn't match, return unevaled\n100 # LapTran(_var1,_var2, _expr )        <-- `Hold(LaplaceTransform(@var1,@var2,@expr));\n\nLapTranDef(_in,_out) <--\n[\n  Local(i,o);\n\n  //Echo(\"50 # LapTran(_t,_s,\",in,\") <-- \",out,\";\");\n  `(50 # LapTran(_t,_s,@in) <-- @out );\n\n  i:=Subst(_t,c_IsPositiveInteger*_t) in;\n  o:=Subst(s,s/c) out;\n\n  //Echo(\"50 # LapTran(_t,_s,\",i,\") <-- \",o/c,\";\");\n  `(50 # LapTran(_t,_s,@i ) <-- @o/c );\n\n  i:=Subst(_t,_t/c_IsPositiveInteger) in;\n  o:=Subst(s,s*c) out;\n\n  //Echo(\"50 # LapTran(_t,_s,\",i,\") <-- \",o/c,\";\");\n  `(50 # LapTran(_t,_s,@i ) <-- @o*c );\n\n];\n\n// transforms of specific functions\nLapTranDef( (_t)^(n_IsConstant),        Gamma(n+1)/s^(n+1) );\nLapTranDef( _t,                         1/s^2 );\nLapTranDef( Sqrt(_t),                         Sqrt(Pi)/(2*s^(3/2)) );\nLapTranDef( c_IsFreeOf({t,s}),                c/s );\nLapTranDef( Sin(_t),                         1/(s^2+1) );\nLapTranDef( Cos(_t),                         s/(s^2+1) );\nLapTranDef( Sinh(_t),                        c/(s^2-1) );\nLapTranDef( Cosh(_t),                        s/(s^2-1) );\nLapTranDef( Exp(_t),                        1/(s-1) );\nLapTranDef( BesselJ(n_IsConstant,_t),        (Sqrt(s^2+1)-s)^n /Sqrt(s^2+1) );\nLapTranDef( BesselI(n_IsConstant,_t),        (s-Sqrt(s^2+1))^n /Sqrt(s^2-1) );\nLapTranDef( Ln(_t),                        -(gamma+Ln(s))/s);\nLapTranDef( Ln(_t)^2,                        Pi^2/(6*s)+(gamma+Ln(s))/s );\nLapTranDef( Erf(_t),                        Exp(s^2/4)*Erfc(s/2)/s );\nLapTranDef( Erf(Sqrt(_t)),                1/(Sqrt(s+1)*s) );\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/transforms/laplace/LaplaceTransform.mpw";
        scriptMap.put("LaplaceTransform",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n\n/* This file defines TrigSimpCombine. TrigSimpCombine is designed to\n   simplify expressions like Cos(a)*Sin(b) to additions\n   only (in effect, removing multiplications between\n   trigonometric functions).\n\n   The accepted expressions allow additions and multiplications\n   between trig. functions, and raising trig. functions to an\n   integer power.\n\n   You can invoke it by calling TrigSimpCombine(f). Examples:\n        TrigSimpCombine(Cos(a)*Sin(a^2+b)^2)\n        TrigSimpCombine(Cos(a)*Sin(a)^2)\n        TrigSimpCombine(Cos(a)^3*Sin(a)^2)\n        TrigSimpCombine(d*Cos(a)^3*Sin(a)^2)\n        TrigSimpCombine(Cos(a)^3*Sin(a)^2)\n        TrigSimpCombine(Cos(a)*Sin(a))\n        TrigSimpCombine(Cos(a)*Sin(b)*Cos(c))\n\n */\n\n\n/* FSin, FCos and :*: are used for the internal representation\n   of the expression to work on:\n   - a*b -> a:*:b   this is used because we want to expand powers,\n     without the standard engine collapsing them back again.\n   - a*Sin(b) -> FSin(a,b) and a*Cos(b) -> FCos(a,b). This makes\n     adding and multiplying expressions with trig. functions, non-trig.\n     functions, constants, etc. a lot easier.\n*/\nRulebase(\"FSin\",{f,x});\nRulebase(\"FCos\",{f,x});\nRulebase(\":*:\",{x,y});\n\n\nIsTrig(f) := (Type(f) =? \"Sin\" Or? Type(f) =? \"Cos\");\nIsFTrig(f) := (Type(f) =? \"FSin\" Or? Type(f) =? \"FCos\");\nIsMul(f) := (Type(f) =? \"*\");\nIsMulF(f) := (Type(f) =? \":*:\");\n\nIsPow(f):=\n  (Type(f) =? \"^\" And?\n   IsInteger(f[2]) And?\n   f[2] >? 1\n  );\n\n\n/* Convert Sin/Cos to FSin/FCos */\nRulebase(\"TrigChange\",{f});\nRule(\"TrigChange\",1,1,Type(f)=?\"Cos\") FCos(1,f[1]);\nRule(\"TrigChange\",1,1,Type(f)=?\"Sin\") FSin(1,f[1]);\n\nRulebase(\"TrigUnChange\",{f});\nRule(\"TrigUnChange\",1,1,Type(f)=?\"FCos\") Cos(f[2]);\nRule(\"TrigUnChange\",1,1,Type(f)=?\"FSin\") Sin(f[2]);\n\n\n/* Do a full replacement to internal format on a term. */\nRulebase(\"FReplace\",{f});\nUnFence(\"FReplace\",1);\nRule(\"FReplace\",1,1,IsMul(f))  Substitute(f[1]) :*: Substitute(f[2]);\nRule(\"FReplace\",1,2,IsPow(f))  (Substitute(f[1]) :*: Substitute(f[1])) :*: Substitute(f[1]^(f[2]-2));\n/*\nRule(\"FReplace\",1,2,IsPow(f))\n[\n  Local(trm,i,res,n);\n  Bind(trm,Substitute(f[1]));\n  Bind(n,f[2]);\n  Bind(res,trm);\n  For(i:=2,i<=?n,i++)\n  [\n    Bind(res,res :*: trm);\n  ];\n  res;\n];\n*/\n\nRule(\"FReplace\",1,3,IsTrig(f)) TrigChange(f);\nFTest(f):=(IsMul(f) Or? IsPow(f) Or? IsTrig(f));\n\n/* Central function that converts to internal format */\nFToInternal(f):=Substitute(f,\"FTest\",\"FReplace\");\n\nFReplaceBack(f):=(Substitute(f[1])*Substitute(f[2]));\nUnFence(\"FReplaceBack\",1);\nFFromInternal(f):=Substitute(f,\"IsMulF\",\"FReplaceBack\");\n\n\n/* FLog(s,f):=[WriteString(s:\" \");Write(f);NewLine();]; */\n FLog(s,f):=[];\n\n\n/* FSimpTerm simplifies the current term, wrt. trigonometric functions. */\nRulebase(\"FSimpTerm\",{f,rlist});\nUnFence(\"FSimpTerm\",2);\n\n/* Addition: add all the subterms */\nRule(\"FSimpTerm\",2,1,Type(f) =? \"+\")\n[\n  Local(result,lst);\n  lst:=Flatten(f,\"+\");\n\n  result:={{},{}};\nFLog(\"simpadd\",lst);\n\n  ForEach(tt,lst)\n  [\n    Local(new);\n    new:=FSimpTerm(tt,{{},{}});\n    result:={Concat(result[1],new[1]),Concat(result[2],new[2])};\n  ];\n  result;\n];\n\n\nTrigNegate(f):=\n[\n  ListToFunction({f[0],-(f[1]),f[2]});\n];\n\n\nFUnTrig(result) := Substitute(result,\"IsFTrig\",\"TrigUnChange\");\n\nRule(\"FSimpTerm\",2,1,Type(f) =? \"-\" And? ArgumentsCount(f)=?1)\n[\n  Local(result);\n  result:=FSimpTerm(f[1],{{},{}});\n  Substitute(result,\"IsFTrig\",\"TrigNegate\");\n];\nRule(\"FSimpTerm\",2,1,Type(f) =? \"-\" And? ArgumentsCount(f)=?2)\n[\n  Local(result1,result2);\n  result1:=FSimpTerm(f[1],{{},{}});\n  result2:=FSimpTerm(-(f[2]),{{},{}});\n  {Concat(result1[1],result2[1]),Concat(result1[2],result2[2])};\n];\n\nRule(\"FSimpTerm\",2,2,Type(f) =? \":*:\")\n[\n  FSimpFactor({Flatten(f,\":*:\")});\n];\nRule(\"FSimpTerm\",2,3,Type(f) =? \"FSin\")\n[\n  {rlist[1],f:(rlist[2])};\n];\nRule(\"FSimpTerm\",2,3,Type(f) =? \"FCos\")\n[\n  {f:(rlist[1]),rlist[2]};\n];\n\nRule(\"FSimpTerm\",2,4,True)\n[\n  {(FCos(f,0)):(rlist[1]),rlist[2]};\n];\n\n/* FSimpFactor does the difficult part. it gets a list, representing\n   factors, a*b*c -> {{a,b,c}}, and has to add terms from it.\n   Special cases to deal with:\n   - (a+b)*c -> a*c+b*c -> {{a,c},{b,c}}\n   - {a,b,c} where one of them is not a trig function or an addition:\n     replace with FCos(b,0), which is b*Cos(0) = b\n   - otherwise, combine two factors and make them into an addition.\n   - the lists should get shorter, but the number of lists should\n     get longer, until there are only single terms to be added.\n */\nFSimpFactor(flist):=\n[\n  Local(rlist);\n  rlist:={{},{}};\n  /* Loop over each term */\n  While(flist !=? {})\n  [\n    Local(term);\nFLog(\"simpfact\",flist);\n    term:=First(flist);\n    flist:=Rest(flist);\n    FProcessTerm(term);\n  ];\nFLog(\"simpfact\",flist);\n\nFLog(\"rlist\",rlist);\n  rlist;\n];\nUnFence(\"FSimpFactor\",1);\n\n\nRulebase(\"FProcessTerm\",{t});\nUnFence(\"FProcessTerm\",1);\n\n/* Deal with (a+b)*c -> a*c+b*c */\nRule(\"FProcessTerm\",1,1,Type(t[1]) =? \"+\")\n[\n  Local(split,term1,term2);\n  split:=t[1];\n  term1:=FlatCopy(t);\n  term2:=FlatCopy(t);\n  term1[1]:=split[1];\n  term2[1]:=split[2];\n  DestructiveInsert(flist,1,term1);\n  DestructiveInsert(flist,1,term2);\n];\nRule(\"FProcessTerm\",1,1,Type(t[1]) =? \"-\" And? ArgumentsCount(t[1]) =? 2)\n[\n  Local(split,term1,term2);\n  split:=t[1];\n  term1:=FlatCopy(t);\n  term2:=FlatCopy(t);\n  term1[1]:=split[1];\n  term2[1]:=split[2];\n  DestructiveInsert(term2,1,FCos(-1,0));\n  DestructiveInsert(flist,1,term1);\n  DestructiveInsert(flist,1,term2);\n];\n\nRule(\"FProcessTerm\",1,1,Length(t)>?1 And? Type(t[2]) =? \"-\" And? ArgumentsCount(t[2]) =? 2)\n[\n  Local(split,term1,term2);\n  split:=t[2];\n  term1:=FlatCopy(t);\n  term2:=FlatCopy(t);\n  term1[2]:=split[1];\n  term2[2]:=split[2];\n  DestructiveInsert(term2,1,FCos(-1,0));\n  DestructiveInsert(flist,1,term1);\n  DestructiveInsert(flist,1,term2);\n];\n\nRule(\"FProcessTerm\",1,1,Type(t[1]) =? \":*:\")\n[\n  Local(split,term);\n  split:=t[1];\n  term:=FlatCopy(t);\n  term[1]:=split[1];\n  DestructiveInsert(term,1,split[2]);\n  DestructiveInsert(flist,1,term);\n];\n\nRule(\"FProcessTerm\",1,1,Length(t)>?1 And? Type(t[2]) =? \":*:\")\n[\n  Local(split,term);\n  split:=t[2];\n  term:=FlatCopy(t);\n  term[2]:=split[1];\n  DestructiveInsert(term,1,split[2]);\n  DestructiveInsert(flist,1,term);\n];\n\nRule(\"FProcessTerm\",1,1,Type(t[1]) =? \"-\" And? ArgumentsCount(t[1]) =? 1)\n[\n  Local(split,term);\n  split:=t[1];\n  term:=FlatCopy(t);\n  term[1]:=split[1];\n  DestructiveInsert(term,1,FCos(-1,0));\n  DestructiveInsert(flist,1,term);\n];\nRule(\"FProcessTerm\",1,1,Length(t)>?1 And? Type(t[2]) =? \"-\" And? ArgumentsCount(t[2]) =? 1)\n[\n  Local(split,term);\n  split:=t[2];\n  term:=FlatCopy(t);\n  term[2]:=split[1];\n  DestructiveInsert(term,1,FCos(-1,0));\n  DestructiveInsert(flist,1,term);\n];\n\n\n/* Deal with (a*(b+c) -> a*b+a*c */\nRule(\"FProcessTerm\",1,1,Length(t)>?1 And? Type(t[2]) =? \"+\")\n[\n  Local(split,term1,term2);\n  split:=t[2];\n  term1:=FlatCopy(t);\n  term2:=FlatCopy(t);\n  term1[2]:=split[1];\n  term2[2]:=split[2];\n  DestructiveInsert(flist,1,term1);\n  DestructiveInsert(flist,1,term2);\n];\n\n\n\n/* Deal with a*FCos(1,b) ->FCos(a,0)*FCos(1,b) */\nRule(\"FProcessTerm\",1,2,Not?(IsFTrig(t[1])) )\n[\n  t[1]:=FCos(t[1],0);\n  DestructiveInsert(flist,1,t);\n];\nRule(\"FProcessTerm\",1,2,Length(t)>?1 And? Not?(IsFTrig(t[2])) )\n[\n  t[2]:=FCos(t[2],0);\n  DestructiveInsert(flist,1,t);\n];\n\n\nRule(\"FProcessTerm\",1,4,Length(t)=?1 And? Type(t[1]) =? \"FCos\")\n[\n  DestructiveInsert(rlist[1],1,t[1]);\n];\nRule(\"FProcessTerm\",1,4,Length(t)=?1 And? Type(t[1]) =? \"FSin\")\n[\n  DestructiveInsert(rlist[2],1,t[1]);\n];\n\n/* Now deal with the real meat: FSin*FCos etc. Reduce the multiplication\n   of the first two terms to an addition, adding two new terms to\n   the pipe line.\n */\nRule(\"FProcessTerm\",1,5,Length(t)>?1)\n[\n  Local(x,y,term1,term2,news);\n  x:=t[1];\n  y:=t[2];\n  news:=TrigSimpCombineB(x,y);\n  /* Drop one term */\n  t:=Rest(t);\n  term1:=FlatCopy(t);\n  term2:=FlatCopy(t);\n  term1[1]:=news[1];\n  term2[1]:=news[2];\n  DestructiveInsert(flist,1,term1);\n  DestructiveInsert(flist,1,term2);\n];\n\n/* TrigSimpCombineB : take two FSin/FCos factors, and write them out into two terms */\nRulebase(\"TrigSimpCombineB\",{x,y});\nRule(\"TrigSimpCombineB\",2,1,Type(x) =? \"FCos\" And? Type(y) =? \"FCos\")\n     { FCos((x[1]*y[1])/2,x[2]+y[2]) , FCos((x[1]*y[1])/2,x[2]-y[2]) };\nRule(\"TrigSimpCombineB\",2,1,Type(x) =? \"FSin\" And? Type(y) =? \"FSin\")\n     { FCos(-(x[1]*y[1])/2,x[2]+y[2]) , FCos((x[1]*y[1])/2,x[2]-y[2]) };\nRule(\"TrigSimpCombineB\",2,1,Type(x) =? \"FSin\" And? Type(y) =? \"FCos\")\n     { FSin((x[1]*y[1])/2,x[2]+y[2]) , FSin( (x[1]*y[1])/2,x[2]-y[2]) };\nRule(\"TrigSimpCombineB\",2,1,Type(x) =? \"FCos\" And? Type(y) =? \"FSin\")\n     { FSin((x[1]*y[1])/2,x[2]+y[2]) , FSin(-(x[1]*y[1])/2,x[2]-y[2]) };\n\n\nRulebase(\"TrigSimpCombine\",{f});\nRule(\"TrigSimpCombine\",1,1,IsList(f))\n  Map(\"TrigSimpCombine\",{f});\n\nRule(\"TrigSimpCombine\",1,10,True)\n[\n  Local(new,varlist);\n  new:=f;\n\n  /* varlist is used for normalizing the trig. arguments */\n  varlist:=VarList(f);\n\n/* Convert to internal format. */\n  new:=FToInternal(new);\nFLog(\"Internal\",new);\n\n  /* terms will contain FSin/FCos entries, the final result */\n\n  /* rlist gathers the true final result */\n  Local(terms);\n  terms:=FSimpTerm(new,{{},{}});\n  /* terms now contains two lists: terms[1] is the list of cosines,\n     and terms[2] the list of sines.\n   */\nFLog(\"terms\",terms);\n\n  /* cassoc and sassoc will contain the assoc lists with the cos/sin\n     arguments as key.\n   */\n  Local(cassoc,sassoc);\n  cassoc:={};\n  sassoc:={};\n  ForEach(item,terms[1])\n  [\n    CosAdd(item);\n  ];\n  ForEach(item,terms[2])\n  [\n    SinAdd(item);\n  ];\nFLog(\"cassoc\",cassoc);\nFLog(\"sassoc\",sassoc);\n\n  /* Now rebuild the normal form */\n  Local(result);\n  result:=0;\n\n//Echo({cassoc});\n//Echo({sassoc});\n  ForEach(item,cassoc)\n  [\nFLog(\"item\",item);\n    result:=result+Expand(FUnTrig(FFromInternal(item[2])))*Cos(item[1]);\n  ];\n  ForEach(item,sassoc)\n  [\nFLog(\"item\",item);\n    result:=result+Expand(FUnTrig(FFromInternal(item[2])))*Sin(item[1]);\n  ];\n\n  result;\n];\n\n\n\nCosAdd(t):=\n[\n  Local(look,arg);\n  arg:=Expand(t[2],varlist);\n  look:=Assoc(arg,cassoc);\n  If(look =? Empty,\n     [\n       arg:=Expand(-arg,varlist);\n       look:=Assoc(arg,cassoc);\n       If(look =? Empty,\n         DestructiveInsert(cassoc,1,{arg,t[1]}),\n         look[2]:=look[2]+t[1]\n         );\n     ]\n     ,\n     look[2]:=look[2]+t[1]\n    );\n];\nUnFence(\"CosAdd\",1);\n\nSinAdd(t):=\n[\n  Local(look,arg);\n  arg:=Expand(t[2],varlist);\n  look:=Assoc(arg,sassoc);\n  If(look =? Empty,\n     [\n       arg:=Expand(-arg,varlist);\n       look:=Assoc(arg,sassoc);\n       If(look =? Empty,\n         DestructiveInsert(sassoc,1,{arg,-(t[1])}),\n         look[2]:=look[2]-(t[1])\n         );\n     ]\n     ,\n     look[2]:=look[2]+t[1]\n    );\n];\nUnFence(\"SinAdd\",1);\n\n\n/*\nIn( 4 ) = Exp(I*a)*Exp(I*a)\nOut( 4 ) = Complex(Cos(a)^2-Sin(a)^2,Cos(a)*Sin(a)+Sin(a)*Cos(a));\nIn( 5 ) = Exp(I*a)*Exp(-I*a)\nOut( 5 ) = Complex(Cos(a)^2+Sin(a)^2,Sin(a)*Cos(a)-Cos(a)*Sin(a));\n\nIn( 5 ) = Exp(I*a)*Exp(I*b)\nOut( 5 ) = Complex(Cos(a)*Cos(b)-Sin(a)*Sin(b),Cos(a)*Sin(b)+Sin(a)*Cos(b));\nIn( 6 ) = Exp(I*a)*Exp(-I*b)\nOut( 6 ) = Complex(Cos(a)*Cos(b)+Sin(a)*Sin(b),Sin(a)*Cos(b)-Cos(a)*Sin(b));\n\n\n*/\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/trigsimp/TrigSimpCombine.mpw";
        scriptMap.put("TrigSimpCombine",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # BigOh(UniVariate(_var,_first,_coefs),_var,_degree) <--\n    [\n     While(first+Length(coefs)>=?(degree+1) And? Length(coefs)>?0) DestructiveDelete(coefs,Length(coefs));\n     UniVariate(var,first,coefs);\n    ];\n20 # BigOh(_uv,_var,_degree)_CanBeUni(uv,var) <-- NormalForm(BigOh(MakeUni(uv,var),var,degree));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/BigOh.mpw";
        scriptMap.put("BigOh",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* CanBeUni returns whether the function can be converted to a\n * univariate, with respect to a variable.\n */\nFunction(\"CanBeUni\",{expression}) CanBeUni(UniVarList(expression),expression);\n\n\n/* Accepting an expression as being convertable to univariate */\n\n/* Dealing wiht a list of variables. The poly should be expandable\n * to each of these variables (smells like tail recursion)\n */\n10 # CanBeUni({},_expression) <-- True;\n20 # CanBeUni(var_IsList,_expression) <--\n    CanBeUni(First(var),expression) And? CanBeUni(Rest(var),expression);\n\n/* Atom can always be a polynom to any variable */\n30 # CanBeUni(_var,expression_IsAtom) <-- True;\n35 # CanBeUni(_var,expression_IsFreeOf(var)) <-- True;\n\n/* Other patterns supported. */\n40 # CanBeUni(_var,_x + _y) <-- CanBeUni(var,x) And? CanBeUni(var,y);\n40 # CanBeUni(_var,_x - _y) <-- CanBeUni(var,x) And? CanBeUni(var,y);\n40 # CanBeUni(_var,   + _y) <-- CanBeUni(var,y);\n40 # CanBeUni(_var,   - _y) <-- CanBeUni(var,y);\n40 # CanBeUni(_var,_x * _y) <-- CanBeUni(var,x) And? CanBeUni(var,y);\n40 # CanBeUni(_var,_x / _y) <-- CanBeUni(var,x) And? IsFreeOf(var,y);\n/* Special case again: raising powers */\n40 # CanBeUni(_var,_x ^ y_IsInteger)_(y >=? 0 And? CanBeUni(var,x)) <-- True;\n41 # CanBeUni(_var,(x_IsFreeOf(var)) ^ (y_IsFreeOf(var))) <-- True;\n50 # CanBeUni(_var,UniVariate(_var,_first,_coefs)) <-- True;\n1000 # CanBeUni(_var,_f)_(Not?(IsFreeOf(var,f))) <-- False;\n1001 # CanBeUni(_var,_f) <-- True;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/CanBeUni.mpw";
        scriptMap.put("CanBeUni",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n5 # Coef(uv_IsUniVar,order_IsList) <--\n[\n  Local(result);\n  result:={};\n  ForEach(item,order)\n  [\n    DestructiveAppend(result,Coef(uv,item));\n  ];\n  result;\n];\n\n10 # Coef(uv_IsUniVar,order_IsInteger)_(order<?uv[2]) <-- 0;\n10 # Coef(uv_IsUniVar,order_IsInteger)_(order>=?uv[2]+Length(uv[3])) <-- 0;\n20 # Coef(uv_IsUniVar,order_IsInteger) <-- uv[3][(order-uv[2])+1];\n30 # Coef(uv_CanBeUni,_order)_(IsInteger(order) Or? IsList(order)) <-- Coef(MakeUni(uv),order);\n\nFunction(\"Coef\",{expression,var,order})\n    NormalForm(Coef(MakeUni(expression,var),order));\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/Coef.mpw";
        scriptMap.put("Coef",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//:::  Collect terms of a polynomial-like expression on powers of var,\n//     starting with power 0.\n\n//Retract(\"CollectOn\",*);\n\n10 # CollectOn(_var,_expr)_(CanBeUni(var,expr)) <--\n[\n    If(InVerboseMode(),Echo(\"<< Collect on:  \",var,\" in expression \",expr));\n    \n    Local(u,a);\n    u := MakeUni(expr,var);\n    If( u[2] >? 0, \n      [ a := FillList(0,u[2]); u[3] := Concat(a,u[3]); u[2] := 0; ]\n    );\n    u[3];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/CollectOn.mpw";
        scriptMap.put("CollectOn",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Content(UniVariate(_var,_first,_coefs)) <-- Gcd(coefs)*var^first;\n20 # Content(poly_CanBeUni) <-- NormalForm(Content(MakeUni(poly)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/Content.mpw";
        scriptMap.put("Content",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"Degree\",*);\n\nRulebase(\"Degree\",{expr});\nRule(\"Degree\",1,0, IsUniVar(expr))\n[\n\n  Local(i,min,max);\n  min:=expr[2];\n  max:=min+Length(expr[3]);\n  i:=max;\n  While(i >=? min And? IsZero(Coef(expr,i))) i--;\n  i;\n];\n\n10 # Degree(poly_CanBeUni)                           <-- Degree(MakeUni(poly));\n\n10 # Degree(_poly,_var)_(CanBeUni(var,poly))         <-- Degree(MakeUni(poly,var));\n\n20 # Degree(_poly,_var)_(Type(poly)=?\"Sqrt\")          <-- Degree(poly^2,var)/2;\n\n20 # Degree(_poly,_var)_(FunctionToList(poly)[1]=? ^) <--\n[\n    Local(ex,pwr,deg);\n    ex  := FunctionToList(poly)[3];\n    pwr := 1/ex;\n    //Tell(\"     \",{ex,pwr});\n    deg := Degree(poly^pwr,var);\n    //Tell(\"     \",deg);\n    deg*ex;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/Degree.mpw";
        scriptMap.put("Degree",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDivPoly(_A,_B,_var,_deg) <--\n[\n  Local(a,b,c,i,j,denom);\n  b:=MakeUni(B,var);\n  denom:=Coef(b,0);\n\n  if (denom =? 0)\n  [\n    Local(f);\n    f:=Content(b);\n    b:=PrimitivePart(b);\n    A:=Simplify(A/f);\n    denom:=Coef(b,0);\n  ];\n  a:=MakeUni(A,var);\n\n  c:=FillList(0,deg+1);\n  For(i:=0,i<=?deg,i++)\n  [\n    Local(sum,j);\n    sum:=0;\n    For(j:=0,j<?i,j++)\n    [\n      sum := sum + c[j+1]*Coef(b,i-j);\n    ];\n    c[i+1] := (Coef(a,i)-sum) / denom;\n  ];\n  NormalForm(UniVariate(var,0,c));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/DivPoly.mpw";
        scriptMap.put("DivPoly",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nDropEndZeroes(list):=\n[\n  Local(end);\n  end:=Length(list);\n  While(list[end] =? 0)\n  [\n    DestructiveDelete(list,end);\n    end:=end-1;\n  ];\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/DropEndZeroes.mpw";
        scriptMap.put("DropEndZeroes",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"ExpandUniVariate\",{var,first,coefs})\n[\n  Local(result,i);\n  result:=0;\n  For(i:=Length(coefs),i>?0,i--)\n  [\n    Local(term);\n    term:=NormalForm(coefs[i])*var^(first+i-1);\n    result:=result+term;\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/ExpandUniVariate.mpw";
        scriptMap.put("ExpandUniVariate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nHorner(_e,_v) <--\n[\n  Local(uni,coefs,result);\n  uni := MakeUni(e,v);\n  coefs:=DestructiveReverse(uni[3]);\n  result:=0;\n\n  While(coefs !=? {})\n  [\n    result := result*v;\n    result := result+First(coefs);\n    coefs  := Rest(coefs);\n  ];\n  result:=result*v^uni[2];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/Horner.mpw";
        scriptMap.put("Horner",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # IsUniVar(UniVariate(_var,_first,_coefs)) <-- True;\n20 # IsUniVar(_anything) <-- False;\n\n200 # aLeft_IsUniVar ^ aRight_IsPositiveInteger <--\n      RepeatedSquaresMultiply(aLeft,aRight);\n\n\n200 # aLeft_IsUniVar - aRight_IsUniVar <--\n[\n  Local(from,result);\n  Local(curl,curr,left,right);\n\n  curl:=aLeft[2];\n  curr:=aRight[2];\n  left:=aLeft[3];\n  right:=aRight[3];\n  result:={};\n  from:=Minimum(curl,curr);\n\n  While(curl<?curr And? left !=? {})\n  [\n    DestructiveAppend(result,First(left));\n    left:=Rest(left);\n    curl++;\n  ];\n  While(curl<?curr)\n  [\n    DestructiveAppend(result,0);\n    curl++;\n  ];\n  While(curr<?curl And? right !=? {})\n  [\n    DestructiveAppend(result,-First(right));\n    right:=Rest(right);\n    curr++;\n  ];\n  While(curr<?curl)\n  [\n    DestructiveAppend(result,0);\n    curr++;\n  ];\n  While(left !=? {} And? right !=? {})\n  [\n    DestructiveAppend(result,First(left)-First(right));\n    left  := Rest(left);\n    right := Rest(right);\n  ];\n\n\n  While(left !=? {})\n  [\n    DestructiveAppend(result,First(left));\n    left  := Rest(left);\n  ];\n  While(right !=? {})\n  [\n    DestructiveAppend(result,-First(right));\n    right := Rest(right);\n  ];\n\n  UniVariate(aLeft[1],from,result);\n];\n\n\n\n/*TODO this can be made twice as fast!*/\n\n201 # (aLeft_IsUniVar * _aRight)_((IsFreeOf(aLeft[1],aRight))) <--\n[\n    aRight*aLeft;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/IsUniVar.mpw";
        scriptMap.put("IsUniVar",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//todo:tk:moved here form Coef.mpw.\n10 # LeadingCoef(uv_IsUniVar) <-- Coef(uv,Degree(uv));\n\n20 # LeadingCoef(uv_CanBeUni) <--\n[\n  Local(uvi);\n  uvi:=MakeUni(uv);\n  Coef(uvi,Degree(uvi));\n];\n10 # LeadingCoef(uv_CanBeUni(var),_var) <--\n[\n  Local(uvi);\n  uvi:=MakeUni(uv,var);\n  Coef(uvi,var,Degree(uvi));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/LeadingCoef.mpw";
        scriptMap.put("LeadingCoef",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"MakeUni\",{expression}) MakeUni(expression,UniVarList(expression));\n\n/* Convert normal form to univariate expression */\nRulebase(\"MakeUni\",{expression,var});\n\n5 # MakeUni(_expr,{}) <-- UniVariate(dummyvar,0,{expression});\n6 # MakeUni(_expr,var_IsList) <--\n[\n  Local(result,item);\n  result:=expression;\n  ForEach(item,var)\n  [\n    result:=MakeUni(result,item);\n  ];\n  result;\n];\n\n10 # MakeUni(UniVariate(_var,_first,_coefs),_var) <--\n    UniVariate(var,first,coefs);\n\n20 # MakeUni(UniVariate(_v,_first,_coefs),_var) <--\n[\n  Local(reslist,item);\n  reslist:={};\n  ForEach(item,expression[3])\n  [\n    If(IsFreeOf(var,item),\n      DestructiveAppend(reslist,item),\n      DestructiveAppend(reslist,MakeUni(item,var))\n      );\n  ];\n  UniVariate(expression[1],expression[2],reslist);\n];\n\n\nLocalSymbols(a,b,var,expression)\n[\n  20 # MakeUni(expression_IsFreeOf(var),_var)\n       <-- UniVariate(var,0,{expression});\n  30 # MakeUni(_var,_var) <-- UniVariate(var,1,{1});\n  30 # MakeUni(_a + _b,_var) <-- MakeUni(a,var) + MakeUni(b,var);\n  30 # MakeUni(_a - _b,_var) <-- MakeUni(a,var) - MakeUni(b,var);\n  30 # MakeUni(   - _b,_var) <--                - MakeUni(b,var);\n  30 # MakeUni(_a * _b,_var) <-- MakeUni(a,var) * MakeUni(b,var);\n  1 # MakeUni(_a ^ n_IsInteger,_var) <-- MakeUni(a,var) ^ n;\n  30 # MakeUni(_a / (b_IsFreeOf(var)),_var) <-- MakeUni(a,var) * (1/b);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/MakeUni.mpw";
        scriptMap.put("MakeUni",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # Monic(UniVariate(_var,_first,_coefs)) <--\n[\n  DropEndZeroes(coefs);\n  UniVariate(var,first,coefs/coefs[Length(coefs)]);\n];\n20 # Monic(poly_CanBeUni) <-- NormalForm(Monic(MakeUni(poly)));\n\n30 # Monic(_poly,_var)_CanBeUni(poly,var) <-- NormalForm(Monic(MakeUni(poly,var)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/Monic.mpw";
        scriptMap.put("Monic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # PrimitivePart(UniVariate(_var,_first,_coefs)) <--\n        UniVariate(var,0,coefs/Gcd(coefs));\n20 # PrimitivePart(poly_CanBeUni) <-- NormalForm(PrimitivePart(MakeUni(poly)));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/PrimitivePart.mpw";
        scriptMap.put("PrimitivePart",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* Repeated squares multiplication\n TODO put somewhere else!!!\n */\n10 # RepeatedSquaresMultiply(_a,- (n_IsInteger)) <-- 1/RepeatedSquaresMultiply(a,n);\n\n15 #  RepeatedSquaresMultiply(UniVariate(_var,_first,{_coef}),(n_IsInteger)) <--\n      UniVariate(var,first*n,{coef^n});\n20 # RepeatedSquaresMultiply(_a,n_IsInteger) <--\n[\n  Local(m,b);\n  Bind(m,1);\n  Bind(b,1);\n  While(m<=?n) Bind(m,(ShiftLeft(m,1)));\n  Bind(m, ShiftRight(m,1));\n  While(m>?0)\n  [\n    Bind(b,b*b);\n    If (Not?(IsEqual(BitAnd(m,n), 0)),Bind(b,b*a));\n    Bind(m, ShiftRight(m,1));\n  ];\n  b;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/RepeatedSquaresMultiply.mpw";
        scriptMap.put("RepeatedSquaresMultiply",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/* division algo: (for zero-base univariates:) */\nFunction(\"UniDivide\",{u,v})\n[\n  Local(m,n,q,r,k,j);\n  m := Length(u)-1;\n  n := Length(v)-1;\n  While (m>?0 And? IsZero(u[m+1])) m--;\n  While (n>?0 And? IsZero(v[n+1])) n--;\n  q := ZeroVector(m-n+1);\n  r := FlatCopy(u);  /*  (m should be >= n) */\n  For(k:=m-n,k>=?0,k--)\n  [\n    q[k+1] := r[n+k+1]/v[n+1];\n    For (j:=n+k-1,j>=?k,j--)\n    [\n      r[j+1] := r[j+1] - q[k+1]*v[j-k+1];\n    ];\n  ];\n  Local(end);\n  end:=Length(r);\n  While (end>?n)\n  [\n    DestructiveDelete(r,end);\n    end:=end-1;\n  ];\n\n  {q,r};\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/UniDivide.mpw";
        scriptMap.put("UniDivide",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"UniGcd\",{u,v})\n[\n  Local(l,div,mod,m);\n\n  DropEndZeroes(u);\n  DropEndZeroes(v);\n/*\n  If(Length(v)>?Length(u),\n    [\n      Locap(swap);\n      swap:=u;\n      u:=v;\n      v:=swap;\n    ] );\n  If(Length(u)=Length(v) And? v[Length(v)] >? u[Length(u)],\n    [\n      Locap(swap);\n      swap:=u;\n      u:=v;\n      v:=swap;\n    ] );\n  */\n\n\n  l:=UniDivide(u,v);\n\n  div:=l[1];\n  mod:=l[2];\n\n  DropEndZeroes(mod);\n  m := Length(mod);\n\n/* Echo({\"v,mod = \",v,mod}); */\n/*  If(m <=? 1, */\n  If(m =? 0,\n     v,\n/*     v/v[Length(v)], */\n     UniGcd(v,mod));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/UniGCD.mpw";
        scriptMap.put("UniGcd",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"UniTaylor\",{taylorfunction,taylorvariable,taylorat,taylororder})\n[\n  Local(n,result,dif,polf);\n  result:={};\n  [\n    MacroLocal(taylorvariable);\n    MacroBind(taylorvariable,taylorat);\n    DestructiveAppend(result,Eval(taylorfunction));\n  ];\n  dif:=taylorfunction;\n  polf:=(taylorvariable-taylorat);\n  For(n:=1,n<=?taylororder,n++)\n  [\n    dif:= Deriv(taylorvariable) dif;\n    MacroLocal(taylorvariable);\n    MacroBind(taylorvariable,taylorat);\n    DestructiveAppend(result,(Eval(dif)/n!));\n  ];\n  UniVariate(taylorvariable,0,result);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/UniTaylor.mpw";
        scriptMap.put("UniTaylor",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Note:tk:since this is used in more than one univariate function, I am publishing it as a def.\n\nUniVarList(expr) := VarList(expr);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/UniVarList.mpw";
        scriptMap.put("UniVarList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Auxiliary function.\nShiftUniVar(UniVariate(_var,_first,_coefs),_fact,_shift)\n   <--\n   [\n//Echo(\"fact, coefs = \",fact,coefs);\n     UniVariate(var,first+shift,fact*coefs);\n   ];\n\n\n\nRulebase(\"UniVariate\",{var,first,coefs});\n\nRule(\"UniVariate\",3,10,Length(coefs)>?0 And? coefs[1]=?0)\n  UniVariate(var,first+1,Rest(coefs));\nRule(\"UniVariate\",3,1000,IsComplex(var) Or? IsList(var))\n    ExpandUniVariate(var,first,coefs);\n\n500 # UniVariate(_var,_f1,_c1) + UniVariate(_var,_f2,_c2) <--\n[\n  Local(from,result);\n  Local(curl,curr,left,right);\n\n  Bind(curl, f1);\n  Bind(curr, f2);\n  Bind(left, c1);\n  Bind(right, c2);\n  Bind(result, {});\n  Bind(from, Minimum(curl,curr));\n\n  While(And?(IsLessThan(curl,curr),left !=? {}))\n  [\n    DestructiveAppend(result,First(left));\n    Bind(left,Rest(left));\n    Bind(curl,AddN(curl,1));\n  ];\n  While(IsLessThan(curl,curr))\n  [\n    DestructiveAppend(result,0);\n    Bind(curl,AddN(curl,1));\n  ];\n  While(And?(IsLessThan(curr,curl), right !=? {}))\n  [\n    DestructiveAppend(result,First(right));\n    Bind(right,Rest(right));\n    Bind(curr,AddN(curr,1));\n  ];\n  While(IsLessThan(curr,curl))\n  [\n    DestructiveAppend(result,0);\n    Bind(curr,AddN(curr,1));\n  ];\n  While(And?(left !=? {}, right !=? {}))\n  [\n    DestructiveAppend(result,First(left)+First(right));\n    Bind(left, Rest(left));\n    Bind(right, Rest(right));\n  ];\n  While(left !=? {})\n  [\n    DestructiveAppend(result,First(left));\n    Bind(left, Rest(left));\n  ];\n  While(right !=? {})\n  [\n    DestructiveAppend(result,First(right));\n    Bind(right, Rest(right));\n  ];\n\n  UniVariate(var,from,result);\n];\n\n\n200 # UniVariate(_var,_first,_coefs) + a_IsNumber <--\n      UniVariate(var,first,coefs) + UniVariate(var,0,{a});\n200 # a_IsNumber + UniVariate(_var,_first,_coefs) <--\n      UniVariate(var,first,coefs) + UniVariate(var,0,{a});\n\n\n200 # - UniVariate(_var,_first,_coefs) <-- UniVariate(var,first,-coefs);\n\n\n200 # (_factor * UniVariate(_var,_first,_coefs))_((IsFreeOf(var,factor))) <--\n  UniVariate(var,first,coefs*factor);\n\n200 # (UniVariate(_var,_first,_coefs)/_factor)_((IsFreeOf(var,factor))) <--\n  UniVariate(var,first,coefs/factor);\n\n\n\n200 # UniVariate(_var,_f1,_c1) * UniVariate(_var,_f2,_c2) <--\n[\n  Local(i,j,n,shifted,result);\n  Bind(result,MakeUni(0,var));\n//Echo(\"c1 = \",var,f1,c1);\n//Echo(\"c2 = \",var,f2,c2);\n  Bind(n,Length(c1));\n  For(i:=1,i<=?n,i++)\n  [\n//Echo(\"before = \",result);\n//Echo(\"parms = \",var,c1,c2,f1,f2,f1+i-1);\n    Bind(result,result+ShiftUniVar(UniVariate(var,f2,c2),MathNth(c1,i),f1+i-1));\n//Echo(\"after = \",result);\n  ];\n//Echo(\"result = \",result);\n  result;\n];\n\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/UniVariate.mpw";
        scriptMap.put("UniVariate",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//  Cyclotomic(n,x):\n//  Returns the cyclotomic polinomial in the variable x\n//  (which is the minimal polynomial of the n-th primitive\n//  roots of the unit).\n//  Autor: Pablo De Napoli\n\n//LoadScriptOnce(\"univar.rep/code.mpi\");\n\n// Auxiliar function for Cyclotomic: returns the internal representation of\n// x^q+a as an univarate polinomial (like MakeUni(x^q+a) but more efficient)\n\nFunction (\"UniVariateBinomial\",{x,q,a})\n[\nLocal(L,i);\nL := {a};\nFor (i:=1,i<?q,i++)\n DestructiveAppend(L,0);\nDestructiveAppend(L,1);\nUniVariate(x,0,L);\n];\n\n// Auxiliar function for Cyclotomic: substitute in the univariate\n// polinomial p the variable x by -x^k. The implementations assumes that\n// the polinomial p starts with x^0\n\nFunction(\"SubstituteInUniVar\",{p,k})\n[\n Local(c,i,d,j,NL);\n L  := p[3];  // The coefficients list\n NL := {};    // The new coefficients list\n d  := Degree(p);\n i  :=d;\n ForEach(c,L) [\n  // c is the coefficient of x^i in p\n  // We append k-1 zeros\n  If (i<?d, For (j:=1,j<?k,j++) DestructiveAppend(NL,0));\n  // We append (-1)^i*c as the coefficient of x^(k*i)\n  DestructiveAppend(NL,If(IsEven(i),c,-c));\n  i--;\n ];\n UniVariate(First(p),0,NL);\n];\n\n\n// Adapted from ExpandUniVariate\n// Auxiliar function for Cyclotomic: substitute in the univariate\n// polinomial p the variable x by -x^k, but returns the result in\n// expanded form\n\nFunction(\"SubstituteAndExpandInUniVar\",{p,k})\n[\n  Local(result,i,var,first,coefs,c,nc,exponent);\n  result:=0;\n  var := p[1];\n  first:= p[2];\n  coefs:= p[3];\n  For(i:=Length(coefs),i>?0,i--)\n  [\n    Local(term);\n    exponent := first+i-1;\n    c:= coefs[i];\n    nc := If(IsEven(exponent),c,-c);\n    term:=NormalForm(nc*var^(exponent*k));\n    result:=result+term;\n  ];\n  result;\n];\n\n// Returns a list of elements of the form {d1,d2,m}\n// where\n// 1) d1,d2 runs through the square free divisors of n\n// 2) d1 divides d2 and d2/d1 is a prime factor of n\n// 3) m=Moebius(d1)\n// Addapted form: MoebiusDivisorsList\n\nCyclotomicDivisorsList(n_IsPositiveInteger) <--\n[\n Local(nFactors,f,result,oldresult,x);\n nFactors:= Factors(n);\n result := {{1,nFactors[1][1],1}};\n nFactors := Rest(nFactors);\n ForEach (f,nFactors)\n    [\n      oldresult := result;\n        ForEach (x,oldresult)\n          result:=Append(result,{x[1]*f[1],x[2]*f[1],-x[3]});\n    ];\n  result;\n];\n\n// CyclotomicFactor(x,a,b): Auxiliary function that constructs the term list of\n// the polynomial\n// Quotient(x^a-1,x^b-1) =\n// x^(b*(p-1)) + x^(b^*(p-2)) + ... + x^(b) + 1\n// p= a/b, b should divide a\n\n\nCyclotomicFactor(_a,_b) <--\n[\n Local(coef,p,i,j,result); p := a/b; result:= {{b*(p-1),1}}; For (i:=\n p-2,i>=?0,i--)\n   DestructiveAppend(result,{b*i,1});\n result;\n];\n\n\n\n// This new implementation makes use of the internal representations of univariate\n// polynomials as SparseUniVar(var,termlist).\n\n\n//  For n even, we write n= m*k, where k is a Power of 2\n//  and m is odd, and redce it to the case m even since:\n//\n//   Cyclotomic(n,x) = Cyclotomic(m,-x^{k/2})\n//\n// If m=1, n is a power of 2, and Cyclotomic(n,x)= x^k+1 */\n\n\n10 # InternalCyclotomic(n_IsEven,_x) <--\n     [\n      Local(k,m,result,p,t);\n       k := 1;\n       m := n;\n        While(IsEven(m))\n       [\n        k := k*2;\n        m := m/2;\n       ];\n       k := k/2 ;\n       If(m>?1, [\n                 p:= InternalCyclotomic(m,x)[2];\n                 // Substitute x by -x^k\n                 result:={};\n                 ForEach(t,p)\n                    DestructiveAppend(result, {t[1]*k,If(IsEven(t[1]),t[2],-t[2])});\n               ],\n                 result := {{k,1},{0,1}} // x^k+1\n        );\n        SparseUniVar(x,result);\n     ];\n\n\n//  For n odd, the algoritm is based on the formula\n//\n//     Cyclotomic(n,x) := Prod (x^(n/d)-1)^Moebius(d)\n//\n// where d runs through the divisors of n.\n\n// We compute in poly1 the product\n// of (x^(n/d)-1) with Moebius(d)=1 , and in poly2 the product of these polynomials\n// with  Moebius(d)=-1. Finally we compute the quotient poly1/poly2\n\n// In order to compute this in a efficient way, we use the functions\n// CyclotomicDivisorsList and  CyclotomicFactors (in order to avoid\n// unnecesary polynomial divisions)\n\n\n20 # InternalCyclotomic(n_IsOdd,_x)_(n>?1) <--\n[\n Local(divisors,poly1,poly2,q,d,f,coef,i,j,result);\n divisors := CyclotomicDivisorsList(n);\n poly1 := {{0,1}};\n poly2 := {{0,1}};\n ForEach (d,divisors)\n [\n   If(InVerboseMode(),Echo(\"d=\",d));\n   f:= CyclotomicFactor(n/d[1],n/d[2]);\n   If (d[3]=?1,poly1:=MultiplyTerms(poly1,f),poly2:=MultiplyTerms(poly2,f));\n   If(InVerboseMode(),\n     [\n       Echo(\"poly1=\",poly1);\n       Echo(\"poly2=\",poly2);\n     ]);\n ];\n If(InVerboseMode(),Echo(\"End ForEach\"));\n result := If(poly2=?{{0,1}},poly1,DivTermList(poly1,poly2));\n SparseUniVar(x,result);\n];\n\n\n10  # Cyclotomic(1,_x) <-- x-1;\n20  # Cyclotomic(n_IsInteger,_x) <-- ExpandSparseUniVar(InternalCyclotomic(n,x));\n\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/cyclotomic/Cyclotomic.mpw";
        scriptMap.put("Cyclotomic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// OldInternalCyclotomic(n,x,WantNormalForm) is the internal implementation\n// WantNormalForm is a boolean parameter. If it is true, returns the normal\n// form, if it is false returns the UniVariate representation.\n\n// This (old) implementation makes use of the internal representations of univariate\n// polynomials as UniVariate(var,begining,coefficients).\n// There is also a version UniVariateCyclotomic(n,x) that returns the\n// cyclotomic polynomial in the UniVariate representation.\n\n\n10 # OldInternalCyclotomic(n_IsEven,_x,WantNormalForm_IsBoolean) <--\n     [\n      Local(k,m,p);\n       k := 1;\n       m := n;\n        While(IsEven(m))\n       [\n        k := k*2;\n        m := m/2;\n       ];\n       k := k/2 ;\n       If(m>?1, [\n                 p := OldInternalCyclotomic(m,x,False);\n                 If (WantNormalForm, SubstituteAndExpandInUniVar(p,k),SubstituteInUniVar(p,k));\n               ],\n                 If (WantNormalForm, x^k+1, UniVariateBinomial(x,k,1))\n        );\n     ];\n\n20 # OldInternalCyclotomic(n_IsOdd,_x,WantNormalForm_IsBoolean)_(n>?1) <--\n[\n Local(divisors,poly1,poly2,q,d,f,result);\n divisors := MoebiusDivisorsList(n);\n poly1 :=1 ;\n poly2 := 1;\n ForEach (d,divisors)\n [\n   q:=n/d[1];\n   f:=UniVariateBinomial(x,q,-1);\n   If (d[2]=?1,poly1:=poly1*f,poly2:=poly2*f);\n ];\n result := Quotient(poly1,poly2);\n If(WantNormalForm,NormalForm(result),result);\n];\n\n10  # OldCyclotomic(1,_x) <-- _x-1;\n20  # OldCyclotomic(n_IsInteger,_x) <-- OldInternalCyclotomic(n,x,True);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/cyclotomic/OldCyclotomic.mpw";
        scriptMap.put("OldCyclotomic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// This function returns the Cyclotomic polynomial, but in the univariate\n// representation\n\n10  # UniVariateCyclotomic(1,_x) <-- UniVariate(x,0,{-1,1});\n20  # UniVariateCyclotomic(n_IsInteger,_x) <-- OldInternalCyclotomic(n,x,False);\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/cyclotomic/UniVariateCyclotomic.mpw";
        scriptMap.put("UniVariateCyclotomic",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nNote:tk:I am publishing this function as a def because\nbut it seems like it was meant to be a published function.\n*/\n\n// Add a term into a termlist: this function assumes that\n//  1) the list of terms is sorted in decreasing order of exponents\n//  2) there are not two terms with the same exponent.\n//  3) There is no term with cero coefficient\n// This assumptions are preserved.\n\n// The parameter begining tell us where to begin the search\n// (it is used for increasing the efficency of the algorithms!)\n// The function returns the position at which the new term is added plus 1.\n// (to be used as begining for sucesive AddTerm calls\n\nFunction(\"AddTerm\",{termlist,term,begining})\n[\n Local(l,i);\n l := Length(termlist);\n If(term[2]!=?0,\n [\n  i:=begining;\n// Fix-me: search by using binary search ?\n  If (l>=?1, While ((i<=?l) And? (term[1]<?termlist[i][1])) i++);\n  If  (i>?l, [DestructiveAppend(termlist,term);i++;],\n          If (term[1]=?termlist[i][1],\n             [ Local(nc);\n               nc:=termlist[i][2]+term[2];\n                 If(nc!=?0,DestructiveReplace(termlist,i,{term[1],nc}),\n                          [DestructiveDelete(termlist,i);i--;]);\n             ],  DestructiveInsert(termlist,i,term))\n     );\n ]\n  );\n i+1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/AddTerm.mpw";
        scriptMap.put("AddTerm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nNote:tk:I am publishing this function as a def because\nbut it seems like it was meant to be a published function.\n*/\n\nFunction(\"AddTerms\",{terms1,terms2})\n[\n  Local(result,begining,t);\n  begining :=1;\n  ForEach (t,terms2)\n     begining :=AddTerm(terms1,t,begining);\n  terms1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/AddTerms.mpw";
        scriptMap.put("AddTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n// Implements the division of polynomials!\n\nFunction(\"DivTermList\",{a,b})\n[\n Local(q,nq,t,c,begining);\n q := {};\n // a[1][1] is the degree of a, b[1][1] is the degree of b\n While ((a!=?{}) And? a[1][1]>=?b[1][1])\n  [\n     begining := 1;\n     If(InVerboseMode(),Echo(\"degree=\",a[1][1]));\n     nq := {a[1][1]-b[1][1],a[1][2]/b[1][2]}; // a new term of the quotient\n     DestructiveAppend(q,nq);\n     // We compute a:= a - nq* b\n     ForEach (t,b)\n       begining := AddTerm(a,{t[1]+nq[1],-t[2]*nq[2]},begining);\n   ];\n   // a is the rest at the end\n q;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/DivTermList.mpw";
        scriptMap.put("DivTermList",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"ExpandSparseUniVar\",{s})\n[\n Local(result,t,var,termlist);\n result :=0;\n var := s[1];\n termlist := s[2];\n ForEach (t,termlist)\n [\n   Local(term);\n   term := NormalForm(t[2]*var^t[1]);\n   result := result + term;\n ];\n result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/ExpandSparseUniVar.mpw";
        scriptMap.put("ExpandSparseUniVar",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"MakeSparseUniVar\",*);\n\n10 # MakeSparseUniVar(poly_CanBeUni,var_IsAtom) <--\n[\n    If(InVerboseMode(),Tell(\"MakeSparseUniVar\",{var,poly}));\n    Local(uni,first,coeffs,n,c,lc,termlist,term);\n    uni    := MakeUni(poly,var);\n    If(InVerboseMode(),Tell(\"      \",uni));\n    first  := uni[2];\n    coeffs := (uni[3]);\n    If(InVerboseMode(),[Tell(\"    \",first); Tell(\"   \",coeffs);]);\n    termlist := {};\n    lc       := Length(coeffs);\n    For(n:=0,n<?lc,n++)\n    [\n        c    := coeffs[n+1];\n        term := {n+first,c};\n        If(InVerboseMode(),Tell(\"        \",term));\n        If(c !=? 0, Push(termlist,term));\n    ];\n    If(InVerboseMode(),Tell(\"   \",{var,termlist}));\n    {var,termlist};\n];\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/MakeSparseUniVar.mpw";
        scriptMap.put("MakeSparseUniVar",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nNote:tk:I am publishing this function as a def because\nbut it seems like it was meant to be a published function.\n*/\n\n// Multiply a list of terms by a Single term.\n\nFunction(\"MultiplySingleTerm\",{termlist,term})\n[\n Local(result,t);\n result:={};\n If(term[2]!=?0,\n       ForEach (t,termlist)\n         DestructiveAppend(result,{t[1]+term[1],t[2]*term[2]}) );\n result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/MultiplySingleTerm.mpw";
        scriptMap.put("MultiplySingleTerm",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nFunction(\"MultiplyTerms\",{terms1,terms2})\n[\n Local(result,t1,t2,begining);\n result:={};\n ForEach (t1,terms1)\n [\n   begining :=1;\n   ForEach (t2,terms2)\n     begining := AddTerm(result,{t1[1]+t2[1],t1[2]*t2[2]},1);\n ];\n result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/MultiplyTerms.mpw";
        scriptMap.put("MultiplyTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nNote:tk:I am publishing this function as a def because\nbut it seems like it was meant to be a published function.\n*/\n\n// SparseUniVariate(variable,termlist) implements an internal representation\n// for univariate polynomials\n// termlist is the list of terms in the form {exponent,coeficient}\n\nRulebase(\"SparseUniVar\",{var,termlist});\n\n300 # SparseUniVar(_var,_terms1) * SparseUniVar(_var,_terms2) <--\nSparseUniVar(var, MultiplyTerms(terms1,terms2));\n\n300 # SparseUniVar(_var,_terms1) + SparseUniVar(_var,_terms2) <--\nSparseUniVar(var, AddTerms(terms1,terms2));\n\n300 # SparseUniVar(_var,_terms1) - SparseUniVar(_var,_terms2) <--\nSparseUniVar(var, SubstractTerms(terms1,terms2));\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/SparseUniVar.mpw";
        scriptMap.put("SparseUniVar",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/*\nNote:tk:I am publishing this function as a def because\nbut it seems like it was meant to be a published function.\n*/\n\nFunction(\"SubtractTerms\",{terms1,terms2})\n[\n  Local(result,t);\n  begining :=1 ;\n  ForEach (t,terms2)\n     begining := AddTerm(terms1,{t[1],-t[2]},1);\n  terms1;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sparse/SubtractTerms.mpw";
        scriptMap.put("SubtractTerms",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nBoundRealRoots(_p) <--\n[\n  BoundRealRoots(p,MinimumBound(p),MaximumBound(p));\n];\n\nBoundRealRoots(_p,_Mmin,_Mmax) <--\n[\n  Local(S,N,work,result,Vmin,Vmax,a,b,Va,Vb,c,Vc,x);\n\n  result:={};\n  if (IsZero(p Where x==0))\n  [\n    p:=Simplify(p/x);\n    result:={{0,0}};\n  ];\n  S:=SturmSequence(p);\n  Vmin := SturmVariations(S,-Infinity);\n  Vmax := SturmVariations(S,Infinity);\n\n//Echo(\"Vmin,Vmax = \",Vmin,Vmax);\n\n  N:=Vmin - Vmax;\n\n//Echo(\"N = \",N);\n\n//Echo(\"Mmin,Mmax = \",Mmin,Mmax);\n  work:={};\n  if (N=?1)\n  [\n    result:={{-Mmax,Mmax}};\n  ];\n  if (N>?1)\n  [\n    work :=\n    {\n      {-Mmax,-Mmin,Vmin,SturmVariations(S,-Mmin)},\n      { Mmin, Mmax,SturmVariations(S, Mmin),Vmax}\n    };\n  ];\n\n//Echo(\"Work start = \",work);\n    While(work !=? {})\n    [\n      {a,b,Va,Vb} := First(work);\n      work := Rest(work);\n      c:=(a+b)/2;\n//Echo(a,b,c);\n      Vc := SturmVariations(S,c);\n      if (IsZero(p Where x == c))\n      [\n        Local(M,Vcmin,Vcplus,pnew);\n        pnew := Simplify((p Where x == x+c)/x);\n        M:=MinimumBound(pnew);\n//Echo(\"Mi = \",M);\n        Vcmin  := SturmVariations(S, c-M);\n        Vcplus := SturmVariations(S, c+M);\n        result:=Concat(result,{{c,c}});\n\n        if (Va =? Vcmin+1)\n        [\n          result:=Concat(result,{{a,c-M}});\n        ];\n        if (Va >? Vcmin+1)\n        [\n          work:=Concat(work,{{a,c-M,Va,Vcmin}});\n        ];\n        if (Vb =? Vcplus-1)\n        [\n          result:=Concat(result,{{c+M,b}});\n        ];\n        if (Vb <? Vcplus-1)\n        [\n          work:=Concat(work,{{c+M,b,Vcplus,Vb}});\n        ];\n      ]\n      else\n      [\n        if (Va =? Vc+1)\n        [\n          result:=Concat(result,{{a,c}});\n        ];\n        if (Va >? Vc+1)\n        [\n          work:=Concat(work,{{a,c,Va,Vc}});\n        ];\n        if (Vb =? Vc-1)\n        [\n          result:=Concat(result,{{c,b}});\n        ];\n        if (Vb <? Vc-1)\n        [\n          work:=Concat(work,{{c,b,Vc,Vb}});\n        ];\n      ];\n    ];\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/BoundRealRoots.mpw";
        scriptMap.put("BoundRealRoots",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\niDebug:=False;\n\n//Retract(\"FindRealRoots\",*);\n\nFindRealRoots(_p) <--\n[\n    If(iDebug,Tell(\"FindRealRoots\",p));\n    Local(vars,var,cc,pp,vlcc,zeroRoot,minb,maxb,rr);\n    vars := VarList(p);\n    var  := vars[1];\n    cc   := Content(p);\n    pp   := PrimitivePart(p);\n    If(iDebug,Tell(\"   \",{cc,pp}));\n    vlcc := VarList(cc);\n    If(Length(vlcc)>?0 And? Contains(vlcc,var), zeroRoot:=True,zeroRoot:=False);\n    p:=SquareFree(Rationalize(pp));\n    If(iDebug,Tell(\"   after sqf\",p));\n    minb := MinimumBound(p);\n    maxb := MaximumBound(p);\n    If(iDebug,Tell(\"   \",{minb,maxb}));\n    rr := FindRealRoots(p,minb,maxb);\n    If(zeroRoot,DestructiveAppend(rr,0));\n    rr;\n];\n\n\nFindRealRoots(_p,_Mmin,_Mmax) <--\n[\n    If(iDebug,Tell(\"  FindRealRoots3\",{p,Mmin,Mmax}));\n    Local(bounds,result,i,prec,requiredPrec);\n    bounds := BoundRealRoots(p,Mmin,Mmax);\n    If(iDebug,Tell(\"      \",{bounds,Length(bounds)}));\n    result:=FillList(0,Length(bounds));\n    requiredPrec := BuiltinPrecisionGet();\n    BuiltinPrecisionSet(BuiltinPrecisionGet()+4);\n    prec:=10^-(requiredPrec+1);\n\n    For(i:=1,i<=?Length(bounds),i++)\n    [\n        If(iDebug,Tell(i));\n        Local(a,b,c,r);\n        {a,b} := bounds[i];\n        c:=N(Eval((a+b)/2));\n        If(iDebug,Tell(\"         \",{a,b,c}));\n        r := Fail;\n        If(iDebug,Tell(\"         newt1\",`Hold(Newton(@p,x,@c,@prec,@a,@b))));\n        if (a !=? b) [r := `Newton(@p,x,@c,prec,a,b);];\n        If(iDebug,Tell(\"         newt2\",r));\n        if (r =? Fail)\n          [\n             Local(c,cold,pa,pb,pc);\n             pa:=(p Where x==a);\n             pb:=(p Where x==b);\n             c:=((a+b)/2);\n             cold := a;\n             While (Abs(cold-c)>?prec)\n             [\n                 pc:=(p Where x==c);\n                 If(iDebug,Tell(\"              \",{a,b,c}));\n                 if (Abs(pc) <? prec)\n                   [ a:=c; b:=c; ]\n                 else if (pa*pc <? 0)\n                   [ b:=c; pb:=pc; ]\n                 else\n                   [ a:=c; pa:=pc; ];\n                   cold:=c;\n                   c:=((a+b)/2);\n             ];\n             r:=c;\n          ];\n        result[i] := N(Eval((r/10)*(10)),requiredPrec);\n    ];\n    BuiltinPrecisionSet(requiredPrec);\n    result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/FindRealRoots.mpw";
        scriptMap.put("FindRealRoots",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n/** Maximum bound on the absolute value of the roots of a\n  polynomial p in variable x, according to Knuth:\n\n  Maximum( Abs(a[n-1]/a[n]) , Abs(a[n-2]/a[n])^(1/2), ... , Abs(a[0]/a[n])^(1/n) )\n\n As described in Davenport.\n */\n 5 # MaximumBound(_p)_(IsZero(p Where x==0)) <-- MaximumBound(Simplify(p/x));\n10 # MaximumBound(_p)_(Degree(p)>?0) <--\n[\n  Local(an);\n  an:=Coef(p,(Degree(p)-1) .. 0)/Coef(p,Degree(p));\n  an := N(Eval(Abs(an)^(1/(1 .. Degree(p)))));\n  Rationalize(2*Maximum(an));\n];\n\n20 # MaximumBound(_p) <-- Infinity;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/MaximumBound.mpw";
        scriptMap.put("MaximumBound",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # MinimumBound(_p)_(IsZero(p Where x==0)) <-- 0;\n\n20 # MinimumBound(_p)_(Degree(p)>?0) <--\n[\n  Local(an,result);\n  an:=Coef(p,1 .. (Degree(p)))/Coef(p,0);\n  an := N(Eval(Abs(an)^(1/(1 .. Degree(p)))));\n\n  result:=0;\n  an:=2*Maximum(an);\n  if(Not? IsZero(an)) [result := 1/an;];\n  Simplify(Rationalize(result));\n];\n30 # MinimumBound(_p) <-- -Infinity;\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/MinimumBound.mpw";
        scriptMap.put("MinimumBound",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\nRealRootsCount(_p) <--\n[\n  Local(S);\n  p:=SquareFree(Rationalize(p));\n  S:=SturmSequence(p);\n  SturmVariations(S,-Infinity)-SturmVariations(S,Infinity);\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/RealRootsCount.mpw";
        scriptMap.put("RealRootsCount",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"SquareFree\",*);\n\n\n10 # SquareFree(_p)_(Length(VarList(p))!=?1) <-- Check(False,\"Argument\",\"Input must be Univariate\");\n\n12 # SquareFree(_p) <-- SquareFree(p,VarList(p)[1]);\n\n14 # SquareFree(_p,_var)_(Not? IsPolynomial(p,var)) <-- Check(False,\"Argument\",\"Input must be Univariate Polynomial\");\n\n16 # SquareFree(_p,_var) <--\n[\n  /*\n  Local(dp,gcd);\n  dp:=MakeMultiNomial(`(Differentiate(var)(@p)),{var});\n\n  p:=MakeMultiNomial(p,{var});\n  gcd:=MultiGcd(p,dp);\n  NormalForm(MultiDivide(p,{gcd})[1][1]);\n  */\n  Quotient(p,Gcd(p,(`(Differentiate(@var)(@p)))));\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/SquareFree.mpw";
        scriptMap.put("SquareFree",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n//Retract(\"SturmSequence\",*);\n\n/** SturmSequence(p) : generate a Sturm sequence for a univariate polynomial\n */\n\n10 # SturmSequence(_p,_var) <--\n[\n  Local(result,i,deg,nt);\n  If(InVerboseMode(),Tell(10));\n  result := {p,`Differentiate(@var)(@p)};\n  deg    := Degree(p,var);\n  For(i:=3,i<=?deg+1,i++)\n  [\n    nt := -NormalForm(MultiDivide(MM(result[i-2],{var}),{MM(result[i-1],{var})})[2]);//??\n    DestructiveAppend(result,nt);\n  ];\n  result;\n];\n\n20 # SturmSequence(_p)_(Length(VarList(p))=?1) <-- SturmSequence(p,VarList(p)[1]);\n\n30 # SturmSequence(_p) <-- Check(Length(VarList(p))=?1,\"Argument\",\"Input must be Univariate Polynomial. \");\n\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/SturmSequence.mpw";
        scriptMap.put("SturmSequence",scriptString);

        scriptString = new String[3];
        scriptString[0] = null;
        scriptString[1] = "\n10 # SturmVariations(_S,Infinity) <--\n[\n  Local(i,s);\n  s:=FillList(0,Length(S));\n  For(i:=1,i<=?Length(S),i++)\n  [\n    s[i] := LeadingCoef(S[i]);\n  ];\n  SturmVariations(s);\n];\n\n10 # SturmVariations(_S,-Infinity) <--\n[\n  Local(i,s);\n  s:=FillList(0,Length(S));\n  For(i:=1,i<=?Length(S),i++)\n  [\n    s[i] := ((-1)^Degree(S[i]))*LeadingCoef(S[i]);\n  ];\n  SturmVariations(s);\n];\n\n20 # SturmVariations(_S,_x) <-- SturmVariations(Eval(S));\nSturmVariations(_S) <--\n[\n  Local(result,prev);\n//Echo(\"S = \",S);\n  result:=0;\n  While(Length(S)>?0 And? IsZero(S[1])) S:=Rest(S);\n//Echo(\"S = \",S);\n  if (Length(S)>?0)\n  [\n    prev:=S[1];\n    ForEach(item,Rest(S))\n    [\n      if(Not? IsZero(item))\n      [\n        if (prev*item <? 0) [result++;];\n        prev:=item;\n      ];\n    ];\n  ];\n  result;\n];\n\n";
        scriptString[2] = "/org/mathpiper/scripts4/univar/sturm/SturmVariations.mpw";
        scriptMap.put("SturmVariations",scriptString);
    }

    public String[] getScript(String functionName)
    {
        return (String[]) scriptMap.get(functionName);
    }

    public Map getMap()
    {
        return  scriptMap;
    }
}
