%uasm65,title=""
;****************************************************************************
;  UMON65 Understandable Monitor for the 6500 series microprocessors.
;  Copyright 2015 by Ted Kosan.
;
;
;****************************************************************************


;****************************************************************************
;                                Equates Area.
;****************************************************************************   
;muvium

;For simple I/O board.
INPUTS		equ 4000h
OUTPUT1	equ 4001h
OUTPUT2	equ 4002h
LCD	    	equ 4003h

;For robot
;servo_left 	equ 4000h
;servo_right 	equ 4001h
;button_left 	equ 4002h
;button_right 	equ 4003h
;field_left 	equ 4004h
;field_right 	equ 4005h
;dist_left 	equ 4006h
;dist_right 	equ 4007h
;delay_secs 	equ 4008h
;delay_msecs 	equ 4009h
;
;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
;
;Transmitt Receive Register.
6551TRR	equ A000h ;400ah


;Status Register.  
;		    Status			          cleared by
;	b0	Parity error * (1: error)       self clearing **
;	b1	Framing error * (1: error)      self clearing **
;	b2	Overrun * (1: error)            self clearing **
;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
;                                                                                                            
;	note: * no interrupt generated for these conditions
;	      ** cleared automatically after a read of RDR and the next 
;		error free receipt of data
6551StR	equ A001h ;400bh 

6551Sleep equ A002h	; When an lda to this address is performed the emulator
			;can be put to sleep.


;Comand Register  
;	b0	Data Terminal Ready
;			0 : disable receiver and all interrupts (DTR high)
;			1 : enable receiver and all interrupts (DTR low)
;	b1	Receiver Interrupt Enable
;			0 : IRQ interrupt enabled from bit 3 of status register
;			1 : IRQ interrupt disabled
;	b3,b2	Transmitter Control
;				Transmit Interrupt    RTS level    Transmitter
;			00	   disabled		high		off
;			01	   enabled		low		on
;			10	   disabled		low		on
;			11	   disabled		low	   Transmit BRK
;	b4	Normal/Echo Mode for Receiver
;			0 : normal
;			1 : echo (bits 2 and 3 must be 0)
;	b5	Parity Enable
;			0 : parity disabled, no parity bit generated or received
;			1 : parity enabled
;	b7,b6	Parity
;			00 : odd parity receiver and transmitter
;			01 : even parity receiver and transmitter
;			10 : mark parity bit transmitted, parity check disabled
;			11 : space parity bit transmitted, parity check disabled


;6551CmR	equ 0b202h  

;Control Register
;
;	b3-b0	baud rate generator:
;			0000 : 16x external clock
;			0001 : 50 baud
;			0010 : 75
;			0011 : 110
;			0100 : 134.5
;			0101 : 150
;			0110 : 300
;			0111 : 600
;			1000 : 1200
;			1001 : 1800
;			1010 : 2400
;			1011 : 3600
;			1100 : 4800
;			1101 : 7200
;			1110 : 9600
;			1111 : 19,200
;	b4	receiver clock source
;			0 : external receiver clock
;			1 : baud rate generator
;	b6,b5	word length                                                                  
;			00 : 8 bits
;			01 : 7
;			10 : 6
;			11 : 5
;	b7	stop bits
;			0 : 1 stop bit
;			1 : 2 stop bits
;			    (1 stop bit if parity and word length = 8)
;			    (1 1/2 stop bits if word length = 5 and no parity)
;6551CtR	equ 0b203h  




;InPort0 Equate.
InPort0	equ 0a000h

;OutPort0 Equate.
OutPort0	equ 0a100h

;****************************************************************************
;                       General Purpose Pointer Area.
;****************************************************************************
	org 0000h
	
GenPoint	dwd ?
IRQVect		dwd ?		;
BRKVect		dwd ?		;Break command indirect vector.
MessPtr		dwd ?		;
PointerA	dwd ?		;
PointerB	dwd ?		;
PointerC	dwd ?		;
NOpAdPtr	dwd ?		;
BOpAdPtr	dwd ?		;
BrkPt1Ad	dwd ?		;
BrkPt2Ad	dwd ?		;
BrkPt3Ad	dwd ?		;                                                                                       
BrkPt4Ad	dwd ?		;


	
;****************************************************************************
;                   General Purpose Variable Storage Area.
;****************************************************************************
;	org 0200h 

		  
Obj1		dbt ?
Obj2		dbt ?
Obj3		dbt ?
Obj2Flg		dbt ?
Obj3Flg		dbt ?
AddMode		dbt ?
SrchTabl	dbt 10d(?)
SrchBtCt	dbt ?
TempAdd		dwd ?
TempAdd2	dwd ?
BrkPt1St	dbt ?
BrkPt2St	dbt ?
BrkPt3St	dbt ?
BrkPt4St	dbt ?
BP1OpHld	dbt ?
BP2OpHld	dbt ?
BP3OpHld	dbt ?
BP4OpHld	dbt ?
BPNumHld	dbt ?
BrValHld	dbt ?
TrBrkFlg	dbt ?
CurInsLn	dbt ?
NOpCdHld	dbt ?
BOpCdHld	dbt ?
BrnchFlg	dbt ?
TracCnt		dbt ?
AddHold		dwd ?
ObCdHld1	dbt ?
ObCdHld2	dbt ?
OpCdHold	dbt ?
TempA		dbt ?
UPgmCntr	dwd ?
UAccum		dbt ?
UXReg		dbt ?
UYReg		dbt ?
UStkPtr		dbt ?
UStatReg	dbt ?
ASCIIbuf	dbt 16d(?)
EndAdd		dwd ?
OpOffSet	dbt ?
OpFld1		dbt 20d(?)
OpFld2		dbt 20d(?)
OpFld3		dbt 20d(?)	
CodeCntr	dbt ?
Number		dbt ?
ChkSum		dbt ?
RecLen		dbt ?
CkSumAc		dwd ?
RecType 	dbt ?
wait0		dbt ?
wait1		dbt ?
		dbt ?
InptBufr	dbt 40d(?)
Command		dbt ?
RegTemp		dbt ?
DataTemp	dbt ?

;****************************************************************************
;                        Monitor Eprom Entry Point.
;****************************************************************************
	org 0e000h Note
	;org 1000h
	jmp Start

;****************************************************************************
;                  Monitor Utility Subroutine Jump Table.
;****************************************************************************
	jmp OutChar	;Output byte in A register to serial port.
	
	jmp GetChar	;Get a byte from the serial port.
	
	jmp GetCharW	;Wait and get a byte from the serial port.
	
	jmp PrntMess	;Print a message to the serial port.
	
	jmp OutSpace	;Output spaces to the serial port.
	
	jmp OutHex	;Output a HEX number to the serial port.
	
	jmp DgtToBin	;Convert an ASCII digit into binary.
	
	jmp GetLine	;Input a line from the serial port.
	

; Beginning of UMON65.
;****************************************************************************
;                       Start of UMON65 Main Routine.
;
;
;****************************************************************************
start *
	ldx #0ffh	;Initialize stack pointer and clear decimal
	txs		; mode.
;	cli		;
	cld		;
	
	jsr InitVars	;Initialize variables.
	
	jmp CkConfig	;Check switch register to determine what mode
			; to run the computer in.

;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
		
;****************************************************************************
;                     Check Computer's Configuration.
;****************************************************************************
CkConfig *
	;lda InPort0	;Get the switch settings and mask out the 
	;and #00001111b	; switch's high nibble.

;CkMon *
	
	;cmp #1d	;If the switch is set to a 1 then print the
	;bne CkEEPROM	; UMON65 monitor startup message and enter the
EnterMon *
	ldx #OpenMess<	; monitor through the maskable interrupt vector.
	ldy #OpenMess>	;
	jsr PrntMess	;
	;brk		    ;
    lda #00000000b	 ;Initialize user's status register.
	sta UStatReg	;

	
	lda #0d	    ;Initialize user's accumulator.
	sta UAccum	;
	
	sta UXReg	;Initialize user's X register.
	
	sta UYReg	;Initialize user's Y register.
	
	lda #0ffh    ;Initialize user's stack pointer
	sta UStkPtr	 ;.
    
    jmp ResetEntryPoint

CkEEPROM *
	cmp #2d		;If the switch is set to a 2 then get the
	bne DoLgtSho	; switch's high nibble and jump to a program
	;lda InPort0	; present in the EEPROM which is indicated by
	and #11110000b	; the high nibble's value.  The program can be
	lsr a		; located at 1 of the following 16 locations:
	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
	clc
	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
	sta PointerA+1d	; 15-DE00.
	lda #0d		;
	sta PointerA	;
	jmp (PointerA)	;
			
DoLgtSho *
	jmp LghtShow
	
;****************************************************************************
;                            Light Show Subroutine.
;****************************************************************************
LghtShow *
	ldy #0h		;Make the Y register count from 0 to 255 and
	sty TempA	; output each number in the count to the
	;sty OutPort0	; light register.
LSOtLoop *		;
	ldx #100d	;
LSInLoop *		;
	iny		;
	bne LSInLoop	;
	dex		;
	bne LSInLoop	;
	inc TempA	;
	lda TempA	;
	;sta OutPort0	;
	jmp LSOtLoop	;

;****************************************************************************
;                            Monitor's Main Loop.
;****************************************************************************
MainLoop *	

	jsr GetLineP	;Get a typed line from the serial port.

	jsr ParsLine	;Break line into fields.
	
	jsr CkValCmd	;Check to see if a valid monitor command was
			; entered and if so execute that command's code.
	jmp MainLoop

	
;****************************************************************************
;                    Get Line From Serial Port Subroutine.
;****************************************************************************
GetLineP *
	ldx #Prompt<	;Print Prompt.
	ldy #Prompt>	;
	jsr PrntMess	;

GetLine *	
	ldy #0d		;Initialize Y index register.
	sty OpOffSet	;Initialize opcode holder offset pointer.
	sty command	;Initialize command holder.
	sty OpFld1	;Initialize operand field 1 buffer.
	sty OpFld2	;Initialize operand field 2 buffer.
	sty OpFld3	;Initialize operand field 3 buffer.
	
	ldy #0d		;Clear input buffer.
	lda #0d		;
ClrInpBf *		;
	sta InptBufr,y	;
	iny		;
	cpy #39d	;
	bne ClrInpBf	;
	
	ldy #0h		;Use Y register as buffer pointer.
	
GtAnChar *
	jsr GetCharW
;	jsr OutChar	;Echo character.  ;Note: remove for muvium.

	cmp #0h		;If no character is entered then try again.
	beq GtAnChar	;
	
	cmp #8d		;Check to see if the user entered a Delete or
	bne CkDel	; a Backspace.  If so then erase the character
	jmp DoDelete	; to the left of the cursor.
CkDel *			;
	cmp #127d	;
	bne GtCkChar	;
DoDelete *		;
	dey		;
	bmi AtStart	;
	lda #32d	;
	jsr OutChar	;
	lda #8d		;
	jsr OutChar	;
	jmp GtAnChar	;

AtStart *
	ldy #0d
	jmp GtAnChar
	
GtCkChar *
	cmp #13d	;If a CR was entered then accept line and exit,
	beq GtLnDone	; if not then accept the next character and
	sta InptBufr,y	; place it into the input buffer.
	iny		;
	
	cpy #39d	;Do not let buffer expand past 40 characters.
	bne GtAnChar
	ldy #39d	;Set buffer at 40 characters if over 40 characters.

	jmp GtAnChar	;
	
GtLnDone *
	;If a NL is in the input buffer then remove it.
	dey
	lda InptBufr,y
	cmp #10d
	beq PutNull
	iny
PutNull	 *
	lda #0h		;Put a NULL at end of the input buffer.
	sta InptBufr,y	;
		
	rts
	
;****************************************************************************
;                       Parse Input Buffer Subroutine.
;****************************************************************************
ParseOpr *	;Entry point if parsing for a UASM command is not
	ldy #0ffh	; desired.
	jmp GtAnoOpr	;
	
ParsLine *
	ldy #0d

	lda InptBufr,y
	beq ExtPrsLn	;If NULL or CR encountered then return.
	
	cmp #63d	;Check for upper case letter.
	bmi ParError	;
	cmp #90d	;	
	bpl CkSmCase	;
	
	sec
	bcs GetCmd	;
	
CkSmCase *
	cmp #97d	;Check for lower case letter.
	bmi ParError	;
	cmp #122d	;
	bpl ParError	;
	                
GetCmd *
	sta command	;Store command in command buffer.
                        
GtAnoOpr *       
	iny		;Point Y to the next operand field and check to
	cpy #20d	;make sure that the input line is not too long.
	beq ParError	;
	                
	lda InptBufr,y	;Check for the end of the input line.
	cmp #0d		;
	beq ExtPrsLn	;
	                
	cmp #32d	;Check for a space between operand fields.
	beq GtAnoOpr	;
	                
ScanOprn *              
	ldx OpOffSet	;Point X to the beginning of the current operand
	txa		; field holder and point OpOffSet to the beginning
	clc             
	adc #20d	; of the next operand field holder.
	sta OpOffSet	;
	
TranDgt *
	lda InptBufr,y	;
	                
	cmp #32d	;If a space is encountered then stop scanning.
	beq DoneScan	;
	                
	Cmp #0d		;If a CR is encountered then stop scanning.
	beq doneScan	;
	                
	sta OpFld1,x	;Transfer current operand from input buffer into
	inx		; current operand field holder.
	iny		;
	cpy #40d
	beq ParError
	
	jmp TranDgt	
	
DoneScan *
	lda #0h		;Put a NULL at the end of the current operand field
	sta OpFld1,x	; holder.
	
	jmp GtAnoOpr

ParError *
	rts
ExtPrsLn *
	rts

;****************************************************************************
;                     Check for Valid Command Subroutine.
;****************************************************************************
CkValCmd *
	sec
	
	lda command
	jsr ToLower

	cmp #108d	;Check for Load command.
	bne NxtCmd1	;
	jsr LdSRecs	;
	jmp ExitCmd	;
                        
NxtCmd1 *
	cmp #100d	;Check for Dump command.
	bne NxtCmd2	;
	jsr Dump	;
	jmp ExitCmd	;
                        
NxtCmd2 *
	cmp #114d	;Check for Register command.
	bne NxtCmd3	;
	jsr Register	;
	jmp ExitCmd	;
		
NxtCmd3 *
	cmp #103d	;Check for Go command.
	bne NxtCmd4	;
	jsr Go		;
	jmp ExitCmd	;
	
NxtCmd4 *
	cmp #101d	;Check for Enter command.
	bne NxtCmd5	;
	jsr Enter	;
	jmp ExitCmd	;
	
NxtCmd5 *
	cmp #102d	;Check for Fill command.
	bne NxtCmd6	;
	jsr Fill	;
	jmp ExitCmd	;

NxtCmd6 *
	cmp #117d	;Check for Unassemble command.
	bne NxtCmd7	;
	jsr UnAssem	;
	jmp ExitCmd	;

NxtCmd7 *
	cmp #116d	;Check for Trace command.
	bne NxtCmd8	;
	jsr Trace	;
	jmp ExitCmd	;

NxtCmd8 *
	cmp #98d	;Check for Breakpoint command.
	bne NxtCmd9	;
	jsr BreakPnt	;
	jmp ExitCmd	;
	
NxtCmd9 *
	cmp #115d	;Check for Search command.
	bne NxtCmd10	;
	jsr Search	;
	jmp ExitCmd	;

NxtCmd10 *
	cmp #109d	;Check for Move command.
	bne NxtCmd11	;
	jsr Move	;
	jmp ExitCmd	;
	
NxtCmd11 *
	cmp #'a'	;Check for Assemble command.
	bne NxtCmd12	;
	jsr Assemble	;
	jmp ExitCmd	;

NxtCmd12 *
	cmp #104d	;Check for Help command.
	bne NxtCmd13	;
	jsr Help	;
	jmp ExitCmd	;
NxtCmd13 *                 
	cmp #63d	;
	bne ExitCmd	;
	jsr Help	;
	jmp ExitCmd	;

ExitCmd *
	bcs CmdOk
	
CmdError *		;If there was an error with a command then
	ldx #CmdErMes<	; print a question mark.
	ldy #CmdErMes>	;
	jsr PrntMess	;
	clc		;
	rts		;
	
CmdOk *
	sec
	rts

;****************************************************************************
;                     Maskable Interrupt Service Subroutine.
;****************************************************************************
MaskInt *
	sei		;Disable interrupts.

	sta TempA	;Save accumulator.
			
	pla		;Check to see if BRK command was executed.
	pha		;
	and #10h	;
	bne DoBRK	;
	
	lda TempA	;Restore accumulator.

IRQ *	
	jmp (IRQVect)
	
DoBRK *
	jmp (BRKVect)

	
;****************************************************************************
;                          Break Service Subroutine.
;****************************************************************************
	
BRK *
	pla		;Save user's status register.
	sta UStatReg	;

	
	lda TempA	;Save user's accumulator.
	sta UAccum	;
	
	stx UXReg	;Save user's X register.
	
	sty UYReg	;Save user's Y register.
	
	tsx
    
    inx ;Remove the remaining 2 bytes that were pushed on the
    inx ; stack by the brk command.
    
	stx UStkPtr	;Save user's stack pointer.
	
	pla		;Save program counter of break instruction
	sec		; that caused execution of this code.
	sbc #1d		;
	sta UPgmCntr	;
	pla		; 
	sbc #0d		;
	sta UPgmCntr+1d	;
;	cli

ResetEntryPoint *
	ldy #0d		;Print user's registers.
	sty OpFld1	;
	jsr Register	;

	lda TrBrkFlg	;If this break was placed by the trace command
	cmp #1d		; then go back to the trace subroutine.
	bne RepBPOp	;
	jmp Tr2ndEnt	;
	
RepBPOp *
	ldy #3d		;Replace the opcodes of all breakpointed
	ldx #6d		; addresses.
CkBPStBr *              ;
	lda BrkPt1St,y	;
	cmp #1d		;
	bne NxtBPStB	;
	lda BP1OpHld,y	;
	sta (BrkPt1Ad,x);
NxtBPStB *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPStBr	;
	
GoMain *
	jmp MainLoop	;Enter monitor.


;****************************************************************************
;                       Assemble Command Subroutine.
;****************************************************************************
Assemble *

	ldx #0d		;Get address to start assembling at and store
	jsr GetAdd	; in pointer A.
	bcs AAddOk	;
	jmp ErrAsem	;
AAddOk *		;
	stx PointerA	;
	sty PointerA+1d	;

AsemTop *		;On new line print current address being
	ldx #CRLF<	; assembled at and get next instruction to be
	ldy #CRLF>	; assembled from user.
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr GetLine	;
	jsr ParseOpr	;
	
	lda OpFld1	;Check for operator to be assembled. If no
	cmp #0d		; operator is found then exit Assemble 
	beq AsemDone	; subroutine.
	cmp #32d	;
	bne ACont	;
AsemDone *              ;
	jmp ExitAsem	;
	
ACont *			;Convert operator in input buffer to upper case,
	ldy #0d		; check to see if it is in the operator table and
ConvAno *		;
	lda OpFld1,y	; output a question mark if operator was not found.
	jsr ToUpper	;
	sta OpFld1,y	;
	iny		;
	cpy #3d		;
	bne ConvAno	;
	jsr OptrScan	;
	bcs AOptrOk	;
	
PrntQues *
	jsr PrntAdd	;If there was an error assembling the instruction
	lda #32d	; input from the user into object code then re-
	jsr OutChar	; output the line and print a question mark.
	ldx #OpFld1<	;
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;
	lda #32d	;
	jsr OutChar	;
	lda #63d	;
	jsr OutChar	;
	jmp AsemTop	;
	
AOptrOk *		;Check address mode of operand and print a quesion
	jsr AdMdScan	; mark if error occures while scanning operand.
	bcs AOpndOk	;
	jmp PrntQues
		
AOpndOk *		;Check to see if address mode of operand is a
	jsr AdMdTbSc	; valid address mode for instruction.
	bcs AOpTbFnd	;
	jmp PrntQues
		
AOpTbFnd *		;Extract object code from operand.
	jsr OpndScan	;
	bcs PrntAssm	;
	jmp PrntQues	;
	
PrntAssm *
	jsr PrntAdd	;Re-output current address.
	
	ldy #0d		;
	
	lda Obj1	;Output opcode, store it in memory, point to next
	sta (PointerA),y; byte, and print one space.
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj2Flg	;Output second object code byte if present, store it in
	beq NoObjCd	; it in memory, point to next byte, and print one
	lda Obj2	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj3Flg	;Output third object code byte if present, store
	beq NoObjCd3	; it in memory, point to next byte, and print one
	lda Obj3	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	jmp NoExSpcs

NoObjCd *		;If fewer then 3 bytes of object code are output
	lda #32d	; then output spaces instead.
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
NoObjCd3 *
	lda #32d	;
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
	
NoExSpcs *
	lda #32d	;
	jsr OutChar	;
	ldx #OpFld1<	;Re-output instruction that user had entered in.
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;

	jmp AsemTop
	
	
ErrAsem *
	clc
	rts
	
ExitAsem *
	sec
	rts
	

;****************************************************************************
;                       Operator Scan Subroutine.
;****************************************************************************
OptrScan *

	ldx #OpTable<	;Point pointer B to beginning of the operator
	stx PointerB	; table.
	ldx #Optable>	;
	stx PointerB+1d	;
	
OSCkAno *
	ldy #0d		;Compare a digit of the operator that the user
OSCkAnCM *		;
	lda (PointerB),y; entered with the analogous digit of the
	cmp OpFld1,y	; operator in the operator table.
	beq CharMtch	;
	
OptScan2 *
	lda PointerB	;Point pointer B to the beginning of the next
	clc		; operator in the operator table.
	adc #10d	;
	sta PointerB	;
	bcc OSNoCary	;
	inc PointerB+1d	;
	
OSNoCary *
	ldy #4d		;Check for the end of the operator table.
	lda (PointerB),y;
	cmp #'Z'	;
	beq OSNoMtch	;
	jmp OSCkAno	;
	
CharMtch *		;Check for an operator match in the operator
	iny		; table.
	cpy #3d		;
	beq OSMatch	;
	jmp OSCkAnCM	;
	
OSNoMtch *
	clc
	rts
	
OSMatch *
	sec
	rts


;****************************************************************************
;                     Address Mode Scan Subroutine.
;****************************************************************************
AdMdScan *

AMSCkIMP *
	ldy #0d		;Check for implied addressing mode.
	lda OpFld2,y	;
	cmp #0d		;
	bne AMSCkIMM	;
	lda #'P'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkIMM *		;Check for immediate addressing mode.
	cmp #'#'	;
	bne AMSCkACC	;
	lda #'M'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkACC *		;Check for accumulator addressing mode.
	cmp #'A'	;
	beq CkSpNull	;
	cmp #'a'	;
	beq CkSpNull	;
	jmp AMSCkREL	;
CkSpNull *		;
	iny		;
	lda OpFld2,y	;
	Cmp #0d		;
	beq IsAcc	;
	cmp #32d	;
	beq IsAcc	;
	jmp AMSCkREL	;
IsAcc *			;
	lda #'C'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkREL *		;Check for relative addressing mode.
	ldy #6d		;
	lda (PointerB),y;
	cmp #'L'	;
	bne AMSCkA_I	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkA_I *		;Dispatch to absolute or indexed check code.
	ldy #0d		;
	lda OpFld2,y	;
	cmp #'('	;
	bne AMSCkAB?	;
	jmp AMSCkId?	;
	
AMSCkAB? *		;Check to see if operand is absolute addressing
	ldy #0d		; mode or absolute indexed addressing mode.
AMSScnAB *		;
	lda OpFld2,y	;
	cmp #','	;
	beq CkXorY	;
	cmp #0d		;
	beq IsABS	;
	iny		;
	jmp AMSScnAB	;
	
CkXorY *		;Check for absolute X or absolute Y addressing
	iny		; mode.
	lda OpFld2,y	;                                                                        
	cmp #'X'	;
	beq IsABX	;
	cmp #'x'	;
	beq IsABX	;
	cmp #'Y'	;
	beq IsABY	;
	cmp #'y'	;
	beq IsABY	;
	jmp ErrAMS	;
	
IsABX *			;Save ABS, ABX or ABY mode in the variable to be
	lda #'X'	; returned.
	sta AddMode	;
	jmp ExitAMS	;
IsABY *			;
	lda #'Y'	;
	sta AddMode	;
	jmp ExitAMS	;
IsABS *			;
	lda #'S'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkId? *		;Dispatch to code that checks for IIR, IRI or
	iny		; IND addressing modes.
	lda OpFld2,y	;
	cmp #','	;
	beq CkIIR	;
	cmp #')'	;
	beq CkIRIIND	;
	cpy #11d	;
	bne AMSCkId?	;
	jmp ErrAMS	;

CkIIR *			;Check for IIR addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'X'	;
	beq IsIIR	;
	cmp #'x'	;
	beq IsIIR	;
	jmp ErrAMS	;
	
IsIIR *
	lda #'R'	;Save IIR addressing mode code in variable to be
	sta AddMode	; returned.
	jmp ExitAMS	;
	
CkIRIIND *		;Check for IND addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #0d		;
	beq IsIND	;
	cmp #','	;
	beq CkIRI	;
	jmp ErrAMS	;
	
CkIRI *			;Check for IRI addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'Y'	;
	beq IsIRI	;
	cmp #'y'	;
	beq IsIRI	;
	jmp ErrAMS	;
	
IsIND *			;Save IND or IRI addressing mode code in variable
	lda #'D'	; to be returned.
	sta AddMode	;
	jmp ExitAMS	;
IsIRI *			;
	lda #'I'	;
	sta AddMode	;
	jmp ExitAMS	;
	
ErrAMS *
	clc
	rts
	
ExitAMS *
	sec
	rts
	
	
;****************************************************************************
;                   Address Mode Table Search Subroutine.
;****************************************************************************
AdMdTbSc *		
	ldy #6d		;Check for address mode match between contents
	lda (PointerB),y; of variable AddMode & OpTable.
	cmp AddMode	;
	beq ExitAdMd	;
	
	lda PointerB	;Pointer Pointer B to next operator in
	clc		; operator table.
	adc #10d	;
	sta PointerB	;
	bcc AdMdNoCy	;
	inc PointerB+1d	;
	
AdMdNoCy *		;Check to see if next operator is the same type
	jsr OSCkANO	; that we are currently trying to assemble.
	bcs AdMdTbSc	;
	
ErrAdMd *
	clc
	rts
	
ExitAdMd *
	sec
	rts

;****************************************************************************
;                       Operand Scan Subroutine.
;****************************************************************************
OpndScan *

	lda #0d		;Initialize the flags that indicate whether or
	sta Obj2Flg	; not there are object bytes in addition to
	sta Obj3Flg	; the opcode object byte.
	
	ldy #7d		;Get the opcode of the instruction being 
	lda (PointerB),y; currently assembled from the opcode table
	sta Obj1	; and put it in Obj1.
	
	lda AddMode	;Check to see what address mode the instruction
	cmp #'P'	; currently being assembled is.
	beq OpndIMP	;
	cmp #'C'	;
	beq OpndACC	;
	cmp #'M'	;
	beq OpndIMM	;
	cmp #'S'	;
	beq OpndAB??	;
	cmp #'X'	;
	beq OpndAB??	;
	cmp #'Y'	;
	beq OpndAB??	;
	cmp #'I'	;
	beq OpndIN??	;
	cmp #'R'	;
	beq OpndIN??	;
	cmp #'D'	;
	beq OpndIN??	;
	cmp #'L'	;
	beq OpndAB??	;
	jmp ErrOpndS	;

OpndIMP *		;Process implied addressing mode.
	jmp ExtOpndS	;
	
OpndACC *		;Process accumulator addressing mode.
	jmp ExtOpndS	;
	
OpndIMM *		;Process immediate addressing mode.
	jsr ScnForHex	;
	bcs OpnMHFnd	;
	jmp ErrOpndS	;
OpnMHFnd *		;
	jsr AsToBin	;
	bcs OpndCvOk	;
	jmp ErrOpndS	;
OpndCvOk *		;
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;


OpndAB?? *		;Process absolute, absolute X, absolute Y.
	jsr ScnForHex	; Check for relative addressing mode and send
	bcs OpnAHFnd	; to appropriate code if found.
	jmp ErrOpndS	;
OpnAHFnd *		;
	jsr GetAdd	;
	bcs OpndAdOk	;
	jmp ErrOpndS	;
OpndAdOk *		;
	lda AddMode	;
	cmp #'L'	;
	beq OpndDoBr	;
DoAdd *			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;

OpndIN?? *		;Process indirect indexed, indexed indirect and
	jsr ScnForHex	; indirect addressing modes.
	bcs OpnINFnd	;
	jmp ErrOpndS	;
OpnINFnd *		;
	jsr GetAdd	;
	bcs OpINAdOk	;
	jmp ErrOpndS	;
OpINAdOk *		;
	lda AddMode	;
	cmp #'D'	;
	beq DoIND	;
	cpy #0d		;
	bne ErrOpndS	;
	stx Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
DoIND *			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;
	
OpndDoBr *		;Put address to be branched to in TempAdd and
	stx TempAdd	; the address of the first byte of the next
	sty TempAdd+1d	; instruction in TempAdd2.
	lda PointerA	;
	sta TempAdd2	;
	lda PointerA+1d	;
	sta TempAdd2+1d	;
	ldy #8d		;
	lda (PointerB),y;
	clc		;
	adc TempAdd2	;
	sta TempAdd2	;
	bcc OpBrNoOv	;
	inc TempAdd2+1d	;
OpBrNoOv *
	sec		;Subtract the address of the first byte of the
	lda TempAdd	; next instruction from the address to be branched
	sbc TempAdd2	; to in order to get the branch offset.
	sta TempAdd	;
	lda TempAdd+1d	;
	sbc TempAdd2+1d	;
	sta TempAdd+1d	;
	
	lda TempAdd+1d	;Check to make sure that MSB of the offset does
	cmp #0ffh	; not indicate a number greater than 127 or less
	beq OpCkNOff	; than 128.
	cmp #0d		;
	bne ErrOpndS	;
	
OpCkPOff *		;Check to make sure that LSB of the offset does
	lda TempAdd	; not contain a number greater than 127 or less
	cmp #128d	; than 128.
	bpl ErrOpndS	;
	jmp OffOk	;
OpCkNOff *		;
	lda TempAdd	;
	cmp #128d	;
	bmi ErrOpndS	;
	
OffOk *			;If offset is OK then put it in Obj2 and return.
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
	
ErrOpndS *
	clc
	rts
	
ExtOpndS *
	sec
	rts


;****************************************************************************
;                     Scan For Hex Digit Subroutine.
;****************************************************************************
ScnForHex *
	ldx #20d		
	
SFHNxtDg *
	ldy #0d		;Scan until either an upper case or a lower case
	lda OpFld1,x	; hex digit is encountered in the input buffer.
SFHCkDgt *		;
	cmp DgtTblUC,y	;
	beq ExitSFH	;
	cmp DgtTblLC,y	;
	beq ExitSFH	;
	iny		;
	cpy #16d	;
	beq IncBfPtr	;
	jmp SFHCkDgt	;

IncBfPtr *		;Point to the next digit in the input buffer.
	inx		;
	cpx #31d	;
	beq ErrSFH	;
	jmp SFHNxtDg	;

ErrSFH *
	clc
	rts
	
ExitSFH *
	sec
	rts
	
	
;****************************************************************************
;                       Breakpoint Command Subroutine.
;****************************************************************************
BreakPnt *
	lda OpFld1	;Check for a +, - or a ? in operand field #1.
	cmp #43d	;
	beq DoPlus	;
	cmp #45d	;
	beq DoMinus	;
	cmp #63d	;
	beq DmpBPAdd	;
	jmp ExitBP	;
DoPlus *		;
	jmp Plus	;
DoMinus *		;
	jmp Minus	;
	
DmpBPAdd *
	ldx #CRLF<	;If question mark was entered then dump current
	ldy #CRLF>	; breakpoints.
	jsr PrntMess	;
	ldy #0ffh	;
	ldx #0ffh	;
OtAdAgin *		;
	iny		;
	inx		;
	lda BrkPt1Ad,y	;
	sta PointerA	;
	iny		;
	lda BrkPt1Ad,y	;
	sta PointerA+1d	;
	lda BrkPt1St,x	;
	beq AdEmpty	;
	jsr PrntAdd	;
AdEmpty *		;
	cpy #7d		;
	bne OtAdAgin	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp ExitBP	;
	
Minus *
	lda OpFld2	;If minus was found in operand field #1 check for
	cmp #0d		; an address in operand field #2.  If no address
	beq ClrAllBP	; was found then clear all breakpoints, if an
	ldx #20d	; address was found then clear that one breakpoint.
	jsr GetAdd	;
	bcs Clr1BP	;
	jmp ExitBP	;
	
ClrAllBP *
	ldy #3d		;Clear all breakpoints.
ZeroBP *		;
	lda #0d		;
	sta BrkPt1St,y	;
	dey		;
	bpl ZeroBP	;
	jmp ExitBP	;
	
Clr1BP *
	stx TempAdd	;Search for a match between a breakpoint address
	sty TempAdd+1d	; in the breakpoint address table and the address
	ldy #3d		; that was entered.
	ldx #6d		;
CkBPAdd *		;
	jsr CmpBPAdd	;
	bcs FoundBP	;
	dey		;
	dex		;
	dex		;
	bpl CkBPAdd	;
	
BPNtFnd *		
	ldx #NoBPMess<	;If no match was found then print an error message
	ldy #NoBPMess>	; and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
FoundBP *
	lda #0d		;If match was found then zero out that breakpoint's
	sta BrkPt1St,y	; status indicator and exit.
	jmp ExitBP	;

Plus *
	lda OpFld2	;If a plus was entered then check operand field
	cmp #0d		; #2 for the address of the new breakpoint.
	beq OutBP2	;
	ldx #20d	;
	jsr GetAdd	;
	bcs BPAdOk	;
OutBP2 *		;
	jmp ExitBP	;


BPAdOk *
	stx TempAdd	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddP *		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmp	;
	jsr CmpBPAdd	;
	bcs OutBP2	;
NoCmp *			;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddP	;
	

	ldy #0d		;If a plus was entered then search breakpoint
CkNxtBP *		;
	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
	cmp #0d		;
	beq EmptyBP	;
	iny		;
	cpy #4d		;
	bne CkNxtBP	;
	
AllBPFull *
	ldx #BPFulMes<	;If all breakpoints are full then print an error
	ldy #BPFulMes>	; message and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
EmptyBP *
	sty BPNumHld	;
	lda #1d		;
	sta BrkPt1St,y	;
	
	
NxtBPSlt0 *
	cpy #0d		;Store new address in first position of
	bne NxtBPSlt1	; breakpoint table.
	lda TempAdd	;
	sta BrkPt1Ad	;
	lda TempAdd+1d	;
	sta BrkPt1Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt1 *		;
	cpy #1d		;Store new address in second position of
	bne NxtBPSlt2	; breakpoint table.
	lda TempAdd	;
	sta BrkPt2Ad	;
	lda TempAdd+1d	;
	sta BrkPt2Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt2 *		;
	cpy #2d		;Store new address in third position of
	bne NxtBPSlt3	; breakpoint table.
	lda TempAdd	;
	sta BrkPt3Ad	;
	lda TempAdd+1d	;
	sta BrkPt3Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt3 *		;
	lda TempAdd	;Store new address in forth position of
	sta BrkPt4Ad	; breakpoint table.
	lda TempAdd+1d	;
	sta BrkPt4Ad+1d	;
	jmp ExitBP	;

ExitBP *
	rts


;****************************************************************************
;                   Compare Breakpoint Address Subroutine.
;****************************************************************************
CmpBPAdd *
	cpy #0d		;Compare LSB of first breakpoint address.
	bne CmpNxt1	;
	lda TempAdd+1d	;
	cmp BrkPt1Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt1 *		;
	cpy #1d		;Compare MSB of second breakpoint address.
	bne CmpNxt2	;
	lda TempAdd+1d	;
	cmp BrkPt2Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt2 *		;
	cpy #2d		;Compare MSB of third breakpoint address.
	bne CmpNxt3	;
	lda TempAdd+1d	;
	cmp BrkPt3Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt3 *		;
	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
	cmp BrkPt4Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CChkFLSB *
	lda TempAdd	;Compare LSB of breakpoint address.
	cmp BrkPt1Ad,x	;
	beq BPMatch	;
	jmp NoMatch	;
	
BPMatch *		;Return with carry set if addresses match.
	sec		;
	rts		;
	
NoMatch *		;Return with carry cleared if addresses
	clc		; do not match.
	rts		;


;****************************************************************************
;                     Dump command Subroutine
;****************************************************************************
Dump *
	
	ldx #0h
	
	lda OpFld1,x	;If no operands then do a standard dump.
	cmp #0h		;
	beq DoStdDmp	;

	jsr AsToBin	;Get start address from operand field #1 and place
	bcs DgtOk1	; in zero page pointer.
	jmp ErrDump	;
DgtOk1 *		;
	sta PointerA+1d	;
	inx		;
	jsr AsToBin	;
	bcs DgtOk2	;
	jmp ErrDump	;
DgtOk2 *		;
	sta PointerA	;
	
	ldx #20d	;If no end address was entered then perform a
	lda OpFld1,x	; standard dump.
	cmp #0h		;
	beq DoStdDmp	;
	
	Jsr AsToBin	;Get end address from operand field #2 and place
	bcs OpFldOk1	; in the variable EndAdd.
	jmp ErrDump	;
OpFldOk1 *		;
	sta EndAdd+1d	;
	inx 		;
	jsr AsToBin	;
	bcs OpFldOk2	;
	jmp ErrDump	;
OpFldOk2 *		;
	sta EndAdd	;
	
	jmp DoDump	
	
DoStdDmp *
	lda PointerA+1d	;Adjust end address so that it will only dump the
	sta EndAdd+1d	; contents of 16 memory locations.
	lda PointerA	;
	sta EndAdd	;
	clc   		;Note: check to make sure this is correct.
	adc #15d	;
	sta EndAdd	;
	bcc DoDump	;
	inc EndAdd+1d	;
	
DoDump *
	lda #13d	;Output a CRLF.
	jsr OutChar	;
	lda #10d	;
	jsr OutChar	;

	ldx #0d		;
	ldy #0d		;

	jsr PrntAdd	;Output address of first dump memory location.
	
DumpAgin *
	lda (PointerA),y;Get byte from memory location.

	jsr PutASCBf	;Put character in ASCII buffer.
	
	jsr OutHex	;Convert to ASCII/Hex and print.
	
	inx
	cpx #16d	;
	bne Chk8	;
	jsr DumpASC	;Output ASCII interpretion of dumped line.
	
Chk8 *			;
	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
	bne OutSpc	; the dump screen.
	lda #32d	;
	jsr OutChar	;
	lda #45d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	jmp ChkEndAd	;
	
OutSpc *
	lda #32d	;Print a space between hex characters on dump screen.
	jsr OutChar	;
	
ChkEndAd *
	lda PointerA	;Check pointer against end address holder.  Exit
	cmp EndAdd	; subroutine if the end address has been reached,
	bne PointNxt	; increment pointer and dump the contents of 
	lda PointerA+1d	; another memory location if not.
	cmp EndAdd+1d	;
	beq ExitDump	;
PointNxt *
	inc PointerA	;
	bne NoCary2	;
	inc PointerA+1d	;
NoCary2 *		;

ChkCR *			;Perform end of dump line functions.
	cpx #16d	;
	bne NotEnd	;
	
	lda #10d	;Print a CRLF and reset X register to point to
	jsr OutChar	; beginning of new dump line.
	lda #13d	;
	jsr Outchar	;
	jsr PrntAdd	;
	ldx #0d		;
NotEnd *
	
	jmp DumpAgin	;

ErrDump *
	clc
	rts

ExitDump *
	inc PointerA	;Point to next location in memory to be dumped
	bne NoCary3	;
	inc PointerA+1d	;
NoCary3 *		;
	sec
	rts

;****************************************************************************
;                 Output the ASCII interpretation of the dumped line.
;****************************************************************************
DumpASC *
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	ldx #0d		;
OutAsc *
	lda ASCIIbuf,x	;
	jsr OutChar	;
	inx		;
	cpx #16d	;
	bne OutAsc	;
	rts


;****************************************************************************
;         Put byte from memory into ASCII buffer from Dump command.
;****************************************************************************
PutASCBf *
	pha
	cmp #32d
	bmi Period
	cmp #127d
	bpl Period
	sta ASCIIbuf,x
	jmp ExitPut
Period *
	lda #46d
	sta ASCIIbuf,x
ExitPut *
	pla
	rts
	
;****************************************************************************
;                        Enter Command Subroutine.
;****************************************************************************
Enter *
	lda OpFld1	;Check for operand in operand field #1.
	cmp #0d		;
	bne ChkOp2	;
	jmp ErrEntr	;
	
ChkOp2 *
	lda OpFld2	;Check for operand in operand field #2.
	cmp #0d		;
	bne ProcEntr	;
	jmp ErrEntr	;
	
ProcEntr *
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs EnAddOk	;
	jmp ErrEntr	;

EnAddOk *
	stx PointerA	;Put address from operand field #1 into
	sty PointerA+1d	; zero page variable Pointer.
	
	ldx #20d	;Get list of bytes to be entered into memory
	jsr GetList	; from operand field #2 and put them in memory
	bcc ErrEntr	; starting at Pointer.
	jmp ExitEntr	;
	
ErrEntr *
	clc
	rts	

ExitEntr *
	sec
	rts


;****************************************************************************
;                        Get List Subroutine
;
;	Zero page variable Pointer points to location in memory where
;	 list members will be placed.
;****************************************************************************
GetList *
	ldy #0d
	
	sty DataTemp	;Use this variable to count bytes in list.	
	
GLNxtByt *
	lda OpFld1,x	;Check for NULL that terminates current
	beq ListErr	; operand field.
	
	jsr AsToBin	;Convert byte in list to binary form and place
	bcs StInMem	; in memory.
	jmp ListErr	;
StInMem *		;
	sta (PointerA),y;
	inc PointerA	;
	bne LstNoOv	;
	inc PointerA+1d	;
LstNoOv *		;
	inc DataTemp	;
	lda DataTemp	;
	cmp #10d	;
	beq ExtGtLst	;
	
	inx		;Point to comma between bytes.

	lda OpFld1,x	;Check for NULL that terminates current
	beq ExtGtLst	; operand field.
	
	inx		;Point to next byte in list.
	
	jmp GLNxtByt	;
	
ExtGtLst *
	sec
	rts

ListErr *
	clc
	rts

;****************************************************************************
;                        Fill Command Subroutine.
;****************************************************************************
Fill *

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs FAdd1ok	;
	jmp ErrFill	;
FAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs FAdd2ok	;
	jmp ErrFill	;
FAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
FillAgin *
	ldx #40d	;Get list and place in memory.
	jsr GetList	;
	bcc ErrFill	;

	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq ChkFLSB	;
;	bmi ExitFill 	;
	jmp FillAgin 	;
ChkFLSB *
	lda EndAdd	; 
	cmp PointerA	;
	beq ExitFill	;
	
	jmp  FillAgin	;
	

ErrFill *
	clc
	rts

ExitFill *
	sec
	rts

;****************************************************************************
;                        Go Command Subroutine
;****************************************************************************
Go *

	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq CurentPC	;
			
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs GAddOk	;
	jmp ErrGo	;
	
GAddOk *		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;

CurentPC *
	ldx UPgmCntr	;
	stx TempAdd	;
	ldy UPgmCntr+1d	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddG *		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmpG	;
	jsr CmpBPAdd	;
	bcs MaError	;
NoCmpG *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddG	;
	jmp NoMatchG	;

MaError *
	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
	ldy #GoBPErrM>	; error message and exit.
	jsr PrntMess	;
	jmp ExitGo	;

NoMatchG *
	ldy #3d		;Check all active breakpoints in table, save
	ldx #6d		; the opcodes of the breakpointed addresses, 
CkBPSt *		;
	lda BrkPt1St,y	; and replace them with BRKs.
	cmp #1d		;
	bne NxtBPSt	;
	lda (BrkPt1Ad,x);
	sta BP1OpHld,y	;
	lda #0d		;
	sta (BrkPt1Ad,x);
NxtBPSt *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPSt	;

	pla		;Remove Go command's return address and the check
	pla		; command's return address from the stack.
	pla		;
	pla		;
    
    lda OpFld1	;Check for operand.
	cmp #0d		;
	beq DoNotRestoreRegistersGo
 
    ldx #0ffh    ;Restore user's registers.
    txs          ;
    lda UStatReg ;
	pha          ;
	lda UAccum	 ;
	ldx UXReg	 ;
	ldy UYReg	 ;
    plp          ;
   
DoNotRestoreRegistersGo *
	
	jmp (UPgmCntr)	;Start executing at address being pointed to by
			; UPGmCntr.	

ErrGo *
	clc
	rts
	
ExitGo *
	sec
	rts

;****************************************************************************
;                       Help Command Subroutine.
;****************************************************************************
Help *
	ldx #HelpMess<
	ldy #HelpMess>
	jsr PrntMess
	rts

;****************************************************************************
;                     Load Command Subroutine
;****************************************************************************
LdSRecs *
	ldx #SRecStMs<
	ldy #SRecStMs>	
	jsr PrntMess
	
	jsr GetCharW	;Wait for first character of record.
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp CkS		;
	
GtAnCh *		;
	jsr GetCharW	;Check for an S.
CkS *			;
	cmp #83d	;
	bne GtAnCh	;
	
	jsr OutChar	;Print an S to the user.
	
	jsr GetCharW	;Get record type ECHO it and store it.
	jsr OutChar	;
	sta RecType	;
	
	cmp #48d	;Check for header record and process.
	bne NtHdr	;
	jsr ProcHdr	;
	bcc SError	;
	jmp NextLine	;
	
NtHdr *			;
	cmp #49d	;Check for code record and process.
	bne NtCd	;
	jsr ProcCode	;
	bcc SError	;
	jmp NextLine	;
	
NtCd *			;
	cmp #57d	;Check for termination record process, and print
	bne SError	; records loaded message.
	jsr ProcTerm	;
	bcc SError	;
	ldx #SRecEnMs<	;
	ldy #SRecEnMs>	;
	jsr PrntMess	;
	jmp ExitSRec	;
	
NextLine *
	jmp GtAnCh

SError *
	ldx #SRecErMe<
	ldy #SRecErMe>	
	jsr PrntMess
	sec
	rts
	
ExitSRec *
	jsr GetCharW
	sec
	rts
	
;****************************************************************************
;                Process Record Length and Address Subroutine
;****************************************************************************
PrRLeAdd *	
	
	lda #0h		;Zero out Checksum accumulator.
	sta CkSumAc	;
	sta CkSumAc+1h	;
	
	jsr Getnum	;Fetch record length and update checksum
	sta RecLen	; accumulator.
	jsr AccCkSum	;
	
	tax		;Adjust code byte counter and store it.
	dex		;
	dex		;
	dex		;
	txa		;
	sta CodeCntr	;
	
	jsr GetNum	;Get most significant byte of address and
	sta PointerA+1h	; store it.
	jsr AccCkSum	;
	
	jsr GetNum	;Get least significant byte of address and
	sta PointerA	; store it.
	jsr AccCkSum	;
	
	rts
	
;****************************************************************************
;        Get Code Byte Without Loading into Memory Subroutine.
;****************************************************************************
GtCodNld *
	
	lda CodeCntr
	beq ExitNld
	
GetOneNl *
	jsr GetNum
	jsr AccCkSum
	dec CodeCntr
	Bne GetOneNl
	
ExitNld *
	rts

;****************************************************************************
;        Get Code Byte and Load it into Memory Subroutine.
;****************************************************************************
GtCodLd *

	lda CodeCntr
	beq ExitLd
	
	ldy #0h
GtOneLd *
	jsr GetNum
	jsr AccCkSum
	sta (PointerA),y	
	inc PointerA
	bne NxtCode
	inc PointerA+1h
NxtCode *
	dec CodeCntr
	bne GtOneld
	
ExitLd *
	rts

;****************************************************************************
;                      Check Checksum Subroutine.
;****************************************************************************
ChkChkSm *

	lda CkSumAc	;Invert lowest byte of the checksum accumulator
	eor #0ffh	; and store it in CkhSum.
	sta ChkSum	;
	
	jsr GetNum	;Compare calculated checksum against S record	
	cmp ChkSum	; checksum.
	beq CkSumOK	;
	clc
	jmp Chkexit
CkSumOK *
	sec
Chkexit *
	rts

;****************************************************************************
;                       Get Number Subroutine.
;****************************************************************************
GetNum *
	tya
	pha

	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in most significat nibble
	bcc ExtGtNum	;
	asl a		; of number.
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in least significant
	bcc ExtGtNum	;
	ora number	; nibble of number.
	sta number	;
	
	pla
	tay
	lda number
ExtGtNum *
	rts

;****************************************************************************
;                    Accumulate Checksum Subroutine.
;****************************************************************************
AccCkSum *
	pha
	clc
	adc CkSumAc
	sta CkSumAc
	bcc NoOvrFlo
	inc CkSumAc+1h
NoOvrFlo *
	pla
	rts

;****************************************************************************
;                ASCII Digit to Binary Number Subroutine.
;
;        Enter with register 'A' containing the number to convert.
;        If the number was valid return its binary conversion in the
;        A register.  If the number is not convertable then clear the
;        carry flag and return.
;****************************************************************************
DgtToBin *
	
	stx RegTemp	;Save the character to convert.
	
	ldx #0h		
	
AnothDgt *
	cmp DgtTblUC,x	;Search through character table and try to find
	beq Match	; a match for the character present in the X
	cmp DgtTblLC,x	; register.
	beq Match	;
	
	inx		;If a match was not found then increment the
	cpx #16d	; table index register and check the next
	beq DgtError	; character.  If all the characters have been 
	jmp AnothDgt	; checked then return with an error.
	
DgtError *
	lda #0h
	clc
	jmp DgtExit

Match *
	txa
	sec
	
	ldx RegTemp
DgtExit	rts
	
;****************************************************************************
;                    Process Header Record Subroutine.
;****************************************************************************

ProcHdr *

	jsr PrRLeAdd
	jsr GtCodNld		
	jsr ChkChkSm
	
	rts

;****************************************************************************
;                     Process Code Record Subroutine
;****************************************************************************
ProcCode *

	jsr PrRLeAdd
	jsr GtCodLd
	jsr ChkChksm
	
	rts

;****************************************************************************
;                     Process Termination Record Subroutine
;****************************************************************************
ProcTerm *

	jsr PrRLeAdd
	jsr GtCodNld	
	jsr ChkChkSm

	rts

;****************************************************************************
;                       Move Command Subroutine.
;****************************************************************************
Move *
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq MOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs MAdd1ok	;
MOut *			;
	jmp ExitMove	;
MAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs MAdd2ok	;
	jmp ExitMove	;
MAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne MNOvFlo	;
	inc EndAdd+1d	;
	
MNOvFlo *		;
	ldx #40d	;Get destination address.
	jsr GetAdd	;
	bcs MAdd3ok	;
	jmp ExitMove	;
MAdd3ok *		;
	stx PointerB	;
	sty PointerB+1d	;

	ldy #0d		;Move bytes between start address and end address
MCont *			;to memory starting at destination address.
	lda (PointerA),y; 
	sta (PointerB),y;
	inc PointerB	;
	bne MNoOvf1	;
	inc PointerB+1d	;
MNoOvf1 *		;
	inc PointerA	;
	bne MNoOvf2	;
	inc PointerA+1d	;
MNoOvf2 *		;
	lda PointerA	;
	cmp EndAdd	;
	beq MCkMSB	;
	jmp MCont	;
MCkMSB *		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitMove	;
	jmp MCont	;
	
ExitMove *
	rts


;****************************************************************************
;                     Register Command Subroutine
;****************************************************************************
Register *
	pha
	txa
	pha
	tya
	pha
	php
	
	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq GenReg	;
	jmp SpecReg	;
	
GenReg *		;
	ldx #RegMess<	;Output register headings.
	ldy #RegMess>	;
	jsr PrntMess	;
	
	ldy #3d		;Output contents of user's program counter.
	jsr OutSpace	;
	lda UPgmCntr+1d	;
	jsr OutHex	;
	lda UPgmCntr	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's accumulator.
	jsr OutSpace	;
	lda UAccum	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's X register.
	jsr OutSpace	;
	lda UXreg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Y register.
	jsr OutSpace	;
	lda UYReg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Stack Pointer.
	jsr OutSpace	;
	lda UStkPtr	;
	jsr OutHex	;
	
	ldy #7d		;Output contents of user's Status register.
	jsr OutSpace	;
	lda UStatReg	;
	ldx #8d		;
NextFlag *		;
	rol a		;
	bcs OutOne	;
OutZero *		;
	pha		;
	lda #30h	;
	jsr OutChar	;
	pla		;
	jmp CkBtPos	;
OutOne *		;
	pha		;
	lda #31h	;
	jsr OutChar	;
	pla		;
CkBtPos *		;
	dex		;
	bne NextFlag	;
	jmp ExitReg	;
	
	
SpecReg *
	lda #13d
	jsr OutChar
	lda #10d
	jsr OutChar
	lda OpFld1
	jsr ToLower

CkPCReg *		;
	cmp #112d	;Get value for Program Counter from user.
	bne CkAReg	;
	lda UpgmCntr+1d	;
	jsr OutHex	;
	lda UpgmCntr	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetPC	;
	jmp ExitReg	;
GetPC	ldx #0d		;
	jsr AsToBin	;
	bcs PCMSBOK	;
	jmp ExitReg	;
PCMSBOK	tay		;
	inx		;
	jsr AsToBin	;
	bcs PCLSBOK	;
	jmp ExitReg	;
PCLSBOK	sta UPgmCntr	;
	sty UPgmCntr+1d	;
	jmp ExitReg	;
	
CkAReg *		;Get value for Accumulator from user.
	cmp #97d	;
	bne CkXReg	;
	lda UAccum	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetA	;
	jmp ExitReg	;
GetA *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs AOK		;
	jmp ExitReg	;
AOK *			;
	sta UAccum	;
	jmp ExitReg	;
	
CkXReg *		;Get value for X register from user.
	cmp #120d	;
	bne CkYReg	;
	lda UXreg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetX	;
	jmp ExitReg	;
GetX *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs XOK		;
	jmp ExitReg	;
XOK *			;
	sta UXReg	;
	jmp ExitReg	;
	
CkYReg *		;Get value for Y register from user.
	cmp #121d	;
	bne CkForS	;
	lda UYReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetY	;
	jmp ExitReg	;
GetY *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs YOK		;
	jmp ExitReg	;
YOK *			;
	sta UYReg	;
	jmp ExitReg	;
	
CkForS *		;Check if user is accessing the Stack Pointer or
	cmp #115d	; the Status Register.
	beq CkPorR	;
	jmp RegInErr	;
CkPorR *		;
	lda OpFld1+1d	;
	jsr ToLower	;
	cmp #112d	;
	beq CkSpReg	;
	cmp #114d	;
	beq CkSRReg	;
	jmp RegInErr	;

CkSpReg *		;
	lda UStkPtr	;Get value for Stack Pointer from user.
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSP	;
	jmp ExitReg	;
GetSP *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs SPOK	;
	jmp ExitReg	;
SPOK *			;
	sta UStkPtr	;
	jmp ExitReg	;
	
CkSRReg *		;Get value for Status Register from user.
	lda UStatReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSR	;
	jmp ExitReg	;
GetSR	ldx #0d		;
	jsr AsToBin	;
	bcs SROK	;
	jmp ExitReg	;
SROK	sta UStatReg	;
	jmp ExitReg	;

RegInErr *
	clc
	jmp ErrRegOt
	
ExitReg *
	sec
ErrRegOt *
	plp
	pla
	tay
	pla
	tax
	pla
	rts

;****************************************************************************
;                       Search Command Subroutine.
;****************************************************************************
Search *
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq SOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs SAdd1ok	;
SOut *			;
	jmp ExitSrch	;
SAdd1ok	*		;
	stx PointerB	;
	sty PointerB+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs SAdd2ok	;
	jmp ExitSrch	;
SAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne SNOvFlo	;
	inc EndAdd+1d	;
	
SNOvFlo	*		;
	ldx #40d	;Get search list from operand field #3 and store
	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
	sta PointerA	; SrchBtCt.
	lda #SrchTabl>	;
	sta PointerA+1d	;
	jsr GetList	;
	bcc ExitSrch	;
	lda DataTemp	;
	sta SrchBtCt	;
	
	lda PointerB	;Transfer start address from pointer A to 
	sta PointerA	; pointer B.  Output a CRLF.
	lda PointerB+1d	;
	sta PointerA+1d	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	
SCkByte1 *		;Compare list with memory.
	ldx #0d		;
	ldy #0d		;
SCkByte2 *		;
	lda (PointerA),y;
	cmp SrchTabl,x	;
	beq SMatch	;
	
IncScPtr *
	jsr IncPntrA	;Increment memory pointer and check to see if
	lda PointerA	; the end address has been reached.
	cmp EndAdd	;
	beq SckMSB	;
	jmp SCkByte1	;
SCkMSB *		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitSrch	;
	jmp SCkByte1	;
	
SMatch *		;
	iny		;Check to see if all bytes in search list match
	inx		; bytes in memory.
	cpx SrchBtCt	;
	beq SFulMtch	;
	jmp SCkByte2	;

SFulMtch *		;
	jsr PrntAdd	;Output address where match was found.
	jsr IncPntrA	;
	jmp SCkByte1	;

ExitSrch *
	rts



;****************************************************************************
;                       Trace Command Subroutine.
;****************************************************************************
Trace *

	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq TNoOper	;
	
	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs TAdd1ok	;
	jmp ErrTrce	;
TAdd1ok *		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;
	
	lda OpFld2	;Check to see if a trace count has been 
	cmp #0d		; specified.
	bne GtTrcCnt	;

TNoOper *
	ldy #1d		;Set trace count to 1.
	sty TracCnt	;
	jmp StartTrc	;

GtTrcCnt *	
	ldx #20d	;Get trace count from user.
	jsr AsToBin	;
	bcs TrValOK	;
	jmp ErrTrce	;
TrValOK *		;
	sta TracCnt	;
	
StartTrc *
	pla		;Remove trace command's return address and
	pla		; the check command routine's return address from
	pla		; the stack.
	pla		;

ContTrc *	
	ldy UPgmCntr	;Transfer user's program counter to pointer A.
	sty PointerA	;
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;

	ldy #0d		;Get opcode of current instruction.
	lda (PointerA),y;
	sta OpCdHold	;
	
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs TOpCdFnd	; an opcode.
	jmp ErrTrce

TOpCdFnd *
	ldy #8d		;Get number of bytes in the current instruction
	lda (PointerB),y; information from opcode table.
	sta CurInsLn	;
	
	ldy #1d		;Get opcode of current instruction.
	lda OpCdHold	;

TrRTS *			;If the opcode is an RTS then copy the return
	cmp #60h	; address from the stack, save the opcode to
	bne TNxtOp0	; be returned to, and place a BRK at the return
	lda #2d		; address.
	sta BrnchFlg	;
	pla		;
	sta BOpAdPtr	;
	pla		;
	sta BOpAdPtr+1d	;
	pha		;
	lda BOpAdPtr	;
	pha		;
	inc BOpAdPtr	;
	bne NNOvflo	;
	inc BOpAdPtr+1d	;
NNOvflo *		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp0 *		;
	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
	bne TNxtOp1	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp1 *
	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
	bne TNxtOp2	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta PointerC	;
	iny		;
	lda (PointerA),y;
	sta PointerC+1d	;
	ldy #0d		;
	lda (PointerC),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerC),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
		
	
TNxtOp2 *
	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
	bne TNxtOp3	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp3 *
	ldy #0d		;Check to see if the current instruction is an
	lda (PointerB),y; actual branch.
	cmp #'B'	;
	bne NoBrnch2	;
	ldy #1d		;
	lda (PointerB),y;
	cmp #'I'	;
	bne Branch	;
NoBrnch2 *		;
	jmp NoBranch	;
	
Branch *		;If the opcode is a branch, Bxx aaaa,
	lda #1d		; then save the opcode of the instruction that
	sta BrnchFlg	; will be branched to and replace it with a BRK.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta BOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
			;
	ldy #1d		;
	lda (PointerA),y;
	sta BrValHld	;
	bpl AddAdd	;
SubAdd *		;
	dec BrValHld	;
	lda BrValHld	;
	eor #0ffh	;
	sta BrValHld	;
	sec		;
	lda BOpAdPtr	;
	sbc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	sbc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
AddAdd *		;
	clc		;
	lda BOpAdPtr	;
	adc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
GtBrOpCd *		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp Both	;
	
NoBranch *
	lda #0d		;Set branch flag to 0 to indicate the current
	sta BrnchFlg	; instruction is not a branch instruction.

Both *
	ldy CurInsLn	;
	lda (PointerA),y;Save the opcode of the next instruction to be
	sta NOpCdHld	; executed if no branch is taken and replace it
			; with a BRK command.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta NOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta NOpAdPtr+1d	;
	lda #0d		;
	sta (PointerA),y;
	
ChBkVect *
	lda #1d		    ;Make BRK jump here instead of main.
	sta TrBrkFlg	;
	
    lda OpFld1	;Check to see if user entered address.
	cmp #0d		;
	beq DoNotRestoreStackPointer
    ldx #0ffh    
    txs          ;
DoNotRestoreStackPointer *

	lda UStatReg	;Restore user's registers.
	pha		        ;
	lda UAccum	    ;
	ldx UXreg	    ;
	ldy UYReg	    ;
	plp		        ;
    
	jmp (UPgmCntr)	;Jump to user's code.
	
Tr2ndEnt *
	lda #0d		;Reset trace break flag.
	sta TrBrkFlg	;
	
CkBrnch *		;
	ldy #0d		;Check to see which opcodes need to be restored.
	lda BrnchFlg	;
	cmp #0d		;
	beq NoBrnch	;
	cmp #1d		;
	beq Brnch	;
	
DoJmp *
	lda BOpCdHld	;Restore opcode to be jumped to.
	sta (BOpAdPtr),y;
	jmp UpDtPtrA	;

Brnch *
	lda BOpCdHld	;Restore opcode to be branched to.
	sta (BOpAdPtr),y;
	
NoBrnch *
	lda NOpCdHld	;Restore opcode that will be executed next in
	sta (NOpAdPtr),y; the instruction stream.

UpDtPtrA *
	ldy UPgmCntr	;Set pointer A to point to the next instruction
	sty PointerA	; to be executed for unassemble.
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;
	
	ldx #CRLF<	;Unassemble next instruction in memory.
	ldy #CRLF>	;
	jsr PrntMess	;
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	jsr StartUnA	;
	
NxtIn *
	dec TracCnt	;Decrement trace count and trace again if it
	beq OutTrce	; is not zero.
	jmp ContTrc	;

OutTrce *
	jmp MainLoop	;Enter the main monitor loop using a jump
			; because the trace command's return address
			; and the check command routine's return address
			; were removed when a trace was initiated.
ErrTrce *
	clc
	rts	

ExitTrce *
	sec
	rts	

;****************************************************************************
;                       Scan for Valid Opcode Subroutine.
;****************************************************************************
ScanOpCd *
	
	ldx #OpTable<	;Point pointer B to beginning of opcode table.
	stx PointerB	;
	ldx #OpTable>	;
	stx PointerB+1d	;
	
CkTblEnd *
	ldy #4d		;Check for end of opcode table.
	lda (PointerB),y;
	cmp #90d	;
	beq OpCdNtFd	;
	
CkNxtOp *		;
	ldy #7d		;Check for an opcode match in the opcode table.
	lda (PointerB),y;
	cmp OpCdHold	;
	beq OpCdFndS	;
	
	lda PointerB	;Point pointer B to next entry in opcode table.
	clc		;
	adc #10d	;
	sta PointerB	;
	bcc ScNoCary	;
	inc PointerB+1d	;
		
ScNoCary *
	jmp CkTblEnd
	
	
OpCdFndS *
	sec
	rts
	
OpCdNtFd *
	clc
	rts
	
;****************************************************************************
;                       Unassemble Command Subroutine.
;****************************************************************************
UnAssem *
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq UNoOper	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs UAdd1ok	;
	jmp ErrUnAs	;
UAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	lda OpFld2	;Check to see if an end address has been 
	cmp #0d		; specified.
	bne GtUEndAd	;
	
UNoOper *
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	clc		;If no end address has been specified by the
	lda PointerA	; user then set the end address to start address
	adc #20d	; + 20d.
	sta EndAdd	;
	bcc UNoCary	;
	ldx EndAdd+1d	;
	inx		;
	stx EndAdd+1d	;
UNoCary *		;
	jmp StartUnA	;
	
GtUEndAd *
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs UAdd2ok	;
	jmp ErrUnAs	;
UAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
StartUnA *
	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq UChkFLSB	;
	bcc UOut	;
	jmp UNotFin 	;
UChkFLSB *
	lda EndAdd	; 
	cmp PointerA	;
	bcc UOut	;
	jmp UNotFin	;
UOut *			;
	jmp ExitUnAs	;

UNotFin *		;
	ldy #0d		;Get opcode byte from memory and save.
	lda (PointerA),y;
	sta OpCdHold	;
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs OpCdFnd	; an opcode.

NtOpCode *
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;

	lda OpCdHold	;Print the bad opcode.
	jsr OutHex	;
	
	ldx #BadOpMes<	;If byte was not an opcode then print question
	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
	jsr PrntMess	;
	jsr IncPntrA	;
	jmp StartUnA	;

OpCdFnd *
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr IncPntrA	;

CkAdMode *
	ldy #6d		;Get addressing mode indicator from table.
	lda (PointerB),y;
	
NxAdMo1 *		;
	cmp #'P'	;Check for implied addressing mode.
	bne NxAdMo2	;
	jmp ImpAdMo	;
	
NxAdMo2 *		;
	cmp #'M'	;Check for immediate addressing mode.
	bne NxAdMo3	;
	jmp ImmAdMo	;	

NxAdMo3 *		;
	cmp #'S'	;Check for absolute addressing mode.
	bne NxAdMo4	;
	jmp AbsxyAdM	;	

NxAdMo4 *		;
	cmp #'X'	;Check for absolute x addressing mode.
	bne NxAdMo5	;
	jmp AbsxyAdM	;

NxAdMo5 *		;
	cmp #'Y'	;Check for absolute y addressing mode.
	bne NxAdMo6	;
	jmp AbsxyAdM	;

NxAdMo6 *		;
	cmp #'R'	;Check for indexed indirect addressing mode.
	bne NxAdMo7	;
	jmp IIRAdMo	;

NxAdMo7 *		;
	cmp #'L'	;Check for relative addressing mode.
	bne NxAdMo8 	;
	jmp RelAdMo	;

NxAdMo8 *		;
	cmp #'C'	;Check for accumulator addressing mode.
	bne NxAdMo9 	;
	jmp AccAdMo	;

NxAdMo9 *		;
	cmp #'D'	;Check for indirect addressing mode.
	bne NxAdMo10 	;
	jmp IndAdMo	;

NxAdMo10 *
	cmp #'I'	;Check for indirect indexed addressing mode.
	bne BdOpCd	;
	jmp IRIAdMo	;

BdOpCd *		;
	jmp NtOpCode	;


ImpAdMo *
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	jmp StartUnA

AccAdMo *
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	lda #65d	;Print a capital A for accumulator addressing.
	jsr OutChar	;
	
	jmp StartUnA


ImmAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #35d	;Print a pound sign.
	jsr OutChar	;
	
	lda ObCdHld1	;Print immediate operand value.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	jmp StartUnA


AbsxyAdM *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	ldy #6d		;Check to see if address mode is abs, abx or
	lda (PointerB),y; aby.
	cmp #'X'	;
	beq AbxAdMo	;
	cmp #'Y'	;
	beq AbyAdMo	;
	
AbsAM *
	jmp StartUnA

AbxAdMo *
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	jmp StartUna
	
AbyAdMo *
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;

	jmp StartUnA


RelAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda PointerA	;Store a copy of the next instruction's start
	sta AddHold	; address.
	lda PointerA+1d	;
	sta AddHold+1d	;
	
	lda ObCdHld1	;Check to see if branch is positive or negative.
	bmi NegBrnch	;
	
PosBrnch *		;If branch is positive then find address being
	lda AddHold	; branched to by adding offset to start address
	clc		; of next instruction in memory.
	adc ObCdHld1	;
	sta AddHold	;
	bcc OutBrAdd	;
	inc AddHold+1d	;
	jmp OutBrAdd	;
		
NegBrnch *
	dec ObCdHld1	;If branch is negative then find address being
	lda ObCdHld1	; branched to by subtracting offset from start
	eor #0ffh	; address of next instruction in memory.
	sta ObCdHld1	;
	lda AddHold	;
	sec		;
	sbc ObCdHld1	;
	sta AddHold	;
	bcs OutBrAdd	;
	dec AddHold+1d	;
	
OutBrAdd *
	lda AddHold+1d	;Print address being branched to.
	jsr OutHex	;
	lda AddHold	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	jmp StartUnA


IRIAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;
	
	jmp StartUnA
	
IIRAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA

IndAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA
	
ErrUnAs *
	clc
	rts

ExitUnAs *
	sec
	rts


;****************************************************************************
;                       Print Mnemonic Subroutine.
;****************************************************************************
PrntMnem *

	ldy #0d		;Use loop to print all three characters of
PrntMore *
	lda (PointerB),y; mnemonic.
	jsr OutChar	;
	iny		;
	cpy #3d		;
	bne PrntMore	;
	
	lda #32d	;Print a space after the mnemonic.
	jsr OutChar	;
	
	rts

;****************************************************************************
;                       Increment Pointer A Subroutine.
;****************************************************************************
IncPntrA *
	inc PointerA
	bne NoOvFl1
	inc PointerA+1d
NoOvFl1 *
	rts



;****************************************************************************
;                        Get Address Subroutine
;
;	X returns LSB of address.  Y returns MSB of address.
;****************************************************************************
GetAdd *		;Convert address found in operand field #x
	jsr AsToBin	; into binary.
	bcs AdMSBOK	;
	jmp ErrGtAd	;
AdMSBOK *		;
	tay		;
	inx		;
	jsr AsToBin	;
	bcs AdLSBOK	;
	jmp ErrGtAd	;
AdLSBOK *		;
	tax

	sec		;If conversion OK then set carry flag and
	rts		; return.
	
ErrGtAd *		;
	clc		;If error then clear carry and return.
	rts		;


;****************************************************************************
;                     Output a Colon Prompt Subroutine.
;****************************************************************************
OutColn *
	ldx #ColnPrmt<
	ldy #ColnPrmt>
	jsr PrntMess
	rts

;****************************************************************************
;                     Out Spaces Subroutine
;
;       Enter with the Y register indicating the number of spaces to output.
;****************************************************************************
OutSpace *		;Output the number of spaces indicated by
	pha		; the Y register.
OtAnoSpc *
	lda #32d
	jsr OutChar
	dey
	bne OtAnoSpc
	pla
	rts


;****************************************************************************
;              Covert ASCII character to lower case Subroutine.
;****************************************************************************
ToLower *
	cmp #65d
	bmi ExitToLo
	cmp #91d
	bpl ExitToLo
	clc
	adc #32d
ExitTolo *
	rts


;****************************************************************************
;              Covert ASCII character to upper case Subroutine.
;****************************************************************************
ToUpper *
	cmp #'a'
	bmi ExitToUp
	cmp #123d
	bpl ExitToUp
	sec
	sbc #32d
ExitToUp *
	rts



;****************************************************************************
;                         Print address.
;****************************************************************************
PrntAdd *
	lda PointerA+1d	;
	jsr OutHex	;
	lda PointerA	;
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	
	rts

;****************************************************************************
;                         Ascii to Binary Subroutine.
;****************************************************************************
AsToBin *		;X points to digits to be converted using
			; OpFld1 as a base.

	lda OpFld1,x	;Convert most significant digit to binary.
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	asl a		;
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	inx		;Convert least significant digit to binary.
	lda OpFld1,x	;
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	ora number	;
	
	sta number	;Store full binary number in number.
	sec
ExtAs2Bn *
	rts
	
;****************************************************************************
;                     Output a Hex byte to the serial port.
;
;            Enter with the number to be output in the A register.
;****************************************************************************
OutHex *
	sta number
	
	lsr a		;Output most significant digit of hex byte to
	lsr a		; serial port.
	lsr a		;
	lsr a		;
	and #0fh	;
	cmp #0ah	;
	bpl Letter1	;
	ora #30h	;
	jmp Print1st	;
Letter1 *		;
	sec
	sbc #9d		;
	ora #40h
Print1st *
	jsr OutChar	;
	
	lda number	;Output least significant digit of hex byte to
	and #0fh	; serial port.
	cmp #0ah	;
	bpl Letter2	;
	ora #30h	;
	jmp Print2nd	;
Letter2 *		;
	sec
	sbc #9d		;
	ora #40h	;
Print2nd *		;
	jsr OutChar	;
	
	lda number
	rts
	
;****************************************************************************
;                     Initialize Variables Subroutine
;****************************************************************************
InitVars *

	;lda #1ah	;Initialize ACIA control register, 2400
	;sta 6551CtR	; Baud.
	
	;lda #0bh	;Initialize ACIA command register.
	;sta 6551CmR	;
		
	lda #BRK<	;Initialize BRK vector.
	sta BRKVect	;
	lda #BRK>	;
	sta BRKVect+1d	;
	
	lda #0d		;Initialize trace break flag.
	sta TrBrkFlg	;
	
	lda #0d		;Initialize break point status variables.
	sta BrkPt1St	;
	sta BrkPt2St	;
	sta BrkPt3St	;
	sta BrkPt4St	;
	
	lda #0d		;Set the output port to all zeros (turn
	;sta OutPort0	; off all of the LEDs).
	
	rts

;****************************************************************************
;                          Print Message Subroutine.
;
; X holds the message pointer's low byte (< means less than) and Y holds its 
; high byte (> means greater than).  The message must have a NULL (0) after 
; the last character in the  Message so the PrntMess subroutine knows when to 
; stop printing.
;****************************************************************************
PrntMess *
	pha
	
	stx MessPtr	;Initialize pointer that will point to each
	sty MessPtr+1h	; character of message.
	
	ldy #0h
	
OutMess *		;
	lda (MessPtr),y	;Get a character from the message and if it is
	beq ExitMess	; a NULL (0) then exit this subroutine.
	
	jsr OutChar	;Output the character to the serial port.
	
	inc MessPtr	;Increment the message pointer to point to the
	bne PrNoOvf	; next character in the message.
	inc MessPtr+1d	;
	
PrNoOvf *
	jmp OutMess
		
ExitMess *
	pla
	
	rts

;****************************************************************************
;           Get Character (Don't Wait) From Serial Channel Subroutine
;****************************************************************************
GetChar *
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
	lda 6551StR	;Check ACIA to see if a character has been
	and #00001000b	; received and return with a NULL if no
	beq NoChar	; character was present.
	
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	jmp ExitGtCh	;
	
NoChar *
	lda #0d
	sta RegTemp
	
ExitGtCh *
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;             Get Character (Wait) From Serial Channel Subroutine
;****************************************************************************
GetCharW *
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
GtCkAgn *	
	lda 6551StR	;Check the ACIA's receiver buffer full register
	and #00001000b	; and wait until a character is received.
	bne CharRec	;
	
	lda 6551Sleep ;Allow the emulator to be put to sleep.
	jmp GtCkAgn
	
CharRec *
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;                 Output Character to Serial Channel Subroutine 
;                   Character to print is in register 'A'
;****************************************************************************
OutChar *
	
	sta RegTemp	;Save registers.
	php		;
	tya		;
	pha		;
	txa		;
	pha		;
	
OtCkAgn *
	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
	and #00010000b	; register and wait until the buffer is empty.
	beq OtCkAgn	;
	
	lda RegTemp	;Output a character to the ACIA's Transmitt
	sta 6551TRR	; register.
	
	pla		;Restore registers.
	tax		;
	pla		;
	tay		;
	plp		;
	lda RegTemp	;
		
	rts


;****************************************************************************
;                          Delay Subroutine
;****************************************************************************
delay *
	pha
	txa
	pha
	tya
	pha
	
	lda #0h
	sta wait0
	lda #10h
	sta wait1
	
	
dw0 *
	dec wait0
	bne dw0
	dec wait1
	bne dw0
	
	pla
	tay
	pla                                                                        
	tax
	pla
	rts


;****************************************************************************
;                Constants
;****************************************************************************

UARTval		dbt 16h,0bh
DgtTblUC	dbt "0123456789ABCDEF"
		dbt 0h
DgtTblLC	dbt "0123456789abcdef"
		dbt 0h
OpenMess	dbt 10d,13d,10d
		dbt "UMON65 V1.18 - Understandable Monitor for the 6500 series microprocessors."
		dbt 10d,13d
		dbt 0h
prompt		dbt 10d,13d
		dbt "-"
		dbt 0h
CRLF		dbt 10d,13d,0d
SRecStMs	dbt 10d,13d
		dbt "Send S records when you are ready..."
		dbt 10d,13d,0d
SRecErMe	dbt 10d,13d,7d
		dbt "Error Loading S Records..."
		dbt 10d,13d,0d
SRecEnMs	dbt 10d,13d,7d
		dbt "S records successfully loaded (press <enter> to continue)."
		dbt 0d
RegMess		dbt 10d,13d,10d
		dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
		dbt 10d,13d,0d
ColnPrmt	dbt 10d,13d
		dbt " :"
		dbt 0d
BadOpMes	dbt "        ???"
		dbt 0d
BPFulMes	dbt 10d,13d
		dbt "All breakpoints are currently in use."
		dbt 0d
NoBPMess	dbt 10d,13d
		dbt "No breakpoint exists at this address."
		dbt 0d
GoBPErrM	dbt 10d,13d
		dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
		dbt 0d
CmdErMes	dbt 10d,13d
		dbt "?"
		dbt 0d
HelpMess	dbt 10d,13d,10d
		dbt "Assemble       A start_address"
		dbt 10d,13d
		dbt "Breakpoint     B (+,-,?) address"
		dbt 10d,13d
		dbt "Dump           D [start_address [end_address]]"
		dbt 10d,13d
		dbt "Enter          E address list"
		dbt 10d,13d
		dbt "Fill           F start_address end_address list"
		dbt 10d,13d
		dbt "Go             G [start_address]"
		dbt 10d,13d
		dbt "Help           H or ?"
		dbt 10d,13d
		dbt "Load           L"
		dbt 10d,13d
		dbt "Move           M start_address end_address destination_address"
		dbt 10d,13d
		dbt "Register       R [PC,AC,XR,YR,SP,SR]"
		dbt 10d,13d
		dbt "Search         S start_address end_address list"
		dbt 10d,13d
		dbt "Trace          T [start_address [value]]"
		dbt 10d,13d
		dbt "Unassemble     U [start_address [end_address]]"
		dbt 10d,13d,0d
	

OpTable		dbt "ADC IMM"
		dbt 069h,2h,2h
		dbt "ADC ABS"
		dbt 06Dh,3h,4h
		dbt "ADC ABX"
		dbt 07Dh,3h,4h
		dbt "ADC ABY"
		dbt 079h,3h,4h
		dbt "ADC IIR"
		dbt 061h,2h,6h
		dbt "ADC IRI"
		dbt 071h,2h,5h
		dbt "AND IMM"
		dbt 029h,2h,2h
		dbt "AND ABS"
		dbt 02Dh,3h,4h
		dbt "AND ABX"
		dbt 03Dh,3h,4h
		dbt "AND ABY"
		dbt 039h,3h,4h
		dbt "AND IIR"
		dbt 021h,2h,6h
		dbt "AND IRI"
		dbt 031h,2h,5h
		dbt "ASL ACC"
		dbt 00Ah,1h,2h
		dbt "ASL ABS"
		dbt 00Eh,3h,6h
		dbt "ASL ABX"
		dbt 01Eh,3h,7h
		dbt "BCC REL"
		dbt 090h,2h,2h
		dbt "BCS REL"
		dbt 0B0h,2h,2h
		dbt "BEQ REL"
		dbt 0F0h,2h,2h
		dbt "BIT ABS"
		dbt 02Ch,3h,4h
		dbt "BMI REL"
		dbt 030h,2h,2h
		dbt "BNE REL"
		dbt 0D0h,2h,2h
		dbt "BPL REL"
		dbt 010h,2h,2h
		dbt "BRK IMP"
		dbt 000h,1h,7h
		dbt "BVC REL"
		dbt 050h,2h,2h
		dbt "BVS REL"
		dbt 070h,2h,2h
		dbt "CLC IMP"
		dbt 018h,1h,2h
		dbt "CLD IMP"
		dbt 0D8h,1h,2h
		dbt "CLI IMP"
		dbt 058h,1h,2h
		dbt "CLV IMP"
		dbt 0B8h,1h,2h
		dbt "CMP IMM"
		dbt 0C9h,2h,2h
		dbt "CMP ABS"
		dbt 0CDh,3h,4h
		dbt "CMP ABX"
		dbt 0DDh,3h,4h
		dbt "CMP ABY"
		dbt 0D9h,3h,4h
		dbt "CMP IIR"
		dbt 0C1h,2h,6h
		dbt "CMP IRI"
		dbt 0D1h,2h,5h
		dbt "CPX IMM"
		dbt 0E0h,2h,2h
		dbt "CPX ABS"
		dbt 0ECh,3h,4h
		dbt "CPY IMM"
		dbt 0C0h,2h,2h
		dbt "CPY ABS"
		dbt 0CCh,3h,4h
		dbt "DEC ABS"
		dbt 0CEh,3h,6h
		dbt "DEC ABX"
		dbt 0DEh,3h,7h
		dbt "DEX IMP"
		dbt 0CAh,1h,2h
		dbt "DEY IMP"
		dbt 088h,1h,2h
		dbt "EOR IMM"
		dbt 049h,2h,2h
		dbt "EOR ABS"
		dbt 04Dh,3h,4h
		dbt "EOR ABX"
		dbt 05Dh,3h,4h
		dbt "EOR ABY"
		dbt 059h,3h,4h
		dbt "EOR IIR"
		dbt 041h,2h,6h
		dbt "EOR IRI"
		dbt 051h,2h,5h
		dbt "INC ABS"
		dbt 0EEh,3h,6h
		dbt "INC ABX"
		dbt 0FEh,3h,7h
		dbt "INX IMP"
		dbt 0E8h,1h,2h
		dbt "INY IMP"
		dbt 0C8h,1h,2h
		dbt "JMP ABS"
		dbt 04Ch,3h,3h
		dbt "JMP IND"
		dbt 06Ch,3h,5h
		dbt "JSR ABS"
		dbt 020h,3h,6h
		dbt "LDA IMM"
		dbt 0A9h,2h,2h
		dbt "LDA ABS"
		dbt 0ADh,3h,4h
		dbt "LDA ABX"
		dbt 0BDh,3h,4h
		dbt "LDA ABY"
		dbt 0B9h,3h,4h
		dbt "LDA IIR"
		dbt 0A1h,2h,6h
		dbt "LDA IRI"
		dbt 0B1h,2h,5h
		dbt "LDX IMM"
		dbt 0A2h,2h,2h
		dbt "LDX ABS"
		dbt 0AEh,3h,4h
		dbt "LDX ABY"
		dbt 0BEh,3h,4h
		dbt "LDY IMM"
		dbt 0A0h,2h,2h
		dbt "LDY ABS"
		dbt 0ACh,3h,4h
		dbt "LDY ABX"
		dbt 0BCh,3h,4h
		dbt "LSR ACC"
		dbt 04Ah,1h,2h
		dbt "LSR ABS"
		dbt 04Eh,3h,6h
		dbt "LSR ABX"
		dbt 05Eh,3h,7h
		dbt "NOP IMP"
		dbt 0EAh,1h,2h
		dbt "ORA IMM"
		dbt 009h,2h,2h
		dbt "ORA ABS"
		dbt 00Dh,3h,4h
		dbt "ORA ABX"
		dbt 01Dh,3h,4h
		dbt "ORA ABY"
		dbt 019h,3h,4h
		dbt "ORA IIR"
		dbt 001h,2h,6h
		dbt "ORA IRI"
		dbt 011h,2h,5h
		dbt "PHA IMP"
		dbt 048h,1h,3h
		dbt "PHP IMP"
		dbt 008h,1h,3h
		dbt "PLA IMP"
		dbt 068h,1h,4h
		dbt "PLP IMP"
		dbt 028h,1h,4h
		dbt "ROL ACC"
		dbt 02Ah,1h,2h
		dbt "ROL ABS"
		dbt 02Eh,3h,6h
		dbt "ROL ABX"
		dbt 03Eh,3h,7h
		dbt "ROR ACC"
		dbt 06Ah,1h,2h
		dbt "ROR ABS"
		dbt 06Eh,3h,6h
		dbt "ROR ABX"
		dbt 07Eh,3h,7h
		dbt "RTI IMP"
		dbt 040h,1h,6h
		dbt "RTS IMP"
		dbt 060h,1h,6h
		dbt "SBC IMM"
		dbt 0E9h,2h,2h
		dbt "SBC ABS"
		dbt 0EDh,3h,4h
		dbt "SBC ABX"
		dbt 0FDh,3h,4h
		dbt "SBC ABY"
		dbt 0F9h,3h,4h
		dbt "SBC IIR"
		dbt 0E1h,2h,6h
		dbt "SBC IRI"
		dbt 0F1h,2h,5h
		dbt "SEC IMP"
		dbt 038h,1h,2h
		dbt "SED IMP"
		dbt 0F8h,1h,2h
		dbt "SEI IMP"
		dbt 078h,1h,2h
		dbt "STA ABS"
		dbt 08Dh,3h,4h
		dbt "STA ABX"
		dbt 09Dh,3h,5h
		dbt "STA ABY"
		dbt 099h,3h,5h
		dbt "STA IIR"
		dbt 081h,2h,6h
		dbt "STA IRI"
		dbt 091h,2h,6h
		dbt "STX ABS"
		dbt 08Eh,3h,4h
		dbt "STY ABS"
		dbt 08Ch,3h,4h
		dbt "TAX IMP"
		dbt 0AAh,1h,2h
		dbt "TAY IMP"
		dbt 0A8h,1h,2h
		dbt "TSX IMP"
		dbt 0BAh,1h,2h
		dbt "TXA IMP"
		dbt 08Ah,1h,2h
		dbt "TXS IMP"
		dbt 09Ah,1h,2h
		dbt "TYA IMP"
		dbt 098h,1h,2h
		dbt "ZZZ ZZZ"
		dbt 000h,0h,0h
		
;****************************************************************************
;       Initialize 6502 reset vector and maskable interrupt vector.
;****************************************************************************
	org 0fffch	;Initialize reset vector.
	dbt 00h,0e0h	;                                                                                         
;	
	org 0fffeh	;Initialize maskable interrupt vector.
	dbt #MaskInt<	;
	dbt #MaskInt>	;
		end
		
; ,output="array",start_address="E000"
%/uasm65

    %output,sequence="10",timestamp="2015-02-04 00:47:55.557",preserve="false"
      *** List file ***
      
                      000001 |;****************************************************************************
                      000002 |;  UMON65 Understandable Monitor for the 6500 series microprocessors.
                      000003 |;  Copyright 2015 by Ted Kosan.
                      000004 |;
                      000005 |;
                      000006 |;****************************************************************************
                      000007 |
                      000008 |
                      000009 |;****************************************************************************
                      000010 |;                                Equates Area.
                      000011 |;****************************************************************************   
                      000012 |;muvium
                      000013 |
                      000014 |;For simple I/O board.
      0000            000015 |INPUTS		equ 4000h
      0000            000016 |OUTPUT1	equ 4001h
      0000            000017 |OUTPUT2	equ 4002h
      0000            000018 |LCD	    	equ 4003h
                      000019 |
                      000020 |;For robot
                      000021 |;servo_left 	equ 4000h
                      000022 |;servo_right 	equ 4001h
                      000023 |;button_left 	equ 4002h
                      000024 |;button_right 	equ 4003h
                      000025 |;field_left 	equ 4004h
                      000026 |;field_right 	equ 4005h
                      000027 |;dist_left 	equ 4006h
                      000028 |;dist_right 	equ 4007h
                      000029 |;delay_secs 	equ 4008h
                      000030 |;delay_msecs 	equ 4009h
                      000031 |;
                      000032 |;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
                      000033 |;
                      000034 |;Transmitt Receive Register.
      0000            000035 |6551TRR	equ A000h ;400ah
                      000036 |
                      000037 |
                      000038 |;Status Register.  
                      000039 |;		    Status			          cleared by
                      000040 |;	b0	Parity error * (1: error)       self clearing **
                      000041 |;	b1	Framing error * (1: error)      self clearing **
                      000042 |;	b2	Overrun * (1: error)            self clearing **
                      000043 |;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
                      000044 |;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
                      000045 |;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
                      000046 |;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
                      000047 |;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
                      000048 |;                                                                                                            
                      000049 |;	note: * no interrupt generated for these conditions
                      000050 |;	      ** cleared automatically after a read of RDR and the next 
                      000051 |;		error free receipt of data
      0000            000052 |6551StR	equ A001h ;400bh 
                      000053 |
      0000            000054 |6551Sleep equ A002h	; When an lda to this address is performed the emulator
                      000055 |			;can be put to sleep.
                      000056 |
                      000057 |
                      000058 |;Comand Register  
                      000059 |;	b0	Data Terminal Ready
                      000060 |;			0 : disable receiver and all interrupts (DTR high)
                      000061 |;			1 : enable receiver and all interrupts (DTR low)
                      000062 |;	b1	Receiver Interrupt Enable
                      000063 |;			0 : IRQ interrupt enabled from bit 3 of status register
                      000064 |;			1 : IRQ interrupt disabled
                      000065 |;	b3,b2	Transmitter Control
                      000066 |;				Transmit Interrupt    RTS level    Transmitter
                      000067 |;			00	   disabled		high		off
                      000068 |;			01	   enabled		low		on
                      000069 |;			10	   disabled		low		on
                      000070 |;			11	   disabled		low	   Transmit BRK
                      000071 |;	b4	Normal/Echo Mode for Receiver
                      000072 |;			0 : normal
                      000073 |;			1 : echo (bits 2 and 3 must be 0)
                      000074 |;	b5	Parity Enable
                      000075 |;			0 : parity disabled, no parity bit generated or received
                      000076 |;			1 : parity enabled
                      000077 |;	b7,b6	Parity
                      000078 |;			00 : odd parity receiver and transmitter
                      000079 |;			01 : even parity receiver and transmitter
                      000080 |;			10 : mark parity bit transmitted, parity check disabled
                      000081 |;			11 : space parity bit transmitted, parity check disabled
                      000082 |
                      000083 |
                      000084 |;6551CmR	equ 0b202h  
                      000085 |
                      000086 |;Control Register
                      000087 |;
                      000088 |;	b3-b0	baud rate generator:
                      000089 |;			0000 : 16x external clock
                      000090 |;			0001 : 50 baud
                      000091 |;			0010 : 75
                      000092 |;			0011 : 110
                      000093 |;			0100 : 134.5
                      000094 |;			0101 : 150
                      000095 |;			0110 : 300
                      000096 |;			0111 : 600
                      000097 |;			1000 : 1200
                      000098 |;			1001 : 1800
                      000099 |;			1010 : 2400
                      000100 |;			1011 : 3600
                      000101 |;			1100 : 4800
                      000102 |;			1101 : 7200
                      000103 |;			1110 : 9600
                      000104 |;			1111 : 19,200
                      000105 |;	b4	receiver clock source
                      000106 |;			0 : external receiver clock
                      000107 |;			1 : baud rate generator
                      000108 |;	b6,b5	word length                                                                  
                      000109 |;			00 : 8 bits
                      000110 |;			01 : 7
                      000111 |;			10 : 6
                      000112 |;			11 : 5
                      000113 |;	b7	stop bits
                      000114 |;			0 : 1 stop bit
                      000115 |;			1 : 2 stop bits
                      000116 |;			    (1 stop bit if parity and word length = 8)
                      000117 |;			    (1 1/2 stop bits if word length = 5 and no parity)
                      000118 |;6551CtR	equ 0b203h  
                      000119 |
                      000120 |
                      000121 |
                      000122 |
                      000123 |;InPort0 Equate.
      0000            000124 |InPort0	equ 0a000h
                      000125 |
                      000126 |;OutPort0 Equate.
      0000            000127 |OutPort0	equ 0a100h
                      000128 |
                      000129 |;****************************************************************************
                      000130 |;                       General Purpose Pointer Area.
                      000131 |;****************************************************************************
      0000            000132 |	org 0000h
                      000133 |	
      0000 00 00      000134 |GenPoint	dwd ?
      0002 00 00      000135 |IRQVect		dwd ?		;
      0004 00 00      000136 |BRKVect		dwd ?		;Break command indirect vector.
      0006 00 00      000137 |MessPtr		dwd ?		;
      0008 00 00      000138 |PointerA	dwd ?		;
      000A 00 00      000139 |PointerB	dwd ?		;
      000C 00 00      000140 |PointerC	dwd ?		;
      000E 00 00      000141 |NOpAdPtr	dwd ?		;
      0010 00 00      000142 |BOpAdPtr	dwd ?		;
      0012 00 00      000143 |BrkPt1Ad	dwd ?		;
      0014 00 00      000144 |BrkPt2Ad	dwd ?		;
      0016 00 00      000145 |BrkPt3Ad	dwd ?		;                                                                                       
      0018 00 00      000146 |BrkPt4Ad	dwd ?		;
                      000147 |
                      000148 |
                      000149 |	
                      000150 |;****************************************************************************
                      000151 |;                   General Purpose Variable Storage Area.
                      000152 |;****************************************************************************
                      000153 |;	org 0200h 
                      000154 |
                      000155 |		  
      001A 00         000156 |Obj1		dbt ?
      001B 00         000157 |Obj2		dbt ?
      001C 00         000158 |Obj3		dbt ?
      001D 00         000159 |Obj2Flg		dbt ?
      001E 00         000160 |Obj3Flg		dbt ?
      001F 00         000161 |AddMode		dbt ?
      0020 00         000162 |SrchTabl	dbt 10d(?)
      0021 00 00 00         
      0024 00 00 00         
      0027 00 00 00         
      002A 00         000163 |SrchBtCt	dbt ?
      002B 00 00      000164 |TempAdd		dwd ?
      002D 00 00      000165 |TempAdd2	dwd ?
      002F 00         000166 |BrkPt1St	dbt ?
      0030 00         000167 |BrkPt2St	dbt ?
      0031 00         000168 |BrkPt3St	dbt ?
      0032 00         000169 |BrkPt4St	dbt ?
      0033 00         000170 |BP1OpHld	dbt ?
      0034 00         000171 |BP2OpHld	dbt ?
      0035 00         000172 |BP3OpHld	dbt ?
      0036 00         000173 |BP4OpHld	dbt ?
      0037 00         000174 |BPNumHld	dbt ?
      0038 00         000175 |BrValHld	dbt ?
      0039 00         000176 |TrBrkFlg	dbt ?
      003A 00         000177 |CurInsLn	dbt ?
      003B 00         000178 |NOpCdHld	dbt ?
      003C 00         000179 |BOpCdHld	dbt ?
      003D 00         000180 |BrnchFlg	dbt ?
      003E 00         000181 |TracCnt		dbt ?
      003F 00 00      000182 |AddHold		dwd ?
      0041 00         000183 |ObCdHld1	dbt ?
      0042 00         000184 |ObCdHld2	dbt ?
      0043 00         000185 |OpCdHold	dbt ?
      0044 00         000186 |TempA		dbt ?
      0045 00 00      000187 |UPgmCntr	dwd ?
      0047 00         000188 |UAccum		dbt ?
      0048 00         000189 |UXReg		dbt ?
      0049 00         000190 |UYReg		dbt ?
      004A 00         000191 |UStkPtr		dbt ?
      004B 00         000192 |UStatReg	dbt ?
      004C 00         000193 |ASCIIbuf	dbt 16d(?)
      004D 00 00 00         
      0050 00 00 00         
      0053 00 00 00         
      0056 00 00 00         
      0059 00 00 00         
      005C 00 00      000194 |EndAdd		dwd ?
      005E 00         000195 |OpOffSet	dbt ?
      005F 00         000196 |OpFld1		dbt 20d(?)
      0060 00 00 00         
      0063 00 00 00         
      0066 00 00 00         
      0069 00 00 00         
      006C 00 00 00         
      006F 00 00 00         
      0072 00               
      0073 00         000197 |OpFld2		dbt 20d(?)
      0074 00 00 00         
      0077 00 00 00         
      007A 00 00 00         
      007D 00 00 00         
      0080 00 00 00         
      0083 00 00 00         
      0086 00               
      0087 00         000198 |OpFld3		dbt 20d(?)	
      0088 00 00 00         
      008B 00 00 00         
      008E 00 00 00         
      0091 00 00 00         
      0094 00 00 00         
      0097 00 00 00         
      009A 00               
      009B 00         000199 |CodeCntr	dbt ?
      009C 00         000200 |Number		dbt ?
      009D 00         000201 |ChkSum		dbt ?
      009E 00         000202 |RecLen		dbt ?
      009F 00 00      000203 |CkSumAc		dwd ?
      00A1 00         000204 |RecType 	dbt ?
      00A2 00         000205 |wait0		dbt ?
      00A3 00         000206 |wait1		dbt ?
      00A4 00         000207 |		dbt ?
      00A5 00         000208 |InptBufr	dbt 40d(?)
      00A6 00 00 00         
      00A9 00 00 00         
      00AC 00 00 00         
      00AF 00 00 00         
      00B2 00 00 00         
      00B5 00 00 00         
      00B8 00 00 00         
      00BB 00 00 00         
      00BE 00 00 00         
      00C1 00 00 00         
      00C4 00 00 00         
      00C7 00 00 00         
      00CA 00 00 00         
      00CD 00         000209 |Command		dbt ?
      00CE 00         000210 |RegTemp		dbt ?
      00CF 00         000211 |DataTemp	dbt ?
                      000212 |
                      000213 |;****************************************************************************
                      000214 |;                        Monitor Eprom Entry Point.
                      000215 |;****************************************************************************
      E000            000216 |	org 0e000h Note
                      000217 |	;org 1000h
      E000 4C 1B E0   000218 |	jmp Start
                      000219 |
                      000220 |;****************************************************************************
                      000221 |;                  Monitor Utility Subroutine Jump Table.
                      000222 |;****************************************************************************
      E003 4C F3 F3   000223 |	jmp OutChar	;Output byte in A register to serial port.
                      000224 |	
      E006 4C AF F3   000225 |	jmp GetChar	;Get a byte from the serial port.
                      000226 |	
      E009 4C D2 F3   000227 |	jmp GetCharW	;Wait and get a byte from the serial port.
                      000228 |	
      E00C 4C 92 F3   000229 |	jmp PrntMess	;Print a message to the serial port.
                      000230 |	
      E00F 4C E2 F2   000231 |	jmp OutSpace	;Output spaces to the serial port.
                      000232 |	
      E012 4C 3E F3   000233 |	jmp OutHex	;Output a HEX number to the serial port.
                      000234 |	
      E015 4C 72 EA   000235 |	jmp DgtToBin	;Convert an ASCII digit into binary.
                      000236 |	
      E018 4C 87 E0   000237 |	jmp GetLine	;Input a line from the serial port.
                      000238 |	
                      000239 |
                      000240 |; Beginning of UMON65.
                      000241 |;****************************************************************************
                      000242 |;                       Start of UMON65 Main Routine.
                      000243 |;
                      000244 |;
                      000245 |;****************************************************************************
      E01B            000246 |start *
      E01B A2 FF      000247 |	ldx #0ffh	;Initialize stack pointer and clear decimal
      E01D 9A         000248 |	txs		; mode.
                      000249 |;	cli		;
      E01E D8         000250 |	cld		;
                      000251 |	
      E01F 20 72 F3   000252 |	jsr InitVars	;Initialize variables.
                      000253 |	
      E022 4C 25 E0   000254 |	jmp CkConfig	;Check switch register to determine what mode
                      000255 |			; to run the computer in.
                      000256 |
                      000257 |;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
                      000258 |		
                      000259 |;****************************************************************************
                      000260 |;                     Check Computer's Configuration.
                      000261 |;****************************************************************************
      E025            000262 |CkConfig *
                      000263 |	;lda InPort0	;Get the switch settings and mask out the 
                      000264 |	;and #00001111b	; switch's high nibble.
                      000265 |
                      000266 |;CkMon *
                      000267 |	
                      000268 |	;cmp #1d	;If the switch is set to a 1 then print the
                      000269 |	;bne CkEEPROM	; UMON65 monitor startup message and enter the
      E025            000270 |EnterMon *
      E025 A2 54      000271 |	ldx #OpenMess<	; monitor through the maskable interrupt vector.
      E027 A0 F4      000272 |	ldy #OpenMess>	;
      E029 20 92 F3   000273 |	jsr PrntMess	;
                      000274 |	;brk		    ;
      E02C A9 00      000275 |    lda #00000000b	 ;Initialize user's status register.
      E02E 8D 4B 00   000276 |	sta UStatReg	;
                      000277 |
                      000278 |	
      E031 A9 00      000279 |	lda #0d	    ;Initialize user's accumulator.
      E033 8D 47 00   000280 |	sta UAccum	;
                      000281 |	
      E036 8D 48 00   000282 |	sta UXReg	;Initialize user's X register.
                      000283 |	
      E039 8D 49 00   000284 |	sta UYReg	;Initialize user's Y register.
                      000285 |	
      E03C A9 FF      000286 |	lda #0ffh    ;Initialize user's stack pointer
      E03E 8D 4A 00   000287 |	sta UStkPtr	 ;.
                      000288 |    
      E041 4C 20 E2   000289 |    jmp ResetEntryPoint
                      000290 |
      E044            000291 |CkEEPROM *
      E044 C9 02      000292 |	cmp #2d		;If the switch is set to a 2 then get the
      E046 D0 13      000293 |	bne DoLgtSho	; switch's high nibble and jump to a program
                      000294 |	;lda InPort0	; present in the EEPROM which is indicated by
      E048 29 F0      000295 |	and #11110000b	; the high nibble's value.  The program can be
      E04A 4A         000296 |	lsr a		; located at 1 of the following 16 locations:
      E04B 4A         000297 |	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
      E04C 4A         000298 |	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
      E04D 18         000299 |	clc
      E04E 69 C0      000300 |	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
      E050 8D 09 00   000301 |	sta PointerA+1d	; 15-DE00.
      E053 A9 00      000302 |	lda #0d		;
      E055 8D 08 00   000303 |	sta PointerA	;
      E058 6C 08 00   000304 |	jmp (PointerA)	;
                      000305 |			
      E05B            000306 |DoLgtSho *
      E05B 4C 5E E0   000307 |	jmp LghtShow
                      000308 |	
                      000309 |;****************************************************************************
                      000310 |;                            Light Show Subroutine.
                      000311 |;****************************************************************************
      E05E            000312 |LghtShow *
      E05E A0 00      000313 |	ldy #0h		;Make the Y register count from 0 to 255 and
      E060 8C 44 00   000314 |	sty TempA	; output each number in the count to the
                      000315 |	;sty OutPort0	; light register.
      E063            000316 |LSOtLoop *		;
      E063 A2 64      000317 |	ldx #100d	;
      E065            000318 |LSInLoop *		;
      E065 C8         000319 |	iny		;
      E066 D0 FD      000320 |	bne LSInLoop	;
      E068 CA         000321 |	dex		;
      E069 D0 FA      000322 |	bne LSInLoop	;
      E06B EE 44 00   000323 |	inc TempA	;
      E06E AD 44 00   000324 |	lda TempA	;
                      000325 |	;sta OutPort0	;
      E071 4C 63 E0   000326 |	jmp LSOtLoop	;
                      000327 |
                      000328 |;****************************************************************************
                      000329 |;                            Monitor's Main Loop.
                      000330 |;****************************************************************************
      E074            000331 |MainLoop *	
                      000332 |
      E074 20 80 E0   000333 |	jsr GetLineP	;Get a typed line from the serial port.
                      000334 |
      E077 20 F2 E0   000335 |	jsr ParsLine	;Break line into fields.
                      000336 |	
      E07A 20 4A E1   000337 |	jsr CkValCmd	;Check to see if a valid monitor command was
                      000338 |			; entered and if so execute that command's code.
      E07D 4C 74 E0   000339 |	jmp MainLoop
                      000340 |
                      000341 |	
                      000342 |;****************************************************************************
                      000343 |;                    Get Line From Serial Port Subroutine.
                      000344 |;****************************************************************************
      E080            000345 |GetLineP *
      E080 A2 A4      000346 |	ldx #Prompt<	;Print Prompt.
      E082 A0 F4      000347 |	ldy #Prompt>	;
      E084 20 92 F3   000348 |	jsr PrntMess	;
                      000349 |
      E087            000350 |GetLine *	
      E087 A0 00      000351 |	ldy #0d		;Initialize Y index register.
      E089 8C 5E 00   000352 |	sty OpOffSet	;Initialize opcode holder offset pointer.
      E08C 8C CD 00   000353 |	sty command	;Initialize command holder.
      E08F 8C 5F 00   000354 |	sty OpFld1	;Initialize operand field 1 buffer.
      E092 8C 73 00   000355 |	sty OpFld2	;Initialize operand field 2 buffer.
      E095 8C 87 00   000356 |	sty OpFld3	;Initialize operand field 3 buffer.
                      000357 |	
      E098 A0 00      000358 |	ldy #0d		;Clear input buffer.
      E09A A9 00      000359 |	lda #0d		;
      E09C            000360 |ClrInpBf *		;
      E09C 99 A5 00   000361 |	sta InptBufr,y	;
      E09F C8         000362 |	iny		;
      E0A0 C0 27      000363 |	cpy #39d	;
      E0A2 D0 F8      000364 |	bne ClrInpBf	;
                      000365 |	
      E0A4 A0 00      000366 |	ldy #0h		;Use Y register as buffer pointer.
                      000367 |	
      E0A6            000368 |GtAnChar *
      E0A6 20 D2 F3   000369 |	jsr GetCharW
                      000370 |;	jsr OutChar	;Echo character.  ;Note: remove for muvium.
                      000371 |
      E0A9 C9 00      000372 |	cmp #0h		;If no character is entered then try again.
      E0AB F0 F9      000373 |	beq GtAnChar	;
                      000374 |	
      E0AD C9 08      000375 |	cmp #8d		;Check to see if the user entered a Delete or
      E0AF D0 03      000376 |	bne CkDel	; a Backspace.  If so then erase the character
      E0B1 4C B8 E0   000377 |	jmp DoDelete	; to the left of the cursor.
      E0B4            000378 |CkDel *			;
      E0B4 C9 7F      000379 |	cmp #127d	;
      E0B6 D0 15      000380 |	bne GtCkChar	;
      E0B8            000381 |DoDelete *		;
      E0B8 88         000382 |	dey		;
      E0B9 30 0D      000383 |	bmi AtStart	;
      E0BB A9 20      000384 |	lda #32d	;
      E0BD 20 F3 F3   000385 |	jsr OutChar	;
      E0C0 A9 08      000386 |	lda #8d		;
      E0C2 20 F3 F3   000387 |	jsr OutChar	;
      E0C5 4C A6 E0   000388 |	jmp GtAnChar	;
                      000389 |
      E0C8            000390 |AtStart *
      E0C8 A0 00      000391 |	ldy #0d
      E0CA 4C A6 E0   000392 |	jmp GtAnChar
                      000393 |	
      E0CD            000394 |GtCkChar *
      E0CD C9 0D      000395 |	cmp #13d	;If a CR was entered then accept line and exit,
      E0CF F0 0D      000396 |	beq GtLnDone	; if not then accept the next character and
      E0D1 99 A5 00   000397 |	sta InptBufr,y	; place it into the input buffer.
      E0D4 C8         000398 |	iny		;
                      000399 |	
      E0D5 C0 27      000400 |	cpy #39d	;Do not let buffer expand past 40 characters.
      E0D7 D0 CD      000401 |	bne GtAnChar
      E0D9 A0 27      000402 |	ldy #39d	;Set buffer at 40 characters if over 40 characters.
                      000403 |
      E0DB 4C A6 E0   000404 |	jmp GtAnChar	;
                      000405 |	
      E0DE            000406 |GtLnDone *
                      000407 |	;If a NL is in the input buffer then remove it.
      E0DE 88         000408 |	dey
      E0DF B9 A5 00   000409 |	lda InptBufr,y
      E0E2 C9 0A      000410 |	cmp #10d
      E0E4 F0 01      000411 |	beq PutNull
      E0E6 C8         000412 |	iny
      E0E7            000413 |PutNull	 *
      E0E7 A9 00      000414 |	lda #0h		;Put a NULL at end of the input buffer.
      E0E9 99 A5 00   000415 |	sta InptBufr,y	;
                      000416 |		
      E0EC 60         000417 |	rts
                      000418 |	
                      000419 |;****************************************************************************
                      000420 |;                       Parse Input Buffer Subroutine.
                      000421 |;****************************************************************************
      E0ED            000422 |ParseOpr *	;Entry point if parsing for a UASM command is not
      E0ED A0 FF      000423 |	ldy #0ffh	; desired.
      E0EF 4C 0F E1   000424 |	jmp GtAnoOpr	;
                      000425 |	
      E0F2            000426 |ParsLine *
      E0F2 A0 00      000427 |	ldy #0d
                      000428 |
      E0F4 B9 A5 00   000429 |	lda InptBufr,y
      E0F7 F0 50      000430 |	beq ExtPrsLn	;If NULL or CR encountered then return.
                      000431 |	
      E0F9 C9 3F      000432 |	cmp #63d	;Check for upper case letter.
      E0FB 30 4B      000433 |	bmi ParError	;
      E0FD C9 5A      000434 |	cmp #90d	;	
      E0FF 10 03      000435 |	bpl CkSmCase	;
                      000436 |	
      E101 38         000437 |	sec
      E102 B0 08      000438 |	bcs GetCmd	;
                      000439 |	
      E104            000440 |CkSmCase *
      E104 C9 61      000441 |	cmp #97d	;Check for lower case letter.
      E106 30 40      000442 |	bmi ParError	;
      E108 C9 7A      000443 |	cmp #122d	;
      E10A 10 3C      000444 |	bpl ParError	;
                      000445 |	                
      E10C            000446 |GetCmd *
      E10C 8D CD 00   000447 |	sta command	;Store command in command buffer.
                      000448 |                        
      E10F            000449 |GtAnoOpr *       
      E10F C8         000450 |	iny		;Point Y to the next operand field and check to
      E110 C0 14      000451 |	cpy #20d	;make sure that the input line is not too long.
      E112 F0 34      000452 |	beq ParError	;
                      000453 |	                
      E114 B9 A5 00   000454 |	lda InptBufr,y	;Check for the end of the input line.
      E117 C9 00      000455 |	cmp #0d		;
      E119 F0 2E      000456 |	beq ExtPrsLn	;
                      000457 |	                
      E11B C9 20      000458 |	cmp #32d	;Check for a space between operand fields.
      E11D F0 F0      000459 |	beq GtAnoOpr	;
                      000460 |	                
      E11F            000461 |ScanOprn *              
      E11F AE 5E 00   000462 |	ldx OpOffSet	;Point X to the beginning of the current operand
      E122 8A         000463 |	txa		; field holder and point OpOffSet to the beginning
      E123 18         000464 |	clc             
      E124 69 14      000465 |	adc #20d	; of the next operand field holder.
      E126 8D 5E 00   000466 |	sta OpOffSet	;
                      000467 |	
      E129            000468 |TranDgt *
      E129 B9 A5 00   000469 |	lda InptBufr,y	;
                      000470 |	                
      E12C C9 20      000471 |	cmp #32d	;If a space is encountered then stop scanning.
      E12E F0 10      000472 |	beq DoneScan	;
                      000473 |	                
      E130 C9 00      000474 |	Cmp #0d		;If a CR is encountered then stop scanning.
      E132 F0 0C      000475 |	beq doneScan	;
                      000476 |	                
      E134 9D 5F 00   000477 |	sta OpFld1,x	;Transfer current operand from input buffer into
      E137 E8         000478 |	inx		; current operand field holder.
      E138 C8         000479 |	iny		;
      E139 C0 28      000480 |	cpy #40d
      E13B F0 0B      000481 |	beq ParError
                      000482 |	
      E13D 4C 29 E1   000483 |	jmp TranDgt	
                      000484 |	
      E140            000485 |DoneScan *
      E140 A9 00      000486 |	lda #0h		;Put a NULL at the end of the current operand field
      E142 9D 5F 00   000487 |	sta OpFld1,x	; holder.
                      000488 |	
      E145 4C 0F E1   000489 |	jmp GtAnoOpr
                      000490 |
      E148            000491 |ParError *
      E148 60         000492 |	rts
      E149            000493 |ExtPrsLn *
      E149 60         000494 |	rts
                      000495 |
                      000496 |;****************************************************************************
                      000497 |;                     Check for Valid Command Subroutine.
                      000498 |;****************************************************************************
      E14A            000499 |CkValCmd *
      E14A 38         000500 |	sec
                      000501 |	
      E14B AD CD 00   000502 |	lda command
      E14E 20 ED F2   000503 |	jsr ToLower
                      000504 |
      E151 C9 6C      000505 |	cmp #108d	;Check for Load command.
      E153 D0 06      000506 |	bne NxtCmd1	;
      E155 20 69 E9   000507 |	jsr LdSRecs	;
      E158 4C DD E1   000508 |	jmp ExitCmd	;
                      000509 |                        
      E15B            000510 |NxtCmd1 *
      E15B C9 64      000511 |	cmp #100d	;Check for Dump command.
      E15D D0 06      000512 |	bne NxtCmd2	;
      E15F 20 3B E7   000513 |	jsr Dump	;
      E162 4C DD E1   000514 |	jmp ExitCmd	;
                      000515 |                        
      E165            000516 |NxtCmd2 *
      E165 C9 72      000517 |	cmp #114d	;Check for Register command.
      E167 D0 06      000518 |	bne NxtCmd3	;
      E169 20 1F EB   000519 |	jsr Register	;
      E16C 4C DD E1   000520 |	jmp ExitCmd	;
                      000521 |		
      E16F            000522 |NxtCmd3 *
      E16F C9 67      000523 |	cmp #103d	;Check for Go command.
      E171 D0 06      000524 |	bne NxtCmd4	;
      E173 20 E0 E8   000525 |	jsr Go		;
      E176 4C DD E1   000526 |	jmp ExitCmd	;
                      000527 |	
      E179            000528 |NxtCmd4 *
      E179 C9 65      000529 |	cmp #101d	;Check for Enter command.
      E17B D0 06      000530 |	bne NxtCmd5	;
      E17D 20 39 E8   000531 |	jsr Enter	;
      E180 4C DD E1   000532 |	jmp ExitCmd	;
                      000533 |	
      E183            000534 |NxtCmd5 *
      E183 C9 66      000535 |	cmp #102d	;Check for Fill command.
      E185 D0 06      000536 |	bne NxtCmd6	;
      E187 20 9F E8   000537 |	jsr Fill	;
      E18A 4C DD E1   000538 |	jmp ExitCmd	;
                      000539 |
      E18D            000540 |NxtCmd6 *
      E18D C9 75      000541 |	cmp #117d	;Check for Unassemble command.
      E18F D0 06      000542 |	bne NxtCmd7	;
      E191 20 B0 EF   000543 |	jsr UnAssem	;
      E194 4C DD E1   000544 |	jmp ExitCmd	;
                      000545 |
      E197            000546 |NxtCmd7 *
      E197 C9 74      000547 |	cmp #116d	;Check for Trace command.
      E199 D0 06      000548 |	bne NxtCmd8	;
      E19B 20 75 ED   000549 |	jsr Trace	;
      E19E 4C DD E1   000550 |	jmp ExitCmd	;
                      000551 |
      E1A1            000552 |NxtCmd8 *
      E1A1 C9 62      000553 |	cmp #98d	;Check for Breakpoint command.
      E1A3 D0 06      000554 |	bne NxtCmd9	;
      E1A5 20 D3 E5   000555 |	jsr BreakPnt	;
      E1A8 4C DD E1   000556 |	jmp ExitCmd	;
                      000557 |	
      E1AB            000558 |NxtCmd9 *
      E1AB C9 73      000559 |	cmp #115d	;Check for Search command.
      E1AD D0 06      000560 |	bne NxtCmd10	;
      E1AF 20 E4 EC   000561 |	jsr Search	;
      E1B2 4C DD E1   000562 |	jmp ExitCmd	;
                      000563 |
      E1B5            000564 |NxtCmd10 *
      E1B5 C9 6D      000565 |	cmp #109d	;Check for Move command.
      E1B7 D0 06      000566 |	bne NxtCmd11	;
      E1B9 20 B3 EA   000567 |	jsr Move	;
      E1BC 4C DD E1   000568 |	jmp ExitCmd	;
                      000569 |	
      E1BF            000570 |NxtCmd11 *
      E1BF C9 61      000571 |	cmp #'a'	;Check for Assemble command.
      E1C1 D0 06      000572 |	bne NxtCmd12	;
      E1C3 20 4A E2   000573 |	jsr Assemble	;
      E1C6 4C DD E1   000574 |	jmp ExitCmd	;
                      000575 |
      E1C9            000576 |NxtCmd12 *
      E1C9 C9 68      000577 |	cmp #104d	;Check for Help command.
      E1CB D0 06      000578 |	bne NxtCmd13	;
      E1CD 20 61 E9   000579 |	jsr Help	;
      E1D0 4C DD E1   000580 |	jmp ExitCmd	;
      E1D3            000581 |NxtCmd13 *                 
      E1D3 C9 3F      000582 |	cmp #63d	;
      E1D5 D0 06      000583 |	bne ExitCmd	;
      E1D7 20 61 E9   000584 |	jsr Help	;
      E1DA 4C DD E1   000585 |	jmp ExitCmd	;
                      000586 |
      E1DD            000587 |ExitCmd *
      E1DD B0 09      000588 |	bcs CmdOk
                      000589 |	
      E1DF            000590 |CmdError *		;If there was an error with a command then
      E1DF A2 1F      000591 |	ldx #CmdErMes<	; print a question mark.
      E1E1 A0 F6      000592 |	ldy #CmdErMes>	;
      E1E3 20 92 F3   000593 |	jsr PrntMess	;
      E1E6 18         000594 |	clc		;
      E1E7 60         000595 |	rts		;
                      000596 |	
      E1E8            000597 |CmdOk *
      E1E8 38         000598 |	sec
      E1E9 60         000599 |	rts
                      000600 |
                      000601 |;****************************************************************************
                      000602 |;                     Maskable Interrupt Service Subroutine.
                      000603 |;****************************************************************************
      E1EA            000604 |MaskInt *
      E1EA 78         000605 |	sei		;Disable interrupts.
                      000606 |
      E1EB 8D 44 00   000607 |	sta TempA	;Save accumulator.
                      000608 |			
      E1EE 68         000609 |	pla		;Check to see if BRK command was executed.
      E1EF 48         000610 |	pha		;
      E1F0 29 10      000611 |	and #10h	;
      E1F2 D0 06      000612 |	bne DoBRK	;
                      000613 |	
      E1F4 AD 44 00   000614 |	lda TempA	;Restore accumulator.
                      000615 |
      E1F7            000616 |IRQ *	
      E1F7 6C 02 00   000617 |	jmp (IRQVect)
                      000618 |	
      E1FA            000619 |DoBRK *
      E1FA 6C 04 00   000620 |	jmp (BRKVect)
                      000621 |
                      000622 |	
                      000623 |;****************************************************************************
                      000624 |;                          Break Service Subroutine.
                      000625 |;****************************************************************************
                      000626 |	
      E1FD            000627 |BRK *
      E1FD 68         000628 |	pla		;Save user's status register.
      E1FE 8D 4B 00   000629 |	sta UStatReg	;
                      000630 |
                      000631 |	
      E201 AD 44 00   000632 |	lda TempA	;Save user's accumulator.
      E204 8D 47 00   000633 |	sta UAccum	;
                      000634 |	
      E207 8E 48 00   000635 |	stx UXReg	;Save user's X register.
                      000636 |	
      E20A 8C 49 00   000637 |	sty UYReg	;Save user's Y register.
                      000638 |	
      E20D BA         000639 |	tsx
                      000640 |    
      E20E E8         000641 |    inx ;Remove the remaining 2 bytes that were pushed on the
      E20F E8         000642 |    inx ; stack by the brk command.
                      000643 |    
      E210 8E 4A 00   000644 |	stx UStkPtr	;Save user's stack pointer.
                      000645 |	
      E213 68         000646 |	pla		;Save program counter of break instruction
      E214 38         000647 |	sec		; that caused execution of this code.
      E215 E9 01      000648 |	sbc #1d		;
      E217 8D 45 00   000649 |	sta UPgmCntr	;
      E21A 68         000650 |	pla		; 
      E21B E9 00      000651 |	sbc #0d		;
      E21D 8D 46 00   000652 |	sta UPgmCntr+1d	;
                      000653 |;	cli
                      000654 |
      E220            000655 |ResetEntryPoint *
      E220 A0 00      000656 |	ldy #0d		;Print user's registers.
      E222 8C 5F 00   000657 |	sty OpFld1	;
      E225 20 1F EB   000658 |	jsr Register	;
                      000659 |
      E228 AD 39 00   000660 |	lda TrBrkFlg	;If this break was placed by the trace command
      E22B C9 01      000661 |	cmp #1d		; then go back to the trace subroutine.
      E22D D0 03      000662 |	bne RepBPOp	;
      E22F 4C 2B EF   000663 |	jmp Tr2ndEnt	;
                      000664 |	
      E232            000665 |RepBPOp *
      E232 A0 03      000666 |	ldy #3d		;Replace the opcodes of all breakpointed
      E234 A2 06      000667 |	ldx #6d		; addresses.
      E236            000668 |CkBPStBr *              ;
      E236 B9 2F 00   000669 |	lda BrkPt1St,y	;
      E239 C9 01      000670 |	cmp #1d		;
      E23B D0 05      000671 |	bne NxtBPStB	;
      E23D B9 33 00   000672 |	lda BP1OpHld,y	;
      E240 81 12      000673 |	sta (BrkPt1Ad,x);
      E242            000674 |NxtBPStB *		;
      E242 88         000675 |	dey		;
      E243 CA         000676 |	dex		;
      E244 CA         000677 |	dex		;
      E245 10 EF      000678 |	bpl CkBPStBr	;
                      000679 |	
      E247            000680 |GoMain *
      E247 4C 74 E0   000681 |	jmp MainLoop	;Enter monitor.
                      000682 |
                      000683 |
                      000684 |;****************************************************************************
                      000685 |;                       Assemble Command Subroutine.
                      000686 |;****************************************************************************
      E24A            000687 |Assemble *
                      000688 |
      E24A A2 00      000689 |	ldx #0d		;Get address to start assembling at and store
      E24C 20 C3 F2   000690 |	jsr GetAdd	; in pointer A.
      E24F B0 03      000691 |	bcs AAddOk	;
      E251 4C 40 E3   000692 |	jmp ErrAsem	;
      E254            000693 |AAddOk *		;
      E254 8E 08 00   000694 |	stx PointerA	;
      E257 8C 09 00   000695 |	sty PointerA+1d	;
                      000696 |
      E25A            000697 |AsemTop *		;On new line print current address being
      E25A A2 A8      000698 |	ldx #CRLF<	; assembled at and get next instruction to be
      E25C A0 F4      000699 |	ldy #CRLF>	; assembled from user.
      E25E 20 92 F3   000700 |	jsr PrntMess	;
      E261 20 05 F3   000701 |	jsr PrntAdd	;
      E264 20 87 E0   000702 |	jsr GetLine	;
      E267 20 ED E0   000703 |	jsr ParseOpr	;
                      000704 |	
      E26A AD 5F 00   000705 |	lda OpFld1	;Check for operator to be assembled. If no
      E26D C9 00      000706 |	cmp #0d		; operator is found then exit Assemble 
      E26F F0 04      000707 |	beq AsemDone	; subroutine.
      E271 C9 20      000708 |	cmp #32d	;
      E273 D0 03      000709 |	bne ACont	;
      E275            000710 |AsemDone *              ;
      E275 4C 42 E3   000711 |	jmp ExitAsem	;
                      000712 |	
      E278            000713 |ACont *			;Convert operator in input buffer to upper case,
      E278 A0 00      000714 |	ldy #0d		; check to see if it is in the operator table and
      E27A            000715 |ConvAno *		;
      E27A B9 5F 00   000716 |	lda OpFld1,y	; output a question mark if operator was not found.
      E27D 20 F9 F2   000717 |	jsr ToUpper	;
      E280 99 5F 00   000718 |	sta OpFld1,y	;
      E283 C8         000719 |	iny		;
      E284 C0 03      000720 |	cpy #3d		;
      E286 D0 F2      000721 |	bne ConvAno	;
      E288 20 44 E3   000722 |	jsr OptrScan	;
      E28B B0 28      000723 |	bcs AOptrOk	;
                      000724 |	
      E28D            000725 |PrntQues *
      E28D 20 05 F3   000726 |	jsr PrntAdd	;If there was an error assembling the instruction
      E290 A9 20      000727 |	lda #32d	; input from the user into object code then re-
      E292 20 F3 F3   000728 |	jsr OutChar	; output the line and print a question mark.
      E295 A2 5F      000729 |	ldx #OpFld1<	;
      E297 A0 00      000730 |	ldy #OpFld1>	;
      E299 20 92 F3   000731 |	jsr PrntMess	;
      E29C A9 20      000732 |	lda #32d  	;
      E29E 20 F3 F3   000733 |	jsr OutChar	;
      E2A1 A2 73      000734 |	ldx #OpFld2<	;
      E2A3 A0 00      000735 |	ldy #OpFld2>	;
      E2A5 20 92 F3   000736 |	jsr PrntMess	;
      E2A8 A9 20      000737 |	lda #32d	;
      E2AA 20 F3 F3   000738 |	jsr OutChar	;
      E2AD A9 3F      000739 |	lda #63d	;
      E2AF 20 F3 F3   000740 |	jsr OutChar	;
      E2B2 4C 5A E2   000741 |	jmp AsemTop	;
                      000742 |	
      E2B5            000743 |AOptrOk *		;Check address mode of operand and print a quesion
      E2B5 20 7C E3   000744 |	jsr AdMdScan	; mark if error occures while scanning operand.
      E2B8 B0 03      000745 |	bcs AOpndOk	;
      E2BA 4C 8D E2   000746 |	jmp PrntQues
                      000747 |		
      E2BD            000748 |AOpndOk *		;Check to see if address mode of operand is a
      E2BD 20 71 E4   000749 |	jsr AdMdTbSc	; valid address mode for instruction.
      E2C0 B0 03      000750 |	bcs AOpTbFnd	;
      E2C2 4C 8D E2   000751 |	jmp PrntQues
                      000752 |		
      E2C5            000753 |AOpTbFnd *		;Extract object code from operand.
      E2C5 20 91 E4   000754 |	jsr OpndScan	;
      E2C8 B0 03      000755 |	bcs PrntAssm	;
      E2CA 4C 8D E2   000756 |	jmp PrntQues	;
                      000757 |	
      E2CD            000758 |PrntAssm *
      E2CD 20 05 F3   000759 |	jsr PrntAdd	;Re-output current address.
                      000760 |	
      E2D0 A0 00      000761 |	ldy #0d		;
                      000762 |	
      E2D2 AD 1A 00   000763 |	lda Obj1	;Output opcode, store it in memory, point to next
      E2D5 91 08      000764 |	sta (PointerA),y; byte, and print one space.
      E2D7 20 3E F3   000765 |	jsr OutHex	;
      E2DA 20 BA F2   000766 |	jsr IncPntrA	;
      E2DD A9 20      000767 |	lda #32d	;
      E2DF 20 F3 F3   000768 |	jsr OutChar	;
                      000769 |	
      E2E2 AD 1D 00   000770 |	lda Obj2Flg	;Output second object code byte if present, store it in
      E2E5 F0 28      000771 |	beq NoObjCd	; it in memory, point to next byte, and print one
      E2E7 AD 1B 00   000772 |	lda Obj2	; space.
      E2EA 91 08      000773 |	sta (PointerA),y;
      E2EC 20 3E F3   000774 |	jsr OutHex	;
      E2EF 20 BA F2   000775 |	jsr IncPntrA	;
      E2F2 A9 20      000776 |	lda #32d	;
      E2F4 20 F3 F3   000777 |	jsr OutChar	;
                      000778 |	
      E2F7 AD 1E 00   000779 |	lda Obj3Flg	;Output third object code byte if present, store
      E2FA F0 1E      000780 |	beq NoObjCd3	; it in memory, point to next byte, and print one
      E2FC AD 1C 00   000781 |	lda Obj3	; space.
      E2FF 91 08      000782 |	sta (PointerA),y;
      E301 20 3E F3   000783 |	jsr OutHex	;
      E304 20 BA F2   000784 |	jsr IncPntrA	;
      E307 A9 20      000785 |	lda #32d	;
      E309 20 F3 F3   000786 |	jsr OutChar	;
      E30C 4C 25 E3   000787 |	jmp NoExSpcs
                      000788 |
      E30F            000789 |NoObjCd *		;If fewer then 3 bytes of object code are output
      E30F A9 20      000790 |	lda #32d	; then output spaces instead.
      E311 20 F3 F3   000791 |	jsr OutChar	;
      E314 20 F3 F3   000792 |	jsr OutChar	;
      E317 20 F3 F3   000793 |	jsr OutChar
      E31A            000794 |NoObjCd3 *
      E31A A9 20      000795 |	lda #32d	;
      E31C 20 F3 F3   000796 |	jsr OutChar	;
      E31F 20 F3 F3   000797 |	jsr OutChar	;
      E322 20 F3 F3   000798 |	jsr OutChar
                      000799 |	
      E325            000800 |NoExSpcs *
      E325 A9 20      000801 |	lda #32d	;
      E327 20 F3 F3   000802 |	jsr OutChar	;
      E32A A2 5F      000803 |	ldx #OpFld1<	;Re-output instruction that user had entered in.
      E32C A0 00      000804 |	ldy #OpFld1>	;
      E32E 20 92 F3   000805 |	jsr PrntMess	;
      E331 A9 20      000806 |	lda #32d  	;
      E333 20 F3 F3   000807 |	jsr OutChar	;
      E336 A2 73      000808 |	ldx #OpFld2<	;
      E338 A0 00      000809 |	ldy #OpFld2>	;
      E33A 20 92 F3   000810 |	jsr PrntMess	;
                      000811 |
      E33D 4C 5A E2   000812 |	jmp AsemTop
                      000813 |	
                      000814 |	
      E340            000815 |ErrAsem *
      E340 18         000816 |	clc
      E341 60         000817 |	rts
                      000818 |	
      E342            000819 |ExitAsem *
      E342 38         000820 |	sec
      E343 60         000821 |	rts
                      000822 |	
                      000823 |
                      000824 |;****************************************************************************
                      000825 |;                       Operator Scan Subroutine.
                      000826 |;****************************************************************************
      E344            000827 |OptrScan *
                      000828 |
      E344 A2 25      000829 |	ldx #OpTable<	;Point pointer B to beginning of the operator
      E346 8E 0A 00   000830 |	stx PointerB	; table.
      E349 A2 F8      000831 |	ldx #Optable>	;
      E34B 8E 0B 00   000832 |	stx PointerB+1d	;
                      000833 |	
      E34E            000834 |OSCkAno *
      E34E A0 00      000835 |	ldy #0d		;Compare a digit of the operator that the user
      E350            000836 |OSCkAnCM *		;
      E350 B1 0A      000837 |	lda (PointerB),y; entered with the analogous digit of the
      E352 D9 5F 00   000838 |	cmp OpFld1,y	; operator in the operator table.
      E355 F0 19      000839 |	beq CharMtch	;
                      000840 |	
      E357            000841 |OptScan2 *
      E357 AD 0A 00   000842 |	lda PointerB	;Point pointer B to the beginning of the next
      E35A 18         000843 |	clc		; operator in the operator table.
      E35B 69 0A      000844 |	adc #10d	;
      E35D 8D 0A 00   000845 |	sta PointerB	;
      E360 90 03      000846 |	bcc OSNoCary	;
      E362 EE 0B 00   000847 |	inc PointerB+1d	;
                      000848 |	
      E365            000849 |OSNoCary *
      E365 A0 04      000850 |	ldy #4d		;Check for the end of the operator table.
      E367 B1 0A      000851 |	lda (PointerB),y;
      E369 C9 5A      000852 |	cmp #'Z'	;
      E36B F0 0B      000853 |	beq OSNoMtch	;
      E36D 4C 4E E3   000854 |	jmp OSCkAno	;
                      000855 |	
      E370            000856 |CharMtch *		;Check for an operator match in the operator
      E370 C8         000857 |	iny		; table.
      E371 C0 03      000858 |	cpy #3d		;
      E373 F0 05      000859 |	beq OSMatch	;
      E375 4C 50 E3   000860 |	jmp OSCkAnCM	;
                      000861 |	
      E378            000862 |OSNoMtch *
      E378 18         000863 |	clc
      E379 60         000864 |	rts
                      000865 |	
      E37A            000866 |OSMatch *
      E37A 38         000867 |	sec
      E37B 60         000868 |	rts
                      000869 |
                      000870 |
                      000871 |;****************************************************************************
                      000872 |;                     Address Mode Scan Subroutine.
                      000873 |;****************************************************************************
      E37C            000874 |AdMdScan *
                      000875 |
      E37C            000876 |AMSCkIMP *
      E37C A0 00      000877 |	ldy #0d		;Check for implied addressing mode.
      E37E B9 73 00   000878 |	lda OpFld2,y	;
      E381 C9 00      000879 |	cmp #0d		;
      E383 D0 08      000880 |	bne AMSCkIMM	;
      E385 A9 50      000881 |	lda #'P'	;
      E387 8D 1F 00   000882 |	sta AddMode	;
      E38A 4C 6F E4   000883 |	jmp ExitAMS	;
                      000884 |	
      E38D            000885 |AMSCkIMM *		;Check for immediate addressing mode.
      E38D C9 23      000886 |	cmp #'#'	;
      E38F D0 08      000887 |	bne AMSCkACC	;
      E391 A9 4D      000888 |	lda #'M'	;
      E393 8D 1F 00   000889 |	sta AddMode	;
      E396 4C 6F E4   000890 |	jmp ExitAMS	;
                      000891 |	
      E399            000892 |AMSCkACC *		;Check for accumulator addressing mode.
      E399 C9 41      000893 |	cmp #'A'	;
      E39B F0 07      000894 |	beq CkSpNull	;
      E39D C9 61      000895 |	cmp #'a'	;
      E39F F0 03      000896 |	beq CkSpNull	;
      E3A1 4C BB E3   000897 |	jmp AMSCkREL	;
      E3A4            000898 |CkSpNull *		;
      E3A4 C8         000899 |	iny		;
      E3A5 B9 73 00   000900 |	lda OpFld2,y	;
      E3A8 C9 00      000901 |	Cmp #0d		;
      E3AA F0 07      000902 |	beq IsAcc	;
      E3AC C9 20      000903 |	cmp #32d	;
      E3AE F0 03      000904 |	beq IsAcc	;
      E3B0 4C BB E3   000905 |	jmp AMSCkREL	;
      E3B3            000906 |IsAcc *			;
      E3B3 A9 43      000907 |	lda #'C'	;
      E3B5 8D 1F 00   000908 |	sta AddMode	;
      E3B8 4C 6F E4   000909 |	jmp ExitAMS	;
                      000910 |	
      E3BB            000911 |AMSCkREL *		;Check for relative addressing mode.
      E3BB A0 06      000912 |	ldy #6d		;
      E3BD B1 0A      000913 |	lda (PointerB),y;
      E3BF C9 4C      000914 |	cmp #'L'	;
      E3C1 D0 06      000915 |	bne AMSCkA_I	;
      E3C3 8D 1F 00   000916 |	sta AddMode	;
      E3C6 4C 6F E4   000917 |	jmp ExitAMS	;
                      000918 |	
      E3C9            000919 |AMSCkA_I *		;Dispatch to absolute or indexed check code.
      E3C9 A0 00      000920 |	ldy #0d		;
      E3CB B9 73 00   000921 |	lda OpFld2,y	;
      E3CE C9 28      000922 |	cmp #'('	;
      E3D0 D0 03      000923 |	bne AMSCkAB?	;
      E3D2 4C 15 E4   000924 |	jmp AMSCkId?	;
                      000925 |	
      E3D5            000926 |AMSCkAB? *		;Check to see if operand is absolute addressing
      E3D5 A0 00      000927 |	ldy #0d		; mode or absolute indexed addressing mode.
      E3D7            000928 |AMSScnAB *		;
      E3D7 B9 73 00   000929 |	lda OpFld2,y	;
      E3DA C9 2C      000930 |	cmp #','	;
      E3DC F0 08      000931 |	beq CkXorY	;
      E3DE C9 00      000932 |	cmp #0d		;
      E3E0 F0 2B      000933 |	beq IsABS	;
      E3E2 C8         000934 |	iny		;
      E3E3 4C D7 E3   000935 |	jmp AMSScnAB	;
                      000936 |	
      E3E6            000937 |CkXorY *		;Check for absolute X or absolute Y addressing
      E3E6 C8         000938 |	iny		; mode.
      E3E7 B9 73 00   000939 |	lda OpFld2,y	;                                                                        
      E3EA C9 58      000940 |	cmp #'X'	;
      E3EC F0 0F      000941 |	beq IsABX	;
      E3EE C9 78      000942 |	cmp #'x'	;
      E3F0 F0 0B      000943 |	beq IsABX	;
      E3F2 C9 59      000944 |	cmp #'Y'	;
      E3F4 F0 0F      000945 |	beq IsABY	;
      E3F6 C9 79      000946 |	cmp #'y'	;
      E3F8 F0 0B      000947 |	beq IsABY	;
      E3FA 4C 6D E4   000948 |	jmp ErrAMS	;
                      000949 |	
      E3FD            000950 |IsABX *			;Save ABS, ABX or ABY mode in the variable to be
      E3FD A9 58      000951 |	lda #'X'	; returned.
      E3FF 8D 1F 00   000952 |	sta AddMode	;
      E402 4C 6F E4   000953 |	jmp ExitAMS	;
      E405            000954 |IsABY *			;
      E405 A9 59      000955 |	lda #'Y'	;
      E407 8D 1F 00   000956 |	sta AddMode	;
      E40A 4C 6F E4   000957 |	jmp ExitAMS	;
      E40D            000958 |IsABS *			;
      E40D A9 53      000959 |	lda #'S'	;
      E40F 8D 1F 00   000960 |	sta AddMode	;
      E412 4C 6F E4   000961 |	jmp ExitAMS	;
                      000962 |	
      E415            000963 |AMSCkId? *		;Dispatch to code that checks for IIR, IRI or
      E415 C8         000964 |	iny		; IND addressing modes.
      E416 B9 73 00   000965 |	lda OpFld2,y	;
      E419 C9 2C      000966 |	cmp #','	;
      E41B F0 0B      000967 |	beq CkIIR	;
      E41D C9 29      000968 |	cmp #')'	;
      E41F F0 1E      000969 |	beq CkIRIIND	;
      E421 C0 0B      000970 |	cpy #11d	;
      E423 D0 F0      000971 |	bne AMSCkId?	;
      E425 4C 6D E4   000972 |	jmp ErrAMS	;
                      000973 |
      E428            000974 |CkIIR *			;Check for IIR addressing mode.
      E428 C8         000975 |	iny		;
      E429 B9 73 00   000976 |	lda OpFld2,y	;
      E42C C9 58      000977 |	cmp #'X'	;
      E42E F0 07      000978 |	beq IsIIR	;
      E430 C9 78      000979 |	cmp #'x'	;
      E432 F0 03      000980 |	beq IsIIR	;
      E434 4C 6D E4   000981 |	jmp ErrAMS	;
                      000982 |	
      E437            000983 |IsIIR *
      E437 A9 52      000984 |	lda #'R'	;Save IIR addressing mode code in variable to be
      E439 8D 1F 00   000985 |	sta AddMode	; returned.
      E43C 4C 6F E4   000986 |	jmp ExitAMS	;
                      000987 |	
      E43F            000988 |CkIRIIND *		;Check for IND addressing mode.
      E43F C8         000989 |	iny		;
      E440 B9 73 00   000990 |	lda OpFld2,y	;
      E443 C9 00      000991 |	cmp #0d		;
      E445 F0 16      000992 |	beq IsIND	;
      E447 C9 2C      000993 |	cmp #','	;
      E449 F0 03      000994 |	beq CkIRI	;
      E44B 4C 6D E4   000995 |	jmp ErrAMS	;
                      000996 |	
      E44E            000997 |CkIRI *			;Check for IRI addressing mode.
      E44E C8         000998 |	iny		;
      E44F B9 73 00   000999 |	lda OpFld2,y	;
      E452 C9 59      001000 |	cmp #'Y'	;
      E454 F0 0F      001001 |	beq IsIRI	;
      E456 C9 79      001002 |	cmp #'y'	;
      E458 F0 0B      001003 |	beq IsIRI	;
      E45A 4C 6D E4   001004 |	jmp ErrAMS	;
                      001005 |	
      E45D            001006 |IsIND *			;Save IND or IRI addressing mode code in variable
      E45D A9 44      001007 |	lda #'D'	; to be returned.
      E45F 8D 1F 00   001008 |	sta AddMode	;
      E462 4C 6F E4   001009 |	jmp ExitAMS	;
      E465            001010 |IsIRI *			;
      E465 A9 49      001011 |	lda #'I'	;
      E467 8D 1F 00   001012 |	sta AddMode	;
      E46A 4C 6F E4   001013 |	jmp ExitAMS	;
                      001014 |	
      E46D            001015 |ErrAMS *
      E46D 18         001016 |	clc
      E46E 60         001017 |	rts
                      001018 |	
      E46F            001019 |ExitAMS *
      E46F 38         001020 |	sec
      E470 60         001021 |	rts
                      001022 |	
                      001023 |	
                      001024 |;****************************************************************************
                      001025 |;                   Address Mode Table Search Subroutine.
                      001026 |;****************************************************************************
      E471            001027 |AdMdTbSc *		
      E471 A0 06      001028 |	ldy #6d		;Check for address mode match between contents
      E473 B1 0A      001029 |	lda (PointerB),y; of variable AddMode & OpTable.
      E475 CD 1F 00   001030 |	cmp AddMode	;
      E478 F0 15      001031 |	beq ExitAdMd	;
                      001032 |	
      E47A AD 0A 00   001033 |	lda PointerB	;Pointer Pointer B to next operator in
      E47D 18         001034 |	clc		; operator table.
      E47E 69 0A      001035 |	adc #10d	;
      E480 8D 0A 00   001036 |	sta PointerB	;
      E483 90 03      001037 |	bcc AdMdNoCy	;
      E485 EE 0B 00   001038 |	inc PointerB+1d	;
                      001039 |	
      E488            001040 |AdMdNoCy *		;Check to see if next operator is the same type
      E488 20 4E E3   001041 |	jsr OSCkANO	; that we are currently trying to assemble.
      E48B B0 E4      001042 |	bcs AdMdTbSc	;
                      001043 |	
      E48D            001044 |ErrAdMd *
      E48D 18         001045 |	clc
      E48E 60         001046 |	rts
                      001047 |	
      E48F            001048 |ExitAdMd *
      E48F 38         001049 |	sec
      E490 60         001050 |	rts
                      001051 |
                      001052 |;****************************************************************************
                      001053 |;                       Operand Scan Subroutine.
                      001054 |;****************************************************************************
      E491            001055 |OpndScan *
                      001056 |
      E491 A9 00      001057 |	lda #0d		;Initialize the flags that indicate whether or
      E493 8D 1D 00   001058 |	sta Obj2Flg	; not there are object bytes in addition to
      E496 8D 1E 00   001059 |	sta Obj3Flg	; the opcode object byte.
                      001060 |	
      E499 A0 07      001061 |	ldy #7d		;Get the opcode of the instruction being 
      E49B B1 0A      001062 |	lda (PointerB),y; currently assembled from the opcode table
      E49D 8D 1A 00   001063 |	sta Obj1	; and put it in Obj1.
                      001064 |	
      E4A0 AD 1F 00   001065 |	lda AddMode	;Check to see what address mode the instruction
      E4A3 C9 50      001066 |	cmp #'P'	; currently being assembled is.
      E4A5 F0 27      001067 |	beq OpndIMP	;
      E4A7 C9 43      001068 |	cmp #'C'	;
      E4A9 F0 26      001069 |	beq OpndACC	;
      E4AB C9 4D      001070 |	cmp #'M'	;
      E4AD F0 25      001071 |	beq OpndIMM	;
      E4AF C9 53      001072 |	cmp #'S'	;
      E4B1 F0 3C      001073 |	beq OpndAB??	;
      E4B3 C9 58      001074 |	cmp #'X'	;
      E4B5 F0 38      001075 |	beq OpndAB??	;
      E4B7 C9 59      001076 |	cmp #'Y'	;
      E4B9 F0 34      001077 |	beq OpndAB??	;
      E4BB C9 49      001078 |	cmp #'I'	;
      E4BD F0 58      001079 |	beq OpndIN??	;
      E4BF C9 52      001080 |	cmp #'R'	;
      E4C1 F0 54      001081 |	beq OpndIN??	;
      E4C3 C9 44      001082 |	cmp #'D'	;
      E4C5 F0 50      001083 |	beq OpndIN??	;
      E4C7 C9 4C      001084 |	cmp #'L'	;
      E4C9 F0 24      001085 |	beq OpndAB??	;
      E4CB 4C AA E5   001086 |	jmp ErrOpndS	;
                      001087 |
      E4CE            001088 |OpndIMP *		;Process implied addressing mode.
      E4CE 4C AC E5   001089 |	jmp ExtOpndS	;
                      001090 |	
      E4D1            001091 |OpndACC *		;Process accumulator addressing mode.
      E4D1 4C AC E5   001092 |	jmp ExtOpndS	;
                      001093 |	
      E4D4            001094 |OpndIMM *		;Process immediate addressing mode.
      E4D4 20 AE E5   001095 |	jsr ScnForHex	;
      E4D7 B0 03      001096 |	bcs OpnMHFnd	;
      E4D9 4C AA E5   001097 |	jmp ErrOpndS	;
      E4DC            001098 |OpnMHFnd *		;
      E4DC 20 1C F3   001099 |	jsr AsToBin	;
      E4DF B0 03      001100 |	bcs OpndCvOk	;
      E4E1 4C AA E5   001101 |	jmp ErrOpndS	;
      E4E4            001102 |OpndCvOk *		;
      E4E4 8D 1B 00   001103 |	sta Obj2	;
      E4E7 A9 01      001104 |	lda #1d		;
      E4E9 8D 1D 00   001105 |	sta Obj2Flg	;
      E4EC 4C AC E5   001106 |	jmp ExtOpndS	;
                      001107 |
                      001108 |
      E4EF            001109 |OpndAB?? *		;Process absolute, absolute X, absolute Y.
      E4EF 20 AE E5   001110 |	jsr ScnForHex	; Check for relative addressing mode and send
      E4F2 B0 03      001111 |	bcs OpnAHFnd	; to appropriate code if found.
      E4F4 4C AA E5   001112 |	jmp ErrOpndS	;
      E4F7            001113 |OpnAHFnd *		;
      E4F7 20 C3 F2   001114 |	jsr GetAdd	;
      E4FA B0 03      001115 |	bcs OpndAdOk	;
      E4FC 4C AA E5   001116 |	jmp ErrOpndS	;
      E4FF            001117 |OpndAdOk *		;
      E4FF AD 1F 00   001118 |	lda AddMode	;
      E502 C9 4C      001119 |	cmp #'L'	;
      E504 F0 48      001120 |	beq OpndDoBr	;
      E506            001121 |DoAdd *			;
      E506 8E 1B 00   001122 |	stx Obj2	;
      E509 8C 1C 00   001123 |	sty Obj3	;
      E50C A9 01      001124 |	lda #1d		;
      E50E 8D 1D 00   001125 |	sta Obj2Flg	;
      E511 8D 1E 00   001126 |	sta Obj3Flg	;
      E514 4C AC E5   001127 |	jmp ExtOpndS	;
                      001128 |
      E517            001129 |OpndIN?? *		;Process indirect indexed, indexed indirect and
      E517 20 AE E5   001130 |	jsr ScnForHex	; indirect addressing modes.
      E51A B0 03      001131 |	bcs OpnINFnd	;
      E51C 4C AA E5   001132 |	jmp ErrOpndS	;
      E51F            001133 |OpnINFnd *		;
      E51F 20 C3 F2   001134 |	jsr GetAdd	;
      E522 B0 03      001135 |	bcs OpINAdOk	;
      E524 4C AA E5   001136 |	jmp ErrOpndS	;
      E527            001137 |OpINAdOk *		;
      E527 AD 1F 00   001138 |	lda AddMode	;
      E52A C9 44      001139 |	cmp #'D'	;
      E52C F0 0F      001140 |	beq DoIND	;
      E52E C0 00      001141 |	cpy #0d		;
      E530 D0 78      001142 |	bne ErrOpndS	;
      E532 8E 1B 00   001143 |	stx Obj2	;
      E535 A9 01      001144 |	lda #1d		;
      E537 8D 1D 00   001145 |	sta Obj2Flg	;
      E53A 4C AC E5   001146 |	jmp ExtOpndS	;
      E53D            001147 |DoIND *			;
      E53D 8E 1B 00   001148 |	stx Obj2	;
      E540 8C 1C 00   001149 |	sty Obj3	;
      E543 A9 01      001150 |	lda #1d		;
      E545 8D 1D 00   001151 |	sta Obj2Flg	;
      E548 8D 1E 00   001152 |	sta Obj3Flg	;
      E54B 4C AC E5   001153 |	jmp ExtOpndS	;
                      001154 |	
      E54E            001155 |OpndDoBr *		;Put address to be branched to in TempAdd and
      E54E 8E 2B 00   001156 |	stx TempAdd	; the address of the first byte of the next
      E551 8C 2C 00   001157 |	sty TempAdd+1d	; instruction in TempAdd2.
      E554 AD 08 00   001158 |	lda PointerA	;
      E557 8D 2D 00   001159 |	sta TempAdd2	;
      E55A AD 09 00   001160 |	lda PointerA+1d	;
      E55D 8D 2E 00   001161 |	sta TempAdd2+1d	;
      E560 A0 08      001162 |	ldy #8d		;
      E562 B1 0A      001163 |	lda (PointerB),y;
      E564 18         001164 |	clc		;
      E565 6D 2D 00   001165 |	adc TempAdd2	;
      E568 8D 2D 00   001166 |	sta TempAdd2	;
      E56B 90 03      001167 |	bcc OpBrNoOv	;
      E56D EE 2E 00   001168 |	inc TempAdd2+1d	;
      E570            001169 |OpBrNoOv *
      E570 38         001170 |	sec		;Subtract the address of the first byte of the
      E571 AD 2B 00   001171 |	lda TempAdd	; next instruction from the address to be branched
      E574 ED 2D 00   001172 |	sbc TempAdd2	; to in order to get the branch offset.
      E577 8D 2B 00   001173 |	sta TempAdd	;
      E57A AD 2C 00   001174 |	lda TempAdd+1d	;
      E57D ED 2E 00   001175 |	sbc TempAdd2+1d	;
      E580 8D 2C 00   001176 |	sta TempAdd+1d	;
                      001177 |	
      E583 AD 2C 00   001178 |	lda TempAdd+1d	;Check to make sure that MSB of the offset does
      E586 C9 FF      001179 |	cmp #0ffh	; not indicate a number greater than 127 or less
      E588 F0 0E      001180 |	beq OpCkNOff	; than 128.
      E58A C9 00      001181 |	cmp #0d		;
      E58C D0 1C      001182 |	bne ErrOpndS	;
                      001183 |	
      E58E            001184 |OpCkPOff *		;Check to make sure that LSB of the offset does
      E58E AD 2B 00   001185 |	lda TempAdd	; not contain a number greater than 127 or less
      E591 C9 80      001186 |	cmp #128d	; than 128.
      E593 10 15      001187 |	bpl ErrOpndS	;
      E595 4C 9F E5   001188 |	jmp OffOk	;
      E598            001189 |OpCkNOff *		;
      E598 AD 2B 00   001190 |	lda TempAdd	;
      E59B C9 80      001191 |	cmp #128d	;
      E59D 30 0B      001192 |	bmi ErrOpndS	;
                      001193 |	
      E59F            001194 |OffOk *			;If offset is OK then put it in Obj2 and return.
      E59F 8D 1B 00   001195 |	sta Obj2	;
      E5A2 A9 01      001196 |	lda #1d		;
      E5A4 8D 1D 00   001197 |	sta Obj2Flg	;
      E5A7 4C AC E5   001198 |	jmp ExtOpndS	;
                      001199 |	
      E5AA            001200 |ErrOpndS *
      E5AA 18         001201 |	clc
      E5AB 60         001202 |	rts
                      001203 |	
      E5AC            001204 |ExtOpndS *
      E5AC 38         001205 |	sec
      E5AD 60         001206 |	rts
                      001207 |
                      001208 |
                      001209 |;****************************************************************************
                      001210 |;                     Scan For Hex Digit Subroutine.
                      001211 |;****************************************************************************
      E5AE            001212 |ScnForHex *
      E5AE A2 14      001213 |	ldx #20d		
                      001214 |	
      E5B0            001215 |SFHNxtDg *
      E5B0 A0 00      001216 |	ldy #0d		;Scan until either an upper case or a lower case
      E5B2 BD 5F 00   001217 |	lda OpFld1,x	; hex digit is encountered in the input buffer.
      E5B5            001218 |SFHCkDgt *		;
      E5B5 D9 32 F4   001219 |	cmp DgtTblUC,y	;
      E5B8 F0 17      001220 |	beq ExitSFH	;
      E5BA D9 43 F4   001221 |	cmp DgtTblLC,y	;
      E5BD F0 12      001222 |	beq ExitSFH	;
      E5BF C8         001223 |	iny		;
      E5C0 C0 10      001224 |	cpy #16d	;
      E5C2 F0 03      001225 |	beq IncBfPtr	;
      E5C4 4C B5 E5   001226 |	jmp SFHCkDgt	;
                      001227 |
      E5C7            001228 |IncBfPtr *		;Point to the next digit in the input buffer.
      E5C7 E8         001229 |	inx		;
      E5C8 E0 1F      001230 |	cpx #31d	;
      E5CA F0 03      001231 |	beq ErrSFH	;
      E5CC 4C B0 E5   001232 |	jmp SFHNxtDg	;
                      001233 |
      E5CF            001234 |ErrSFH *
      E5CF 18         001235 |	clc
      E5D0 60         001236 |	rts
                      001237 |	
      E5D1            001238 |ExitSFH *
      E5D1 38         001239 |	sec
      E5D2 60         001240 |	rts
                      001241 |	
                      001242 |	
                      001243 |;****************************************************************************
                      001244 |;                       Breakpoint Command Subroutine.
                      001245 |;****************************************************************************
      E5D3            001246 |BreakPnt *
      E5D3 AD 5F 00   001247 |	lda OpFld1	;Check for a +, - or a ? in operand field #1.
      E5D6 C9 2B      001248 |	cmp #43d	;
      E5D8 F0 0B      001249 |	beq DoPlus	;
      E5DA C9 2D      001250 |	cmp #45d	;
      E5DC F0 0A      001251 |	beq DoMinus	;
      E5DE C9 3F      001252 |	cmp #63d	;
      E5E0 F0 09      001253 |	beq DmpBPAdd	;
      E5E2 4C F3 E6   001254 |	jmp ExitBP	;
      E5E5            001255 |DoPlus *		;
      E5E5 4C 5F E6   001256 |	jmp Plus	;
      E5E8            001257 |DoMinus *		;
      E5E8 4C 1B E6   001258 |	jmp Minus	;
                      001259 |	
      E5EB            001260 |DmpBPAdd *
      E5EB A2 A8      001261 |	ldx #CRLF<	;If question mark was entered then dump current
      E5ED A0 F4      001262 |	ldy #CRLF>	; breakpoints.
      E5EF 20 92 F3   001263 |	jsr PrntMess	;
      E5F2 A0 FF      001264 |	ldy #0ffh	;
      E5F4 A2 FF      001265 |	ldx #0ffh	;
      E5F6            001266 |OtAdAgin *		;
      E5F6 C8         001267 |	iny		;
      E5F7 E8         001268 |	inx		;
      E5F8 B9 12 00   001269 |	lda BrkPt1Ad,y	;
      E5FB 8D 08 00   001270 |	sta PointerA	;
      E5FE C8         001271 |	iny		;
      E5FF B9 12 00   001272 |	lda BrkPt1Ad,y	;
      E602 8D 09 00   001273 |	sta PointerA+1d	;
      E605 BD 2F 00   001274 |	lda BrkPt1St,x	;
      E608 F0 03      001275 |	beq AdEmpty	;
      E60A 20 05 F3   001276 |	jsr PrntAdd	;
      E60D            001277 |AdEmpty *		;
      E60D C0 07      001278 |	cpy #7d		;
      E60F D0 E5      001279 |	bne OtAdAgin	;
      E611 A2 A8      001280 |	ldx #CRLF<	;
      E613 A0 F4      001281 |	ldy #CRLF>	;
      E615 20 92 F3   001282 |	jsr PrntMess	;
      E618 4C F3 E6   001283 |	jmp ExitBP	;
                      001284 |	
      E61B            001285 |Minus *
      E61B AD 73 00   001286 |	lda OpFld2	;If minus was found in operand field #1 check for
      E61E C9 00      001287 |	cmp #0d		; an address in operand field #2.  If no address
      E620 F0 0A      001288 |	beq ClrAllBP	; was found then clear all breakpoints, if an
      E622 A2 14      001289 |	ldx #20d	; address was found then clear that one breakpoint.
      E624 20 C3 F2   001290 |	jsr GetAdd	;
      E627 B0 10      001291 |	bcs Clr1BP	;
      E629 4C F3 E6   001292 |	jmp ExitBP	;
                      001293 |	
      E62C            001294 |ClrAllBP *
      E62C A0 03      001295 |	ldy #3d		;Clear all breakpoints.
      E62E            001296 |ZeroBP *		;
      E62E A9 00      001297 |	lda #0d		;
      E630 99 2F 00   001298 |	sta BrkPt1St,y	;
      E633 88         001299 |	dey		;
      E634 10 F8      001300 |	bpl ZeroBP	;
      E636 4C F3 E6   001301 |	jmp ExitBP	;
                      001302 |	
      E639            001303 |Clr1BP *
      E639 8E 2B 00   001304 |	stx TempAdd	;Search for a match between a breakpoint address
      E63C 8C 2C 00   001305 |	sty TempAdd+1d	; in the breakpoint address table and the address
      E63F A0 03      001306 |	ldy #3d		; that was entered.
      E641 A2 06      001307 |	ldx #6d		;
      E643            001308 |CkBPAdd *		;
      E643 20 F4 E6   001309 |	jsr CmpBPAdd	;
      E646 B0 0F      001310 |	bcs FoundBP	;
      E648 88         001311 |	dey		;
      E649 CA         001312 |	dex		;
      E64A CA         001313 |	dex		;
      E64B 10 F6      001314 |	bpl CkBPAdd	;
                      001315 |	
      E64D            001316 |BPNtFnd *		
      E64D A2 B5      001317 |	ldx #NoBPMess<	;If no match was found then print an error message
      E64F A0 F5      001318 |	ldy #NoBPMess>	; and exit.
      E651 20 92 F3   001319 |	jsr PrntMess	;
      E654 4C F3 E6   001320 |	jmp ExitBP	;
                      001321 |	
      E657            001322 |FoundBP *
      E657 A9 00      001323 |	lda #0d		;If match was found then zero out that breakpoint's
      E659 99 2F 00   001324 |	sta BrkPt1St,y	; status indicator and exit.
      E65C 4C F3 E6   001325 |	jmp ExitBP	;
                      001326 |
      E65F            001327 |Plus *
      E65F AD 73 00   001328 |	lda OpFld2	;If a plus was entered then check operand field
      E662 C9 00      001329 |	cmp #0d		; #2 for the address of the new breakpoint.
      E664 F0 07      001330 |	beq OutBP2	;
      E666 A2 14      001331 |	ldx #20d	;
      E668 20 C3 F2   001332 |	jsr GetAdd	;
      E66B B0 03      001333 |	bcs BPAdOk	;
      E66D            001334 |OutBP2 *		;
      E66D 4C F3 E6   001335 |	jmp ExitBP	;
                      001336 |
                      001337 |
      E670            001338 |BPAdOk *
      E670 8E 2B 00   001339 |	stx TempAdd	;
      E673 8C 2C 00   001340 |	sty TempAdd+1d	;
      E676 A0 03      001341 |	ldy #3d		;Check to make sure that breakpoint address has
      E678 A2 06      001342 |	ldx #6d		; not already been entered into table.
      E67A            001343 |CkBPAddP *		;
      E67A B9 2F 00   001344 |	lda BrkPt1St,y	;
      E67D C9 00      001345 |	cmp #0d		;
      E67F F0 05      001346 |	beq NoCmp	;
      E681 20 F4 E6   001347 |	jsr CmpBPAdd	;
      E684 B0 E7      001348 |	bcs OutBP2	;
      E686            001349 |NoCmp *			;
      E686 88         001350 |	dey		;
      E687 CA         001351 |	dex		;
      E688 CA         001352 |	dex		;
      E689 10 EF      001353 |	bpl CkBPAddP	;
                      001354 |	
                      001355 |
      E68B A0 00      001356 |	ldy #0d		;If a plus was entered then search breakpoint
      E68D            001357 |CkNxtBP *		;
      E68D B9 2F 00   001358 |	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
      E690 C9 00      001359 |	cmp #0d		;
      E692 F0 0F      001360 |	beq EmptyBP	;
      E694 C8         001361 |	iny		;
      E695 C0 04      001362 |	cpy #4d		;
      E697 D0 F4      001363 |	bne CkNxtBP	;
                      001364 |	
      E699            001365 |AllBPFull *
      E699 A2 8D      001366 |	ldx #BPFulMes<	;If all breakpoints are full then print an error
      E69B A0 F5      001367 |	ldy #BPFulMes>	; message and exit.
      E69D 20 92 F3   001368 |	jsr PrntMess	;
      E6A0 4C F3 E6   001369 |	jmp ExitBP	;
                      001370 |	
      E6A3            001371 |EmptyBP *
      E6A3 8C 37 00   001372 |	sty BPNumHld	;
      E6A6 A9 01      001373 |	lda #1d		;
      E6A8 99 2F 00   001374 |	sta BrkPt1St,y	;
                      001375 |	
                      001376 |	
      E6AB            001377 |NxtBPSlt0 *
      E6AB C0 00      001378 |	cpy #0d		;Store new address in first position of
      E6AD D0 0F      001379 |	bne NxtBPSlt1	; breakpoint table.
      E6AF AD 2B 00   001380 |	lda TempAdd	;
      E6B2 8D 12 00   001381 |	sta BrkPt1Ad	;
      E6B5 AD 2C 00   001382 |	lda TempAdd+1d	;
      E6B8 8D 13 00   001383 |	sta BrkPt1Ad+1d	;
      E6BB 4C F3 E6   001384 |	jmp ExitBP	;
                      001385 |	
      E6BE            001386 |NxtBPSlt1 *		;
      E6BE C0 01      001387 |	cpy #1d		;Store new address in second position of
      E6C0 D0 0F      001388 |	bne NxtBPSlt2	; breakpoint table.
      E6C2 AD 2B 00   001389 |	lda TempAdd	;
      E6C5 8D 14 00   001390 |	sta BrkPt2Ad	;
      E6C8 AD 2C 00   001391 |	lda TempAdd+1d	;
      E6CB 8D 15 00   001392 |	sta BrkPt2Ad+1d	;
      E6CE 4C F3 E6   001393 |	jmp ExitBP	;
                      001394 |	
      E6D1            001395 |NxtBPSlt2 *		;
      E6D1 C0 02      001396 |	cpy #2d		;Store new address in third position of
      E6D3 D0 0F      001397 |	bne NxtBPSlt3	; breakpoint table.
      E6D5 AD 2B 00   001398 |	lda TempAdd	;
      E6D8 8D 16 00   001399 |	sta BrkPt3Ad	;
      E6DB AD 2C 00   001400 |	lda TempAdd+1d	;
      E6DE 8D 17 00   001401 |	sta BrkPt3Ad+1d	;
      E6E1 4C F3 E6   001402 |	jmp ExitBP	;
                      001403 |	
      E6E4            001404 |NxtBPSlt3 *		;
      E6E4 AD 2B 00   001405 |	lda TempAdd	;Store new address in forth position of
      E6E7 8D 18 00   001406 |	sta BrkPt4Ad	; breakpoint table.
      E6EA AD 2C 00   001407 |	lda TempAdd+1d	;
      E6ED 8D 19 00   001408 |	sta BrkPt4Ad+1d	;
      E6F0 4C F3 E6   001409 |	jmp ExitBP	;
                      001410 |
      E6F3            001411 |ExitBP *
      E6F3 60         001412 |	rts
                      001413 |
                      001414 |
                      001415 |;****************************************************************************
                      001416 |;                   Compare Breakpoint Address Subroutine.
                      001417 |;****************************************************************************
      E6F4            001418 |CmpBPAdd *
      E6F4 C0 00      001419 |	cpy #0d		;Compare LSB of first breakpoint address.
      E6F6 D0 0B      001420 |	bne CmpNxt1	;
      E6F8 AD 2C 00   001421 |	lda TempAdd+1d	;
      E6FB CD 13 00   001422 |	cmp BrkPt1Ad+1d	;
      E6FE F0 2C      001423 |	beq CChkFLSB	;
      E700 4C 39 E7   001424 |	jmp NoMatch 	;
                      001425 |	
      E703            001426 |CmpNxt1 *		;
      E703 C0 01      001427 |	cpy #1d		;Compare MSB of second breakpoint address.
      E705 D0 0B      001428 |	bne CmpNxt2	;
      E707 AD 2C 00   001429 |	lda TempAdd+1d	;
      E70A CD 15 00   001430 |	cmp BrkPt2Ad+1d	;
      E70D F0 1D      001431 |	beq CChkFLSB	;
      E70F 4C 39 E7   001432 |	jmp NoMatch 	;
                      001433 |	
      E712            001434 |CmpNxt2 *		;
      E712 C0 02      001435 |	cpy #2d		;Compare MSB of third breakpoint address.
      E714 D0 0B      001436 |	bne CmpNxt3	;
      E716 AD 2C 00   001437 |	lda TempAdd+1d	;
      E719 CD 17 00   001438 |	cmp BrkPt3Ad+1d	;
      E71C F0 0E      001439 |	beq CChkFLSB	;
      E71E 4C 39 E7   001440 |	jmp NoMatch 	;
                      001441 |	
      E721            001442 |CmpNxt3 *		;
      E721 AD 2C 00   001443 |	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
      E724 CD 19 00   001444 |	cmp BrkPt4Ad+1d	;
      E727 F0 03      001445 |	beq CChkFLSB	;
      E729 4C 39 E7   001446 |	jmp NoMatch 	;
                      001447 |	
      E72C            001448 |CChkFLSB *
      E72C AD 2B 00   001449 |	lda TempAdd	;Compare LSB of breakpoint address.
      E72F DD 12 00   001450 |	cmp BrkPt1Ad,x	;
      E732 F0 03      001451 |	beq BPMatch	;
      E734 4C 39 E7   001452 |	jmp NoMatch	;
                      001453 |	
      E737            001454 |BPMatch *		;Return with carry set if addresses match.
      E737 38         001455 |	sec		;
      E738 60         001456 |	rts		;
                      001457 |	
      E739            001458 |NoMatch *		;Return with carry cleared if addresses
      E739 18         001459 |	clc		; do not match.
      E73A 60         001460 |	rts		;
                      001461 |
                      001462 |
                      001463 |;****************************************************************************
                      001464 |;                     Dump command Subroutine
                      001465 |;****************************************************************************
      E73B            001466 |Dump *
                      001467 |	
      E73B A2 00      001468 |	ldx #0h
                      001469 |	
      E73D BD 5F 00   001470 |	lda OpFld1,x	;If no operands then do a standard dump.
      E740 C9 00      001471 |	cmp #0h		;
      E742 F0 3A      001472 |	beq DoStdDmp	;
                      001473 |
      E744 20 1C F3   001474 |	jsr AsToBin	;Get start address from operand field #1 and place
      E747 B0 03      001475 |	bcs DgtOk1	; in zero page pointer.
      E749 4C FF E7   001476 |	jmp ErrDump	;
      E74C            001477 |DgtOk1 *		;
      E74C 8D 09 00   001478 |	sta PointerA+1d	;
      E74F E8         001479 |	inx		;
      E750 20 1C F3   001480 |	jsr AsToBin	;
      E753 B0 03      001481 |	bcs DgtOk2	;
      E755 4C FF E7   001482 |	jmp ErrDump	;
      E758            001483 |DgtOk2 *		;
      E758 8D 08 00   001484 |	sta PointerA	;
                      001485 |	
      E75B A2 14      001486 |	ldx #20d	;If no end address was entered then perform a
      E75D BD 5F 00   001487 |	lda OpFld1,x	; standard dump.
      E760 C9 00      001488 |	cmp #0h		;
      E762 F0 1A      001489 |	beq DoStdDmp	;
                      001490 |	
      E764 20 1C F3   001491 |	Jsr AsToBin	;Get end address from operand field #2 and place
      E767 B0 03      001492 |	bcs OpFldOk1	; in the variable EndAdd.
      E769 4C FF E7   001493 |	jmp ErrDump	;
      E76C            001494 |OpFldOk1 *		;
      E76C 8D 5D 00   001495 |	sta EndAdd+1d	;
      E76F E8         001496 |	inx 		;
      E770 20 1C F3   001497 |	jsr AsToBin	;
      E773 B0 03      001498 |	bcs OpFldOk2	;
      E775 4C FF E7   001499 |	jmp ErrDump	;
      E778            001500 |OpFldOk2 *		;
      E778 8D 5C 00   001501 |	sta EndAdd	;
                      001502 |	
      E77B 4C 95 E7   001503 |	jmp DoDump	
                      001504 |	
      E77E            001505 |DoStdDmp *
      E77E AD 09 00   001506 |	lda PointerA+1d	;Adjust end address so that it will only dump the
      E781 8D 5D 00   001507 |	sta EndAdd+1d	; contents of 16 memory locations.
      E784 AD 08 00   001508 |	lda PointerA	;
      E787 8D 5C 00   001509 |	sta EndAdd	;
      E78A 18         001510 |	clc   		;Note: check to make sure this is correct.
      E78B 69 0F      001511 |	adc #15d	;
      E78D 8D 5C 00   001512 |	sta EndAdd	;
      E790 90 03      001513 |	bcc DoDump	;
      E792 EE 5D 00   001514 |	inc EndAdd+1d	;
                      001515 |	
      E795            001516 |DoDump *
      E795 A9 0D      001517 |	lda #13d	;Output a CRLF.
      E797 20 F3 F3   001518 |	jsr OutChar	;
      E79A A9 0A      001519 |	lda #10d	;
      E79C 20 F3 F3   001520 |	jsr OutChar	;
                      001521 |
      E79F A2 00      001522 |	ldx #0d		;
      E7A1 A0 00      001523 |	ldy #0d		;
                      001524 |
      E7A3 20 05 F3   001525 |	jsr PrntAdd	;Output address of first dump memory location.
                      001526 |	
      E7A6            001527 |DumpAgin *
      E7A6 B1 08      001528 |	lda (PointerA),y;Get byte from memory location.
                      001529 |
      E7A8 20 23 E8   001530 |	jsr PutASCBf	;Put character in ASCII buffer.
                      001531 |	
      E7AB 20 3E F3   001532 |	jsr OutHex	;Convert to ASCII/Hex and print.
                      001533 |	
      E7AE E8         001534 |	inx
      E7AF E0 10      001535 |	cpx #16d	;
      E7B1 D0 03      001536 |	bne Chk8	;
      E7B3 20 0B E8   001537 |	jsr DumpASC	;Output ASCII interpretion of dumped line.
                      001538 |	
      E7B6            001539 |Chk8 *			;
      E7B6 E0 08      001540 |	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
      E7B8 D0 12      001541 |	bne OutSpc	; the dump screen.
      E7BA A9 20      001542 |	lda #32d	;
      E7BC 20 F3 F3   001543 |	jsr OutChar	;
      E7BF A9 2D      001544 |	lda #45d	;
      E7C1 20 F3 F3   001545 |	jsr OutChar	;
      E7C4 A9 20      001546 |	lda #32d	;
      E7C6 20 F3 F3   001547 |	jsr OutChar	;
      E7C9 4C D1 E7   001548 |	jmp ChkEndAd	;
                      001549 |	
      E7CC            001550 |OutSpc *
      E7CC A9 20      001551 |	lda #32d	;Print a space between hex characters on dump screen.
      E7CE 20 F3 F3   001552 |	jsr OutChar	;
                      001553 |	
      E7D1            001554 |ChkEndAd *
      E7D1 AD 08 00   001555 |	lda PointerA	;Check pointer against end address holder.  Exit
      E7D4 CD 5C 00   001556 |	cmp EndAdd	; subroutine if the end address has been reached,
      E7D7 D0 08      001557 |	bne PointNxt	; increment pointer and dump the contents of 
      E7D9 AD 09 00   001558 |	lda PointerA+1d	; another memory location if not.
      E7DC CD 5D 00   001559 |	cmp EndAdd+1d	;
      E7DF F0 20      001560 |	beq ExitDump	;
      E7E1            001561 |PointNxt *
      E7E1 EE 08 00   001562 |	inc PointerA	;
      E7E4 D0 03      001563 |	bne NoCary2	;
      E7E6 EE 09 00   001564 |	inc PointerA+1d	;
      E7E9            001565 |NoCary2 *		;
                      001566 |
      E7E9            001567 |ChkCR *			;Perform end of dump line functions.
      E7E9 E0 10      001568 |	cpx #16d	;
      E7EB D0 0F      001569 |	bne NotEnd	;
                      001570 |	
      E7ED A9 0A      001571 |	lda #10d	;Print a CRLF and reset X register to point to
      E7EF 20 F3 F3   001572 |	jsr OutChar	; beginning of new dump line.
      E7F2 A9 0D      001573 |	lda #13d	;
      E7F4 20 F3 F3   001574 |	jsr Outchar	;
      E7F7 20 05 F3   001575 |	jsr PrntAdd	;
      E7FA A2 00      001576 |	ldx #0d		;
      E7FC            001577 |NotEnd *
                      001578 |	
      E7FC 4C A6 E7   001579 |	jmp DumpAgin	;
                      001580 |
      E7FF            001581 |ErrDump *
      E7FF 18         001582 |	clc
      E800 60         001583 |	rts
                      001584 |
      E801            001585 |ExitDump *
      E801 EE 08 00   001586 |	inc PointerA	;Point to next location in memory to be dumped
      E804 D0 03      001587 |	bne NoCary3	;
      E806 EE 09 00   001588 |	inc PointerA+1d	;
      E809            001589 |NoCary3 *		;
      E809 38         001590 |	sec
      E80A 60         001591 |	rts
                      001592 |
                      001593 |;****************************************************************************
                      001594 |;                 Output the ASCII interpretation of the dumped line.
                      001595 |;****************************************************************************
      E80B            001596 |DumpASC *
      E80B A9 20      001597 |	lda #32d	;
      E80D 20 F3 F3   001598 |	jsr OutChar	;
      E810 A9 20      001599 |	lda #32d	;
      E812 20 F3 F3   001600 |	jsr OutChar	;
      E815 A2 00      001601 |	ldx #0d		;
      E817            001602 |OutAsc *
      E817 BD 4C 00   001603 |	lda ASCIIbuf,x	;
      E81A 20 F3 F3   001604 |	jsr OutChar	;
      E81D E8         001605 |	inx		;
      E81E E0 10      001606 |	cpx #16d	;
      E820 D0 F5      001607 |	bne OutAsc	;
      E822 60         001608 |	rts
                      001609 |
                      001610 |
                      001611 |;****************************************************************************
                      001612 |;         Put byte from memory into ASCII buffer from Dump command.
                      001613 |;****************************************************************************
      E823            001614 |PutASCBf *
      E823 48         001615 |	pha
      E824 C9 20      001616 |	cmp #32d
      E826 30 0A      001617 |	bmi Period
      E828 C9 7F      001618 |	cmp #127d
      E82A 10 06      001619 |	bpl Period
      E82C 9D 4C 00   001620 |	sta ASCIIbuf,x
      E82F 4C 37 E8   001621 |	jmp ExitPut
      E832            001622 |Period *
      E832 A9 2E      001623 |	lda #46d
      E834 9D 4C 00   001624 |	sta ASCIIbuf,x
      E837            001625 |ExitPut *
      E837 68         001626 |	pla
      E838 60         001627 |	rts
                      001628 |	
                      001629 |;****************************************************************************
                      001630 |;                        Enter Command Subroutine.
                      001631 |;****************************************************************************
      E839            001632 |Enter *
      E839 AD 5F 00   001633 |	lda OpFld1	;Check for operand in operand field #1.
      E83C C9 00      001634 |	cmp #0d		;
      E83E D0 03      001635 |	bne ChkOp2	;
      E840 4C 67 E8   001636 |	jmp ErrEntr	;
                      001637 |	
      E843            001638 |ChkOp2 *
      E843 AD 73 00   001639 |	lda OpFld2	;Check for operand in operand field #2.
      E846 C9 00      001640 |	cmp #0d		;
      E848 D0 03      001641 |	bne ProcEntr	;
      E84A 4C 67 E8   001642 |	jmp ErrEntr	;
                      001643 |	
      E84D            001644 |ProcEntr *
      E84D A2 00      001645 |	ldx #0d		;Get address from operand field #1.
      E84F 20 C3 F2   001646 |	jsr GetAdd	;
      E852 B0 03      001647 |	bcs EnAddOk	;
      E854 4C 67 E8   001648 |	jmp ErrEntr	;
                      001649 |
      E857            001650 |EnAddOk *
      E857 8E 08 00   001651 |	stx PointerA	;Put address from operand field #1 into
      E85A 8C 09 00   001652 |	sty PointerA+1d	; zero page variable Pointer.
                      001653 |	
      E85D A2 14      001654 |	ldx #20d	;Get list of bytes to be entered into memory
      E85F 20 6B E8   001655 |	jsr GetList	; from operand field #2 and put them in memory
      E862 90 03      001656 |	bcc ErrEntr	; starting at Pointer.
      E864 4C 69 E8   001657 |	jmp ExitEntr	;
                      001658 |	
      E867            001659 |ErrEntr *
      E867 18         001660 |	clc
      E868 60         001661 |	rts	
                      001662 |
      E869            001663 |ExitEntr *
      E869 38         001664 |	sec
      E86A 60         001665 |	rts
                      001666 |
                      001667 |
                      001668 |;****************************************************************************
                      001669 |;                        Get List Subroutine
                      001670 |;
                      001671 |;	Zero page variable Pointer points to location in memory where
                      001672 |;	 list members will be placed.
                      001673 |;****************************************************************************
      E86B            001674 |GetList *
      E86B A0 00      001675 |	ldy #0d
                      001676 |	
      E86D 8C CF 00   001677 |	sty DataTemp	;Use this variable to count bytes in list.	
                      001678 |	
      E870            001679 |GLNxtByt *
      E870 BD 5F 00   001680 |	lda OpFld1,x	;Check for NULL that terminates current
      E873 F0 28      001681 |	beq ListErr	; operand field.
                      001682 |	
      E875 20 1C F3   001683 |	jsr AsToBin	;Convert byte in list to binary form and place
      E878 B0 03      001684 |	bcs StInMem	; in memory.
      E87A 4C 9D E8   001685 |	jmp ListErr	;
      E87D            001686 |StInMem *		;
      E87D 91 08      001687 |	sta (PointerA),y;
      E87F EE 08 00   001688 |	inc PointerA	;
      E882 D0 03      001689 |	bne LstNoOv	;
      E884 EE 09 00   001690 |	inc PointerA+1d	;
      E887            001691 |LstNoOv *		;
      E887 EE CF 00   001692 |	inc DataTemp	;
      E88A AD CF 00   001693 |	lda DataTemp	;
      E88D C9 0A      001694 |	cmp #10d	;
      E88F F0 0A      001695 |	beq ExtGtLst	;
                      001696 |	
      E891 E8         001697 |	inx		;Point to comma between bytes.
                      001698 |
      E892 BD 5F 00   001699 |	lda OpFld1,x	;Check for NULL that terminates current
      E895 F0 04      001700 |	beq ExtGtLst	; operand field.
                      001701 |	
      E897 E8         001702 |	inx		;Point to next byte in list.
                      001703 |	
      E898 4C 70 E8   001704 |	jmp GLNxtByt	;
                      001705 |	
      E89B            001706 |ExtGtLst *
      E89B 38         001707 |	sec
      E89C 60         001708 |	rts
                      001709 |
      E89D            001710 |ListErr *
      E89D 18         001711 |	clc
      E89E 60         001712 |	rts
                      001713 |
                      001714 |;****************************************************************************
                      001715 |;                        Fill Command Subroutine.
                      001716 |;****************************************************************************
      E89F            001717 |Fill *
                      001718 |
      E89F A2 00      001719 |	ldx #0d		;Get start address.
      E8A1 20 C3 F2   001720 |	jsr GetAdd	;
      E8A4 B0 03      001721 |	bcs FAdd1ok	;
      E8A6 4C DC E8   001722 |	jmp ErrFill	;
      E8A9            001723 |FAdd1ok *		;
      E8A9 8E 08 00   001724 |	stx PointerA	;
      E8AC 8C 09 00   001725 |	sty PointerA+1d	;
                      001726 |	
      E8AF A2 14      001727 |	ldx #20d	;Get end address.
      E8B1 20 C3 F2   001728 |	jsr GetAdd	;
      E8B4 B0 03      001729 |	bcs FAdd2ok	;
      E8B6 4C DC E8   001730 |	jmp ErrFill	;
      E8B9            001731 |FAdd2ok *		;
      E8B9 8E 5C 00   001732 |	stx EndAdd	;
      E8BC 8C 5D 00   001733 |	sty EndAdd+1d	;
                      001734 |	
      E8BF            001735 |FillAgin *
      E8BF A2 28      001736 |	ldx #40d	;Get list and place in memory.
      E8C1 20 6B E8   001737 |	jsr GetList	;
      E8C4 90 16      001738 |	bcc ErrFill	;
                      001739 |
      E8C6 AD 5D 00   001740 |	lda EndAdd+1d	;Check to see if end address has been reached.
      E8C9 CD 09 00   001741 |	cmp PointerA+1d	;
      E8CC F0 03      001742 |	beq ChkFLSB	;
                      001743 |;	bmi ExitFill 	;
      E8CE 4C BF E8   001744 |	jmp FillAgin 	;
      E8D1            001745 |ChkFLSB *
      E8D1 AD 5C 00   001746 |	lda EndAdd	; 
      E8D4 CD 08 00   001747 |	cmp PointerA	;
      E8D7 F0 05      001748 |	beq ExitFill	;
                      001749 |	
      E8D9 4C BF E8   001750 |	jmp  FillAgin	;
                      001751 |	
                      001752 |
      E8DC            001753 |ErrFill *
      E8DC 18         001754 |	clc
      E8DD 60         001755 |	rts
                      001756 |
      E8DE            001757 |ExitFill *
      E8DE 38         001758 |	sec
      E8DF 60         001759 |	rts
                      001760 |
                      001761 |;****************************************************************************
                      001762 |;                        Go Command Subroutine
                      001763 |;****************************************************************************
      E8E0            001764 |Go *
                      001765 |
      E8E0 AD 5F 00   001766 |	lda OpFld1	;Check for operand.
      E8E3 C9 00      001767 |	cmp #0d		;
      E8E5 F0 10      001768 |	beq CurentPC	;
                      001769 |			
      E8E7 A2 00      001770 |	ldx #0d		;Get address from operand field #1.
      E8E9 20 C3 F2   001771 |	jsr GetAdd	;
      E8EC B0 03      001772 |	bcs GAddOk	;
      E8EE 4C 5D E9   001773 |	jmp ErrGo	;
                      001774 |	
      E8F1            001775 |GAddOk *		;
      E8F1 8E 45 00   001776 |	stx UPgmCntr	;
      E8F4 8C 46 00   001777 |	sty UPgmCntr+1d	;
                      001778 |
      E8F7            001779 |CurentPC *
      E8F7 AE 45 00   001780 |	ldx UPgmCntr	;
      E8FA 8E 2B 00   001781 |	stx TempAdd	;
      E8FD AC 46 00   001782 |	ldy UPgmCntr+1d	;
      E900 8C 2C 00   001783 |	sty TempAdd+1d	;
      E903 A0 03      001784 |	ldy #3d		;Check to make sure that breakpoint address has
      E905 A2 06      001785 |	ldx #6d		; not already been entered into table.
      E907            001786 |CkBPAddG *		;
      E907 B9 2F 00   001787 |	lda BrkPt1St,y	;
      E90A C9 00      001788 |	cmp #0d		;
      E90C F0 05      001789 |	beq NoCmpG	;
      E90E 20 F4 E6   001790 |	jsr CmpBPAdd	;
      E911 B0 08      001791 |	bcs MaError	;
      E913            001792 |NoCmpG *		;
      E913 88         001793 |	dey		;
      E914 CA         001794 |	dex		;
      E915 CA         001795 |	dex		;
      E916 10 EF      001796 |	bpl CkBPAddG	;
      E918 4C 25 E9   001797 |	jmp NoMatchG	;
                      001798 |
      E91B            001799 |MaError *
      E91B A2 DD      001800 |	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
      E91D A0 F5      001801 |	ldy #GoBPErrM>	; error message and exit.
      E91F 20 92 F3   001802 |	jsr PrntMess	;
      E922 4C 5F E9   001803 |	jmp ExitGo	;
                      001804 |
      E925            001805 |NoMatchG *
      E925 A0 03      001806 |	ldy #3d		;Check all active breakpoints in table, save
      E927 A2 06      001807 |	ldx #6d		; the opcodes of the breakpointed addresses, 
      E929            001808 |CkBPSt *		;
      E929 B9 2F 00   001809 |	lda BrkPt1St,y	; and replace them with BRKs.
      E92C C9 01      001810 |	cmp #1d		;
      E92E D0 09      001811 |	bne NxtBPSt	;
      E930 A1 12      001812 |	lda (BrkPt1Ad,x);
      E932 99 33 00   001813 |	sta BP1OpHld,y	;
      E935 A9 00      001814 |	lda #0d		;
      E937 81 12      001815 |	sta (BrkPt1Ad,x);
      E939            001816 |NxtBPSt *		;
      E939 88         001817 |	dey		;
      E93A CA         001818 |	dex		;
      E93B CA         001819 |	dex		;
      E93C 10 EB      001820 |	bpl CkBPSt	;
                      001821 |
      E93E 68         001822 |	pla		;Remove Go command's return address and the check
      E93F 68         001823 |	pla		; command's return address from the stack.
      E940 68         001824 |	pla		;
      E941 68         001825 |	pla		;
                      001826 |    
      E942 AD 5F 00   001827 |    lda OpFld1	;Check for operand.
      E945 C9 00      001828 |	cmp #0d		;
      E947 F0 11      001829 |	beq DoNotRestoreRegistersGo
                      001830 | 
      E949 A2 FF      001831 |    ldx #0ffh    ;Restore user's registers.
      E94B 9A         001832 |    txs          ;
      E94C AD 4B 00   001833 |    lda UStatReg ;
      E94F 48         001834 |	pha          ;
      E950 AD 47 00   001835 |	lda UAccum	 ;
      E953 AE 48 00   001836 |	ldx UXReg	 ;
      E956 AC 49 00   001837 |	ldy UYReg	 ;
      E959 28         001838 |    plp          ;
                      001839 |   
      E95A            001840 |DoNotRestoreRegistersGo *
                      001841 |	
      E95A 6C 45 00   001842 |	jmp (UPgmCntr)	;Start executing at address being pointed to by
                      001843 |			; UPGmCntr.	
                      001844 |
      E95D            001845 |ErrGo *
      E95D 18         001846 |	clc
      E95E 60         001847 |	rts
                      001848 |	
      E95F            001849 |ExitGo *
      E95F 38         001850 |	sec
      E960 60         001851 |	rts
                      001852 |
                      001853 |;****************************************************************************
                      001854 |;                       Help Command Subroutine.
                      001855 |;****************************************************************************
      E961            001856 |Help *
      E961 A2 23      001857 |	ldx #HelpMess<
      E963 A0 F6      001858 |	ldy #HelpMess>
      E965 20 92 F3   001859 |	jsr PrntMess
      E968 60         001860 |	rts
                      001861 |
                      001862 |;****************************************************************************
                      001863 |;                     Load Command Subroutine
                      001864 |;****************************************************************************
      E969            001865 |LdSRecs *
      E969 A2 AB      001866 |	ldx #SRecStMs<
      E96B A0 F4      001867 |	ldy #SRecStMs>	
      E96D 20 92 F3   001868 |	jsr PrntMess
                      001869 |	
      E970 20 D2 F3   001870 |	jsr GetCharW	;Wait for first character of record.
      E973 A2 A8      001871 |	ldx #CRLF<	;
      E975 A0 F4      001872 |	ldy #CRLF>	;
      E977 20 92 F3   001873 |	jsr PrntMess	;
      E97A 4C 80 E9   001874 |	jmp CkS		;
                      001875 |	
      E97D            001876 |GtAnCh *		;
      E97D 20 D2 F3   001877 |	jsr GetCharW	;Check for an S.
      E980            001878 |CkS *			;
      E980 C9 53      001879 |	cmp #83d	;
      E982 D0 F9      001880 |	bne GtAnCh	;
                      001881 |	
      E984 20 F3 F3   001882 |	jsr OutChar	;Print an S to the user.
                      001883 |	
      E987 20 D2 F3   001884 |	jsr GetCharW	;Get record type ECHO it and store it.
      E98A 20 F3 F3   001885 |	jsr OutChar	;
      E98D 8D A1 00   001886 |	sta RecType	;
                      001887 |	
      E990 C9 30      001888 |	cmp #48d	;Check for header record and process.
      E992 D0 08      001889 |	bne NtHdr	;
      E994 20 95 EA   001890 |	jsr ProcHdr	;
      E997 90 25      001891 |	bcc SError	;
      E999 4C BB E9   001892 |	jmp NextLine	;
                      001893 |	
      E99C            001894 |NtHdr *			;
      E99C C9 31      001895 |	cmp #49d	;Check for code record and process.
      E99E D0 08      001896 |	bne NtCd	;
      E9A0 20 9F EA   001897 |	jsr ProcCode	;
      E9A3 90 19      001898 |	bcc SError	;
      E9A5 4C BB E9   001899 |	jmp NextLine	;
                      001900 |	
      E9A8            001901 |NtCd *			;
      E9A8 C9 39      001902 |	cmp #57d	;Check for termination record process, and print
      E9AA D0 12      001903 |	bne SError	; records loaded message.
      E9AC 20 A9 EA   001904 |	jsr ProcTerm	;
      E9AF 90 0D      001905 |	bcc SError	;
      E9B1 A2 F4      001906 |	ldx #SRecEnMs<	;
      E9B3 A0 F4      001907 |	ldy #SRecEnMs>	;
      E9B5 20 92 F3   001908 |	jsr PrntMess	;
      E9B8 4C C7 E9   001909 |	jmp ExitSRec	;
                      001910 |	
      E9BB            001911 |NextLine *
      E9BB 4C 7D E9   001912 |	jmp GtAnCh
                      001913 |
      E9BE            001914 |SError *
      E9BE A2 D4      001915 |	ldx #SRecErMe<
      E9C0 A0 F4      001916 |	ldy #SRecErMe>	
      E9C2 20 92 F3   001917 |	jsr PrntMess
      E9C5 38         001918 |	sec
      E9C6 60         001919 |	rts
                      001920 |	
      E9C7            001921 |ExitSRec *
      E9C7 20 D2 F3   001922 |	jsr GetCharW
      E9CA 38         001923 |	sec
      E9CB 60         001924 |	rts
                      001925 |	
                      001926 |;****************************************************************************
                      001927 |;                Process Record Length and Address Subroutine
                      001928 |;****************************************************************************
      E9CC            001929 |PrRLeAdd *	
                      001930 |	
      E9CC A9 00      001931 |	lda #0h		;Zero out Checksum accumulator.
      E9CE 8D 9F 00   001932 |	sta CkSumAc	;
      E9D1 8D A0 00   001933 |	sta CkSumAc+1h	;
                      001934 |	
      E9D4 20 3C EA   001935 |	jsr Getnum	;Fetch record length and update checksum
      E9D7 8D 9E 00   001936 |	sta RecLen	; accumulator.
      E9DA 20 63 EA   001937 |	jsr AccCkSum	;
                      001938 |	
      E9DD AA         001939 |	tax		;Adjust code byte counter and store it.
      E9DE CA         001940 |	dex		;
      E9DF CA         001941 |	dex		;
      E9E0 CA         001942 |	dex		;
      E9E1 8A         001943 |	txa		;
      E9E2 8D 9B 00   001944 |	sta CodeCntr	;
                      001945 |	
      E9E5 20 3C EA   001946 |	jsr GetNum	;Get most significant byte of address and
      E9E8 8D 09 00   001947 |	sta PointerA+1h	; store it.
      E9EB 20 63 EA   001948 |	jsr AccCkSum	;
                      001949 |	
      E9EE 20 3C EA   001950 |	jsr GetNum	;Get least significant byte of address and
      E9F1 8D 08 00   001951 |	sta PointerA	; store it.
      E9F4 20 63 EA   001952 |	jsr AccCkSum	;
                      001953 |	
      E9F7 60         001954 |	rts
                      001955 |	
                      001956 |;****************************************************************************
                      001957 |;        Get Code Byte Without Loading into Memory Subroutine.
                      001958 |;****************************************************************************
      E9F8            001959 |GtCodNld *
                      001960 |	
      E9F8 AD 9B 00   001961 |	lda CodeCntr
      E9FB F0 0B      001962 |	beq ExitNld
                      001963 |	
      E9FD            001964 |GetOneNl *
      E9FD 20 3C EA   001965 |	jsr GetNum
      EA00 20 63 EA   001966 |	jsr AccCkSum
      EA03 CE 9B 00   001967 |	dec CodeCntr
      EA06 D0 F5      001968 |	Bne GetOneNl
                      001969 |	
      EA08            001970 |ExitNld *
      EA08 60         001971 |	rts
                      001972 |
                      001973 |;****************************************************************************
                      001974 |;        Get Code Byte and Load it into Memory Subroutine.
                      001975 |;****************************************************************************
      EA09            001976 |GtCodLd *
                      001977 |
      EA09 AD 9B 00   001978 |	lda CodeCntr
      EA0C F0 17      001979 |	beq ExitLd
                      001980 |	
      EA0E A0 00      001981 |	ldy #0h
      EA10            001982 |GtOneLd *
      EA10 20 3C EA   001983 |	jsr GetNum
      EA13 20 63 EA   001984 |	jsr AccCkSum
      EA16 91 08      001985 |	sta (PointerA),y	
      EA18 EE 08 00   001986 |	inc PointerA
      EA1B D0 03      001987 |	bne NxtCode
      EA1D EE 09 00   001988 |	inc PointerA+1h
      EA20            001989 |NxtCode *
      EA20 CE 9B 00   001990 |	dec CodeCntr
      EA23 D0 EB      001991 |	bne GtOneld
                      001992 |	
      EA25            001993 |ExitLd *
      EA25 60         001994 |	rts
                      001995 |
                      001996 |;****************************************************************************
                      001997 |;                      Check Checksum Subroutine.
                      001998 |;****************************************************************************
      EA26            001999 |ChkChkSm *
                      002000 |
      EA26 AD 9F 00   002001 |	lda CkSumAc	;Invert lowest byte of the checksum accumulator
      EA29 49 FF      002002 |	eor #0ffh	; and store it in CkhSum.
      EA2B 8D 9D 00   002003 |	sta ChkSum	;
                      002004 |	
      EA2E 20 3C EA   002005 |	jsr GetNum	;Compare calculated checksum against S record	
      EA31 CD 9D 00   002006 |	cmp ChkSum	; checksum.
      EA34 F0 04      002007 |	beq CkSumOK	;
      EA36 18         002008 |	clc
      EA37 4C 3B EA   002009 |	jmp Chkexit
      EA3A            002010 |CkSumOK *
      EA3A 38         002011 |	sec
      EA3B            002012 |Chkexit *
      EA3B 60         002013 |	rts
                      002014 |
                      002015 |;****************************************************************************
                      002016 |;                       Get Number Subroutine.
                      002017 |;****************************************************************************
      EA3C            002018 |GetNum *
      EA3C 98         002019 |	tya
      EA3D 48         002020 |	pha
                      002021 |
      EA3E 20 D2 F3   002022 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA41 20 72 EA   002023 |	jsr DgtToBin	; and position hex digit in most significat nibble
      EA44 90 1C      002024 |	bcc ExtGtNum	;
      EA46 0A         002025 |	asl a		; of number.
      EA47 0A         002026 |	asl a		;
      EA48 0A         002027 |	asl a		;
      EA49 0A         002028 |	asl a		;
      EA4A 29 F0      002029 |	and #0f0h	;
      EA4C 8D 9C 00   002030 |	sta number	;
                      002031 |	
      EA4F 20 D2 F3   002032 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA52 20 72 EA   002033 |	jsr DgtToBin	; and position hex digit in least significant
      EA55 90 0B      002034 |	bcc ExtGtNum	;
      EA57 0D 9C 00   002035 |	ora number	; nibble of number.
      EA5A 8D 9C 00   002036 |	sta number	;
                      002037 |	
      EA5D 68         002038 |	pla
      EA5E A8         002039 |	tay
      EA5F AD 9C 00   002040 |	lda number
      EA62            002041 |ExtGtNum *
      EA62 60         002042 |	rts
                      002043 |
                      002044 |;****************************************************************************
                      002045 |;                    Accumulate Checksum Subroutine.
                      002046 |;****************************************************************************
      EA63            002047 |AccCkSum *
      EA63 48         002048 |	pha
      EA64 18         002049 |	clc
      EA65 6D 9F 00   002050 |	adc CkSumAc
      EA68 8D 9F 00   002051 |	sta CkSumAc
      EA6B 90 03      002052 |	bcc NoOvrFlo
      EA6D EE A0 00   002053 |	inc CkSumAc+1h
      EA70            002054 |NoOvrFlo *
      EA70 68         002055 |	pla
      EA71 60         002056 |	rts
                      002057 |
                      002058 |;****************************************************************************
                      002059 |;                ASCII Digit to Binary Number Subroutine.
                      002060 |;
                      002061 |;        Enter with register 'A' containing the number to convert.
                      002062 |;        If the number was valid return its binary conversion in the
                      002063 |;        A register.  If the number is not convertable then clear the
                      002064 |;        carry flag and return.
                      002065 |;****************************************************************************
      EA72            002066 |DgtToBin *
                      002067 |	
      EA72 8E CE 00   002068 |	stx RegTemp	;Save the character to convert.
                      002069 |	
      EA75 A2 00      002070 |	ldx #0h		
                      002071 |	
      EA77            002072 |AnothDgt *
      EA77 DD 32 F4   002073 |	cmp DgtTblUC,x	;Search through character table and try to find
      EA7A F0 13      002074 |	beq Match	; a match for the character present in the X
      EA7C DD 43 F4   002075 |	cmp DgtTblLC,x	; register.
      EA7F F0 0E      002076 |	beq Match	;
                      002077 |	
      EA81 E8         002078 |	inx		;If a match was not found then increment the
      EA82 E0 10      002079 |	cpx #16d	; table index register and check the next
      EA84 F0 03      002080 |	beq DgtError	; character.  If all the characters have been 
      EA86 4C 77 EA   002081 |	jmp AnothDgt	; checked then return with an error.
                      002082 |	
      EA89            002083 |DgtError *
      EA89 A9 00      002084 |	lda #0h
      EA8B 18         002085 |	clc
      EA8C 4C 94 EA   002086 |	jmp DgtExit
                      002087 |
      EA8F            002088 |Match *
      EA8F 8A         002089 |	txa
      EA90 38         002090 |	sec
                      002091 |	
      EA91 AE CE 00   002092 |	ldx RegTemp
      EA94 60         002093 |DgtExit	rts
                      002094 |	
                      002095 |;****************************************************************************
                      002096 |;                    Process Header Record Subroutine.
                      002097 |;****************************************************************************
                      002098 |
      EA95            002099 |ProcHdr *
                      002100 |
      EA95 20 CC E9   002101 |	jsr PrRLeAdd
      EA98 20 F8 E9   002102 |	jsr GtCodNld		
      EA9B 20 26 EA   002103 |	jsr ChkChkSm
                      002104 |	
      EA9E 60         002105 |	rts
                      002106 |
                      002107 |;****************************************************************************
                      002108 |;                     Process Code Record Subroutine
                      002109 |;****************************************************************************
      EA9F            002110 |ProcCode *
                      002111 |
      EA9F 20 CC E9   002112 |	jsr PrRLeAdd
      EAA2 20 09 EA   002113 |	jsr GtCodLd
      EAA5 20 26 EA   002114 |	jsr ChkChksm
                      002115 |	
      EAA8 60         002116 |	rts
                      002117 |
                      002118 |;****************************************************************************
                      002119 |;                     Process Termination Record Subroutine
                      002120 |;****************************************************************************
      EAA9            002121 |ProcTerm *
                      002122 |
      EAA9 20 CC E9   002123 |	jsr PrRLeAdd
      EAAC 20 F8 E9   002124 |	jsr GtCodNld	
      EAAF 20 26 EA   002125 |	jsr ChkChkSm
                      002126 |
      EAB2 60         002127 |	rts
                      002128 |
                      002129 |;****************************************************************************
                      002130 |;                       Move Command Subroutine.
                      002131 |;****************************************************************************
      EAB3            002132 |Move *
      EAB3 AD 5F 00   002133 |	lda OpFld1	;Check for operands.
      EAB6 C9 00      002134 |	cmp #0d		;
      EAB8 F0 07      002135 |	beq MOut	;
                      002136 |
      EABA A2 00      002137 |	ldx #0d		;Get start address.
      EABC 20 C3 F2   002138 |	jsr GetAdd	;
      EABF B0 03      002139 |	bcs MAdd1ok	;
      EAC1            002140 |MOut *			;
      EAC1 4C 1E EB   002141 |	jmp ExitMove	;
      EAC4            002142 |MAdd1ok *		;
      EAC4 8E 08 00   002143 |	stx PointerA	;
      EAC7 8C 09 00   002144 |	sty PointerA+1d	;
                      002145 |	
      EACA A2 14      002146 |	ldx #20d	;Get end address and increment by 1.
      EACC 20 C3 F2   002147 |	jsr GetAdd	;
      EACF B0 03      002148 |	bcs MAdd2ok	;
      EAD1 4C 1E EB   002149 |	jmp ExitMove	;
      EAD4            002150 |MAdd2ok *		;
      EAD4 8E 5C 00   002151 |	stx EndAdd	;
      EAD7 8C 5D 00   002152 |	sty EndAdd+1d	;
      EADA EE 5C 00   002153 |	inc EndAdd	;
      EADD D0 03      002154 |	bne MNOvFlo	;
      EADF EE 5D 00   002155 |	inc EndAdd+1d	;
                      002156 |	
      EAE2            002157 |MNOvFlo *		;
      EAE2 A2 28      002158 |	ldx #40d	;Get destination address.
      EAE4 20 C3 F2   002159 |	jsr GetAdd	;
      EAE7 B0 03      002160 |	bcs MAdd3ok	;
      EAE9 4C 1E EB   002161 |	jmp ExitMove	;
      EAEC            002162 |MAdd3ok *		;
      EAEC 8E 0A 00   002163 |	stx PointerB	;
      EAEF 8C 0B 00   002164 |	sty PointerB+1d	;
                      002165 |
      EAF2 A0 00      002166 |	ldy #0d		;Move bytes between start address and end address
      EAF4            002167 |MCont *			;to memory starting at destination address.
      EAF4 B1 08      002168 |	lda (PointerA),y; 
      EAF6 91 0A      002169 |	sta (PointerB),y;
      EAF8 EE 0A 00   002170 |	inc PointerB	;
      EAFB D0 03      002171 |	bne MNoOvf1	;
      EAFD EE 0B 00   002172 |	inc PointerB+1d	;
      EB00            002173 |MNoOvf1 *		;
      EB00 EE 08 00   002174 |	inc PointerA	;
      EB03 D0 03      002175 |	bne MNoOvf2	;
      EB05 EE 09 00   002176 |	inc PointerA+1d	;
      EB08            002177 |MNoOvf2 *		;
      EB08 AD 08 00   002178 |	lda PointerA	;
      EB0B CD 5C 00   002179 |	cmp EndAdd	;
      EB0E F0 03      002180 |	beq MCkMSB	;
      EB10 4C F4 EA   002181 |	jmp MCont	;
      EB13            002182 |MCkMSB *		;
      EB13 AD 09 00   002183 |	lda PointerA+1d	;
      EB16 CD 5D 00   002184 |	cmp EndAdd+1d	;
      EB19 F0 03      002185 |	beq ExitMove	;
      EB1B 4C F4 EA   002186 |	jmp MCont	;
                      002187 |	
      EB1E            002188 |ExitMove *
      EB1E 60         002189 |	rts
                      002190 |
                      002191 |
                      002192 |;****************************************************************************
                      002193 |;                     Register Command Subroutine
                      002194 |;****************************************************************************
      EB1F            002195 |Register *
      EB1F 48         002196 |	pha
      EB20 8A         002197 |	txa
      EB21 48         002198 |	pha
      EB22 98         002199 |	tya
      EB23 48         002200 |	pha
      EB24 08         002201 |	php
                      002202 |	
      EB25 AD 5F 00   002203 |	lda OpFld1	;Check for operand.
      EB28 C9 00      002204 |	cmp #0d		;
      EB2A F0 03      002205 |	beq GenReg	;
      EB2C 4C 97 EB   002206 |	jmp SpecReg	;
                      002207 |	
      EB2F            002208 |GenReg *		;
      EB2F A2 32      002209 |	ldx #RegMess<	;Output register headings.
      EB31 A0 F5      002210 |	ldy #RegMess>	;
      EB33 20 92 F3   002211 |	jsr PrntMess	;
                      002212 |	
      EB36 A0 03      002213 |	ldy #3d		;Output contents of user's program counter.
      EB38 20 E2 F2   002214 |	jsr OutSpace	;
      EB3B AD 46 00   002215 |	lda UPgmCntr+1d	;
      EB3E 20 3E F3   002216 |	jsr OutHex	;
      EB41 AD 45 00   002217 |	lda UPgmCntr	;
      EB44 20 3E F3   002218 |	jsr OutHex	;
                      002219 |	
      EB47 A0 09      002220 |	ldy #9d		;Output contents of user's accumulator.
      EB49 20 E2 F2   002221 |	jsr OutSpace	;
      EB4C AD 47 00   002222 |	lda UAccum	;
      EB4F 20 3E F3   002223 |	jsr OutHex	;
                      002224 |	
      EB52 A0 09      002225 |	ldy #9d		;Output contents of user's X register.
      EB54 20 E2 F2   002226 |	jsr OutSpace	;
      EB57 AD 48 00   002227 |	lda UXreg	;
      EB5A 20 3E F3   002228 |	jsr OutHex	;
                      002229 |	
      EB5D A0 08      002230 |	ldy #8d		;Output contents of user's Y register.
      EB5F 20 E2 F2   002231 |	jsr OutSpace	;
      EB62 AD 49 00   002232 |	lda UYReg	;
      EB65 20 3E F3   002233 |	jsr OutHex	;
                      002234 |	
      EB68 A0 08      002235 |	ldy #8d		;Output contents of user's Stack Pointer.
      EB6A 20 E2 F2   002236 |	jsr OutSpace	;
      EB6D AD 4A 00   002237 |	lda UStkPtr	;
      EB70 20 3E F3   002238 |	jsr OutHex	;
                      002239 |	
      EB73 A0 07      002240 |	ldy #7d		;Output contents of user's Status register.
      EB75 20 E2 F2   002241 |	jsr OutSpace	;
      EB78 AD 4B 00   002242 |	lda UStatReg	;
      EB7B A2 08      002243 |	ldx #8d		;
      EB7D            002244 |NextFlag *		;
      EB7D 2A         002245 |	rol a		;
      EB7E B0 0A      002246 |	bcs OutOne	;
      EB80            002247 |OutZero *		;
      EB80 48         002248 |	pha		;
      EB81 A9 30      002249 |	lda #30h	;
      EB83 20 F3 F3   002250 |	jsr OutChar	;
      EB86 68         002251 |	pla		;
      EB87 4C 91 EB   002252 |	jmp CkBtPos	;
      EB8A            002253 |OutOne *		;
      EB8A 48         002254 |	pha		;
      EB8B A9 31      002255 |	lda #31h	;
      EB8D 20 F3 F3   002256 |	jsr OutChar	;
      EB90 68         002257 |	pla		;
      EB91            002258 |CkBtPos *		;
      EB91 CA         002259 |	dex		;
      EB92 D0 E9      002260 |	bne NextFlag	;
      EB94 4C DC EC   002261 |	jmp ExitReg	;
                      002262 |	
                      002263 |	
      EB97            002264 |SpecReg *
      EB97 A9 0D      002265 |	lda #13d
      EB99 20 F3 F3   002266 |	jsr OutChar
      EB9C A9 0A      002267 |	lda #10d
      EB9E 20 F3 F3   002268 |	jsr OutChar
      EBA1 AD 5F 00   002269 |	lda OpFld1
      EBA4 20 ED F2   002270 |	jsr ToLower
                      002271 |
      EBA7            002272 |CkPCReg *		;
      EBA7 C9 70      002273 |	cmp #112d	;Get value for Program Counter from user.
      EBA9 D0 3C      002274 |	bne CkAReg	;
      EBAB AD 46 00   002275 |	lda UpgmCntr+1d	;
      EBAE 20 3E F3   002276 |	jsr OutHex	;
      EBB1 AD 45 00   002277 |	lda UpgmCntr	;
      EBB4 20 3E F3   002278 |	jsr OutHex	;
      EBB7 20 DA F2   002279 |	jsr OutColn	;
      EBBA 20 87 E0   002280 |	jsr GetLine	;
      EBBD 20 ED E0   002281 |	jsr ParseOpr	;
      EBC0 AD 5F 00   002282 |	lda OpFld1	;
      EBC3 C9 00      002283 |	cmp #0d		;
      EBC5 D0 03      002284 |	bne GetPC	;
      EBC7 4C DC EC   002285 |	jmp ExitReg	;
      EBCA A2 00      002286 |GetPC	ldx #0d		;
      EBCC 20 1C F3   002287 |	jsr AsToBin	;
      EBCF B0 03      002288 |	bcs PCMSBOK	;
      EBD1 4C DC EC   002289 |	jmp ExitReg	;
      EBD4 A8         002290 |PCMSBOK	tay		;
      EBD5 E8         002291 |	inx		;
      EBD6 20 1C F3   002292 |	jsr AsToBin	;
      EBD9 B0 03      002293 |	bcs PCLSBOK	;
      EBDB 4C DC EC   002294 |	jmp ExitReg	;
      EBDE 8D 45 00   002295 |PCLSBOK	sta UPgmCntr	;
      EBE1 8C 46 00   002296 |	sty UPgmCntr+1d	;
      EBE4 4C DC EC   002297 |	jmp ExitReg	;
                      002298 |	
      EBE7            002299 |CkAReg *		;Get value for Accumulator from user.
      EBE7 C9 61      002300 |	cmp #97d	;
      EBE9 D0 29      002301 |	bne CkXReg	;
      EBEB AD 47 00   002302 |	lda UAccum	;
      EBEE 20 3E F3   002303 |	jsr OutHex	;
      EBF1 20 DA F2   002304 |	jsr OutColn	;
      EBF4 20 87 E0   002305 |	jsr GetLine	;
      EBF7 20 ED E0   002306 |	jsr ParseOpr	;
      EBFA AD 5F 00   002307 |	lda OpFld1	;
      EBFD C9 00      002308 |	cmp #0d		;
      EBFF D0 03      002309 |	bne GetA	;
      EC01 4C DC EC   002310 |	jmp ExitReg	;
      EC04            002311 |GetA *			;
      EC04 A2 00      002312 |	ldx #0d		;
      EC06 20 1C F3   002313 |	jsr AsToBin	;
      EC09 B0 03      002314 |	bcs AOK		;
      EC0B 4C DC EC   002315 |	jmp ExitReg	;
      EC0E            002316 |AOK *			;
      EC0E 8D 47 00   002317 |	sta UAccum	;
      EC11 4C DC EC   002318 |	jmp ExitReg	;
                      002319 |	
      EC14            002320 |CkXReg *		;Get value for X register from user.
      EC14 C9 78      002321 |	cmp #120d	;
      EC16 D0 29      002322 |	bne CkYReg	;
      EC18 AD 48 00   002323 |	lda UXreg	;
      EC1B 20 3E F3   002324 |	jsr OutHex	;
      EC1E 20 DA F2   002325 |	jsr OutColn	;
      EC21 20 87 E0   002326 |	jsr GetLine	;
      EC24 20 ED E0   002327 |	jsr ParseOpr	;
      EC27 AD 5F 00   002328 |	lda OpFld1	;
      EC2A C9 00      002329 |	cmp #0d		;
      EC2C D0 03      002330 |	bne GetX	;
      EC2E 4C DC EC   002331 |	jmp ExitReg	;
      EC31            002332 |GetX *			;
      EC31 A2 00      002333 |	ldx #0d		;
      EC33 20 1C F3   002334 |	jsr AsToBin	;
      EC36 B0 03      002335 |	bcs XOK		;
      EC38 4C DC EC   002336 |	jmp ExitReg	;
      EC3B            002337 |XOK *			;
      EC3B 8D 48 00   002338 |	sta UXReg	;
      EC3E 4C DC EC   002339 |	jmp ExitReg	;
                      002340 |	
      EC41            002341 |CkYReg *		;Get value for Y register from user.
      EC41 C9 79      002342 |	cmp #121d	;
      EC43 D0 29      002343 |	bne CkForS	;
      EC45 AD 49 00   002344 |	lda UYReg	;
      EC48 20 3E F3   002345 |	jsr OutHex	;
      EC4B 20 DA F2   002346 |	jsr OutColn	;
      EC4E 20 87 E0   002347 |	jsr GetLine	;
      EC51 20 ED E0   002348 |	jsr ParseOpr	;
      EC54 AD 5F 00   002349 |	lda OpFld1	;
      EC57 C9 00      002350 |	cmp #0d		;
      EC59 D0 03      002351 |	bne GetY	;
      EC5B 4C DC EC   002352 |	jmp ExitReg	;
      EC5E            002353 |GetY *			;
      EC5E A2 00      002354 |	ldx #0d		;
      EC60 20 1C F3   002355 |	jsr AsToBin	;
      EC63 B0 03      002356 |	bcs YOK		;
      EC65 4C DC EC   002357 |	jmp ExitReg	;
      EC68            002358 |YOK *			;
      EC68 8D 49 00   002359 |	sta UYReg	;
      EC6B 4C DC EC   002360 |	jmp ExitReg	;
                      002361 |	
      EC6E            002362 |CkForS *		;Check if user is accessing the Stack Pointer or
      EC6E C9 73      002363 |	cmp #115d	; the Status Register.
      EC70 F0 03      002364 |	beq CkPorR	;
      EC72 4C D8 EC   002365 |	jmp RegInErr	;
      EC75            002366 |CkPorR *		;
      EC75 AD 60 00   002367 |	lda OpFld1+1d	;
      EC78 20 ED F2   002368 |	jsr ToLower	;
      EC7B C9 70      002369 |	cmp #112d	;
      EC7D F0 07      002370 |	beq CkSpReg	;
      EC7F C9 72      002371 |	cmp #114d	;
      EC81 F0 2C      002372 |	beq CkSRReg	;
      EC83 4C D8 EC   002373 |	jmp RegInErr	;
                      002374 |
      EC86            002375 |CkSpReg *		;
      EC86 AD 4A 00   002376 |	lda UStkPtr	;Get value for Stack Pointer from user.
      EC89 20 3E F3   002377 |	jsr OutHex	;
      EC8C 20 DA F2   002378 |	jsr OutColn	;
      EC8F 20 87 E0   002379 |	jsr GetLine	;
      EC92 20 ED E0   002380 |	jsr ParseOpr	;
      EC95 AD 5F 00   002381 |	lda OpFld1	;
      EC98 C9 00      002382 |	cmp #0d		;
      EC9A D0 03      002383 |	bne GetSP	;
      EC9C 4C DC EC   002384 |	jmp ExitReg	;
      EC9F            002385 |GetSP *			;
      EC9F A2 00      002386 |	ldx #0d		;
      ECA1 20 1C F3   002387 |	jsr AsToBin	;
      ECA4 B0 03      002388 |	bcs SPOK	;
      ECA6 4C DC EC   002389 |	jmp ExitReg	;
      ECA9            002390 |SPOK *			;
      ECA9 8D 4A 00   002391 |	sta UStkPtr	;
      ECAC 4C DC EC   002392 |	jmp ExitReg	;
                      002393 |	
      ECAF            002394 |CkSRReg *		;Get value for Status Register from user.
      ECAF AD 4B 00   002395 |	lda UStatReg	;
      ECB2 20 3E F3   002396 |	jsr OutHex	;
      ECB5 20 DA F2   002397 |	jsr OutColn	;
      ECB8 20 87 E0   002398 |	jsr GetLine	;
      ECBB 20 ED E0   002399 |	jsr ParseOpr	;
      ECBE AD 5F 00   002400 |	lda OpFld1	;
      ECC1 C9 00      002401 |	cmp #0d		;
      ECC3 D0 03      002402 |	bne GetSR	;
      ECC5 4C DC EC   002403 |	jmp ExitReg	;
      ECC8 A2 00      002404 |GetSR	ldx #0d		;
      ECCA 20 1C F3   002405 |	jsr AsToBin	;
      ECCD B0 03      002406 |	bcs SROK	;
      ECCF 4C DC EC   002407 |	jmp ExitReg	;
      ECD2 8D 4B 00   002408 |SROK	sta UStatReg	;
      ECD5 4C DC EC   002409 |	jmp ExitReg	;
                      002410 |
      ECD8            002411 |RegInErr *
      ECD8 18         002412 |	clc
      ECD9 4C DD EC   002413 |	jmp ErrRegOt
                      002414 |	
      ECDC            002415 |ExitReg *
      ECDC 38         002416 |	sec
      ECDD            002417 |ErrRegOt *
      ECDD 28         002418 |	plp
      ECDE 68         002419 |	pla
      ECDF A8         002420 |	tay
      ECE0 68         002421 |	pla
      ECE1 AA         002422 |	tax
      ECE2 68         002423 |	pla
      ECE3 60         002424 |	rts
                      002425 |
                      002426 |;****************************************************************************
                      002427 |;                       Search Command Subroutine.
                      002428 |;****************************************************************************
      ECE4            002429 |Search *
      ECE4 AD 5F 00   002430 |	lda OpFld1	;Check for operands.
      ECE7 C9 00      002431 |	cmp #0d		;
      ECE9 F0 07      002432 |	beq SOut	;
                      002433 |
      ECEB A2 00      002434 |	ldx #0d		;Get start address.
      ECED 20 C3 F2   002435 |	jsr GetAdd	;
      ECF0 B0 03      002436 |	bcs SAdd1ok	;
      ECF2            002437 |SOut *			;
      ECF2 4C 74 ED   002438 |	jmp ExitSrch	;
      ECF5            002439 |SAdd1ok	*		;
      ECF5 8E 0A 00   002440 |	stx PointerB	;
      ECF8 8C 0B 00   002441 |	sty PointerB+1d	;
                      002442 |	
      ECFB A2 14      002443 |	ldx #20d	;Get end address and increment by 1.
      ECFD 20 C3 F2   002444 |	jsr GetAdd	;
      ED00 B0 03      002445 |	bcs SAdd2ok	;
      ED02 4C 74 ED   002446 |	jmp ExitSrch	;
      ED05            002447 |SAdd2ok *		;
      ED05 8E 5C 00   002448 |	stx EndAdd	;
      ED08 8C 5D 00   002449 |	sty EndAdd+1d	;
      ED0B EE 5C 00   002450 |	inc EndAdd	;
      ED0E D0 03      002451 |	bne SNOvFlo	;
      ED10 EE 5D 00   002452 |	inc EndAdd+1d	;
                      002453 |	
      ED13            002454 |SNOvFlo	*		;
      ED13 A2 28      002455 |	ldx #40d	;Get search list from operand field #3 and store
      ED15 A9 20      002456 |	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
      ED17 8D 08 00   002457 |	sta PointerA	; SrchBtCt.
      ED1A A9 00      002458 |	lda #SrchTabl>	;
      ED1C 8D 09 00   002459 |	sta PointerA+1d	;
      ED1F 20 6B E8   002460 |	jsr GetList	;
      ED22 90 50      002461 |	bcc ExitSrch	;
      ED24 AD CF 00   002462 |	lda DataTemp	;
      ED27 8D 2A 00   002463 |	sta SrchBtCt	;
                      002464 |	
      ED2A AD 0A 00   002465 |	lda PointerB	;Transfer start address from pointer A to 
      ED2D 8D 08 00   002466 |	sta PointerA	; pointer B.  Output a CRLF.
      ED30 AD 0B 00   002467 |	lda PointerB+1d	;
      ED33 8D 09 00   002468 |	sta PointerA+1d	;
      ED36 A2 A8      002469 |	ldx #CRLF<	;
      ED38 A0 F4      002470 |	ldy #CRLF>	;
      ED3A 20 92 F3   002471 |	jsr PrntMess	;
                      002472 |	
      ED3D            002473 |SCkByte1 *		;Compare list with memory.
      ED3D A2 00      002474 |	ldx #0d		;
      ED3F A0 00      002475 |	ldy #0d		;
      ED41            002476 |SCkByte2 *		;
      ED41 B1 08      002477 |	lda (PointerA),y;
      ED43 DD 20 00   002478 |	cmp SrchTabl,x	;
      ED46 F0 19      002479 |	beq SMatch	;
                      002480 |	
      ED48            002481 |IncScPtr *
      ED48 20 BA F2   002482 |	jsr IncPntrA	;Increment memory pointer and check to see if
      ED4B AD 08 00   002483 |	lda PointerA	; the end address has been reached.
      ED4E CD 5C 00   002484 |	cmp EndAdd	;
      ED51 F0 03      002485 |	beq SckMSB	;
      ED53 4C 3D ED   002486 |	jmp SCkByte1	;
      ED56            002487 |SCkMSB *		;
      ED56 AD 09 00   002488 |	lda PointerA+1d	;
      ED59 CD 5D 00   002489 |	cmp EndAdd+1d	;
      ED5C F0 16      002490 |	beq ExitSrch	;
      ED5E 4C 3D ED   002491 |	jmp SCkByte1	;
                      002492 |	
      ED61            002493 |SMatch *		;
      ED61 C8         002494 |	iny		;Check to see if all bytes in search list match
      ED62 E8         002495 |	inx		; bytes in memory.
      ED63 EC 2A 00   002496 |	cpx SrchBtCt	;
      ED66 F0 03      002497 |	beq SFulMtch	;
      ED68 4C 41 ED   002498 |	jmp SCkByte2	;
                      002499 |
      ED6B            002500 |SFulMtch *		;
      ED6B 20 05 F3   002501 |	jsr PrntAdd	;Output address where match was found.
      ED6E 20 BA F2   002502 |	jsr IncPntrA	;
      ED71 4C 3D ED   002503 |	jmp SCkByte1	;
                      002504 |
      ED74            002505 |ExitSrch *
      ED74 60         002506 |	rts
                      002507 |
                      002508 |
                      002509 |
                      002510 |;****************************************************************************
                      002511 |;                       Trace Command Subroutine.
                      002512 |;****************************************************************************
      ED75            002513 |Trace *
                      002514 |
      ED75 AD 5F 00   002515 |	lda OpFld1	;Check for operands.
      ED78 C9 00      002516 |	cmp #0d		;
      ED7A F0 17      002517 |	beq TNoOper	;
                      002518 |	
      ED7C A2 00      002519 |	ldx #0d		;Get start address.
      ED7E 20 C3 F2   002520 |	jsr GetAdd	;
      ED81 B0 03      002521 |	bcs TAdd1ok	;
      ED83 4C 7C EF   002522 |	jmp ErrTrce	;
      ED86            002523 |TAdd1ok *		;
      ED86 8E 45 00   002524 |	stx UPgmCntr	;
      ED89 8C 46 00   002525 |	sty UPgmCntr+1d	;
                      002526 |	
      ED8C AD 73 00   002527 |	lda OpFld2	;Check to see if a trace count has been 
      ED8F C9 00      002528 |	cmp #0d		; specified.
      ED91 D0 08      002529 |	bne GtTrcCnt	;
                      002530 |
      ED93            002531 |TNoOper *
      ED93 A0 01      002532 |	ldy #1d		;Set trace count to 1.
      ED95 8C 3E 00   002533 |	sty TracCnt	;
      ED98 4C A8 ED   002534 |	jmp StartTrc	;
                      002535 |
      ED9B            002536 |GtTrcCnt *	
      ED9B A2 14      002537 |	ldx #20d	;Get trace count from user.
      ED9D 20 1C F3   002538 |	jsr AsToBin	;
      EDA0 B0 03      002539 |	bcs TrValOK	;
      EDA2 4C 7C EF   002540 |	jmp ErrTrce	;
      EDA5            002541 |TrValOK *		;
      EDA5 8D 3E 00   002542 |	sta TracCnt	;
                      002543 |	
      EDA8            002544 |StartTrc *
      EDA8 68         002545 |	pla		;Remove trace command's return address and
      EDA9 68         002546 |	pla		; the check command routine's return address from
      EDAA 68         002547 |	pla		; the stack.
      EDAB 68         002548 |	pla		;
                      002549 |
      EDAC            002550 |ContTrc *	
      EDAC AC 45 00   002551 |	ldy UPgmCntr	;Transfer user's program counter to pointer A.
      EDAF 8C 08 00   002552 |	sty PointerA	;
      EDB2 AC 46 00   002553 |	ldy UPgmCntr+1d	;
      EDB5 8C 09 00   002554 |	sty PointerA+1d	;
                      002555 |
      EDB8 A0 00      002556 |	ldy #0d		;Get opcode of current instruction.
      EDBA B1 08      002557 |	lda (PointerA),y;
      EDBC 8D 43 00   002558 |	sta OpCdHold	;
                      002559 |	
      EDBF 20 80 EF   002560 |	jsr ScanOpCd	;Check to see if byte from memory location was
      EDC2 B0 03      002561 |	bcs TOpCdFnd	; an opcode.
      EDC4 4C 7C EF   002562 |	jmp ErrTrce
                      002563 |
      EDC7            002564 |TOpCdFnd *
      EDC7 A0 08      002565 |	ldy #8d		;Get number of bytes in the current instruction
      EDC9 B1 0A      002566 |	lda (PointerB),y; information from opcode table.
      EDCB 8D 3A 00   002567 |	sta CurInsLn	;
                      002568 |	
      EDCE A0 01      002569 |	ldy #1d		;Get opcode of current instruction.
      EDD0 AD 43 00   002570 |	lda OpCdHold	;
                      002571 |
      EDD3            002572 |TrRTS *			;If the opcode is an RTS then copy the return
      EDD3 C9 60      002573 |	cmp #60h	; address from the stack, save the opcode to
      EDD5 D0 28      002574 |	bne TNxtOp0	; be returned to, and place a BRK at the return
      EDD7 A9 02      002575 |	lda #2d		; address.
      EDD9 8D 3D 00   002576 |	sta BrnchFlg	;
      EDDC 68         002577 |	pla		;
      EDDD 8D 10 00   002578 |	sta BOpAdPtr	;
      EDE0 68         002579 |	pla		;
      EDE1 8D 11 00   002580 |	sta BOpAdPtr+1d	;
      EDE4 48         002581 |	pha		;
      EDE5 AD 10 00   002582 |	lda BOpAdPtr	;
      EDE8 48         002583 |	pha		;
      EDE9 EE 10 00   002584 |	inc BOpAdPtr	;
      EDEC D0 03      002585 |	bne NNOvflo	;
      EDEE EE 11 00   002586 |	inc BOpAdPtr+1d	;
      EDF1            002587 |NNOvflo *		;
      EDF1 A0 00      002588 |	ldy #0d		;
      EDF3 B1 10      002589 |	lda (BOpAdPtr),y;
      EDF5 8D 3C 00   002590 |	sta BOpCdHld	;
      EDF8 A9 00      002591 |	lda #0d		;
      EDFA 91 10      002592 |	sta (BOpAdPtr),y;
      EDFC 4C 0B EF   002593 |	jmp ChBkVect	;
                      002594 |	
      EDFF            002595 |TNxtOp0 *		;
      EDFF C9 4C      002596 |	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
      EE01 D0 1E      002597 |	bne TNxtOp1	; then save the opcode of the instruction that
      EE03 A9 02      002598 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE05 8D 3D 00   002599 |	sta BrnchFlg	;
      EE08 B1 08      002600 |	lda (PointerA),y;
      EE0A 8D 10 00   002601 |	sta BOpAdPtr	;
      EE0D C8         002602 |	iny		;
      EE0E B1 08      002603 |	lda (PointerA),y;
      EE10 8D 11 00   002604 |	sta BOpAdPtr+1d	;
      EE13 A0 00      002605 |	ldy #0d		;
      EE15 B1 10      002606 |	lda (BOpAdPtr),y;
      EE17 8D 3C 00   002607 |	sta BOpCdHld	;
      EE1A A9 00      002608 |	lda #0d		;
      EE1C 91 10      002609 |	sta (BOpAdPtr),y;
      EE1E 4C 0B EF   002610 |	jmp ChBkVect	;
                      002611 |	
      EE21            002612 |TNxtOp1 *
      EE21 C9 6C      002613 |	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
      EE23 D0 2B      002614 |	bne TNxtOp2	; then save the opcode of the instruction that
      EE25 A9 02      002615 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE27 8D 3D 00   002616 |	sta BrnchFlg	;
      EE2A B1 08      002617 |	lda (PointerA),y;
      EE2C 8D 0C 00   002618 |	sta PointerC	;
      EE2F C8         002619 |	iny		;
      EE30 B1 08      002620 |	lda (PointerA),y;
      EE32 8D 0D 00   002621 |	sta PointerC+1d	;
      EE35 A0 00      002622 |	ldy #0d		;
      EE37 B1 0C      002623 |	lda (PointerC),y;
      EE39 8D 10 00   002624 |	sta BOpAdPtr	;
      EE3C C8         002625 |	iny		;
      EE3D B1 0C      002626 |	lda (PointerC),y;
      EE3F 8D 11 00   002627 |	sta BOpAdPtr+1d	;
      EE42 A0 00      002628 |	ldy #0d		;
      EE44 B1 10      002629 |	lda (BOpAdPtr),y;
      EE46 8D 3C 00   002630 |	sta BOpCdHld	;
      EE49 A9 00      002631 |	lda #0d		;
      EE4B 91 10      002632 |	sta (BOpAdPtr),y;
      EE4D 4C 0B EF   002633 |	jmp ChBkVect	;
                      002634 |		
                      002635 |	
      EE50            002636 |TNxtOp2 *
      EE50 C9 20      002637 |	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
      EE52 D0 1E      002638 |	bne TNxtOp3	; then save the opcode of the instruction that
      EE54 A9 02      002639 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE56 8D 3D 00   002640 |	sta BrnchFlg	;
      EE59 B1 08      002641 |	lda (PointerA),y;
      EE5B 8D 10 00   002642 |	sta BOpAdPtr	;
      EE5E C8         002643 |	iny		;
      EE5F B1 08      002644 |	lda (PointerA),y;
      EE61 8D 11 00   002645 |	sta BOpAdPtr+1d	;
      EE64 A0 00      002646 |	ldy #0d		;
      EE66 B1 10      002647 |	lda (BOpAdPtr),y;
      EE68 8D 3C 00   002648 |	sta BOpCdHld	;
      EE6B A9 00      002649 |	lda #0d		;
      EE6D 91 10      002650 |	sta (BOpAdPtr),y;
      EE6F 4C 0B EF   002651 |	jmp ChBkVect	;
                      002652 |	
      EE72            002653 |TNxtOp3 *
      EE72 A0 00      002654 |	ldy #0d		;Check to see if the current instruction is an
      EE74 B1 0A      002655 |	lda (PointerB),y; actual branch.
      EE76 C9 42      002656 |	cmp #'B'	;
      EE78 D0 08      002657 |	bne NoBrnch2	;
      EE7A A0 01      002658 |	ldy #1d		;
      EE7C B1 0A      002659 |	lda (PointerB),y;
      EE7E C9 49      002660 |	cmp #'I'	;
      EE80 D0 03      002661 |	bne Branch	;
      EE82            002662 |NoBrnch2 *		;
      EE82 4C E8 EE   002663 |	jmp NoBranch	;
                      002664 |	
      EE85            002665 |Branch *		;If the opcode is a branch, Bxx aaaa,
      EE85 A9 01      002666 |	lda #1d		; then save the opcode of the instruction that
      EE87 8D 3D 00   002667 |	sta BrnchFlg	; will be branched to and replace it with a BRK.
      EE8A 18         002668 |	clc		;
      EE8B AD 08 00   002669 |	lda PointerA	;
      EE8E 6D 3A 00   002670 |	adc CurInsLn	;
      EE91 8D 10 00   002671 |	sta BOpAdPtr	;
      EE94 AD 09 00   002672 |	lda PointerA+1d	;
      EE97 69 00      002673 |	adc #0d		;
      EE99 8D 11 00   002674 |	sta BOpAdPtr+1d	;
                      002675 |			;
      EE9C A0 01      002676 |	ldy #1d		;
      EE9E B1 08      002677 |	lda (PointerA),y;
      EEA0 8D 38 00   002678 |	sta BrValHld	;
      EEA3 10 20      002679 |	bpl AddAdd	;
      EEA5            002680 |SubAdd *		;
      EEA5 CE 38 00   002681 |	dec BrValHld	;
      EEA8 AD 38 00   002682 |	lda BrValHld	;
      EEAB 49 FF      002683 |	eor #0ffh	;
      EEAD 8D 38 00   002684 |	sta BrValHld	;
      EEB0 38         002685 |	sec		;
      EEB1 AD 10 00   002686 |	lda BOpAdPtr	;
      EEB4 ED 38 00   002687 |	sbc BrValHld	;
      EEB7 8D 10 00   002688 |	sta BOpAdPtr	;
      EEBA AD 11 00   002689 |	lda BOpAdPtr+1d	;
      EEBD E9 00      002690 |	sbc #0d		;
      EEBF 8D 11 00   002691 |	sta BOpAdPtr+1d	;
      EEC2 4C DA EE   002692 |	jmp GtBrOpCd	;
      EEC5            002693 |AddAdd *		;
      EEC5 18         002694 |	clc		;
      EEC6 AD 10 00   002695 |	lda BOpAdPtr	;
      EEC9 6D 38 00   002696 |	adc BrValHld	;
      EECC 8D 10 00   002697 |	sta BOpAdPtr	;
      EECF AD 11 00   002698 |	lda BOpAdPtr+1d	;
      EED2 69 00      002699 |	adc #0d		;
      EED4 8D 11 00   002700 |	sta BOpAdPtr+1d	;
      EED7 4C DA EE   002701 |	jmp GtBrOpCd	;
      EEDA            002702 |GtBrOpCd *		;
      EEDA A0 00      002703 |	ldy #0d		;
      EEDC B1 10      002704 |	lda (BOpAdPtr),y;
      EEDE 8D 3C 00   002705 |	sta BOpCdHld	;
      EEE1 A9 00      002706 |	lda #0d		;
      EEE3 91 10      002707 |	sta (BOpAdPtr),y;
      EEE5 4C ED EE   002708 |	jmp Both	;
                      002709 |	
      EEE8            002710 |NoBranch *
      EEE8 A9 00      002711 |	lda #0d		;Set branch flag to 0 to indicate the current
      EEEA 8D 3D 00   002712 |	sta BrnchFlg	; instruction is not a branch instruction.
                      002713 |
      EEED            002714 |Both *
      EEED AC 3A 00   002715 |	ldy CurInsLn	;
      EEF0 B1 08      002716 |	lda (PointerA),y;Save the opcode of the next instruction to be
      EEF2 8D 3B 00   002717 |	sta NOpCdHld	; executed if no branch is taken and replace it
                      002718 |			; with a BRK command.
      EEF5 18         002719 |	clc		;
      EEF6 AD 08 00   002720 |	lda PointerA	;
      EEF9 6D 3A 00   002721 |	adc CurInsLn	;
      EEFC 8D 0E 00   002722 |	sta NOpAdPtr	;
      EEFF AD 09 00   002723 |	lda PointerA+1d	;
      EF02 69 00      002724 |	adc #0d		;
      EF04 8D 0F 00   002725 |	sta NOpAdPtr+1d	;
      EF07 A9 00      002726 |	lda #0d		;
      EF09 91 08      002727 |	sta (PointerA),y;
                      002728 |	
      EF0B            002729 |ChBkVect *
      EF0B A9 01      002730 |	lda #1d		    ;Make BRK jump here instead of main.
      EF0D 8D 39 00   002731 |	sta TrBrkFlg	;
                      002732 |	
      EF10 AD 5F 00   002733 |    lda OpFld1	;Check to see if user entered address.
      EF13 C9 00      002734 |	cmp #0d		;
      EF15 F0 03      002735 |	beq DoNotRestoreStackPointer
      EF17 A2 FF      002736 |    ldx #0ffh    
      EF19 9A         002737 |    txs          ;
      EF1A            002738 |DoNotRestoreStackPointer *
                      002739 |
      EF1A AD 4B 00   002740 |	lda UStatReg	;Restore user's registers.
      EF1D 48         002741 |	pha		        ;
      EF1E AD 47 00   002742 |	lda UAccum	    ;
      EF21 AE 48 00   002743 |	ldx UXreg	    ;
      EF24 AC 49 00   002744 |	ldy UYReg	    ;
      EF27 28         002745 |	plp		        ;
                      002746 |    
      EF28 6C 45 00   002747 |	jmp (UPgmCntr)	;Jump to user's code.
                      002748 |	
      EF2B            002749 |Tr2ndEnt *
      EF2B A9 00      002750 |	lda #0d		;Reset trace break flag.
      EF2D 8D 39 00   002751 |	sta TrBrkFlg	;
                      002752 |	
      EF30            002753 |CkBrnch *		;
      EF30 A0 00      002754 |	ldy #0d		;Check to see which opcodes need to be restored.
      EF32 AD 3D 00   002755 |	lda BrnchFlg	;
      EF35 C9 00      002756 |	cmp #0d		;
      EF37 F0 11      002757 |	beq NoBrnch	;
      EF39 C9 01      002758 |	cmp #1d		;
      EF3B F0 08      002759 |	beq Brnch	;
                      002760 |	
      EF3D            002761 |DoJmp *
      EF3D AD 3C 00   002762 |	lda BOpCdHld	;Restore opcode to be jumped to.
      EF40 91 10      002763 |	sta (BOpAdPtr),y;
      EF42 4C 4F EF   002764 |	jmp UpDtPtrA	;
                      002765 |
      EF45            002766 |Brnch *
      EF45 AD 3C 00   002767 |	lda BOpCdHld	;Restore opcode to be branched to.
      EF48 91 10      002768 |	sta (BOpAdPtr),y;
                      002769 |	
      EF4A            002770 |NoBrnch *
      EF4A AD 3B 00   002771 |	lda NOpCdHld	;Restore opcode that will be executed next in
      EF4D 91 0E      002772 |	sta (NOpAdPtr),y; the instruction stream.
                      002773 |
      EF4F            002774 |UpDtPtrA *
      EF4F AC 45 00   002775 |	ldy UPgmCntr	;Set pointer A to point to the next instruction
      EF52 8C 08 00   002776 |	sty PointerA	; to be executed for unassemble.
      EF55 AC 46 00   002777 |	ldy UPgmCntr+1d	;
      EF58 8C 09 00   002778 |	sty PointerA+1d	;
                      002779 |	
      EF5B A2 A8      002780 |	ldx #CRLF<	;Unassemble next instruction in memory.
      EF5D A0 F4      002781 |	ldy #CRLF>	;
      EF5F 20 92 F3   002782 |	jsr PrntMess	;
      EF62 AD 08 00   002783 |	lda PointerA	;
      EF65 8D 5C 00   002784 |	sta EndAdd	;
      EF68 AD 09 00   002785 |	lda PointerA+1d	;
      EF6B 8D 5D 00   002786 |	sta EndAdd+1d	;
      EF6E 20 FF EF   002787 |	jsr StartUnA	;
                      002788 |	
      EF71            002789 |NxtIn *
      EF71 CE 3E 00   002790 |	dec TracCnt	;Decrement trace count and trace again if it
      EF74 F0 03      002791 |	beq OutTrce	; is not zero.
      EF76 4C AC ED   002792 |	jmp ContTrc	;
                      002793 |
      EF79            002794 |OutTrce *
      EF79 4C 74 E0   002795 |	jmp MainLoop	;Enter the main monitor loop using a jump
                      002796 |			; because the trace command's return address
                      002797 |			; and the check command routine's return address
                      002798 |			; were removed when a trace was initiated.
      EF7C            002799 |ErrTrce *
      EF7C 18         002800 |	clc
      EF7D 60         002801 |	rts	
                      002802 |
      EF7E            002803 |ExitTrce *
      EF7E 38         002804 |	sec
      EF7F 60         002805 |	rts	
                      002806 |
                      002807 |;****************************************************************************
                      002808 |;                       Scan for Valid Opcode Subroutine.
                      002809 |;****************************************************************************
      EF80            002810 |ScanOpCd *
                      002811 |	
      EF80 A2 25      002812 |	ldx #OpTable<	;Point pointer B to beginning of opcode table.
      EF82 8E 0A 00   002813 |	stx PointerB	;
      EF85 A2 F8      002814 |	ldx #OpTable>	;
      EF87 8E 0B 00   002815 |	stx PointerB+1d	;
                      002816 |	
      EF8A            002817 |CkTblEnd *
      EF8A A0 04      002818 |	ldy #4d		;Check for end of opcode table.
      EF8C B1 0A      002819 |	lda (PointerB),y;
      EF8E C9 5A      002820 |	cmp #90d	;
      EF90 F0 1C      002821 |	beq OpCdNtFd	;
                      002822 |	
      EF92            002823 |CkNxtOp *		;
      EF92 A0 07      002824 |	ldy #7d		;Check for an opcode match in the opcode table.
      EF94 B1 0A      002825 |	lda (PointerB),y;
      EF96 CD 43 00   002826 |	cmp OpCdHold	;
      EF99 F0 11      002827 |	beq OpCdFndS	;
                      002828 |	
      EF9B AD 0A 00   002829 |	lda PointerB	;Point pointer B to next entry in opcode table.
      EF9E 18         002830 |	clc		;
      EF9F 69 0A      002831 |	adc #10d	;
      EFA1 8D 0A 00   002832 |	sta PointerB	;
      EFA4 90 03      002833 |	bcc ScNoCary	;
      EFA6 EE 0B 00   002834 |	inc PointerB+1d	;
                      002835 |		
      EFA9            002836 |ScNoCary *
      EFA9 4C 8A EF   002837 |	jmp CkTblEnd
                      002838 |	
                      002839 |	
      EFAC            002840 |OpCdFndS *
      EFAC 38         002841 |	sec
      EFAD 60         002842 |	rts
                      002843 |	
      EFAE            002844 |OpCdNtFd *
      EFAE 18         002845 |	clc
      EFAF 60         002846 |	rts
                      002847 |	
                      002848 |;****************************************************************************
                      002849 |;                       Unassemble Command Subroutine.
                      002850 |;****************************************************************************
      EFB0            002851 |UnAssem *
      EFB0 AD 5F 00   002852 |	lda OpFld1	;Check for operands.
      EFB3 C9 00      002853 |	cmp #0d		;
      EFB5 F0 17      002854 |	beq UNoOper	;
                      002855 |
      EFB7 A2 00      002856 |	ldx #0d		;Get start address.
      EFB9 20 C3 F2   002857 |	jsr GetAdd	;
      EFBC B0 03      002858 |	bcs UAdd1ok	;
      EFBE 4C A4 F2   002859 |	jmp ErrUnAs	;
      EFC1            002860 |UAdd1ok *		;
      EFC1 8E 08 00   002861 |	stx PointerA	;
      EFC4 8C 09 00   002862 |	sty PointerA+1d	;
                      002863 |	
      EFC7 AD 73 00   002864 |	lda OpFld2	;Check to see if an end address has been 
      EFCA C9 00      002865 |	cmp #0d		; specified.
      EFCC D0 21      002866 |	bne GtUEndAd	;
                      002867 |	
      EFCE            002868 |UNoOper *
      EFCE AD 08 00   002869 |	lda PointerA	;
      EFD1 8D 5C 00   002870 |	sta EndAdd	;
      EFD4 AD 09 00   002871 |	lda PointerA+1d	;
      EFD7 8D 5D 00   002872 |	sta EndAdd+1d	;
      EFDA 18         002873 |	clc		;If no end address has been specified by the
      EFDB AD 08 00   002874 |	lda PointerA	; user then set the end address to start address
      EFDE 69 14      002875 |	adc #20d	; + 20d.
      EFE0 8D 5C 00   002876 |	sta EndAdd	;
      EFE3 90 07      002877 |	bcc UNoCary	;
      EFE5 AE 5D 00   002878 |	ldx EndAdd+1d	;
      EFE8 E8         002879 |	inx		;
      EFE9 8E 5D 00   002880 |	stx EndAdd+1d	;
      EFEC            002881 |UNoCary *		;
      EFEC 4C FF EF   002882 |	jmp StartUnA	;
                      002883 |	
      EFEF            002884 |GtUEndAd *
      EFEF A2 14      002885 |	ldx #20d	;Get end address.
      EFF1 20 C3 F2   002886 |	jsr GetAdd	;
      EFF4 B0 03      002887 |	bcs UAdd2ok	;
      EFF6 4C A4 F2   002888 |	jmp ErrUnAs	;
      EFF9            002889 |UAdd2ok *		;
      EFF9 8E 5C 00   002890 |	stx EndAdd	;
      EFFC 8C 5D 00   002891 |	sty EndAdd+1d	;
                      002892 |	
      EFFF            002893 |StartUnA *
      EFFF AD 5D 00   002894 |	lda EndAdd+1d	;Check to see if end address has been reached.
      F002 CD 09 00   002895 |	cmp PointerA+1d	;
      F005 F0 05      002896 |	beq UChkFLSB	;
      F007 90 0E      002897 |	bcc UOut	;
      F009 4C 1A F0   002898 |	jmp UNotFin 	;
      F00C            002899 |UChkFLSB *
      F00C AD 5C 00   002900 |	lda EndAdd	; 
      F00F CD 08 00   002901 |	cmp PointerA	;
      F012 90 03      002902 |	bcc UOut	;
      F014 4C 1A F0   002903 |	jmp UNotFin	;
      F017            002904 |UOut *			;
      F017 4C A6 F2   002905 |	jmp ExitUnAs	;
                      002906 |
      F01A            002907 |UNotFin *		;
      F01A A0 00      002908 |	ldy #0d		;Get opcode byte from memory and save.
      F01C B1 08      002909 |	lda (PointerA),y;
      F01E 8D 43 00   002910 |	sta OpCdHold	;
      F021 20 80 EF   002911 |	jsr ScanOpCd	;Check to see if byte from memory location was
      F024 B0 1D      002912 |	bcs OpCdFnd	; an opcode.
                      002913 |
      F026            002914 |NtOpCode *
      F026 A2 A8      002915 |	ldx #CRLF<	;Print start address of current instruction.
      F028 A0 F4      002916 |	ldy #CRLF>	;
      F02A 20 92 F3   002917 |	jsr PrntMess	;
      F02D 20 05 F3   002918 |	jsr PrntAdd	;
                      002919 |
      F030 AD 43 00   002920 |	lda OpCdHold	;Print the bad opcode.
      F033 20 3E F3   002921 |	jsr OutHex	;
                      002922 |	
      F036 A2 81      002923 |	ldx #BadOpMes<	;If byte was not an opcode then print question
      F038 A0 F5      002924 |	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
      F03A 20 92 F3   002925 |	jsr PrntMess	;
      F03D 20 BA F2   002926 |	jsr IncPntrA	;
      F040 4C FF EF   002927 |	jmp StartUnA	;
                      002928 |
      F043            002929 |OpCdFnd *
      F043 A2 A8      002930 |	ldx #CRLF<	;Print start address of current instruction.
      F045 A0 F4      002931 |	ldy #CRLF>	;
      F047 20 92 F3   002932 |	jsr PrntMess	;
      F04A 20 05 F3   002933 |	jsr PrntAdd	;
      F04D 20 BA F2   002934 |	jsr IncPntrA	;
                      002935 |
      F050            002936 |CkAdMode *
      F050 A0 06      002937 |	ldy #6d		;Get addressing mode indicator from table.
      F052 B1 0A      002938 |	lda (PointerB),y;
                      002939 |	
      F054            002940 |NxAdMo1 *		;
      F054 C9 50      002941 |	cmp #'P'	;Check for implied addressing mode.
      F056 D0 03      002942 |	bne NxAdMo2	;
      F058 4C 9D F0   002943 |	jmp ImpAdMo	;
                      002944 |	
      F05B            002945 |NxAdMo2 *		;
      F05B C9 4D      002946 |	cmp #'M'	;Check for immediate addressing mode.
      F05D D0 03      002947 |	bne NxAdMo3	;
      F05F 4C C4 F0   002948 |	jmp ImmAdMo	;	
                      002949 |
      F062            002950 |NxAdMo3 *		;
      F062 C9 53      002951 |	cmp #'S'	;Check for absolute addressing mode.
      F064 D0 03      002952 |	bne NxAdMo4	;
      F066 4C F7 F0   002953 |	jmp AbsxyAdM	;	
                      002954 |
      F069            002955 |NxAdMo4 *		;
      F069 C9 58      002956 |	cmp #'X'	;Check for absolute x addressing mode.
      F06B D0 03      002957 |	bne NxAdMo5	;
      F06D 4C F7 F0   002958 |	jmp AbsxyAdM	;
                      002959 |
      F070            002960 |NxAdMo5 *		;
      F070 C9 59      002961 |	cmp #'Y'	;Check for absolute y addressing mode.
      F072 D0 03      002962 |	bne NxAdMo6	;
      F074 4C F7 F0   002963 |	jmp AbsxyAdM	;
                      002964 |
      F077            002965 |NxAdMo6 *		;
      F077 C9 52      002966 |	cmp #'R'	;Check for indexed indirect addressing mode.
      F079 D0 03      002967 |	bne NxAdMo7	;
      F07B 4C 14 F2   002968 |	jmp IIRAdMo	;
                      002969 |
      F07E            002970 |NxAdMo7 *		;
      F07E C9 4C      002971 |	cmp #'L'	;Check for relative addressing mode.
      F080 D0 03      002972 |	bne NxAdMo8 	;
      F082 4C 61 F1   002973 |	jmp RelAdMo	;
                      002974 |
      F085            002975 |NxAdMo8 *		;
      F085 C9 43      002976 |	cmp #'C'	;Check for accumulator addressing mode.
      F087 D0 03      002977 |	bne NxAdMo9 	;
      F089 4C AE F0   002978 |	jmp AccAdMo	;
                      002979 |
      F08C            002980 |NxAdMo9 *		;
      F08C C9 44      002981 |	cmp #'D'	;Check for indirect addressing mode.
      F08E D0 03      002982 |	bne NxAdMo10 	;
      F090 4C 56 F2   002983 |	jmp IndAdMo	;
                      002984 |
      F093            002985 |NxAdMo10 *
      F093 C9 49      002986 |	cmp #'I'	;Check for indirect indexed addressing mode.
      F095 D0 03      002987 |	bne BdOpCd	;
      F097 4C D2 F1   002988 |	jmp IRIAdMo	;
                      002989 |
      F09A            002990 |BdOpCd *		;
      F09A 4C 26 F0   002991 |	jmp NtOpCode	;
                      002992 |
                      002993 |
      F09D            002994 |ImpAdMo *
      F09D AD 43 00   002995 |	lda OpCdHold	;Print the opcode.
      F0A0 20 3E F3   002996 |	jsr OutHex	;
                      002997 |	
      F0A3 A0 08      002998 |	ldy #8d		;Print spaces between object code field and
      F0A5 20 E2 F2   002999 |	jsr OutSpace	; operator field.
                      003000 |		
      F0A8 20 A8 F2   003001 |	jsr PrntMnem	;Print the operator.
                      003002 |	
      F0AB 4C FF EF   003003 |	jmp StartUnA
                      003004 |
      F0AE            003005 |AccAdMo *
      F0AE AD 43 00   003006 |	lda OpCdHold	;Print the opcode.
      F0B1 20 3E F3   003007 |	jsr OutHex	;
                      003008 |	
      F0B4 A0 08      003009 |	ldy #8d		;Print spaces between object code field and
      F0B6 20 E2 F2   003010 |	jsr OutSpace	; operator field.
                      003011 |		
      F0B9 20 A8 F2   003012 |	jsr PrntMnem	;Print the operator.
                      003013 |	
      F0BC A9 41      003014 |	lda #65d	;Print a capital A for accumulator addressing.
      F0BE 20 F3 F3   003015 |	jsr OutChar	;
                      003016 |	
      F0C1 4C FF EF   003017 |	jmp StartUnA
                      003018 |
                      003019 |
      F0C4            003020 |ImmAdMo *
      F0C4 A0 00      003021 |	ldy #0d
                      003022 |
      F0C6 AD 43 00   003023 |	lda OpCdHold	;Print the opcode and a space.
      F0C9 20 3E F3   003024 |	jsr OutHex	;
      F0CC A9 20      003025 |	lda #32d	;
      F0CE 20 F3 F3   003026 |	jsr OutChar	;
                      003027 |	
      F0D1 B1 08      003028 |	lda (PointerA),y;Print the second byte of the instruction and
      F0D3 8D 41 00   003029 |	sta ObCdHld1	; increment the memory pointer.
      F0D6 20 3E F3   003030 |	jsr OutHex	;
      F0D9 20 BA F2   003031 |	jsr IncPntrA	;
                      003032 |	
      F0DC A0 05      003033 |	ldy #5d		;Print spaces between object code field and
      F0DE 20 E2 F2   003034 |	jsr OutSpace	; operator field.
                      003035 |	
      F0E1 20 A8 F2   003036 |	jsr PrntMnem	;Print the operator.
                      003037 |	
      F0E4 A9 23      003038 |	lda #35d	;Print a pound sign.
      F0E6 20 F3 F3   003039 |	jsr OutChar	;
                      003040 |	
      F0E9 AD 41 00   003041 |	lda ObCdHld1	;Print immediate operand value.
      F0EC 20 3E F3   003042 |	jsr OutHex	;
                      003043 |	
      F0EF A9 68      003044 |	lda #104d	;Print lower case h to indicate hex number.
      F0F1 20 F3 F3   003045 |	jsr OutChar	;
                      003046 |	
      F0F4 4C FF EF   003047 |	jmp StartUnA
                      003048 |
                      003049 |
      F0F7            003050 |AbsxyAdM *
      F0F7 A0 00      003051 |	ldy #0d
                      003052 |
      F0F9 AD 43 00   003053 |	lda OpCdHold	;Print the opcode and a space.
      F0FC 20 3E F3   003054 |	jsr OutHex	;
      F0FF A9 20      003055 |	lda #32d	;
      F101 20 F3 F3   003056 |	jsr OutChar	;
                      003057 |	
      F104 B1 08      003058 |	lda (PointerA),y;Print the second byte of the instruction and
      F106 8D 41 00   003059 |	sta ObCdHld1	; increment the memory pointer
      F109 20 3E F3   003060 |	jsr OutHex	;
      F10C 20 BA F2   003061 |	jsr IncPntrA	;
                      003062 |	
      F10F A9 20      003063 |	lda #32d	;Print a space between obj codes.
      F111 20 F3 F3   003064 |	jsr OutChar	;
                      003065 |	
      F114 B1 08      003066 |	lda (PointerA),y;Print the third byte of the instruction and
      F116 8D 42 00   003067 |	sta ObCdHld2	; increment the memory pointer
      F119 20 3E F3   003068 |	jsr OutHex	;
      F11C 20 BA F2   003069 |	jsr IncPntrA	;
                      003070 |	
      F11F A0 02      003071 |	ldy #2d		;Print spaces between object code field and
      F121 20 E2 F2   003072 |	jsr OutSpace	; operator field.
                      003073 |	
      F124 20 A8 F2   003074 |	jsr PrntMnem	;Print the operator.
                      003075 |
      F127 AD 42 00   003076 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F12A 20 3E F3   003077 |	jsr OutHex	;
      F12D AD 41 00   003078 |	lda ObCdHld1	;
      F130 20 3E F3   003079 |	jsr OutHex	;
                      003080 |	
      F133 A9 68      003081 |	lda #104d	;Print lower case h to indicate hex number.
      F135 20 F3 F3   003082 |	jsr OutChar	;
                      003083 |
      F138 A0 06      003084 |	ldy #6d		;Check to see if address mode is abs, abx or
      F13A B1 0A      003085 |	lda (PointerB),y; aby.
      F13C C9 58      003086 |	cmp #'X'	;
      F13E F0 07      003087 |	beq AbxAdMo	;
      F140 C9 59      003088 |	cmp #'Y'	;
      F142 F0 10      003089 |	beq AbyAdMo	;
                      003090 |	
      F144            003091 |AbsAM *
      F144 4C FF EF   003092 |	jmp StartUnA
                      003093 |
      F147            003094 |AbxAdMo *
      F147 A9 2C      003095 |	lda #44d	;Print comma and x.
      F149 20 F3 F3   003096 |	jsr OutChar	;
      F14C A9 58      003097 |	lda #88d	;
      F14E 20 F3 F3   003098 |	jsr OutChar	;
                      003099 |	
      F151 4C FF EF   003100 |	jmp StartUna
                      003101 |	
      F154            003102 |AbyAdMo *
      F154 A9 2C      003103 |	lda #44d	;Print comma and y.
      F156 20 F3 F3   003104 |	jsr OutChar	;
      F159 A9 59      003105 |	lda #89d	;
      F15B 20 F3 F3   003106 |	jsr OutChar	;
                      003107 |
      F15E 4C FF EF   003108 |	jmp StartUnA
                      003109 |
                      003110 |
      F161            003111 |RelAdMo *
      F161 A0 00      003112 |	ldy #0d
                      003113 |
      F163 AD 43 00   003114 |	lda OpCdHold	;Print the opcode and a space.
      F166 20 3E F3   003115 |	jsr OutHex	;
      F169 A9 20      003116 |	lda #32d	;
      F16B 20 F3 F3   003117 |	jsr OutChar	;
                      003118 |	
      F16E B1 08      003119 |	lda (PointerA),y;Print the second byte of the instruction and
      F170 8D 41 00   003120 |	sta ObCdHld1	; increment the memory pointer.
      F173 20 3E F3   003121 |	jsr OutHex	;
      F176 20 BA F2   003122 |	jsr IncPntrA	;
                      003123 |	
      F179 A0 05      003124 |	ldy #5d		;Print spaces between object code field and
      F17B 20 E2 F2   003125 |	jsr OutSpace	; operator field.
                      003126 |	
      F17E 20 A8 F2   003127 |	jsr PrntMnem	;Print the operator.
                      003128 |
      F181 AD 08 00   003129 |	lda PointerA	;Store a copy of the next instruction's start
      F184 8D 3F 00   003130 |	sta AddHold	; address.
      F187 AD 09 00   003131 |	lda PointerA+1d	;
      F18A 8D 40 00   003132 |	sta AddHold+1d	;
                      003133 |	
      F18D AD 41 00   003134 |	lda ObCdHld1	;Check to see if branch is positive or negative.
      F190 30 12      003135 |	bmi NegBrnch	;
                      003136 |	
      F192            003137 |PosBrnch *		;If branch is positive then find address being
      F192 AD 3F 00   003138 |	lda AddHold	; branched to by adding offset to start address
      F195 18         003139 |	clc		; of next instruction in memory.
      F196 6D 41 00   003140 |	adc ObCdHld1	;
      F199 8D 3F 00   003141 |	sta AddHold	;
      F19C 90 20      003142 |	bcc OutBrAdd	;
      F19E EE 40 00   003143 |	inc AddHold+1d	;
      F1A1 4C BE F1   003144 |	jmp OutBrAdd	;
                      003145 |		
      F1A4            003146 |NegBrnch *
      F1A4 CE 41 00   003147 |	dec ObCdHld1	;If branch is negative then find address being
      F1A7 AD 41 00   003148 |	lda ObCdHld1	; branched to by subtracting offset from start
      F1AA 49 FF      003149 |	eor #0ffh	; address of next instruction in memory.
      F1AC 8D 41 00   003150 |	sta ObCdHld1	;
      F1AF AD 3F 00   003151 |	lda AddHold	;
      F1B2 38         003152 |	sec		;
      F1B3 ED 41 00   003153 |	sbc ObCdHld1	;
      F1B6 8D 3F 00   003154 |	sta AddHold	;
      F1B9 B0 03      003155 |	bcs OutBrAdd	;
      F1BB CE 40 00   003156 |	dec AddHold+1d	;
                      003157 |	
      F1BE            003158 |OutBrAdd *
      F1BE AD 40 00   003159 |	lda AddHold+1d	;Print address being branched to.
      F1C1 20 3E F3   003160 |	jsr OutHex	;
      F1C4 AD 3F 00   003161 |	lda AddHold	;
      F1C7 20 3E F3   003162 |	jsr OutHex	;
                      003163 |	
      F1CA A9 68      003164 |	lda #104d	;Print lower case h to indicate hex number.
      F1CC 20 F3 F3   003165 |	jsr OutChar	;
                      003166 |
      F1CF 4C FF EF   003167 |	jmp StartUnA
                      003168 |
                      003169 |
      F1D2            003170 |IRIAdMo *
      F1D2 A0 00      003171 |	ldy #0d
                      003172 |
      F1D4 AD 43 00   003173 |	lda OpCdHold	;Print the opcode and a space.
      F1D7 20 3E F3   003174 |	jsr OutHex	;
      F1DA A9 20      003175 |	lda #32d	;
      F1DC 20 F3 F3   003176 |	jsr OutChar	;
                      003177 |	
      F1DF B1 08      003178 |	lda (PointerA),y;Print the second byte of the instruction and
      F1E1 8D 41 00   003179 |	sta ObCdHld1	; increment the memory pointer.
      F1E4 20 3E F3   003180 |	jsr OutHex	;
      F1E7 20 BA F2   003181 |	jsr IncPntrA	;
                      003182 |	
      F1EA A0 05      003183 |	ldy #5d		;Print spaces between object code field and
      F1EC 20 E2 F2   003184 |	jsr OutSpace	; operator field.
                      003185 |	
      F1EF 20 A8 F2   003186 |	jsr PrntMnem	;Print the operator.
                      003187 |	
      F1F2 A9 28      003188 |	lda #40d	;Print (.
      F1F4 20 F3 F3   003189 |	jsr OutChar	;
                      003190 |	
      F1F7 AD 41 00   003191 |	lda ObCdHld1	;Print offset into zero page.
      F1FA 20 3E F3   003192 |	jsr OutHex	;
                      003193 |	
      F1FD A9 68      003194 |	lda #104d	;Print lower case h to indicate hex.
      F1FF 20 F3 F3   003195 |	jsr OutChar	;
                      003196 |	
      F202 A9 29      003197 |	lda #41d	;Print ).
      F204 20 F3 F3   003198 |	jsr OutChar	;
                      003199 |	
      F207 A9 2C      003200 |	lda #44d	;Print comma and y.
      F209 20 F3 F3   003201 |	jsr OutChar	;
      F20C A9 59      003202 |	lda #89d	;
      F20E 20 F3 F3   003203 |	jsr OutChar	;
                      003204 |	
      F211 4C FF EF   003205 |	jmp StartUnA
                      003206 |	
      F214            003207 |IIRAdMo *
      F214 A0 00      003208 |	ldy #0d
                      003209 |
      F216 AD 43 00   003210 |	lda OpCdHold	;Print the opcode and a space.
      F219 20 3E F3   003211 |	jsr OutHex	;
      F21C A9 20      003212 |	lda #32d	;
      F21E 20 F3 F3   003213 |	jsr OutChar	;
                      003214 |	
      F221 B1 08      003215 |	lda (PointerA),y;Print the second byte of the instruction and
      F223 8D 41 00   003216 |	sta ObCdHld1	; increment the memory pointer.
      F226 20 3E F3   003217 |	jsr OutHex	;
      F229 20 BA F2   003218 |	jsr IncPntrA	;
                      003219 |	
      F22C A0 05      003220 |	ldy #5d		;Print spaces between object code field and
      F22E 20 E2 F2   003221 |	jsr OutSpace	; operator field.
                      003222 |	
      F231 20 A8 F2   003223 |	jsr PrntMnem	;Print the operator.
                      003224 |	
      F234 A9 28      003225 |	lda #40d	;Print (.
      F236 20 F3 F3   003226 |	jsr OutChar	;
                      003227 |	
      F239 AD 41 00   003228 |	lda ObCdHld1	;Print offset into zero page.
      F23C 20 3E F3   003229 |	jsr OutHex	;
                      003230 |	
      F23F A9 68      003231 |	lda #104d	;Print lower case h to indicate hex.
      F241 20 F3 F3   003232 |	jsr OutChar	;
                      003233 |	
      F244 A9 2C      003234 |	lda #44d	;Print comma and x.
      F246 20 F3 F3   003235 |	jsr OutChar	;
      F249 A9 58      003236 |	lda #88d	;
      F24B 20 F3 F3   003237 |	jsr OutChar	;
                      003238 |	
      F24E A9 29      003239 |	lda #41d	;Print ).
      F250 20 F3 F3   003240 |	jsr OutChar	;
                      003241 |	
      F253 4C FF EF   003242 |	jmp StartUnA
                      003243 |
      F256            003244 |IndAdMo *
      F256 A0 00      003245 |	ldy #0d
                      003246 |
      F258 AD 43 00   003247 |	lda OpCdHold	;Print the opcode and a space.
      F25B 20 3E F3   003248 |	jsr OutHex	;
      F25E A9 20      003249 |	lda #32d	;
      F260 20 F3 F3   003250 |	jsr OutChar	;
                      003251 |	
      F263 B1 08      003252 |	lda (PointerA),y;Print the second byte of the instruction and
      F265 8D 41 00   003253 |	sta ObCdHld1	; increment the memory pointer
      F268 20 3E F3   003254 |	jsr OutHex	;
      F26B 20 BA F2   003255 |	jsr IncPntrA	;
                      003256 |	
      F26E A9 20      003257 |	lda #32d	;Print a space between obj codes.
      F270 20 F3 F3   003258 |	jsr OutChar	;
                      003259 |	
      F273 B1 08      003260 |	lda (PointerA),y;Print the third byte of the instruction and
      F275 8D 42 00   003261 |	sta ObCdHld2	; increment the memory pointer
      F278 20 3E F3   003262 |	jsr OutHex	;
      F27B 20 BA F2   003263 |	jsr IncPntrA	;
                      003264 |	
      F27E A0 02      003265 |	ldy #2d		;Print spaces between object code field and
      F280 20 E2 F2   003266 |	jsr OutSpace	; operator field.
                      003267 |	
      F283 20 A8 F2   003268 |	jsr PrntMnem	;Print the operator.
                      003269 |
      F286 A9 28      003270 |	lda #40d	;Print (.
      F288 20 F3 F3   003271 |	jsr OutChar	;
                      003272 |	
      F28B AD 42 00   003273 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F28E 20 3E F3   003274 |	jsr OutHex	;
      F291 AD 41 00   003275 |	lda ObCdHld1	;
      F294 20 3E F3   003276 |	jsr OutHex	;
                      003277 |	
      F297 A9 68      003278 |	lda #104d	;Print lower case h to indicate hex number.
      F299 20 F3 F3   003279 |	jsr OutChar	;
                      003280 |	
      F29C A9 29      003281 |	lda #41d	;Print ).
      F29E 20 F3 F3   003282 |	jsr OutChar	;
                      003283 |	
      F2A1 4C FF EF   003284 |	jmp StartUnA
                      003285 |	
      F2A4            003286 |ErrUnAs *
      F2A4 18         003287 |	clc
      F2A5 60         003288 |	rts
                      003289 |
      F2A6            003290 |ExitUnAs *
      F2A6 38         003291 |	sec
      F2A7 60         003292 |	rts
                      003293 |
                      003294 |
                      003295 |;****************************************************************************
                      003296 |;                       Print Mnemonic Subroutine.
                      003297 |;****************************************************************************
      F2A8            003298 |PrntMnem *
                      003299 |
      F2A8 A0 00      003300 |	ldy #0d		;Use loop to print all three characters of
      F2AA            003301 |PrntMore *
      F2AA B1 0A      003302 |	lda (PointerB),y; mnemonic.
      F2AC 20 F3 F3   003303 |	jsr OutChar	;
      F2AF C8         003304 |	iny		;
      F2B0 C0 03      003305 |	cpy #3d		;
      F2B2 D0 F6      003306 |	bne PrntMore	;
                      003307 |	
      F2B4 A9 20      003308 |	lda #32d	;Print a space after the mnemonic.
      F2B6 20 F3 F3   003309 |	jsr OutChar	;
                      003310 |	
      F2B9 60         003311 |	rts
                      003312 |
                      003313 |;****************************************************************************
                      003314 |;                       Increment Pointer A Subroutine.
                      003315 |;****************************************************************************
      F2BA            003316 |IncPntrA *
      F2BA EE 08 00   003317 |	inc PointerA
      F2BD D0 03      003318 |	bne NoOvFl1
      F2BF EE 09 00   003319 |	inc PointerA+1d
      F2C2            003320 |NoOvFl1 *
      F2C2 60         003321 |	rts
                      003322 |
                      003323 |
                      003324 |
                      003325 |;****************************************************************************
                      003326 |;                        Get Address Subroutine
                      003327 |;
                      003328 |;	X returns LSB of address.  Y returns MSB of address.
                      003329 |;****************************************************************************
      F2C3            003330 |GetAdd *		;Convert address found in operand field #x
      F2C3 20 1C F3   003331 |	jsr AsToBin	; into binary.
      F2C6 B0 03      003332 |	bcs AdMSBOK	;
      F2C8 4C D8 F2   003333 |	jmp ErrGtAd	;
      F2CB            003334 |AdMSBOK *		;
      F2CB A8         003335 |	tay		;
      F2CC E8         003336 |	inx		;
      F2CD 20 1C F3   003337 |	jsr AsToBin	;
      F2D0 B0 03      003338 |	bcs AdLSBOK	;
      F2D2 4C D8 F2   003339 |	jmp ErrGtAd	;
      F2D5            003340 |AdLSBOK *		;
      F2D5 AA         003341 |	tax
                      003342 |
      F2D6 38         003343 |	sec		;If conversion OK then set carry flag and
      F2D7 60         003344 |	rts		; return.
                      003345 |	
      F2D8            003346 |ErrGtAd *		;
      F2D8 18         003347 |	clc		;If error then clear carry and return.
      F2D9 60         003348 |	rts		;
                      003349 |
                      003350 |
                      003351 |;****************************************************************************
                      003352 |;                     Output a Colon Prompt Subroutine.
                      003353 |;****************************************************************************
      F2DA            003354 |OutColn *
      F2DA A2 7C      003355 |	ldx #ColnPrmt<
      F2DC A0 F5      003356 |	ldy #ColnPrmt>
      F2DE 20 92 F3   003357 |	jsr PrntMess
      F2E1 60         003358 |	rts
                      003359 |
                      003360 |;****************************************************************************
                      003361 |;                     Out Spaces Subroutine
                      003362 |;
                      003363 |;       Enter with the Y register indicating the number of spaces to output.
                      003364 |;****************************************************************************
      F2E2            003365 |OutSpace *		;Output the number of spaces indicated by
      F2E2 48         003366 |	pha		; the Y register.
      F2E3            003367 |OtAnoSpc *
      F2E3 A9 20      003368 |	lda #32d
      F2E5 20 F3 F3   003369 |	jsr OutChar
      F2E8 88         003370 |	dey
      F2E9 D0 F8      003371 |	bne OtAnoSpc
      F2EB 68         003372 |	pla
      F2EC 60         003373 |	rts
                      003374 |
                      003375 |
                      003376 |;****************************************************************************
                      003377 |;              Covert ASCII character to lower case Subroutine.
                      003378 |;****************************************************************************
      F2ED            003379 |ToLower *
      F2ED C9 41      003380 |	cmp #65d
      F2EF 30 07      003381 |	bmi ExitToLo
      F2F1 C9 5B      003382 |	cmp #91d
      F2F3 10 03      003383 |	bpl ExitToLo
      F2F5 18         003384 |	clc
      F2F6 69 20      003385 |	adc #32d
      F2F8            003386 |ExitTolo *
      F2F8 60         003387 |	rts
                      003388 |
                      003389 |
                      003390 |;****************************************************************************
                      003391 |;              Covert ASCII character to upper case Subroutine.
                      003392 |;****************************************************************************
      F2F9            003393 |ToUpper *
      F2F9 C9 61      003394 |	cmp #'a'
      F2FB 30 07      003395 |	bmi ExitToUp
      F2FD C9 7B      003396 |	cmp #123d
      F2FF 10 03      003397 |	bpl ExitToUp
      F301 38         003398 |	sec
      F302 E9 20      003399 |	sbc #32d
      F304            003400 |ExitToUp *
      F304 60         003401 |	rts
                      003402 |
                      003403 |
                      003404 |
                      003405 |;****************************************************************************
                      003406 |;                         Print address.
                      003407 |;****************************************************************************
      F305            003408 |PrntAdd *
      F305 AD 09 00   003409 |	lda PointerA+1d	;
      F308 20 3E F3   003410 |	jsr OutHex	;
      F30B AD 08 00   003411 |	lda PointerA	;
      F30E 20 3E F3   003412 |	jsr OutHex	;
      F311 A9 20      003413 |	lda #32d	;
      F313 20 F3 F3   003414 |	jsr OutChar	;
      F316 A9 20      003415 |	lda #32d	;
      F318 20 F3 F3   003416 |	jsr OutChar	;
                      003417 |	
      F31B 60         003418 |	rts
                      003419 |
                      003420 |;****************************************************************************
                      003421 |;                         Ascii to Binary Subroutine.
                      003422 |;****************************************************************************
      F31C            003423 |AsToBin *		;X points to digits to be converted using
                      003424 |			; OpFld1 as a base.
                      003425 |
      F31C BD 5F 00   003426 |	lda OpFld1,x	;Convert most significant digit to binary.
      F31F 20 72 EA   003427 |	jsr DgtToBin	;
      F322 90 19      003428 |	bcc ExtAs2Bn	;
      F324 0A         003429 |	asl a		;
      F325 0A         003430 |	asl a		;
      F326 0A         003431 |	asl a		;
      F327 0A         003432 |	asl a		;
      F328 29 F0      003433 |	and #0f0h	;
      F32A 8D 9C 00   003434 |	sta number	;
                      003435 |	
      F32D E8         003436 |	inx		;Convert least significant digit to binary.
      F32E BD 5F 00   003437 |	lda OpFld1,x	;
      F331 20 72 EA   003438 |	jsr DgtToBin	;
      F334 90 07      003439 |	bcc ExtAs2Bn	;
      F336 0D 9C 00   003440 |	ora number	;
                      003441 |	
      F339 8D 9C 00   003442 |	sta number	;Store full binary number in number.
      F33C 38         003443 |	sec
      F33D            003444 |ExtAs2Bn *
      F33D 60         003445 |	rts
                      003446 |	
                      003447 |;****************************************************************************
                      003448 |;                     Output a Hex byte to the serial port.
                      003449 |;
                      003450 |;            Enter with the number to be output in the A register.
                      003451 |;****************************************************************************
      F33E            003452 |OutHex *
      F33E 8D 9C 00   003453 |	sta number
                      003454 |	
      F341 4A         003455 |	lsr a		;Output most significant digit of hex byte to
      F342 4A         003456 |	lsr a		; serial port.
      F343 4A         003457 |	lsr a		;
      F344 4A         003458 |	lsr a		;
      F345 29 0F      003459 |	and #0fh	;
      F347 C9 0A      003460 |	cmp #0ah	;
      F349 10 05      003461 |	bpl Letter1	;
      F34B 09 30      003462 |	ora #30h	;
      F34D 4C 55 F3   003463 |	jmp Print1st	;
      F350            003464 |Letter1 *		;
      F350 38         003465 |	sec
      F351 E9 09      003466 |	sbc #9d		;
      F353 09 40      003467 |	ora #40h
      F355            003468 |Print1st *
      F355 20 F3 F3   003469 |	jsr OutChar	;
                      003470 |	
      F358 AD 9C 00   003471 |	lda number	;Output least significant digit of hex byte to
      F35B 29 0F      003472 |	and #0fh	; serial port.
      F35D C9 0A      003473 |	cmp #0ah	;
      F35F 10 05      003474 |	bpl Letter2	;
      F361 09 30      003475 |	ora #30h	;
      F363 4C 6B F3   003476 |	jmp Print2nd	;
      F366            003477 |Letter2 *		;
      F366 38         003478 |	sec
      F367 E9 09      003479 |	sbc #9d		;
      F369 09 40      003480 |	ora #40h	;
      F36B            003481 |Print2nd *		;
      F36B 20 F3 F3   003482 |	jsr OutChar	;
                      003483 |	
      F36E AD 9C 00   003484 |	lda number
      F371 60         003485 |	rts
                      003486 |	
                      003487 |;****************************************************************************
                      003488 |;                     Initialize Variables Subroutine
                      003489 |;****************************************************************************
      F372            003490 |InitVars *
                      003491 |
                      003492 |	;lda #1ah	;Initialize ACIA control register, 2400
                      003493 |	;sta 6551CtR	; Baud.
                      003494 |	
                      003495 |	;lda #0bh	;Initialize ACIA command register.
                      003496 |	;sta 6551CmR	;
                      003497 |		
      F372 A9 FD      003498 |	lda #BRK<	;Initialize BRK vector.
      F374 8D 04 00   003499 |	sta BRKVect	;
      F377 A9 E1      003500 |	lda #BRK>	;
      F379 8D 05 00   003501 |	sta BRKVect+1d	;
                      003502 |	
      F37C A9 00      003503 |	lda #0d		;Initialize trace break flag.
      F37E 8D 39 00   003504 |	sta TrBrkFlg	;
                      003505 |	
      F381 A9 00      003506 |	lda #0d		;Initialize break point status variables.
      F383 8D 2F 00   003507 |	sta BrkPt1St	;
      F386 8D 30 00   003508 |	sta BrkPt2St	;
      F389 8D 31 00   003509 |	sta BrkPt3St	;
      F38C 8D 32 00   003510 |	sta BrkPt4St	;
                      003511 |	
      F38F A9 00      003512 |	lda #0d		;Set the output port to all zeros (turn
                      003513 |	;sta OutPort0	; off all of the LEDs).
                      003514 |	
      F391 60         003515 |	rts
                      003516 |
                      003517 |;****************************************************************************
                      003518 |;                          Print Message Subroutine.
                      003519 |;
                      003520 |; X holds the message pointer's low byte (< means less than) and Y holds its 
                      003521 |; high byte (> means greater than).  The message must have a NULL (0) after 
                      003522 |; the last character in the  Message so the PrntMess subroutine knows when to 
                      003523 |; stop printing.
                      003524 |;****************************************************************************
      F392            003525 |PrntMess *
      F392 48         003526 |	pha
                      003527 |	
      F393 8E 06 00   003528 |	stx MessPtr	;Initialize pointer that will point to each
      F396 8C 07 00   003529 |	sty MessPtr+1h	; character of message.
                      003530 |	
      F399 A0 00      003531 |	ldy #0h
                      003532 |	
      F39B            003533 |OutMess *		;
      F39B B1 06      003534 |	lda (MessPtr),y	;Get a character from the message and if it is
      F39D F0 0E      003535 |	beq ExitMess	; a NULL (0) then exit this subroutine.
                      003536 |	
      F39F 20 F3 F3   003537 |	jsr OutChar	;Output the character to the serial port.
                      003538 |	
      F3A2 EE 06 00   003539 |	inc MessPtr	;Increment the message pointer to point to the
      F3A5 D0 03      003540 |	bne PrNoOvf	; next character in the message.
      F3A7 EE 07 00   003541 |	inc MessPtr+1d	;
                      003542 |	
      F3AA            003543 |PrNoOvf *
      F3AA 4C 9B F3   003544 |	jmp OutMess
                      003545 |		
      F3AD            003546 |ExitMess *
      F3AD 68         003547 |	pla
                      003548 |	
      F3AE 60         003549 |	rts
                      003550 |
                      003551 |;****************************************************************************
                      003552 |;           Get Character (Don't Wait) From Serial Channel Subroutine
                      003553 |;****************************************************************************
      F3AF            003554 |GetChar *
      F3AF 08         003555 |	php		;Save the registers on the stack.
      F3B0 8A         003556 |	txa		;
      F3B1 48         003557 |	pha		;
      F3B2 98         003558 |	tya		;
      F3B3 48         003559 |	pha		;
                      003560 |	
      F3B4 AD 01 A0   003561 |	lda 6551StR	;Check ACIA to see if a character has been
      F3B7 29 08      003562 |	and #00001000b	; received and return with a NULL if no
      F3B9 F0 09      003563 |	beq NoChar	; character was present.
                      003564 |	
      F3BB AD 00 A0   003565 |	lda 6551TRR	;Get the received character from the ACIA's 
      F3BE 8D CE 00   003566 |	sta RegTemp	; receive register.
      F3C1 4C C9 F3   003567 |	jmp ExitGtCh	;
                      003568 |	
      F3C4            003569 |NoChar *
      F3C4 A9 00      003570 |	lda #0d
      F3C6 8D CE 00   003571 |	sta RegTemp
                      003572 |	
      F3C9            003573 |ExitGtCh *
      F3C9 68         003574 |	pla		;Restore the registers.
      F3CA A8         003575 |	tay		;
      F3CB 68         003576 |	pla		;
      F3CC AA         003577 |	tax		;
      F3CD 28         003578 |	plp		;
      F3CE AD CE 00   003579 |	lda RegTemp	;
                      003580 |	
      F3D1 60         003581 |	rts
                      003582 |	
                      003583 |;****************************************************************************
                      003584 |;             Get Character (Wait) From Serial Channel Subroutine
                      003585 |;****************************************************************************
      F3D2            003586 |GetCharW *
      F3D2 08         003587 |	php		;Save the registers on the stack.
      F3D3 8A         003588 |	txa		;
      F3D4 48         003589 |	pha		;
      F3D5 98         003590 |	tya		;
      F3D6 48         003591 |	pha		;
                      003592 |	
      F3D7            003593 |GtCkAgn *	
      F3D7 AD 01 A0   003594 |	lda 6551StR	;Check the ACIA's receiver buffer full register
      F3DA 29 08      003595 |	and #00001000b	; and wait until a character is received.
      F3DC D0 06      003596 |	bne CharRec	;
                      003597 |	
      F3DE AD 02 A0   003598 |	lda 6551Sleep ;Allow the emulator to be put to sleep.
      F3E1 4C D7 F3   003599 |	jmp GtCkAgn
                      003600 |	
      F3E4            003601 |CharRec *
      F3E4 AD 00 A0   003602 |	lda 6551TRR	;Get the received character from the ACIA's 
      F3E7 8D CE 00   003603 |	sta RegTemp	; receive register.
                      003604 |	
      F3EA 68         003605 |	pla		;Restore the registers.
      F3EB A8         003606 |	tay		;
      F3EC 68         003607 |	pla		;
      F3ED AA         003608 |	tax		;
      F3EE 28         003609 |	plp		;
      F3EF AD CE 00   003610 |	lda RegTemp	;
                      003611 |	
      F3F2 60         003612 |	rts
                      003613 |	
                      003614 |;****************************************************************************
                      003615 |;                 Output Character to Serial Channel Subroutine 
                      003616 |;                   Character to print is in register 'A'
                      003617 |;****************************************************************************
      F3F3            003618 |OutChar *
                      003619 |	
      F3F3 8D CE 00   003620 |	sta RegTemp	;Save registers.
      F3F6 08         003621 |	php		;
      F3F7 98         003622 |	tya		;
      F3F8 48         003623 |	pha		;
      F3F9 8A         003624 |	txa		;
      F3FA 48         003625 |	pha		;
                      003626 |	
      F3FB            003627 |OtCkAgn *
      F3FB AD 01 A0   003628 |	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
      F3FE 29 10      003629 |	and #00010000b	; register and wait until the buffer is empty.
      F400 F0 F9      003630 |	beq OtCkAgn	;
                      003631 |	
      F402 AD CE 00   003632 |	lda RegTemp	;Output a character to the ACIA's Transmitt
      F405 8D 00 A0   003633 |	sta 6551TRR	; register.
                      003634 |	
      F408 68         003635 |	pla		;Restore registers.
      F409 AA         003636 |	tax		;
      F40A 68         003637 |	pla		;
      F40B A8         003638 |	tay		;
      F40C 28         003639 |	plp		;
      F40D AD CE 00   003640 |	lda RegTemp	;
                      003641 |		
      F410 60         003642 |	rts
                      003643 |
                      003644 |
                      003645 |;****************************************************************************
                      003646 |;                          Delay Subroutine
                      003647 |;****************************************************************************
      F411            003648 |delay *
      F411 48         003649 |	pha
      F412 8A         003650 |	txa
      F413 48         003651 |	pha
      F414 98         003652 |	tya
      F415 48         003653 |	pha
                      003654 |	
      F416 A9 00      003655 |	lda #0h
      F418 8D A2 00   003656 |	sta wait0
      F41B A9 10      003657 |	lda #10h
      F41D 8D A3 00   003658 |	sta wait1
                      003659 |	
                      003660 |	
      F420            003661 |dw0 *
      F420 CE A2 00   003662 |	dec wait0
      F423 D0 FB      003663 |	bne dw0
      F425 CE A3 00   003664 |	dec wait1
      F428 D0 F6      003665 |	bne dw0
                      003666 |	
      F42A 68         003667 |	pla
      F42B A8         003668 |	tay
      F42C 68         003669 |	pla                                                                        
      F42D AA         003670 |	tax
      F42E 68         003671 |	pla
      F42F 60         003672 |	rts
                      003673 |
                      003674 |
                      003675 |;****************************************************************************
                      003676 |;                Constants
                      003677 |;****************************************************************************
                      003678 |
      F430 16         003679 |UARTval		dbt 16h,0bh
      F431 0B               
      F432 30         003680 |DgtTblUC	dbt "0123456789ABCDEF"
      F433 31 32 33         
      F436 34 35 36         
      F439 37 38 39         
      F43C 41 42 43         
      F43F 44 45 46         
      F442 00         003681 |		dbt 0h
      F443 30         003682 |DgtTblLC	dbt "0123456789abcdef"
      F444 31 32 33         
      F447 34 35 36         
      F44A 37 38 39         
      F44D 61 62 63         
      F450 64 65 66         
      F453 00         003683 |		dbt 0h
      F454 0A         003684 |OpenMess	dbt 10d,13d,10d
      F455 0D               
      F456 0A               
      F457 55         003685 |		dbt "UMON65 V1.18 - Understandable Monitor for the 6500 series microprocessors."
      F458 4D 4F 4E         
      F45B 36 35 20         
      F45E 56 31 2E         
      F461 31 38 20         
      F464 2D 20 55         
      F467 6E 64 65         
      F46A 72 73 74         
      F46D 61 6E 64         
      F470 61 62 6C         
      F473 65 20 4D         
      F476 6F 6E 69         
      F479 74 6F 72         
      F47C 20 66 6F         
      F47F 72 20 74         
      F482 68 65 20         
      F485 36 35 30         
      F488 30 20 73         
      F48B 65 72 69         
      F48E 65 73 20         
      F491 6D 69 63         
      F494 72 6F 70         
      F497 72 6F 63         
      F49A 65 73 73         
      F49D 6F 72 73         
      F4A0 2E               
      F4A1 0A         003686 |		dbt 10d,13d
      F4A2 0D               
      F4A3 00         003687 |		dbt 0h
      F4A4 0A         003688 |prompt		dbt 10d,13d
      F4A5 0D               
      F4A6 2D         003689 |		dbt "-"
      F4A7 00         003690 |		dbt 0h
      F4A8 0A         003691 |CRLF		dbt 10d,13d,0d
      F4A9 0D               
      F4AA 00               
      F4AB 0A         003692 |SRecStMs	dbt 10d,13d
      F4AC 0D               
      F4AD 53         003693 |		dbt "Send S records when you are ready..."
      F4AE 65 6E 64         
      F4B1 20 53 20         
      F4B4 72 65 63         
      F4B7 6F 72 64         
      F4BA 73 20 77         
      F4BD 68 65 6E         
      F4C0 20 79 6F         
      F4C3 75 20 61         
      F4C6 72 65 20         
      F4C9 72 65 61         
      F4CC 64 79 2E         
      F4CF 2E 2E            
      F4D1 0A         003694 |		dbt 10d,13d,0d
      F4D2 0D               
      F4D3 00               
      F4D4 0A         003695 |SRecErMe	dbt 10d,13d,7d
      F4D5 0D               
      F4D6 07               
      F4D7 45         003696 |		dbt "Error Loading S Records..."
      F4D8 72 72 6F         
      F4DB 72 20 4C         
      F4DE 6F 61 64         
      F4E1 69 6E 67         
      F4E4 20 53 20         
      F4E7 52 65 63         
      F4EA 6F 72 64         
      F4ED 73 2E 2E         
      F4F0 2E               
      F4F1 0A         003697 |		dbt 10d,13d,0d
      F4F2 0D               
      F4F3 00               
      F4F4 0A         003698 |SRecEnMs	dbt 10d,13d,7d
      F4F5 0D               
      F4F6 07               
      F4F7 53         003699 |		dbt "S records successfully loaded (press <enter> to continue)."
      F4F8 20 72 65         
      F4FB 63 6F 72         
      F4FE 64 73 20         
      F501 73 75 63         
      F504 63 65 73         
      F507 73 66 75         
      F50A 6C 6C 79         
      F50D 20 6C 6F         
      F510 61 64 65         
      F513 64 20 28         
      F516 70 72 65         
      F519 73 73 20         
      F51C 3C 65 6E         
      F51F 74 65 72         
      F522 3E 20 74         
      F525 6F 20 63         
      F528 6F 6E 74         
      F52B 69 6E 75         
      F52E 65 29 2E         
      F531 00         003700 |		dbt 0d
      F532 0A         003701 |RegMess		dbt 10d,13d,10d
      F533 0D               
      F534 0A               
      F535 50         003702 |		dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
      F536 67 6D 43         
      F539 6E 74 72         
      F53C 28 50 43         
      F53F 29 20 20         
      F542 41 63 63         
      F545 75 6D 28         
      F548 41 43 29         
      F54B 20 20 58         
      F54E 52 65 67         
      F551 28 58 52         
      F554 29 20 20         
      F557 59 52 65         
      F55A 67 28 59         
      F55D 52 29 20         
      F560 20 53 74         
      F563 6B 50 74         
      F566 72 28 53         
      F569 50 29 20         
      F56C 20 4E 56         
      F56F 2D 42 44         
      F572 49 5A 43         
      F575 28 53 52         
      F578 29               
      F579 0A         003703 |		dbt 10d,13d,0d
      F57A 0D               
      F57B 00               
      F57C 0A         003704 |ColnPrmt	dbt 10d,13d
      F57D 0D               
      F57E 20         003705 |		dbt " :"
      F57F 3A               
      F580 00         003706 |		dbt 0d
      F581 20         003707 |BadOpMes	dbt "        ???"
      F582 20 20 20         
      F585 20 20 20         
      F588 20 3F 3F         
      F58B 3F               
      F58C 00         003708 |		dbt 0d
      F58D 0A         003709 |BPFulMes	dbt 10d,13d
      F58E 0D               
      F58F 41         003710 |		dbt "All breakpoints are currently in use."
      F590 6C 6C 20         
      F593 62 72 65         
      F596 61 6B 70         
      F599 6F 69 6E         
      F59C 74 73 20         
      F59F 61 72 65         
      F5A2 20 63 75         
      F5A5 72 72 65         
      F5A8 6E 74 6C         
      F5AB 79 20 69         
      F5AE 6E 20 75         
      F5B1 73 65 2E         
      F5B4 00         003711 |		dbt 0d
      F5B5 0A         003712 |NoBPMess	dbt 10d,13d
      F5B6 0D               
      F5B7 4E         003713 |		dbt "No breakpoint exists at this address."
      F5B8 6F 20 62         
      F5BB 72 65 61         
      F5BE 6B 70 6F         
      F5C1 69 6E 74         
      F5C4 20 65 78         
      F5C7 69 73 74         
      F5CA 73 20 61         
      F5CD 74 20 74         
      F5D0 68 69 73         
      F5D3 20 61 64         
      F5D6 64 72 65         
      F5D9 73 73 2E         
      F5DC 00         003714 |		dbt 0d
      F5DD 0A         003715 |GoBPErrM	dbt 10d,13d
      F5DE 0D               
      F5DF 59         003716 |		dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
      F5E0 6F 75 20         
      F5E3 63 61 6E         
      F5E6 6E 6F 74         
      F5E9 20 47 4F         
      F5EC 20 61 74         
      F5EF 20 61 20         
      F5F2 62 72 65         
      F5F5 61 6B 70         
      F5F8 6F 69 6E         
      F5FB 74 65 64         
      F5FE 20 61 64         
      F601 64 72 65         
      F604 73 73 2C         
      F607 20 54 52         
      F60A 41 43 45         
      F60D 20 70 61         
      F610 73 74 20         
      F613 69 74 20         
      F616 74 68 65         
      F619 6E 20 47         
      F61C 4F 2E            
      F61E 00         003717 |		dbt 0d
      F61F 0A         003718 |CmdErMes	dbt 10d,13d
      F620 0D               
      F621 3F         003719 |		dbt "?"
      F622 00         003720 |		dbt 0d
      F623 0A         003721 |HelpMess	dbt 10d,13d,10d
      F624 0D               
      F625 0A               
      F626 41         003722 |		dbt "Assemble       A start_address"
      F627 73 73 65         
      F62A 6D 62 6C         
      F62D 65 20 20         
      F630 20 20 20         
      F633 20 20 41         
      F636 20 73 74         
      F639 61 72 74         
      F63C 5F 61 64         
      F63F 64 72 65         
      F642 73 73            
      F644 0A         003723 |		dbt 10d,13d
      F645 0D               
      F646 42         003724 |		dbt "Breakpoint     B (+,-,?) address"
      F647 72 65 61         
      F64A 6B 70 6F         
      F64D 69 6E 74         
      F650 20 20 20         
      F653 20 20 42         
      F656 20 28 2B         
      F659 2C 2D 2C         
      F65C 3F 29 20         
      F65F 61 64 64         
      F662 72 65 73         
      F665 73               
      F666 0A         003725 |		dbt 10d,13d
      F667 0D               
      F668 44         003726 |		dbt "Dump           D [start_address [end_address]]"
      F669 75 6D 70         
      F66C 20 20 20         
      F66F 20 20 20         
      F672 20 20 20         
      F675 20 20 44         
      F678 20 5B 73         
      F67B 74 61 72         
      F67E 74 5F 61         
      F681 64 64 72         
      F684 65 73 73         
      F687 20 5B 65         
      F68A 6E 64 5F         
      F68D 61 64 64         
      F690 72 65 73         
      F693 73 5D 5D         
      F696 0A         003727 |		dbt 10d,13d
      F697 0D               
      F698 45         003728 |		dbt "Enter          E address list"
      F699 6E 74 65         
      F69C 72 20 20         
      F69F 20 20 20         
      F6A2 20 20 20         
      F6A5 20 20 45         
      F6A8 20 61 64         
      F6AB 64 72 65         
      F6AE 73 73 20         
      F6B1 6C 69 73         
      F6B4 74               
      F6B5 0A         003729 |		dbt 10d,13d
      F6B6 0D               
      F6B7 46         003730 |		dbt "Fill           F start_address end_address list"
      F6B8 69 6C 6C         
      F6BB 20 20 20         
      F6BE 20 20 20         
      F6C1 20 20 20         
      F6C4 20 20 46         
      F6C7 20 73 74         
      F6CA 61 72 74         
      F6CD 5F 61 64         
      F6D0 64 72 65         
      F6D3 73 73 20         
      F6D6 65 6E 64         
      F6D9 5F 61 64         
      F6DC 64 72 65         
      F6DF 73 73 20         
      F6E2 6C 69 73         
      F6E5 74               
      F6E6 0A         003731 |		dbt 10d,13d
      F6E7 0D               
      F6E8 47         003732 |		dbt "Go             G [start_address]"
      F6E9 6F 20 20         
      F6EC 20 20 20         
      F6EF 20 20 20         
      F6F2 20 20 20         
      F6F5 20 20 47         
      F6F8 20 5B 73         
      F6FB 74 61 72         
      F6FE 74 5F 61         
      F701 64 64 72         
      F704 65 73 73         
      F707 5D               
      F708 0A         003733 |		dbt 10d,13d
      F709 0D               
      F70A 48         003734 |		dbt "Help           H or ?"
      F70B 65 6C 70         
      F70E 20 20 20         
      F711 20 20 20         
      F714 20 20 20         
      F717 20 20 48         
      F71A 20 6F 72         
      F71D 20 3F            
      F71F 0A         003735 |		dbt 10d,13d
      F720 0D               
      F721 4C         003736 |		dbt "Load           L"
      F722 6F 61 64         
      F725 20 20 20         
      F728 20 20 20         
      F72B 20 20 20         
      F72E 20 20 4C         
      F731 0A         003737 |		dbt 10d,13d
      F732 0D               
      F733 4D         003738 |		dbt "Move           M start_address end_address destination_address"
      F734 6F 76 65         
      F737 20 20 20         
      F73A 20 20 20         
      F73D 20 20 20         
      F740 20 20 4D         
      F743 20 73 74         
      F746 61 72 74         
      F749 5F 61 64         
      F74C 64 72 65         
      F74F 73 73 20         
      F752 65 6E 64         
      F755 5F 61 64         
      F758 64 72 65         
      F75B 73 73 20         
      F75E 64 65 73         
      F761 74 69 6E         
      F764 61 74 69         
      F767 6F 6E 5F         
      F76A 61 64 64         
      F76D 72 65 73         
      F770 73               
      F771 0A         003739 |		dbt 10d,13d
      F772 0D               
      F773 52         003740 |		dbt "Register       R [PC,AC,XR,YR,SP,SR]"
      F774 65 67 69         
      F777 73 74 65         
      F77A 72 20 20         
      F77D 20 20 20         
      F780 20 20 52         
      F783 20 5B 50         
      F786 43 2C 41         
      F789 43 2C 58         
      F78C 52 2C 59         
      F78F 52 2C 53         
      F792 50 2C 53         
      F795 52 5D            
      F797 0A         003741 |		dbt 10d,13d
      F798 0D               
      F799 53         003742 |		dbt "Search         S start_address end_address list"
      F79A 65 61 72         
      F79D 63 68 20         
      F7A0 20 20 20         
      F7A3 20 20 20         
      F7A6 20 20 53         
      F7A9 20 73 74         
      F7AC 61 72 74         
      F7AF 5F 61 64         
      F7B2 64 72 65         
      F7B5 73 73 20         
      F7B8 65 6E 64         
      F7BB 5F 61 64         
      F7BE 64 72 65         
      F7C1 73 73 20         
      F7C4 6C 69 73         
      F7C7 74               
      F7C8 0A         003743 |		dbt 10d,13d
      F7C9 0D               
      F7CA 54         003744 |		dbt "Trace          T [start_address [value]]"
      F7CB 72 61 63         
      F7CE 65 20 20         
      F7D1 20 20 20         
      F7D4 20 20 20         
      F7D7 20 20 54         
      F7DA 20 5B 73         
      F7DD 74 61 72         
      F7E0 74 5F 61         
      F7E3 64 64 72         
      F7E6 65 73 73         
      F7E9 20 5B 76         
      F7EC 61 6C 75         
      F7EF 65 5D 5D         
      F7F2 0A         003745 |		dbt 10d,13d
      F7F3 0D               
      F7F4 55         003746 |		dbt "Unassemble     U [start_address [end_address]]"
      F7F5 6E 61 73         
      F7F8 73 65 6D         
      F7FB 62 6C 65         
      F7FE 20 20 20         
      F801 20 20 55         
      F804 20 5B 73         
      F807 74 61 72         
      F80A 74 5F 61         
      F80D 64 64 72         
      F810 65 73 73         
      F813 20 5B 65         
      F816 6E 64 5F         
      F819 61 64 64         
      F81C 72 65 73         
      F81F 73 5D 5D         
      F822 0A         003747 |		dbt 10d,13d,0d
      F823 0D               
      F824 00               
                      003748 |	
                      003749 |
      F825 41         003750 |OpTable		dbt "ADC IMM"
      F826 44 43 20         
      F829 49 4D 4D         
      F82C 69         003751 |		dbt 069h,2h,2h
      F82D 02               
      F82E 02               
      F82F 41         003752 |		dbt "ADC ABS"
      F830 44 43 20         
      F833 41 42 53         
      F836 6D         003753 |		dbt 06Dh,3h,4h
      F837 03               
      F838 04               
      F839 41         003754 |		dbt "ADC ABX"
      F83A 44 43 20         
      F83D 41 42 58         
      F840 7D         003755 |		dbt 07Dh,3h,4h
      F841 03               
      F842 04               
      F843 41         003756 |		dbt "ADC ABY"
      F844 44 43 20         
      F847 41 42 59         
      F84A 79         003757 |		dbt 079h,3h,4h
      F84B 03               
      F84C 04               
      F84D 41         003758 |		dbt "ADC IIR"
      F84E 44 43 20         
      F851 49 49 52         
      F854 61         003759 |		dbt 061h,2h,6h
      F855 02               
      F856 06               
      F857 41         003760 |		dbt "ADC IRI"
      F858 44 43 20         
      F85B 49 52 49         
      F85E 71         003761 |		dbt 071h,2h,5h
      F85F 02               
      F860 05               
      F861 41         003762 |		dbt "AND IMM"
      F862 4E 44 20         
      F865 49 4D 4D         
      F868 29         003763 |		dbt 029h,2h,2h
      F869 02               
      F86A 02               
      F86B 41         003764 |		dbt "AND ABS"
      F86C 4E 44 20         
      F86F 41 42 53         
      F872 2D         003765 |		dbt 02Dh,3h,4h
      F873 03               
      F874 04               
      F875 41         003766 |		dbt "AND ABX"
      F876 4E 44 20         
      F879 41 42 58         
      F87C 3D         003767 |		dbt 03Dh,3h,4h
      F87D 03               
      F87E 04               
      F87F 41         003768 |		dbt "AND ABY"
      F880 4E 44 20         
      F883 41 42 59         
      F886 39         003769 |		dbt 039h,3h,4h
      F887 03               
      F888 04               
      F889 41         003770 |		dbt "AND IIR"
      F88A 4E 44 20         
      F88D 49 49 52         
      F890 21         003771 |		dbt 021h,2h,6h
      F891 02               
      F892 06               
      F893 41         003772 |		dbt "AND IRI"
      F894 4E 44 20         
      F897 49 52 49         
      F89A 31         003773 |		dbt 031h,2h,5h
      F89B 02               
      F89C 05               
      F89D 41         003774 |		dbt "ASL ACC"
      F89E 53 4C 20         
      F8A1 41 43 43         
      F8A4 0A         003775 |		dbt 00Ah,1h,2h
      F8A5 01               
      F8A6 02               
      F8A7 41         003776 |		dbt "ASL ABS"
      F8A8 53 4C 20         
      F8AB 41 42 53         
      F8AE 0E         003777 |		dbt 00Eh,3h,6h
      F8AF 03               
      F8B0 06               
      F8B1 41         003778 |		dbt "ASL ABX"
      F8B2 53 4C 20         
      F8B5 41 42 58         
      F8B8 1E         003779 |		dbt 01Eh,3h,7h
      F8B9 03               
      F8BA 07               
      F8BB 42         003780 |		dbt "BCC REL"
      F8BC 43 43 20         
      F8BF 52 45 4C         
      F8C2 90         003781 |		dbt 090h,2h,2h
      F8C3 02               
      F8C4 02               
      F8C5 42         003782 |		dbt "BCS REL"
      F8C6 43 53 20         
      F8C9 52 45 4C         
      F8CC B0         003783 |		dbt 0B0h,2h,2h
      F8CD 02               
      F8CE 02               
      F8CF 42         003784 |		dbt "BEQ REL"
      F8D0 45 51 20         
      F8D3 52 45 4C         
      F8D6 F0         003785 |		dbt 0F0h,2h,2h
      F8D7 02               
      F8D8 02               
      F8D9 42         003786 |		dbt "BIT ABS"
      F8DA 49 54 20         
      F8DD 41 42 53         
      F8E0 2C         003787 |		dbt 02Ch,3h,4h
      F8E1 03               
      F8E2 04               
      F8E3 42         003788 |		dbt "BMI REL"
      F8E4 4D 49 20         
      F8E7 52 45 4C         
      F8EA 30         003789 |		dbt 030h,2h,2h
      F8EB 02               
      F8EC 02               
      F8ED 42         003790 |		dbt "BNE REL"
      F8EE 4E 45 20         
      F8F1 52 45 4C         
      F8F4 D0         003791 |		dbt 0D0h,2h,2h
      F8F5 02               
      F8F6 02               
      F8F7 42         003792 |		dbt "BPL REL"
      F8F8 50 4C 20         
      F8FB 52 45 4C         
      F8FE 10         003793 |		dbt 010h,2h,2h
      F8FF 02               
      F900 02               
      F901 42         003794 |		dbt "BRK IMP"
      F902 52 4B 20         
      F905 49 4D 50         
      F908 00         003795 |		dbt 000h,1h,7h
      F909 01               
      F90A 07               
      F90B 42         003796 |		dbt "BVC REL"
      F90C 56 43 20         
      F90F 52 45 4C         
      F912 50         003797 |		dbt 050h,2h,2h
      F913 02               
      F914 02               
      F915 42         003798 |		dbt "BVS REL"
      F916 56 53 20         
      F919 52 45 4C         
      F91C 70         003799 |		dbt 070h,2h,2h
      F91D 02               
      F91E 02               
      F91F 43         003800 |		dbt "CLC IMP"
      F920 4C 43 20         
      F923 49 4D 50         
      F926 18         003801 |		dbt 018h,1h,2h
      F927 01               
      F928 02               
      F929 43         003802 |		dbt "CLD IMP"
      F92A 4C 44 20         
      F92D 49 4D 50         
      F930 D8         003803 |		dbt 0D8h,1h,2h
      F931 01               
      F932 02               
      F933 43         003804 |		dbt "CLI IMP"
      F934 4C 49 20         
      F937 49 4D 50         
      F93A 58         003805 |		dbt 058h,1h,2h
      F93B 01               
      F93C 02               
      F93D 43         003806 |		dbt "CLV IMP"
      F93E 4C 56 20         
      F941 49 4D 50         
      F944 B8         003807 |		dbt 0B8h,1h,2h
      F945 01               
      F946 02               
      F947 43         003808 |		dbt "CMP IMM"
      F948 4D 50 20         
      F94B 49 4D 4D         
      F94E C9         003809 |		dbt 0C9h,2h,2h
      F94F 02               
      F950 02               
      F951 43         003810 |		dbt "CMP ABS"
      F952 4D 50 20         
      F955 41 42 53         
      F958 CD         003811 |		dbt 0CDh,3h,4h
      F959 03               
      F95A 04               
      F95B 43         003812 |		dbt "CMP ABX"
      F95C 4D 50 20         
      F95F 41 42 58         
      F962 DD         003813 |		dbt 0DDh,3h,4h
      F963 03               
      F964 04               
      F965 43         003814 |		dbt "CMP ABY"
      F966 4D 50 20         
      F969 41 42 59         
      F96C D9         003815 |		dbt 0D9h,3h,4h
      F96D 03               
      F96E 04               
      F96F 43         003816 |		dbt "CMP IIR"
      F970 4D 50 20         
      F973 49 49 52         
      F976 C1         003817 |		dbt 0C1h,2h,6h
      F977 02               
      F978 06               
      F979 43         003818 |		dbt "CMP IRI"
      F97A 4D 50 20         
      F97D 49 52 49         
      F980 D1         003819 |		dbt 0D1h,2h,5h
      F981 02               
      F982 05               
      F983 43         003820 |		dbt "CPX IMM"
      F984 50 58 20         
      F987 49 4D 4D         
      F98A E0         003821 |		dbt 0E0h,2h,2h
      F98B 02               
      F98C 02               
      F98D 43         003822 |		dbt "CPX ABS"
      F98E 50 58 20         
      F991 41 42 53         
      F994 EC         003823 |		dbt 0ECh,3h,4h
      F995 03               
      F996 04               
      F997 43         003824 |		dbt "CPY IMM"
      F998 50 59 20         
      F99B 49 4D 4D         
      F99E C0         003825 |		dbt 0C0h,2h,2h
      F99F 02               
      F9A0 02               
      F9A1 43         003826 |		dbt "CPY ABS"
      F9A2 50 59 20         
      F9A5 41 42 53         
      F9A8 CC         003827 |		dbt 0CCh,3h,4h
      F9A9 03               
      F9AA 04               
      F9AB 44         003828 |		dbt "DEC ABS"
      F9AC 45 43 20         
      F9AF 41 42 53         
      F9B2 CE         003829 |		dbt 0CEh,3h,6h
      F9B3 03               
      F9B4 06               
      F9B5 44         003830 |		dbt "DEC ABX"
      F9B6 45 43 20         
      F9B9 41 42 58         
      F9BC DE         003831 |		dbt 0DEh,3h,7h
      F9BD 03               
      F9BE 07               
      F9BF 44         003832 |		dbt "DEX IMP"
      F9C0 45 58 20         
      F9C3 49 4D 50         
      F9C6 CA         003833 |		dbt 0CAh,1h,2h
      F9C7 01               
      F9C8 02               
      F9C9 44         003834 |		dbt "DEY IMP"
      F9CA 45 59 20         
      F9CD 49 4D 50         
      F9D0 88         003835 |		dbt 088h,1h,2h
      F9D1 01               
      F9D2 02               
      F9D3 45         003836 |		dbt "EOR IMM"
      F9D4 4F 52 20         
      F9D7 49 4D 4D         
      F9DA 49         003837 |		dbt 049h,2h,2h
      F9DB 02               
      F9DC 02               
      F9DD 45         003838 |		dbt "EOR ABS"
      F9DE 4F 52 20         
      F9E1 41 42 53         
      F9E4 4D         003839 |		dbt 04Dh,3h,4h
      F9E5 03               
      F9E6 04               
      F9E7 45         003840 |		dbt "EOR ABX"
      F9E8 4F 52 20         
      F9EB 41 42 58         
      F9EE 5D         003841 |		dbt 05Dh,3h,4h
      F9EF 03               
      F9F0 04               
      F9F1 45         003842 |		dbt "EOR ABY"
      F9F2 4F 52 20         
      F9F5 41 42 59         
      F9F8 59         003843 |		dbt 059h,3h,4h
      F9F9 03               
      F9FA 04               
      F9FB 45         003844 |		dbt "EOR IIR"
      F9FC 4F 52 20         
      F9FF 49 49 52         
      FA02 41         003845 |		dbt 041h,2h,6h
      FA03 02               
      FA04 06               
      FA05 45         003846 |		dbt "EOR IRI"
      FA06 4F 52 20         
      FA09 49 52 49         
      FA0C 51         003847 |		dbt 051h,2h,5h
      FA0D 02               
      FA0E 05               
      FA0F 49         003848 |		dbt "INC ABS"
      FA10 4E 43 20         
      FA13 41 42 53         
      FA16 EE         003849 |		dbt 0EEh,3h,6h
      FA17 03               
      FA18 06               
      FA19 49         003850 |		dbt "INC ABX"
      FA1A 4E 43 20         
      FA1D 41 42 58         
      FA20 FE         003851 |		dbt 0FEh,3h,7h
      FA21 03               
      FA22 07               
      FA23 49         003852 |		dbt "INX IMP"
      FA24 4E 58 20         
      FA27 49 4D 50         
      FA2A E8         003853 |		dbt 0E8h,1h,2h
      FA2B 01               
      FA2C 02               
      FA2D 49         003854 |		dbt "INY IMP"
      FA2E 4E 59 20         
      FA31 49 4D 50         
      FA34 C8         003855 |		dbt 0C8h,1h,2h
      FA35 01               
      FA36 02               
      FA37 4A         003856 |		dbt "JMP ABS"
      FA38 4D 50 20         
      FA3B 41 42 53         
      FA3E 4C         003857 |		dbt 04Ch,3h,3h
      FA3F 03               
      FA40 03               
      FA41 4A         003858 |		dbt "JMP IND"
      FA42 4D 50 20         
      FA45 49 4E 44         
      FA48 6C         003859 |		dbt 06Ch,3h,5h
      FA49 03               
      FA4A 05               
      FA4B 4A         003860 |		dbt "JSR ABS"
      FA4C 53 52 20         
      FA4F 41 42 53         
      FA52 20         003861 |		dbt 020h,3h,6h
      FA53 03               
      FA54 06               
      FA55 4C         003862 |		dbt "LDA IMM"
      FA56 44 41 20         
      FA59 49 4D 4D         
      FA5C A9         003863 |		dbt 0A9h,2h,2h
      FA5D 02               
      FA5E 02               
      FA5F 4C         003864 |		dbt "LDA ABS"
      FA60 44 41 20         
      FA63 41 42 53         
      FA66 AD         003865 |		dbt 0ADh,3h,4h
      FA67 03               
      FA68 04               
      FA69 4C         003866 |		dbt "LDA ABX"
      FA6A 44 41 20         
      FA6D 41 42 58         
      FA70 BD         003867 |		dbt 0BDh,3h,4h
      FA71 03               
      FA72 04               
      FA73 4C         003868 |		dbt "LDA ABY"
      FA74 44 41 20         
      FA77 41 42 59         
      FA7A B9         003869 |		dbt 0B9h,3h,4h
      FA7B 03               
      FA7C 04               
      FA7D 4C         003870 |		dbt "LDA IIR"
      FA7E 44 41 20         
      FA81 49 49 52         
      FA84 A1         003871 |		dbt 0A1h,2h,6h
      FA85 02               
      FA86 06               
      FA87 4C         003872 |		dbt "LDA IRI"
      FA88 44 41 20         
      FA8B 49 52 49         
      FA8E B1         003873 |		dbt 0B1h,2h,5h
      FA8F 02               
      FA90 05               
      FA91 4C         003874 |		dbt "LDX IMM"
      FA92 44 58 20         
      FA95 49 4D 4D         
      FA98 A2         003875 |		dbt 0A2h,2h,2h
      FA99 02               
      FA9A 02               
      FA9B 4C         003876 |		dbt "LDX ABS"
      FA9C 44 58 20         
      FA9F 41 42 53         
      FAA2 AE         003877 |		dbt 0AEh,3h,4h
      FAA3 03               
      FAA4 04               
      FAA5 4C         003878 |		dbt "LDX ABY"
      FAA6 44 58 20         
      FAA9 41 42 59         
      FAAC BE         003879 |		dbt 0BEh,3h,4h
      FAAD 03               
      FAAE 04               
      FAAF 4C         003880 |		dbt "LDY IMM"
      FAB0 44 59 20         
      FAB3 49 4D 4D         
      FAB6 A0         003881 |		dbt 0A0h,2h,2h
      FAB7 02               
      FAB8 02               
      FAB9 4C         003882 |		dbt "LDY ABS"
      FABA 44 59 20         
      FABD 41 42 53         
      FAC0 AC         003883 |		dbt 0ACh,3h,4h
      FAC1 03               
      FAC2 04               
      FAC3 4C         003884 |		dbt "LDY ABX"
      FAC4 44 59 20         
      FAC7 41 42 58         
      FACA BC         003885 |		dbt 0BCh,3h,4h
      FACB 03               
      FACC 04               
      FACD 4C         003886 |		dbt "LSR ACC"
      FACE 53 52 20         
      FAD1 41 43 43         
      FAD4 4A         003887 |		dbt 04Ah,1h,2h
      FAD5 01               
      FAD6 02               
      FAD7 4C         003888 |		dbt "LSR ABS"
      FAD8 53 52 20         
      FADB 41 42 53         
      FADE 4E         003889 |		dbt 04Eh,3h,6h
      FADF 03               
      FAE0 06               
      FAE1 4C         003890 |		dbt "LSR ABX"
      FAE2 53 52 20         
      FAE5 41 42 58         
      FAE8 5E         003891 |		dbt 05Eh,3h,7h
      FAE9 03               
      FAEA 07               
      FAEB 4E         003892 |		dbt "NOP IMP"
      FAEC 4F 50 20         
      FAEF 49 4D 50         
      FAF2 EA         003893 |		dbt 0EAh,1h,2h
      FAF3 01               
      FAF4 02               
      FAF5 4F         003894 |		dbt "ORA IMM"
      FAF6 52 41 20         
      FAF9 49 4D 4D         
      FAFC 09         003895 |		dbt 009h,2h,2h
      FAFD 02               
      FAFE 02               
      FAFF 4F         003896 |		dbt "ORA ABS"
      FB00 52 41 20         
      FB03 41 42 53         
      FB06 0D         003897 |		dbt 00Dh,3h,4h
      FB07 03               
      FB08 04               
      FB09 4F         003898 |		dbt "ORA ABX"
      FB0A 52 41 20         
      FB0D 41 42 58         
      FB10 1D         003899 |		dbt 01Dh,3h,4h
      FB11 03               
      FB12 04               
      FB13 4F         003900 |		dbt "ORA ABY"
      FB14 52 41 20         
      FB17 41 42 59         
      FB1A 19         003901 |		dbt 019h,3h,4h
      FB1B 03               
      FB1C 04               
      FB1D 4F         003902 |		dbt "ORA IIR"
      FB1E 52 41 20         
      FB21 49 49 52         
      FB24 01         003903 |		dbt 001h,2h,6h
      FB25 02               
      FB26 06               
      FB27 4F         003904 |		dbt "ORA IRI"
      FB28 52 41 20         
      FB2B 49 52 49         
      FB2E 11         003905 |		dbt 011h,2h,5h
      FB2F 02               
      FB30 05               
      FB31 50         003906 |		dbt "PHA IMP"
      FB32 48 41 20         
      FB35 49 4D 50         
      FB38 48         003907 |		dbt 048h,1h,3h
      FB39 01               
      FB3A 03               
      FB3B 50         003908 |		dbt "PHP IMP"
      FB3C 48 50 20         
      FB3F 49 4D 50         
      FB42 08         003909 |		dbt 008h,1h,3h
      FB43 01               
      FB44 03               
      FB45 50         003910 |		dbt "PLA IMP"
      FB46 4C 41 20         
      FB49 49 4D 50         
      FB4C 68         003911 |		dbt 068h,1h,4h
      FB4D 01               
      FB4E 04               
      FB4F 50         003912 |		dbt "PLP IMP"
      FB50 4C 50 20         
      FB53 49 4D 50         
      FB56 28         003913 |		dbt 028h,1h,4h
      FB57 01               
      FB58 04               
      FB59 52         003914 |		dbt "ROL ACC"
      FB5A 4F 4C 20         
      FB5D 41 43 43         
      FB60 2A         003915 |		dbt 02Ah,1h,2h
      FB61 01               
      FB62 02               
      FB63 52         003916 |		dbt "ROL ABS"
      FB64 4F 4C 20         
      FB67 41 42 53         
      FB6A 2E         003917 |		dbt 02Eh,3h,6h
      FB6B 03               
      FB6C 06               
      FB6D 52         003918 |		dbt "ROL ABX"
      FB6E 4F 4C 20         
      FB71 41 42 58         
      FB74 3E         003919 |		dbt 03Eh,3h,7h
      FB75 03               
      FB76 07               
      FB77 52         003920 |		dbt "ROR ACC"
      FB78 4F 52 20         
      FB7B 41 43 43         
      FB7E 6A         003921 |		dbt 06Ah,1h,2h
      FB7F 01               
      FB80 02               
      FB81 52         003922 |		dbt "ROR ABS"
      FB82 4F 52 20         
      FB85 41 42 53         
      FB88 6E         003923 |		dbt 06Eh,3h,6h
      FB89 03               
      FB8A 06               
      FB8B 52         003924 |		dbt "ROR ABX"
      FB8C 4F 52 20         
      FB8F 41 42 58         
      FB92 7E         003925 |		dbt 07Eh,3h,7h
      FB93 03               
      FB94 07               
      FB95 52         003926 |		dbt "RTI IMP"
      FB96 54 49 20         
      FB99 49 4D 50         
      FB9C 40         003927 |		dbt 040h,1h,6h
      FB9D 01               
      FB9E 06               
      FB9F 52         003928 |		dbt "RTS IMP"
      FBA0 54 53 20         
      FBA3 49 4D 50         
      FBA6 60         003929 |		dbt 060h,1h,6h
      FBA7 01               
      FBA8 06               
      FBA9 53         003930 |		dbt "SBC IMM"
      FBAA 42 43 20         
      FBAD 49 4D 4D         
      FBB0 E9         003931 |		dbt 0E9h,2h,2h
      FBB1 02               
      FBB2 02               
      FBB3 53         003932 |		dbt "SBC ABS"
      FBB4 42 43 20         
      FBB7 41 42 53         
      FBBA ED         003933 |		dbt 0EDh,3h,4h
      FBBB 03               
      FBBC 04               
      FBBD 53         003934 |		dbt "SBC ABX"
      FBBE 42 43 20         
      FBC1 41 42 58         
      FBC4 FD         003935 |		dbt 0FDh,3h,4h
      FBC5 03               
      FBC6 04               
      FBC7 53         003936 |		dbt "SBC ABY"
      FBC8 42 43 20         
      FBCB 41 42 59         
      FBCE F9         003937 |		dbt 0F9h,3h,4h
      FBCF 03               
      FBD0 04               
      FBD1 53         003938 |		dbt "SBC IIR"
      FBD2 42 43 20         
      FBD5 49 49 52         
      FBD8 E1         003939 |		dbt 0E1h,2h,6h
      FBD9 02               
      FBDA 06               
      FBDB 53         003940 |		dbt "SBC IRI"
      FBDC 42 43 20         
      FBDF 49 52 49         
      FBE2 F1         003941 |		dbt 0F1h,2h,5h
      FBE3 02               
      FBE4 05               
      FBE5 53         003942 |		dbt "SEC IMP"
      FBE6 45 43 20         
      FBE9 49 4D 50         
      FBEC 38         003943 |		dbt 038h,1h,2h
      FBED 01               
      FBEE 02               
      FBEF 53         003944 |		dbt "SED IMP"
      FBF0 45 44 20         
      FBF3 49 4D 50         
      FBF6 F8         003945 |		dbt 0F8h,1h,2h
      FBF7 01               
      FBF8 02               
      FBF9 53         003946 |		dbt "SEI IMP"
      FBFA 45 49 20         
      FBFD 49 4D 50         
      FC00 78         003947 |		dbt 078h,1h,2h
      FC01 01               
      FC02 02               
      FC03 53         003948 |		dbt "STA ABS"
      FC04 54 41 20         
      FC07 41 42 53         
      FC0A 8D         003949 |		dbt 08Dh,3h,4h
      FC0B 03               
      FC0C 04               
      FC0D 53         003950 |		dbt "STA ABX"
      FC0E 54 41 20         
      FC11 41 42 58         
      FC14 9D         003951 |		dbt 09Dh,3h,5h
      FC15 03               
      FC16 05               
      FC17 53         003952 |		dbt "STA ABY"
      FC18 54 41 20         
      FC1B 41 42 59         
      FC1E 99         003953 |		dbt 099h,3h,5h
      FC1F 03               
      FC20 05               
      FC21 53         003954 |		dbt "STA IIR"
      FC22 54 41 20         
      FC25 49 49 52         
      FC28 81         003955 |		dbt 081h,2h,6h
      FC29 02               
      FC2A 06               
      FC2B 53         003956 |		dbt "STA IRI"
      FC2C 54 41 20         
      FC2F 49 52 49         
      FC32 91         003957 |		dbt 091h,2h,6h
      FC33 02               
      FC34 06               
      FC35 53         003958 |		dbt "STX ABS"
      FC36 54 58 20         
      FC39 41 42 53         
      FC3C 8E         003959 |		dbt 08Eh,3h,4h
      FC3D 03               
      FC3E 04               
      FC3F 53         003960 |		dbt "STY ABS"
      FC40 54 59 20         
      FC43 41 42 53         
      FC46 8C         003961 |		dbt 08Ch,3h,4h
      FC47 03               
      FC48 04               
      FC49 54         003962 |		dbt "TAX IMP"
      FC4A 41 58 20         
      FC4D 49 4D 50         
      FC50 AA         003963 |		dbt 0AAh,1h,2h
      FC51 01               
      FC52 02               
      FC53 54         003964 |		dbt "TAY IMP"
      FC54 41 59 20         
      FC57 49 4D 50         
      FC5A A8         003965 |		dbt 0A8h,1h,2h
      FC5B 01               
      FC5C 02               
      FC5D 54         003966 |		dbt "TSX IMP"
      FC5E 53 58 20         
      FC61 49 4D 50         
      FC64 BA         003967 |		dbt 0BAh,1h,2h
      FC65 01               
      FC66 02               
      FC67 54         003968 |		dbt "TXA IMP"
      FC68 58 41 20         
      FC6B 49 4D 50         
      FC6E 8A         003969 |		dbt 08Ah,1h,2h
      FC6F 01               
      FC70 02               
      FC71 54         003970 |		dbt "TXS IMP"
      FC72 58 53 20         
      FC75 49 4D 50         
      FC78 9A         003971 |		dbt 09Ah,1h,2h
      FC79 01               
      FC7A 02               
      FC7B 54         003972 |		dbt "TYA IMP"
      FC7C 59 41 20         
      FC7F 49 4D 50         
      FC82 98         003973 |		dbt 098h,1h,2h
      FC83 01               
      FC84 02               
      FC85 5A         003974 |		dbt "ZZZ ZZZ"
      FC86 5A 5A 20         
      FC89 5A 5A 5A         
      FC8C 00         003975 |		dbt 000h,0h,0h
      FC8D 00               
      FC8E 00               
                      003976 |		
                      003977 |;****************************************************************************
                      003978 |;       Initialize 6502 reset vector and maskable interrupt vector.
                      003979 |;****************************************************************************
      FFFC            003980 |	org 0fffch	;Initialize reset vector.
      FFFC 00         003981 |	dbt 00h,0e0h	;                                                                                         
      FFFD E0               
                      003982 |;	
      FFFE            003983 |	org 0fffeh	;Initialize maskable interrupt vector.
      FFFE EA         003984 |	dbt #MaskInt<	;
      FFFF E1         003985 |	dbt #MaskInt>	;
                      003986 |		end
                      003987 |		
                      003988 |; ,output="array",start_address="E000"
      
      *** Executable code ***
      
      %s19,descrption="Execute this fold to send program to U6502 monitor.",preserve="false",output="array",start_address="E000"
      	S007000055415347C8
      	S11700000000000000000000000000000000000000000000E8
      	S11700140000000000000000000000000000000000000000D4
      	S11700280000000000000000000000000000000000000000C0
      	S117003C0000000000000000000000000000000000000000AC
      	S1170050000000000000000000000000000000000000000098
      	S1170064000000000000000000000000000000000000000084
      	S1170078000000000000000000000000000000000000000070
      	S117008C00000000000000000000000000000000000000005C
      	S11700A0000000000000000000000000000000000000000048
      	S11700B4000000000000000000000000000000000000000034
      	S10B00C800000000000000002C
      	S117E0004C1BE04CF3F34CAFF34CD2F34C92F34CE2F24C3E15
      	S117E014F34C72EA4C87E0A2FF9AD82072F34C25E0A254A027
      	S117E028F42092F3A9008D4B00A9008D47008D48008D49009E
      	S117E03CA9FF8D4A004C20E2C902D01329F04A4A4A1869C019
      	S117E0508D0900A9008D08006C08004C5EE0A0008C4400A2D4
      	S117E06464C8D0FDCAD0FAEE4400AD44004C63E02080E020C5
      	S117E078F2E0204AE14C74E0A2A4A0F42092F3A0008C5E00CA
      	S117E08C8CCD008C5F008C73008C8700A000A90099A500C8D7
      	S117E0A0C027D0F8A00020D2F3C900F0F9C908D0034CB8E0FA
      	S117E0B4C97FD01588300DA92020F3F3A90820F3F34CA6E00A
      	S117E0C8A0004CA6E0C90DF00D99A500C8C027D0CDA0274C5E
      	S117E0DCA6E088B9A500C90AF001C8A90099A50060A0FF4C02
      	S117E0F00FE1A000B9A500F050C93F304BC95A100338B00841
      	S117E104C9613040C97A103C8DCD00C8C014F034B9A500C999
      	S117E11800F02EC920F0F0AE5E008A1869148D5E00B9A50094
      	S117E12CC920F010C900F00C9D5F00E8C8C028F00B4C29E148
      	S117E140A9009D5F004C0FE1606038ADCD0020EDF2C96CD070
      	S117E154062069E94CDDE1C964D006203BE74CDDE1C972D0D7
      	S117E16806201FEB4CDDE1C967D00620E0E84CDDE1C965D06F
      	S117E17C062039E84CDDE1C966D006209FE84CDDE1C975D076
      	S117E1900620B0EF4CDDE1C974D0062075ED4CDDE1C962D00E
      	S117E1A40620D3E54CDDE1C973D00620E4EC4CDDE1C96DD069
      	S117E1B80620B3EA4CDDE1C961D006204AE24CDDE1C968D02B
      	S117E1CC062061E94CDDE1C93FD0062061E94CDDE1B009A214
      	S117E1E01FA0F62092F318603860788D440068482910D006B5
      	S117E1F4AD44006C02006C0400688D4B00AD44008D47008EB1
      	S117E20848008C4900BAE8E88E4A006838E9018D450068E9D2
      	S117E21C008D4600A0008C5F00201FEBAD3900C901D0034C93
      	S117E2302BEFA003A206B92F00C901D005B93300811288CA19
      	S117E244CA10EF4C74E0A20020C3F2B0034C40E38E08008C9E
      	S117E2580900A2A8A0F42092F32005F32087E020EDE0AD5F8A
      	S117E26C00C900F004C920D0034C42E3A000B95F0020F9F2ED
      	S117E280995F00C8C003D0F22044E3B0282005F3A92020F32E
      	S117E294F3A25FA0002092F3A92020F3F3A273A0002092F310
      	S117E2A8A92020F3F3A93F20F3F34C5AE2207CE3B0034C8D0E
      	S117E2BCE22071E4B0034C8DE22091E4B0034C8DE22005F36A
      	S117E2D0A000AD1A009108203EF320BAF2A92020F3F3AD1D80
      	S117E2E400F028AD1B009108203EF320BAF2A92020F3F3AD10
      	S117E2F81E00F01EAD1C009108203EF320BAF2A92020F3F394
      	S117E30C4C25E3A92020F3F320F3F320F3F3A92020F3F320DB
      	S117E320F3F320F3F3A92020F3F3A25FA0002092F3A92020FB
      	S117E334F3F3A273A0002092F34C5AE218603860A2258E0A9A
      	S117E34800A2F88E0B00A000B10AD95F00F019AD0A001869B6
      	S117E35C0A8D0A009003EE0B00A004B10AC95AF00B4C4EE382
      	S117E370C8C003F0054C50E318603860A000B97300C900D021
      	S117E38408A9508D1F004C6FE4C923D008A94D8D1F004C6F14
      	S117E398E4C941F007C961F0034CBBE3C8B97300C900F007CD
      	S117E3ACC920F0034CBBE3A9438D1F004C6FE4A006B10AC932
      	S117E3C04CD0068D1F004C6FE4A000B97300C928D0034C15E7
      	S117E3D4E4A000B97300C92CF008C900F02BC84CD7E3C8B961
      	S117E3E87300C958F00FC978F00BC959F00FC979F00B4C6D37
      	S117E3FCE4A9588D1F004C6FE4A9598D1F004C6FE4A9538D03
      	S117E4101F004C6FE4C8B97300C92CF00BC929F01EC00BD0B7
      	S117E424F04C6DE4C8B97300C958F007C978F0034C6DE4A9CD
      	S117E438528D1F004C6FE4C8B97300C900F016C92CF0034C38
      	S117E44C6DE4C8B97300C959F00FC979F00B4C6DE4A9448DFE
      	S117E4601F004C6FE4A9498D1F004C6FE418603860A006B142
      	S117E4740ACD1F00F015AD0A0018690A8D0A009003EE0B0030
      	S117E488204EE3B0E418603860A9008D1D008D1E00A007B131
      	S117E49C0A8D1A00AD1F00C950F027C943F026C94DF025C9A5
      	S117E4B053F03CC958F038C959F034C949F058C952F054C9C4
      	S117E4C444F050C94CF0244CAAE54CACE54CACE520AEE5B09B
      	S117E4D8034CAAE5201CF3B0034CAAE58D1B00A9018D1D0095
      	S117E4EC4CACE520AEE5B0034CAAE520C3F2B0034CAAE5ADEA
      	S117E5001F00C94CF0488E1B008C1C00A9018D1D008D1E0047
      	S117E5144CACE520AEE5B0034CAAE520C3F2B0034CAAE5ADC1
      	S117E5281F00C944F00FC000D0788E1B00A9018D1D004CACB3
      	S117E53CE58E1B008C1C00A9018D1D008D1E004CACE58E2BFC
      	S117E550008C2C00AD08008D2D00AD09008D2E00A008B10AB8
      	S117E564186D2D008D2D009003EE2E0038AD2B00ED2D008DCD
      	S117E5782B00AD2C00ED2E008D2C00AD2C00C9FFF00EC9004B
      	S117E58CD01CAD2B00C98010154C9FE5AD2B00C980300B8D8C
      	S117E5A01B00A9018D1D004CACE518603860A214A000BD5F95
      	S117E5B400D932F4F017D943F4F012C8C010F0034CB5E5E8DE
      	S117E5C8E01FF0034CB0E518603860AD5F00C92BF00BC92D67
      	S117E5DCF00AC93FF0094CF3E64C5FE64C1BE6A2A8A0F4202B
      	S117E5F092F3A0FFA2FFC8E8B912008D0800C8B912008D0915
      	S117E60400BD2F00F0032005F3C007D0E5A2A8A0F42092F308
      	S117E6184CF3E6AD7300C900F00AA21420C3F2B0104CF3E672
      	S117E62CA003A900992F008810F84CF3E68E2B008C2C00A0FC
      	S117E64003A20620F4E6B00F88CACA10F6A2B5A0F52092F3AB
      	S117E6544CF3E6A900992F004CF3E6AD7300C900F007A2145D
      	S117E66820C3F2B0034CF3E68E2B008C2C00A003A206B92F49
      	S117E67C00C900F00520F4E6B0E788CACA10EFA000B92F0094
      	S117E690C900F00FC8C004D0F4A28DA0F52092F34CF3E68C40
      	S117E6A43700A901992F00C000D00FAD2B008D1200AD2C00C6
      	S117E6B88D13004CF3E6C001D00FAD2B008D1400AD2C008D06
      	S117E6CC15004CF3E6C002D00FAD2B008D1600AD2C008D1763
      	S117E6E0004CF3E6AD2B008D1800AD2C008D19004CF3E6607C
      	S117E6F4C000D00BAD2C00CD1300F02C4C39E7C001D00BADE9
      	S117E7082C00CD1500F01D4C39E7C002D00BAD2C00CD170018
      	S117E71CF00E4C39E7AD2C00CD1900F0034C39E7AD2B00DDA8
      	S117E7301200F0034C39E738601860A200BD5F00C900F03A9F
      	S117E744201CF3B0034CFFE78D0900E8201CF3B0034CFFE717
      	S117E7588D0800A214BD5F00C900F01A201CF3B0034CFFE75B
      	S117E76C8D5D00E8201CF3B0034CFFE78D5C004C95E7AD0948
      	S117E780008D5D00AD08008D5C0018690F8D5C009003EE5DA2
      	S117E79400A90D20F3F3A90A20F3F3A200A0002005F3B108E5
      	S117E7A82023E8203EF3E8E010D003200BE8E008D012A9208C
      	S117E7BC20F3F3A92D20F3F3A92020F3F34CD1E7A92020F3B4
      	S117E7D0F3AD0800CD5C00D008AD0900CD5D00F020EE0800A2
      	S117E7E4D003EE0900E010D00FA90A20F3F3A90D20F3F320EF
      	S117E7F805F3A2004CA6E71860EE0800D003EE09003860A91D
      	S117E80C2020F3F3A92020F3F3A200BD4C0020F3F3E8E01076
      	S117E820D0F56048C920300AC97F10069D4C004C37E8A92EC7
      	S117E8349D4C006860AD5F00C900D0034C67E8AD7300C900EF
      	S117E848D0034C67E8A20020C3F2B0034C67E88E08008C095A
      	S117E85C00A214206BE890034C69E818603860A0008CCF0040
      	S117E870BD5F00F028201CF3B0034C9DE89108EE0800D00347
      	S117E884EE0900EECF00ADCF00C90AF00AE8BD5F00F004E89F
      	S117E8984C70E838601860A20020C3F2B0034CDCE88E0800E4
      	S117E8AC8C0900A21420C3F2B0034CDCE88E5C008C5D00A2FC
      	S117E8C028206BE89016AD5D00CD0900F0034CBFE8AD5C0030
      	S117E8D4CD0800F0054CBFE818603860AD5F00C900F010A2E8
      	S117E8E80020C3F2B0034C5DE98E45008C4600AE45008E2BAD
      	S117E8FC00AC46008C2C00A003A206B92F00C900F00520F455
      	S117E910E6B00888CACA10EF4C25E9A2DDA0F52092F34C5F78
      	S117E924E9A003A206B92F00C901D009A112993300A9008173
      	S117E9381288CACA10EB68686868AD5F00C900F011A2FF9AED
      	S117E94CAD4B0048AD4700AE4800AC4900286C45001860380B
      	S117E96060A223A0F62092F360A2ABA0F42092F320D2F3A2D2
      	S117E974A8A0F42092F34C80E920D2F3C953D0F920F3F32005
      	S117E988D2F320F3F38DA100C930D0082095EA90254CBBE969
      	S117E99CC931D008209FEA90194CBBE9C939D01220A9EA9028
      	S117E9B00DA2F4A0F42092F34CC7E94C7DE9A2D4A0F4209209
      	S117E9C4F3386020D2F33860A9008D9F008DA000203CEA8D5E
      	S117E9D89E002063EAAACACACA8A8D9B00203CEA8D09002066
      	S117E9EC63EA203CEA8D08002063EA60AD9B00F00B203CEA95
      	S117EA002063EACE9B00D0F560AD9B00F017A000203CEA20AE
      	S117EA1463EA9108EE0800D003EE0900CE9B00D0EB60AD9F74
      	S117EA280049FF8D9D00203CEACD9D00F004184C3BEA38609F
      	S117EA3C984820D2F32072EA901C0A0A0A0A29F08D9C00204B
      	S117EA50D2F32072EA900B0D9C008D9C0068A8AD9C006048FF
      	S117EA64186D9F008D9F009003EEA00068608ECE00A200DD86
      	S117EA7832F4F013DD43F4F00EE8E010F0034C77EAA9001812
      	S117EA8C4C94EA8A38AECE006020CCE920F8E92026EA602084
      	S117EAA0CCE92009EA2026EA6020CCE920F8E92026EA60ADF3
      	S117EAB45F00C900F007A20020C3F2B0034C1EEB8E08008C8A
      	S117EAC80900A21420C3F2B0034C1EEB8E5C008C5D00EE5C7D
      	S117EADC00D003EE5D00A22820C3F2B0034C1EEB8E0A008C39
      	S117EAF00B00A000B108910AEE0A00D003EE0B00EE0800D085
      	S117EB0403EE0900AD0800CD5C00F0034CF4EAAD0900CD5D24
      	S117EB1800F0034CF4EA60488A48984808AD5F00C900F0039E
      	S117EB2C4C97EBA232A0F52092F3A00320E2F2AD4600203E0D
      	S117EB40F3AD4500203EF3A00920E2F2AD4700203EF3A009FC
      	S117EB5420E2F2AD4800203EF3A00820E2F2AD4900203EF38C
      	S117EB68A00820E2F2AD4A00203EF3A00720E2F2AD4B00A27C
      	S117EB7C082AB00A48A93020F3F3684C91EB48A93120F3F316
      	S117EB9068CAD0E94CDCECA90D20F3F3A90A20F3F3AD5F00ED
      	S117EBA420EDF2C970D03CAD4600203EF3AD4500203EF3206E
      	S117EBB8DAF22087E020EDE0AD5F00C900D0034CDCECA200A7
      	S117EBCC201CF3B0034CDCECA8E8201CF3B0034CDCEC8D45E3
      	S117EBE0008C46004CDCECC961D029AD4700203EF320DAF2E3
      	S117EBF42087E020EDE0AD5F00C900D0034CDCECA200201CFB
      	S117EC08F3B0034CDCEC8D47004CDCECC978D029AD48002003
      	S117EC1C3EF320DAF22087E020EDE0AD5F00C900D0034CDC7F
      	S117EC30ECA200201CF3B0034CDCEC8D48004CDCECC979D04D
      	S117EC4429AD4900203EF320DAF22087E020EDE0AD5F00C913
      	S117EC5800D0034CDCECA200201CF3B0034CDCEC8D49004C03
      	S117EC6CDCECC973F0034CD8ECAD600020EDF2C970F007C984
      	S117EC8072F02C4CD8ECAD4A00203EF320DAF22087E020ED16
      	S117EC94E0AD5F00C900D0034CDCECA200201CF3B0034CDC20
      	S117ECA8EC8D4A004CDCECAD4B00203EF320DAF22087E020A1
      	S117ECBCEDE0AD5F00C900D0034CDCECA200201CF3B0034CE7
      	S117ECD0DCEC8D4B004CDCEC184CDDEC382868A868AA686001
      	S117ECE4AD5F00C900F007A20020C3F2B0034C74ED8E0A00DD
      	S117ECF88C0B00A21420C3F2B0034C74ED8E5C008C5D00EEC1
      	S117ED0C5C00D003EE5D00A228A9208D0800A9008D090020EE
      	S117ED206BE89050ADCF008D2A00AD0A008D0800AD0B008DE4
      	S117ED340900A2A8A0F42092F3A200A000B108DD2000F0193A
      	S117ED4820BAF2AD0800CD5C00F0034C3DEDAD0900CD5D00C0
      	S117ED5CF0164C3DEDC8E8EC2A00F0034C41ED2005F320BAFE
      	S117ED70F24C3DED60AD5F00C900F017A20020C3F2B0034C71
      	S117ED847CEF8E45008C4600AD7300C900D008A0018C3E003B
      	S117ED984CA8EDA214201CF3B0034C7CEF8D3E0068686868C8
      	S117EDACAC45008C0800AC46008C0900A000B1088D430020FA
      	S117EDC080EFB0034C7CEFA008B10A8D3A00A001AD4300C9DE
      	S117EDD460D028A9028D3D00688D1000688D110048AD10004A
      	S117EDE848EE1000D003EE1100A000B1108D3C00A900911087
      	S117EDFC4C0BEFC94CD01EA9028D3D00B1088D1000C8B1086A
      	S117EE108D1100A000B1108D3C00A90091104C0BEFC96CD08D
      	S117EE242BA9028D3D00B1088D0C00C8B1088D0D00A000B178
      	S117EE380C8D1000C8B10C8D1100A000B1108D3C00A9009192
      	S117EE4C104C0BEFC920D01EA9028D3D00B1088D1000C8B13D
      	S117EE60088D1100A000B1108D3C00A90091104C0BEFA0009A
      	S117EE74B10AC942D008A001B10AC949D0034CE8EEA9018D4E
      	S117EE883D0018AD08006D3A008D1000AD090069008D110067
      	S117EE9CA001B1088D38001020CE3800AD380049FF8D380017
      	S117EEB038AD1000ED38008D1000AD1100E9008D11004CDA28
      	S117EEC4EE18AD10006D38008D1000AD110069008D11004C20
      	S117EED8DAEEA000B1108D3C00A90091104CEDEEA9008D3D4C
      	S117EEEC00AC3A00B1088D3B0018AD08006D3A008D0E00ADEB
      	S117EF00090069008D0F00A9009108A9018D3900AD5F00C964
      	S117EF1400F003A2FF9AAD4B0048AD4700AE4800AC49002870
      	S117EF286C4500A9008D3900A000AD3D00C900F011C901F0A3
      	S117EF3C08AD3C0091104C4FEFAD3C009110AD3B00910EACE4
      	S117EF5045008C0800AC46008C0900A2A8A0F42092F3AD0811
      	S117EF64008D5C00AD09008D5D0020FFEFCE3E00F0034CAC07
      	S117EF78ED4C74E018603860A2258E0A00A2F88E0B00A004AE
      	S117EF8CB10AC95AF01CA007B10ACD4300F011AD0A001869D8
      	S117EFA00A8D0A009003EE0B004C8AEF38601860AD5F00C982
      	S117EFB400F017A20020C3F2B0034CA4F28E08008C0900AD5A
      	S117EFC87300C900D021AD08008D5C00AD09008D5D0018AD01
      	S117EFDC080069148D5C009007AE5D00E88E5D004CFFEFA25E
      	S117EFF01420C3F2B0034CA4F28E5C008C5D00AD5D00CD09D8
      	S117F00400F005900E4C1AF0AD5C00CD080090034C1AF04CF8
      	S117F018A6F2A000B1088D43002080EFB01DA2A8A0F4209233
      	S117F02CF32005F3AD4300203EF3A281A0F52092F320BAF257
      	S117F0404CFFEFA2A8A0F42092F32005F320BAF2A006B10AB6
      	S117F054C950D0034C9DF0C94DD0034CC4F0C953D0034CF7C4
      	S117F068F0C958D0034CF7F0C959D0034CF7F0C952D0034C17
      	S117F07C14F2C94CD0034C61F1C943D0034CAEF0C944D00347
      	S117F0904C56F2C949D0034CD2F14C26F0AD4300203EF3A09D
      	S117F0A40820E2F220A8F24CFFEFAD4300203EF3A00820E279
      	S117F0B8F220A8F2A94120F3F34CFFEFA000AD4300203EF389
      	S117F0CCA92020F3F3B1088D4100203EF320BAF2A00520E212
      	S117F0E0F220A8F2A92320F3F3AD4100203EF3A96820F3F344
      	S117F0F44CFFEFA000AD4300203EF3A92020F3F3B1088D4193
      	S117F10800203EF320BAF2A92020F3F3B1088D4200203EF32A
      	S117F11C20BAF2A00220E2F220A8F2AD4200203EF3AD410091
      	S117F130203EF3A96820F3F3A006B10AC958F007C959F010C4
      	S117F1444CFFEFA92C20F3F3A95820F3F34CFFEFA92C20F375
      	S117F158F3A95920F3F34CFFEFA000AD4300203EF3A92020A0
      	S117F16CF3F3B1088D4100203EF320BAF2A00520E2F220A8A0
      	S117F180F2AD08008D3F00AD09008D4000AD41003012AD3F65
      	S117F19400186D41008D3F009020EE40004CBEF1CE4100AD3C
      	S117F1A8410049FF8D4100AD3F0038ED41008D3F00B003CE59
      	S117F1BC4000AD4000203EF3AD3F00203EF3A96820F3F34C1D
      	S117F1D0FFEFA000AD4300203EF3A92020F3F3B1088D410002
      	S117F1E4203EF320BAF2A00520E2F220A8F2A92820F3F3AD1F
      	S117F1F84100203EF3A96820F3F3A92920F3F3A92C20F3F3A3
      	S117F20CA95920F3F34CFFEFA000AD4300203EF3A92020F3EB
      	S117F220F3B1088D4100203EF320BAF2A00520E2F220A8F2EC
      	S117F234A92820F3F3AD4100203EF3A96820F3F3A92C20F3AD
      	S117F248F3A95820F3F3A92920F3F34CFFEFA000AD430020F2
      	S117F25C3EF3A92020F3F3B1088D4100203EF320BAF2A9202D
      	S117F27020F3F3B1088D4200203EF320BAF2A00220E2F22025
      	S117F284A8F2A92820F3F3AD4200203EF3AD4100203EF3A9D9
      	S117F2986820F3F3A92920F3F34CFFEF18603860A000B10A73
      	S117F2AC20F3F3C8C003D0F6A92020F3F360EE0800D003EE0D
      	S117F2C0090060201CF3B0034CD8F2A8E8201CF3B0034CD83F
      	S117F2D4F2AA38601860A27CA0F52092F36048A92020F3F3A7
      	S117F2E888D0F86860C9413007C95B100318692060C9613023
      	S117F2FC07C97B100338E92060AD0900203EF3AD0800203EE1
      	S117F310F3A92020F3F3A92020F3F360BD5F002072EA9019B3
      	S117F3240A0A0A0A29F08D9C00E8BD5F002072EA90070D9CA7
      	S117F338008D9C0038608D9C004A4A4A4A290FC90A10050982
      	S117F34C304C55F338E909094020F3F3AD9C00290FC90A1008
      	S117F3600509304C6BF338E909094020F3F3AD9C0060A9FDE5
      	S117F3748D0400A9E18D0500A9008D3900A9008D2F008D3043
      	S117F388008D31008D3200A90060488E06008C0700A000B127
      	S117F39C06F00E20F3F3EE0600D003EE07004C9BF3686008E9
      	S117F3B08A489848AD01A02908F009AD00A08DCE004CC9F36B
      	S117F3C4A9008DCE0068A868AA28ADCE0060088A489848ADA1
      	S117F3D801A02908D006AD02A04CD7F3AD00A08DCE0068A858
      	S117F3EC68AA28ADCE00608DCE000898488A48AD01A0291058
      	S117F400F0F9ADCE008D00A068AA68A828ADCE0060488A4824
      	S117F4149848A9008DA200A9108DA300CEA200D0FBCEA30093
      	S117F428D0F668A868AA6860160B30313233343536373839EE
      	S117F43C4142434445460030313233343536373839616263F0
      	S117F450646566000A0D0A554D4F4E36352056312E3138204C
      	S117F4642D20556E6465727374616E6461626C65204D6F6E4D
      	S117F47869746F7220666F7220746865203635303020736513
      	S117F48C72696573206D6963726F70726F636573736F727328
      	S117F4A02E0A0D000A0D2D000A0D000A0D53656E6420532080
      	S117F4B47265636F726473207768656E20796F7520617265A7
      	S117F4C82072656164792E2E2E0A0D000A0D074572726F722E
      	S117F4DC204C6F6164696E672053205265636F7264732E2E79
      	S117F4F02E0A0D000A0D0753207265636F72647320737563D1
      	S117F5046365737366756C6C79206C6F616465642028707262
      	S117F518657373203C656E7465723E20746F20636F6E746998
      	S117F52C6E7565292E000A0D0A50676D436E74722850432968
      	S117F5402020416363756D284143292020585265672858522D
      	S117F5542920205952656728595229202053746B50747228F3
      	S117F56853502920204E562D4244495A43285352290A0D0035
      	S117F57C0A0D203A0020202020202020203F3F3F000A0D41F1
      	S117F5906C6C20627265616B706F696E7473206172652063EE
      	S117F5A4757272656E746C7920696E207573652E000A0D4ED3
      	S117F5B86F20627265616B706F696E7420657869737473209D
      	S117F5CC6174207468697320616464726573732E000A0D59D6
      	S117F5E06F752063616E6E6F7420474F20617420612062726C
      	S117F5F465616B706F696E74656420616464726573732C2089
      	S117F60854524143452070617374206974207468656E204770
      	S117F61C4F2E000A0D3F000A0D0A417373656D626C65202076
      	S117F6302020202020412073746172745F616464726573734E
      	S117F6440A0D427265616B706F696E7420202020204220285E
      	S117F6582B2C2D2C3F2920616464726573730A0D44756D70CF
      	S117F66C202020202020202020202044205B73746172745FDA
      	S117F68061646472657373205B656E645F6164647265737395
      	S117F6945D5D0A0D456E74657220202020202020202020450A
      	S117F6A82061646472657373206C6973740A0D46696C6C20AA
      	S117F6BC20202020202020202020462073746172745F61643E
      	S117F6D0647265737320656E645F61646472657373206C6970
      	S117F6E473740A0D476F202020202020202020202020204773
      	S117F6F8205B73746172745F616464726573735D0A0D4865EB
      	S117F70C6C70202020202020202020202048206F72203F0AF7
      	S117F7200D4C6F616420202020202020202020204C0A0D4D34
      	S117F7346F766520202020202020202020204D2073746172EC
      	S117F748745F6164647265737320656E645F616464726573C7
      	S117F75C732064657374696E6174696F6E5F6164647265738E
      	S117F770730A0D526567697374657220202020202020522060
      	S117F7845B50432C41432C58522C59522C53502C53525D0A1B
      	S117F7980D536561726368202020202020202020532073747C
      	S117F7AC6172745F6164647265737320656E645F6164647268
      	S117F7C0657373206C6973740A0D5472616365202020202064
      	S117F7D4202020202054205B73746172745F616464726573AE
      	S117F7E873205B76616C75655D5D0A0D556E617373656D62EF
      	S117F7FC6C65202020202055205B73746172745F616464728C
      	S117F810657373205B656E645F616464726573735D5D0A0DCD
      	S117F8240041444320494D4D690202414443204142536D0366
      	S117F83804414443204142587D03044144432041425979032D
      	S117F84C04414443204949526102064144432049524971022C
      	S117F86005414E4420494D4D290202414E44204142532D038F
      	S117F87404414E44204142583D0304414E442041425939035B
      	S117F88804414E4420494952210206414E442049524931025A
      	S117F89C0541534C204143430A010241534C204142530E0394
      	S117F8B00641534C204142581E03074243432052454C9002DA
      	S117F8C4024243532052454CB002024245512052454CF002CE
      	S117F8D802424954204142532C0304424D492052454C300201
      	S117F8EC02424E452052454CD0020242504C2052454C100263
      	S117F9000242524B20494D500001074256432052454C5002D0
      	S117F914024256532052454C700202434C4320494D50180186
      	S117F92802434C4420494D50D80102434C4920494D505801DA
      	S117F93C02434C5620494D50B80102434D5020494D4DC9025D
      	S117F95002434D5020414253CD0304434D5020414258DD0338
      	S117F96404434D5020414259D90304434D5020494952C10224
      	S117F97806434D5020495249D1020543505820494D4DE002E5
      	S117F98C0243505820414253EC030443505920494D4DC002DC
      	S117F9A00243505920414253CC030444454320414253CE0305
      	S117F9B40644454320414258DE030744455820494D50CA01D4
      	S117F9C80244455920494D50880102454F5220494D4D49027E
      	S117F9DC02454F52204142534D0304454F52204142585D03A0
      	S117F9F004454F5220414259590304454F522049495241028C
      	S117FA0406454F5220495249510205494E4320414253EE03E1
      	S117FA1806494E4320414258FE0307494E5820494D50E80115
      	S117FA2C02494E5920494D50C801024A4D50204142534C03D3
      	S117FA40034A4D5020494E446C03054A53522041425320034D
      	S117FA54064C444120494D4DA902024C444120414253AD039C
      	S117FA68044C444120414258BD03044C444120414259B90369
      	S117FA7C044C444120494952A102064C444120495249B10268
      	S117FA90054C445820494D4DA202024C445820414253AE0339
      	S117FAA4044C445820414259BE03044C445920494D4DA0020F
      	S117FAB8024C445920414253AC03044C445920414258BC03FF
      	S117FACC044C5352204143434A01024C5352204142534E03C1
      	S117FAE0064C5352204142585E03074E4F5020494D50EA01D6
      	S117FAF4024F524120494D4D0902024F5241204142530D031E
      	S117FB08044F5241204142581D03044F5241204142591903E6
      	S117FB1C044F5241204949520102064F5241204952491102E5
      	S117FB300550484120494D5048010350485020494D50080196
      	S117FB4403504C4120494D50680104504C5020494D5028013B
      	S117FB5804524F4C204143432A0102524F4C204142532E037C
      	S117FB6C06524F4C204142583E0307524F52204143436A0106
      	S117FB8002524F52204142536E0306524F52204142587E039C
      	S117FB940752544920494D5040010652545320494D506001B6
      	S117FBA80653424320494D4DE9020253424320414253ED03B9
      	S117FBBC0453424320414258FD030453424320414259F90386
      	S117FBD00453424320494952E1020653424320495249F10285
      	S117FBE40553454320494D5038010253454420494D50F8010D
      	S117FBF80253454920494D50780102535441204142538D0323
      	S117FC0C04535441204142589D0305535441204142599903D4
      	S117FC200553544120494952810206535441204952499102D3
      	S117FC3406535458204142538E0304535459204142538C03A3
      	S117FC480454415820494D50AA010254415920494D50A80163
      	S117FC5C0254535820494D50BA010254584120494D508A014E
      	S117FC700254585320494D509A010254594120494D5098014B
      	S10EFC84025A5A5A205A5A5A00000033
      	S105FFFC00E01F
      	S105FFFEEAE132
      	S9030000FC
      %/s19

          %output,sequence="11",timestamp="2015-02-04 00:48:13.209",preserve="false"
            {76,27,224,76,243,243,76,175,243,76,210,243,76,146,243,76,226,242,76,62,243,76,114,234,76,135,224,162,255,154,216,32,114,243,76,37,224,162,84,160,244,32,146,243,169,0,141,75,0,169,0,141,71,0,141,72,0,141,73,0,169,255,141,74,0,76,32,226,201,2,208,19,41,240,74,74,74,24,105,192,141,9,0,169,0,141,8,0,108,8,0,76,94,224,160,0,140,68,0,162,100,200,208,253,202,208,250,238,68,0,173,68,0,76,99,224,32,128,224,32,242,224,32,74,225,76,116,224,162,164,160,244,32,146,243,160,0,140,94,0,140,205,0,140,95,0,140,115,0,140,135,0,160,0,169,0,153,165,0,200,192,39,208,248,160,0,32,210,243,201,0,240,249,201,8,208,3,76,184,224,201,127,208,21,136,48,13,169,32,32,243,243,169,8,32,243,243,76,166,224,160,0,76,166,224,201,13,240,13,153,165,0,200,192,39,208,205,160,39,76,166,224,136,185,165,0,201,10,240,1,200,169,0,153,165,0,96,160,255,76,15,225,160,0,185,165,0,240,80,201,63,48,75,201,90,16,3,56,176,8,201,97,48,64,201,122,16,60,141,205,0,200,192,20,240,52,185,165,0,201,0,240,46,201,32,240,240,174,94,0,138,24,105,20,141,94,0,185,165,0,201,32,240,16,201,0,240,12,157,95,0,232,200,192,40,240,11,76,41,225,169,0,157,95,0,76,15,225,96,96,56,173,205,0,32,237,242,201,108,208,6,32,105,233,76,221,225,201,100,208,6,32,59,231,76,221,225,201,114,208,6,32,31,235,76,221,225,201,103,208,6,32,224,232,76,221,225,201,101,208,6,32,57,232,76,221,225,201,102,208,6,32,159,232,76,221,225,201,117,208,6,32,176,239,76,221,225,201,116,208,6,32,117,237,76,221,225,201,98,208,6,32,211,229,76,221,225,201,115,208,6,32,228,236,76,221,225,201,109,208,6,32,179,234,76,221,225,201,97,208,6,32,74,226,76,221,225,201,104,208,6,32,97,233,76,221,225,201,63,208,6,32,97,233,76,221,225,176,9,162,31,160,246,32,146,243,24,96,56,96,120,141,68,0,104,72,41,16,208,6,173,68,0,108,2,0,108,4,0,104,141,75,0,173,68,0,141,71,0,142,72,0,140,73,0,186,232,232,142,74,0,104,56,233,1,141,69,0,104,233,0,141,70,0,160,0,140,95,0,32,31,235,173,57,0,201,1,208,3,76,43,239,160,3,162,6,185,47,0,201,1,208,5,185,51,0,129,18,136,202,202,16,239,76,116,224,162,0,32,195,242,176,3,76,64,227,142,8,0,140,9,0,162,168,160,244,32,146,243,32,5,243,32,135,224,32,237,224,173,95,0,201,0,240,4,201,32,208,3,76,66,227,160,0,185,95,0,32,249,242,153,95,0,200,192,3,208,242,32,68,227,176,40,32,5,243,169,32,32,243,243,162,95,160,0,32,146,243,169,32,32,243,243,162,115,160,0,32,146,243,169,32,32,243,243,169,63,32,243,243,76,90,226,32,124,227,176,3,76,141,226,32,113,228,176,3,76,141,226,32,145,228,176,3,76,141,226,32,5,243,160,0,173,26,0,145,8,32,62,243,32,186,242,169,32,32,243,243,173,29,0,240,40,173,27,0,145,8,32,62,243,32,186,242,169,32,32,243,243,173,30,0,240,30,173,28,0,145,8,32,62,243,32,186,242,169,32,32,243,243,76,37,227,169,32,32,243,243,32,243,243,32,243,243,169,32,32,243,243,32,243,243,32,243,243,169,32,32,243,243,162,95,160,0,32,146,243,169,32,32,243,243,162,115,160,0,32,146,243,76,90,226,24,96,56,96,162,37,142,10,0,162,248,142,11,0,160,0,177,10,217,95,0,240,25,173,10,0,24,105,10,141,10,0,144,3,238,11,0,160,4,177,10,201,90,240,11,76,78,227,200,192,3,240,5,76,80,227,24,96,56,96,160,0,185,115,0,201,0,208,8,169,80,141,31,0,76,111,228,201,35,208,8,169,77,141,31,0,76,111,228,201,65,240,7,201,97,240,3,76,187,227,200,185,115,0,201,0,240,7,201,32,240,3,76,187,227,169,67,141,31,0,76,111,228,160,6,177,10,201,76,208,6,141,31,0,76,111,228,160,0,185,115,0,201,40,208,3,76,21,228,160,0,185,115,0,201,44,240,8,201,0,240,43,200,76,215,227,200,185,115,0,201,88,240,15,201,120,240,11,201,89,240,15,201,121,240,11,76,109,228,169,88,141,31,0,76,111,228,169,89,141,31,0,76,111,228,169,83,141,31,0,76,111,228,200,185,115,0,201,44,240,11,201,41,240,30,192,11,208,240,76,109,228,200,185,115,0,201,88,240,7,201,120,240,3,76,109,228,169,82,141,31,0,76,111,228,200,185,115,0,201,0,240,22,201,44,240,3,76,109,228,200,185,115,0,201,89,240,15,201,121,240,11,76,109,228,169,68,141,31,0,76,111,228,169,73,141,31,0,76,111,228,24,96,56,96,160,6,177,10,205,31,0,240,21,173,10,0,24,105,10,141,10,0,144,3,238,11,0,32,78,227,176,228,24,96,56,96,169,0,141,29,0,141,30,0,160,7,177,10,141,26,0,173,31,0,201,80,240,39,201,67,240,38,201,77,240,37,201,83,240,60,201,88,240,56,201,89,240,52,201,73,240,88,201,82,240,84,201,68,240,80,201,76,240,36,76,170,229,76,172,229,76,172,229,32,174,229,176,3,76,170,229,32,28,243,176,3,76,170,229,141,27,0,169,1,141,29,0,76,172,229,32,174,229,176,3,76,170,229,32,195,242,176,3,76,170,229,173,31,0,201,76,240,72,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,172,229,32,174,229,176,3,76,170,229,32,195,242,176,3,76,170,229,173,31,0,201,68,240,15,192,0,208,120,142,27,0,169,1,141,29,0,76,172,229,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,172,229,142,43,0,140,44,0,173,8,0,141,45,0,173,9,0,141,46,0,160,8,177,10,24,109,45,0,141,45,0,144,3,238,46,0,56,173,43,0,237,45,0,141,43,0,173,44,0,237,46,0,141,44,0,173,44,0,201,255,240,14,201,0,208,28,173,43,0,201,128,16,21,76,159,229,173,43,0,201,128,48,11,141,27,0,169,1,141,29,0,76,172,229,24,96,56,96,162,20,160,0,189,95,0,217,50,244,240,23,217,67,244,240,18,200,192,16,240,3,76,181,229,232,224,31,240,3,76,176,229,24,96,56,96,173,95,0,201,43,240,11,201,45,240,10,201,63,240,9,76,243,230,76,95,230,76,27,230,162,168,160,244,32,146,243,160,255,162,255,200,232,185,18,0,141,8,0,200,185,18,0,141,9,0,189,47,0,240,3,32,5,243,192,7,208,229,162,168,160,244,32,146,243,76,243,230,173,115,0,201,0,240,10,162,20,32,195,242,176,16,76,243,230,160,3,169,0,153,47,0,136,16,248,76,243,230,142,43,0,140,44,0,160,3,162,6,32,244,230,176,15,136,202,202,16,246,162,181,160,245,32,146,243,76,243,230,169,0,153,47,0,76,243,230,173,115,0,201,0,240,7,162,20,32,195,242,176,3,76,243,230,142,43,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,244,230,176,231,136,202,202,16,239,160,0,185,47,0,201,0,240,15,200,192,4,208,244,162,141,160,245,32,146,243,76,243,230,140,55,0,169,1,153,47,0,192,0,208,15,173,43,0,141,18,0,173,44,0,141,19,0,76,243,230,192,1,208,15,173,43,0,141,20,0,173,44,0,141,21,0,76,243,230,192,2,208,15,173,43,0,141,22,0,173,44,0,141,23,0,76,243,230,173,43,0,141,24,0,173,44,0,141,25,0,76,243,230,96,192,0,208,11,173,44,0,205,19,0,240,44,76,57,231,192,1,208,11,173,44,0,205,21,0,240,29,76,57,231,192,2,208,11,173,44,0,205,23,0,240,14,76,57,231,173,44,0,205,25,0,240,3,76,57,231,173,43,0,221,18,0,240,3,76,57,231,56,96,24,96,162,0,189,95,0,201,0,240,58,32,28,243,176,3,76,255,231,141,9,0,232,32,28,243,176,3,76,255,231,141,8,0,162,20,189,95,0,201,0,240,26,32,28,243,176,3,76,255,231,141,93,0,232,32,28,243,176,3,76,255,231,141,92,0,76,149,231,173,9,0,141,93,0,173,8,0,141,92,0,24,105,15,141,92,0,144,3,238,93,0,169,13,32,243,243,169,10,32,243,243,162,0,160,0,32,5,243,177,8,32,35,232,32,62,243,232,224,16,208,3,32,11,232,224,8,208,18,169,32,32,243,243,169,45,32,243,243,169,32,32,243,243,76,209,231,169,32,32,243,243,173,8,0,205,92,0,208,8,173,9,0,205,93,0,240,32,238,8,0,208,3,238,9,0,224,16,208,15,169,10,32,243,243,169,13,32,243,243,32,5,243,162,0,76,166,231,24,96,238,8,0,208,3,238,9,0,56,96,169,32,32,243,243,169,32,32,243,243,162,0,189,76,0,32,243,243,232,224,16,208,245,96,72,201,32,48,10,201,127,16,6,157,76,0,76,55,232,169,46,157,76,0,104,96,173,95,0,201,0,208,3,76,103,232,173,115,0,201,0,208,3,76,103,232,162,0,32,195,242,176,3,76,103,232,142,8,0,140,9,0,162,20,32,107,232,144,3,76,105,232,24,96,56,96,160,0,140,207,0,189,95,0,240,40,32,28,243,176,3,76,157,232,145,8,238,8,0,208,3,238,9,0,238,207,0,173,207,0,201,10,240,10,232,189,95,0,240,4,232,76,112,232,56,96,24,96,162,0,32,195,242,176,3,76,220,232,142,8,0,140,9,0,162,20,32,195,242,176,3,76,220,232,142,92,0,140,93,0,162,40,32,107,232,144,22,173,93,0,205,9,0,240,3,76,191,232,173,92,0,205,8,0,240,5,76,191,232,24,96,56,96,173,95,0,201,0,240,16,162,0,32,195,242,176,3,76,93,233,142,69,0,140,70,0,174,69,0,142,43,0,172,70,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,244,230,176,8,136,202,202,16,239,76,37,233,162,221,160,245,32,146,243,76,95,233,160,3,162,6,185,47,0,201,1,208,9,161,18,153,51,0,169,0,129,18,136,202,202,16,235,104,104,104,104,173,95,0,201,0,240,17,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,24,96,56,96,162,35,160,246,32,146,243,96,162,171,160,244,32,146,243,32,210,243,162,168,160,244,32,146,243,76,128,233,32,210,243,201,83,208,249,32,243,243,32,210,243,32,243,243,141,161,0,201,48,208,8,32,149,234,144,37,76,187,233,201,49,208,8,32,159,234,144,25,76,187,233,201,57,208,18,32,169,234,144,13,162,244,160,244,32,146,243,76,199,233,76,125,233,162,212,160,244,32,146,243,56,96,32,210,243,56,96,169,0,141,159,0,141,160,0,32,60,234,141,158,0,32,99,234,170,202,202,202,138,141,155,0,32,60,234,141,9,0,32,99,234,32,60,234,141,8,0,32,99,234,96,173,155,0,240,11,32,60,234,32,99,234,206,155,0,208,245,96,173,155,0,240,23,160,0,32,60,234,32,99,234,145,8,238,8,0,208,3,238,9,0,206,155,0,208,235,96,173,159,0,73,255,141,157,0,32,60,234,205,157,0,240,4,24,76,59,234,56,96,152,72,32,210,243,32,114,234,144,28,10,10,10,10,41,240,141,156,0,32,210,243,32,114,234,144,11,13,156,0,141,156,0,104,168,173,156,0,96,72,24,109,159,0,141,159,0,144,3,238,160,0,104,96,142,206,0,162,0,221,50,244,240,19,221,67,244,240,14,232,224,16,240,3,76,119,234,169,0,24,76,148,234,138,56,174,206,0,96,32,204,233,32,248,233,32,38,234,96,32,204,233,32,9,234,32,38,234,96,32,204,233,32,248,233,32,38,234,96,173,95,0,201,0,240,7,162,0,32,195,242,176,3,76,30,235,142,8,0,140,9,0,162,20,32,195,242,176,3,76,30,235,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,32,195,242,176,3,76,30,235,142,10,0,140,11,0,160,0,177,8,145,10,238,10,0,208,3,238,11,0,238,8,0,208,3,238,9,0,173,8,0,205,92,0,240,3,76,244,234,173,9,0,205,93,0,240,3,76,244,234,96,72,138,72,152,72,8,173,95,0,201,0,240,3,76,151,235,162,50,160,245,32,146,243,160,3,32,226,242,173,70,0,32,62,243,173,69,0,32,62,243,160,9,32,226,242,173,71,0,32,62,243,160,9,32,226,242,173,72,0,32,62,243,160,8,32,226,242,173,73,0,32,62,243,160,8,32,226,242,173,74,0,32,62,243,160,7,32,226,242,173,75,0,162,8,42,176,10,72,169,48,32,243,243,104,76,145,235,72,169,49,32,243,243,104,202,208,233,76,220,236,169,13,32,243,243,169,10,32,243,243,173,95,0,32,237,242,201,112,208,60,173,70,0,32,62,243,173,69,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,168,232,32,28,243,176,3,76,220,236,141,69,0,140,70,0,76,220,236,201,97,208,41,173,71,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,141,71,0,76,220,236,201,120,208,41,173,72,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,141,72,0,76,220,236,201,121,208,41,173,73,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,141,73,0,76,220,236,201,115,240,3,76,216,236,173,96,0,32,237,242,201,112,240,7,201,114,240,44,76,216,236,173,74,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,141,74,0,76,220,236,173,75,0,32,62,243,32,218,242,32,135,224,32,237,224,173,95,0,201,0,208,3,76,220,236,162,0,32,28,243,176,3,76,220,236,141,75,0,76,220,236,24,76,221,236,56,40,104,168,104,170,104,96,173,95,0,201,0,240,7,162,0,32,195,242,176,3,76,116,237,142,10,0,140,11,0,162,20,32,195,242,176,3,76,116,237,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,169,32,141,8,0,169,0,141,9,0,32,107,232,144,80,173,207,0,141,42,0,173,10,0,141,8,0,173,11,0,141,9,0,162,168,160,244,32,146,243,162,0,160,0,177,8,221,32,0,240,25,32,186,242,173,8,0,205,92,0,240,3,76,61,237,173,9,0,205,93,0,240,22,76,61,237,200,232,236,42,0,240,3,76,65,237,32,5,243,32,186,242,76,61,237,96,173,95,0,201,0,240,23,162,0,32,195,242,176,3,76,124,239,142,69,0,140,70,0,173,115,0,201,0,208,8,160,1,140,62,0,76,168,237,162,20,32,28,243,176,3,76,124,239,141,62,0,104,104,104,104,172,69,0,140,8,0,172,70,0,140,9,0,160,0,177,8,141,67,0,32,128,239,176,3,76,124,239,160,8,177,10,141,58,0,160,1,173,67,0,201,96,208,40,169,2,141,61,0,104,141,16,0,104,141,17,0,72,173,16,0,72,238,16,0,208,3,238,17,0,160,0,177,16,141,60,0,169,0,145,16,76,11,239,201,76,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,11,239,201,108,208,43,169,2,141,61,0,177,8,141,12,0,200,177,8,141,13,0,160,0,177,12,141,16,0,200,177,12,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,11,239,201,32,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,11,239,160,0,177,10,201,66,208,8,160,1,177,10,201,73,208,3,76,232,238,169,1,141,61,0,24,173,8,0,109,58,0,141,16,0,173,9,0,105,0,141,17,0,160,1,177,8,141,56,0,16,32,206,56,0,173,56,0,73,255,141,56,0,56,173,16,0,237,56,0,141,16,0,173,17,0,233,0,141,17,0,76,218,238,24,173,16,0,109,56,0,141,16,0,173,17,0,105,0,141,17,0,76,218,238,160,0,177,16,141,60,0,169,0,145,16,76,237,238,169,0,141,61,0,172,58,0,177,8,141,59,0,24,173,8,0,109,58,0,141,14,0,173,9,0,105,0,141,15,0,169,0,145,8,169,1,141,57,0,173,95,0,201,0,240,3,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,169,0,141,57,0,160,0,173,61,0,201,0,240,17,201,1,240,8,173,60,0,145,16,76,79,239,173,60,0,145,16,173,59,0,145,14,172,69,0,140,8,0,172,70,0,140,9,0,162,168,160,244,32,146,243,173,8,0,141,92,0,173,9,0,141,93,0,32,255,239,206,62,0,240,3,76,172,237,76,116,224,24,96,56,96,162,37,142,10,0,162,248,142,11,0,160,4,177,10,201,90,240,28,160,7,177,10,205,67,0,240,17,173,10,0,24,105,10,141,10,0,144,3,238,11,0,76,138,239,56,96,24,96,173,95,0,201,0,240,23,162,0,32,195,242,176,3,76,164,242,142,8,0,140,9,0,173,115,0,201,0,208,33,173,8,0,141,92,0,173,9,0,141,93,0,24,173,8,0,105,20,141,92,0,144,7,174,93,0,232,142,93,0,76,255,239,162,20,32,195,242,176,3,76,164,242,142,92,0,140,93,0,173,93,0,205,9,0,240,5,144,14,76,26,240,173,92,0,205,8,0,144,3,76,26,240,76,166,242,160,0,177,8,141,67,0,32,128,239,176,29,162,168,160,244,32,146,243,32,5,243,173,67,0,32,62,243,162,129,160,245,32,146,243,32,186,242,76,255,239,162,168,160,244,32,146,243,32,5,243,32,186,242,160,6,177,10,201,80,208,3,76,157,240,201,77,208,3,76,196,240,201,83,208,3,76,247,240,201,88,208,3,76,247,240,201,89,208,3,76,247,240,201,82,208,3,76,20,242,201,76,208,3,76,97,241,201,67,208,3,76,174,240,201,68,208,3,76,86,242,201,73,208,3,76,210,241,76,38,240,173,67,0,32,62,243,160,8,32,226,242,32,168,242,76,255,239,173,67,0,32,62,243,160,8,32,226,242,32,168,242,169,65,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,160,5,32,226,242,32,168,242,169,35,32,243,243,173,65,0,32,62,243,169,104,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,169,32,32,243,243,177,8,141,66,0,32,62,243,32,186,242,160,2,32,226,242,32,168,242,173,66,0,32,62,243,173,65,0,32,62,243,169,104,32,243,243,160,6,177,10,201,88,240,7,201,89,240,16,76,255,239,169,44,32,243,243,169,88,32,243,243,76,255,239,169,44,32,243,243,169,89,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,160,5,32,226,242,32,168,242,173,8,0,141,63,0,173,9,0,141,64,0,173,65,0,48,18,173,63,0,24,109,65,0,141,63,0,144,32,238,64,0,76,190,241,206,65,0,173,65,0,73,255,141,65,0,173,63,0,56,237,65,0,141,63,0,176,3,206,64,0,173,64,0,32,62,243,173,63,0,32,62,243,169,104,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,160,5,32,226,242,32,168,242,169,40,32,243,243,173,65,0,32,62,243,169,104,32,243,243,169,41,32,243,243,169,44,32,243,243,169,89,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,160,5,32,226,242,32,168,242,169,40,32,243,243,173,65,0,32,62,243,169,104,32,243,243,169,44,32,243,243,169,88,32,243,243,169,41,32,243,243,76,255,239,160,0,173,67,0,32,62,243,169,32,32,243,243,177,8,141,65,0,32,62,243,32,186,242,169,32,32,243,243,177,8,141,66,0,32,62,243,32,186,242,160,2,32,226,242,32,168,242,169,40,32,243,243,173,66,0,32,62,243,173,65,0,32,62,243,169,104,32,243,243,169,41,32,243,243,76,255,239,24,96,56,96,160,0,177,10,32,243,243,200,192,3,208,246,169,32,32,243,243,96,238,8,0,208,3,238,9,0,96,32,28,243,176,3,76,216,242,168,232,32,28,243,176,3,76,216,242,170,56,96,24,96,162,124,160,245,32,146,243,96,72,169,32,32,243,243,136,208,248,104,96,201,65,48,7,201,91,16,3,24,105,32,96,201,97,48,7,201,123,16,3,56,233,32,96,173,9,0,32,62,243,173,8,0,32,62,243,169,32,32,243,243,169,32,32,243,243,96,189,95,0,32,114,234,144,25,10,10,10,10,41,240,141,156,0,232,189,95,0,32,114,234,144,7,13,156,0,141,156,0,56,96,141,156,0,74,74,74,74,41,15,201,10,16,5,9,48,76,85,243,56,233,9,9,64,32,243,243,173,156,0,41,15,201,10,16,5,9,48,76,107,243,56,233,9,9,64,32,243,243,173,156,0,96,169,253,141,4,0,169,225,141,5,0,169,0,141,57,0,169,0,141,47,0,141,48,0,141,49,0,141,50,0,169,0,96,72,142,6,0,140,7,0,160,0,177,6,240,14,32,243,243,238,6,0,208,3,238,7,0,76,155,243,104,96,8,138,72,152,72,173,1,160,41,8,240,9,173,0,160,141,206,0,76,201,243,169,0,141,206,0,104,168,104,170,40,173,206,0,96,8,138,72,152,72,173,1,160,41,8,208,6,173,2,160,76,215,243,173,0,160,141,206,0,104,168,104,170,40,173,206,0,96,141,206,0,8,152,72,138,72,173,1,160,41,16,240,249,173,206,0,141,0,160,104,170,104,168,40,173,206,0,96,72,138,72,152,72,169,0,141,162,0,169,16,141,163,0,206,162,0,208,251,206,163,0,208,246,104,168,104,170,104,96,22,11,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,0,48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,0,10,13,10,85,77,79,78,54,53,32,86,49,46,49,56,32,45,32,85,110,100,101,114,115,116,97,110,100,97,98,108,101,32,77,111,110,105,116,111,114,32,102,111,114,32,116,104,101,32,54,53,48,48,32,115,101,114,105,101,115,32,109,105,99,114,111,112,114,111,99,101,115,115,111,114,115,46,10,13,0,10,13,45,0,10,13,0,10,13,83,101,110,100,32,83,32,114,101,99,111,114,100,115,32,119,104,101,110,32,121,111,117,32,97,114,101,32,114,101,97,100,121,46,46,46,10,13,0,10,13,7,69,114,114,111,114,32,76,111,97,100,105,110,103,32,83,32,82,101,99,111,114,100,115,46,46,46,10,13,0,10,13,7,83,32,114,101,99,111,114,100,115,32,115,117,99,99,101,115,115,102,117,108,108,121,32,108,111,97,100,101,100,32,40,112,114,101,115,115,32,60,101,110,116,101,114,62,32,116,111,32,99,111,110,116,105,110,117,101,41,46,0,10,13,10,80,103,109,67,110,116,114,40,80,67,41,32,32,65,99,99,117,109,40,65,67,41,32,32,88,82,101,103,40,88,82,41,32,32,89,82,101,103,40,89,82,41,32,32,83,116,107,80,116,114,40,83,80,41,32,32,78,86,45,66,68,73,90,67,40,83,82,41,10,13,0,10,13,32,58,0,32,32,32,32,32,32,32,32,63,63,63,0,10,13,65,108,108,32,98,114,101,97,107,112,111,105,110,116,115,32,97,114,101,32,99,117,114,114,101,110,116,108,121,32,105,110,32,117,115,101,46,0,10,13,78,111,32,98,114,101,97,107,112,111,105,110,116,32,101,120,105,115,116,115,32,97,116,32,116,104,105,115,32,97,100,100,114,101,115,115,46,0,10,13,89,111,117,32,99,97,110,110,111,116,32,71,79,32,97,116,32,97,32,98,114,101,97,107,112,111,105,110,116,101,100,32,97,100,100,114,101,115,115,44,32,84,82,65,67,69,32,112,97,115,116,32,105,116,32,116,104,101,110,32,71,79,46,0,10,13,63,0,10,13,10,65,115,115,101,109,98,108,101,32,32,32,32,32,32,32,65,32,115,116,97,114,116,95,97,100,100,114,101,115,115,10,13,66,114,101,97,107,112,111,105,110,116,32,32,32,32,32,66,32,40,43,44,45,44,63,41,32,97,100,100,114,101,115,115,10,13,68,117,109,112,32,32,32,32,32,32,32,32,32,32,32,68,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,69,110,116,101,114,32,32,32,32,32,32,32,32,32,32,69,32,97,100,100,114,101,115,115,32,108,105,115,116,10,13,70,105,108,108,32,32,32,32,32,32,32,32,32,32,32,70,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,71,111,32,32,32,32,32,32,32,32,32,32,32,32,32,71,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,93,10,13,72,101,108,112,32,32,32,32,32,32,32,32,32,32,32,72,32,111,114,32,63,10,13,76,111,97,100,32,32,32,32,32,32,32,32,32,32,32,76,10,13,77,111,118,101,32,32,32,32,32,32,32,32,32,32,32,77,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,100,101,115,116,105,110,97,116,105,111,110,95,97,100,100,114,101,115,115,10,13,82,101,103,105,115,116,101,114,32,32,32,32,32,32,32,82,32,91,80,67,44,65,67,44,88,82,44,89,82,44,83,80,44,83,82,93,10,13,83,101,97,114,99,104,32,32,32,32,32,32,32,32,32,83,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,84,114,97,99,101,32,32,32,32,32,32,32,32,32,32,84,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,118,97,108,117,101,93,93,10,13,85,110,97,115,115,101,109,98,108,101,32,32,32,32,32,85,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,0,65,68,67,32,73,77,77,105,2,2,65,68,67,32,65,66,83,109,3,4,65,68,67,32,65,66,88,125,3,4,65,68,67,32,65,66,89,121,3,4,65,68,67,32,73,73,82,97,2,6,65,68,67,32,73,82,73,113,2,5,65,78,68,32,73,77,77,41,2,2,65,78,68,32,65,66,83,45,3,4,65,78,68,32,65,66,88,61,3,4,65,78,68,32,65,66,89,57,3,4,65,78,68,32,73,73,82,33,2,6,65,78,68,32,73,82,73,49,2,5,65,83,76,32,65,67,67,10,1,2,65,83,76,32,65,66,83,14,3,6,65,83,76,32,65,66,88,30,3,7,66,67,67,32,82,69,76,144,2,2,66,67,83,32,82,69,76,176,2,2,66,69,81,32,82,69,76,240,2,2,66,73,84,32,65,66,83,44,3,4,66,77,73,32,82,69,76,48,2,2,66,78,69,32,82,69,76,208,2,2,66,80,76,32,82,69,76,16,2,2,66,82,75,32,73,77,80,0,1,7,66,86,67,32,82,69,76,80,2,2,66,86,83,32,82,69,76,112,2,2,67,76,67,32,73,77,80,24,1,2,67,76,68,32,73,77,80,216,1,2,67,76,73,32,73,77,80,88,1,2,67,76,86,32,73,77,80,184,1,2,67,77,80,32,73,77,77,201,2,2,67,77,80,32,65,66,83,205,3,4,67,77,80,32,65,66,88,221,3,4,67,77,80,32,65,66,89,217,3,4,67,77,80,32,73,73,82,193,2,6,67,77,80,32,73,82,73,209,2,5,67,80,88,32,73,77,77,224,2,2,67,80,88,32,65,66,83,236,3,4,67,80,89,32,73,77,77,192,2,2,67,80,89,32,65,66,83,204,3,4,68,69,67,32,65,66,83,206,3,6,68,69,67,32,65,66,88,222,3,7,68,69,88,32,73,77,80,202,1,2,68,69,89,32,73,77,80,136,1,2,69,79,82,32,73,77,77,73,2,2,69,79,82,32,65,66,83,77,3,4,69,79,82,32,65,66,88,93,3,4,69,79,82,32,65,66,89,89,3,4,69,79,82,32,73,73,82,65,2,6,69,79,82,32,73,82,73,81,2,5,73,78,67,32,65,66,83,238,3,6,73,78,67,32,65,66,88,254,3,7,73,78,88,32,73,77,80,232,1,2,73,78,89,32,73,77,80,200,1,2,74,77,80,32,65,66,83,76,3,3,74,77,80,32,73,78,68,108,3,5,74,83,82,32,65,66,83,32,3,6,76,68,65,32,73,77,77,169,2,2,76,68,65,32,65,66,83,173,3,4,76,68,65,32,65,66,88,189,3,4,76,68,65,32,65,66,89,185,3,4,76,68,65,32,73,73,82,161,2,6,76,68,65,32,73,82,73,177,2,5,76,68,88,32,73,77,77,162,2,2,76,68,88,32,65,66,83,174,3,4,76,68,88,32,65,66,89,190,3,4,76,68,89,32,73,77,77,160,2,2,76,68,89,32,65,66,83,172,3,4,76,68,89,32,65,66,88,188,3,4,76,83,82,32,65,67,67,74,1,2,76,83,82,32,65,66,83,78,3,6,76,83,82,32,65,66,88,94,3,7,78,79,80,32,73,77,80,234,1,2,79,82,65,32,73,77,77,9,2,2,79,82,65,32,65,66,83,13,3,4,79,82,65,32,65,66,88,29,3,4,79,82,65,32,65,66,89,25,3,4,79,82,65,32,73,73,82,1,2,6,79,82,65,32,73,82,73,17,2,5,80,72,65,32,73,77,80,72,1,3,80,72,80,32,73,77,80,8,1,3,80,76,65,32,73,77,80,104,1,4,80,76,80,32,73,77,80,40,1,4,82,79,76,32,65,67,67,42,1,2,82,79,76,32,65,66,83,46,3,6,82,79,76,32,65,66,88,62,3,7,82,79,82,32,65,67,67,106,1,2,82,79,82,32,65,66,83,110,3,6,82,79,82,32,65,66,88,126,3,7,82,84,73,32,73,77,80,64,1,6,82,84,83,32,73,77,80,96,1,6,83,66,67,32,73,77,77,233,2,2,83,66,67,32,65,66,83,237,3,4,83,66,67,32,65,66,88,253,3,4,83,66,67,32,65,66,89,249,3,4,83,66,67,32,73,73,82,225,2,6,83,66,67,32,73,82,73,241,2,5,83,69,67,32,73,77,80,56,1,2,83,69,68,32,73,77,80,248,1,2,83,69,73,32,73,77,80,120,1,2,83,84,65,32,65,66,83,141,3,4,83,84,65,32,65,66,88,157,3,5,83,84,65,32,65,66,89,153,3,5,83,84,65,32,73,73,82,129,2,6,83,84,65,32,73,82,73,145,2,6,83,84,88,32,65,66,83,142,3,4,83,84,89,32,65,66,83,140,3,4,84,65,88,32,73,77,80,170,1,2,84,65,89,32,73,77,80,168,1,2,84,83,88,32,73,77,80,186,1,2,84,88,65,32,73,77,80,138,1,2,84,88,83,32,73,77,80,154,1,2,84,89,65,32,73,77,80,152,1,2,90,90,90,32,90,90,90,0,0,0,0,224,234,225};
.         %/output

.   %/output





