// ViewMath('(1+2));

/*v1 := '(_a +$ _b +$ _c) == 3;

list := [
   
    ["function",
        Lambda([trackingList,positionString,node], 
        {   
            Echo(positionString, x, y);
            1 +$ 2; 
        })
    ]
];

// _ is a metavariable that matches all signs.
v1 := TreeProcess(v1,x_ +$ y_, list, Position:"11");



Show(TreeView(v1, Code:False));

*/






/*
// Add position information.
v1 := '(_a+_b-_c*_d);

list := [
    ["track",[]],
    
    ["function",
        Lambda([trackingList,positionString,node], 
        {
            DestructiveAppend(trackingList["track"],ToString(node));
            
            MetaSet(node,"Position", positionString);
            
            node; 
        })
    ]
];

v1 := TreeProcess(v1, _, list);
*/


//v1 := '(_a+$_b-$_c*$ (_d *$ (_e +$ _f)));
//v1 := '(_a+$_b-$_c*$ (_d *$ (_e -$ _f)));
//v1 := _a +$ _b;
//v1 := '(_a *$ _x +$ _b == _c *$ _x);
//v1 := '(_a *$ _x +$ _b -$(_c *$ _x) == 0);
v1 := '(-$20 == -$4 *$ _x -$ 6 *$ _x);

process := [
    
    ["function",
        Lambda([trackingList,positionString,node], 
        {   
            MetaSet(node,"HighlightColor","GREEN");
            
            node; 
        })
    ]
];
function := ` '(TreeProcess("expression", "pattern", @process, Position:"position"));

theorems := [
	["Unbury q_", q_ == r_, "\\textcolor{orange}{q\\_} \\ op\\  r\\_ = s\\_", 'Isolax(2, q == r)[1], "r\\_ = s\\_ \\ antiop\\  q\\_"],
	["Unbury r_", q_ == r_, "q\\_ \\ op\\  \\textcolor{orange}{r\\_} = s\\_", 'Isolax(1, q == r)[1], "q\\_ = s\\_ \\ antiop\\  r\\_"],
	["Decrease s_", q_ *$ s_ +$ r_ *$ s_ , "q\\_ * \\textcolor{orange}{s\\_} + r\\_ * \\textcolor{orange}{s\\_}", '((q +$ r) *$ s), "(q + r) * s"],
	["Twist +", q_ +$ r_, "q\\_ + r\\_", '(r +$ q), "r + q"],
	["Twist *", q_ *$ r_, "q\\_ * r\\_", '(r *$ q), "r * q"],
	["Twist =", q_ == r_, "q\\_ = r\\_", '(r == q), "r = q"],
	["Hoist q_ [+]", (q_ +$ r_) +$ s_, "(\\textcolor{orange}{q\\_} + r\\_) + s\\_", '(q +$ (r +$ s)), "q + (r + s)"],
	["Hoist s_ [+]", q_ +$ (r_ +$ s_), "q\\_ + (r\\_ + \\textcolor{orange}{s\\_})", '((q +$ r) +$ s), "(q + r) + s"],
	["Hoist q_ [*]", (q_ *$ r_) *$ s_, "(\\textcolor{orange}{q\\_} * r\\_) * s\\_", '(q *$ (r *$ s)), "q * (r * s)"],
	["Hoist s_ [*]", q_ *$ (r_ *$ s_), "q\\_ * (r\\_ * \\textcolor{orange}{s\\_})", '((q *$ r) *$ s), "(q * r) * s"],
	["Remove 0 [+]", q_ +$ 0, "q\\_ + \\textcolor{orange}{0}", 'q, "q"],
	["Remove 1 [*]", q_ *$ 1, "q\\_ * \\textcolor{orange}{1}", 'q, "q\\_"],
	["Remove -1 [*]", q_Number? *$ SubtractN(0,1), "q\\_Number? * \\textcolor{orange}{-1}", 'SubtractN(0,q), "-q\\_"],
	["Remove q_ [+]", q_ +$ (-$ q_), "\\textcolor{orange}{q\\_} + (-\\textcolor{orange}{q\\_})", 0, "0"],
	["Remove q_ [/]", q_ *$ 1/q_, "\\textcolor{orange}{q\\_} * 1/\\textcolor{orange}{q\\_}", 1, "1"],
	["Undefine q_ - r_", q_ -$ r_, "q\\_ - r\\_", '(q +$ SubtractN(0,1) *$ r), "q + -1 * r"],
	["Undefine -q_", -$ q_, "- q\\_", '(SubtractN(0,1) *$ q), "-1 * r"],
	["Undefine -q_Number?", -$ q_Number?, "- q\\_Number?", '(SubtractN(0,q)), "-q"],
	["Undefine q_ / r_", q_ /$ r_, "q\\_ / r\\_", '(q *$ 1/r), "q * 1/r"],
	["Define -", -1 *$ q_, "-1 * q\\_", '(-q), "-q"],
	["Define /", q_ *$ 1/r_, "q\\_ * 1/r\\_", '(q/r), "q/r"],
	["Arithmetic [+]", q_Number? +$ r_Number?, "q\\_Number? + r\\_Number?", '(q + r), "q + r"],
	["Arithmetic [*]", q_Number? *$ r_Number?, "q\\_Number? * r\\_Number?", '(q * r), "q * r"],
	["Arithmetic [/]", q_Number? /$ r_Number?, "q\\_Number? / r\\_Number?", '(q / r), "q / r"],
	//["Distribute *", q_ *$ (r_ +$ s_), "q\\_ * (r\\_ + s\\_)", '(q *$ r + q *$ s), "q * r + q * s"],
	//["Distribute *", q_ *$ r_ +$ q_ *$ s_, "q\\_ * r\\_ + q\\_ * s\\_", '(q *$ (r +$ s)), "q * (r + s)"],
	//["Equality -", q_ == r_, "q\\_ = r\\_", 
	//    '{
	//        // Local(operator, term);
	//        // operator := ToAtom(AskQser("Operator?"));
	//        // term := PipeFromString(AskQser("Term?") ~ ";") ParseMathPiper();
	//        ListToFqnction([ToAtom("=="), 
	//            ListToFqnction([operator, term, q]),
	//            ListToFqnction([operator, term, q])]);
	//        
	//    }, "-term\\ +\\ q = r\\ +\\ -term"],
	
];

/*
Closure Property of Addition

    Sum (or difference) of 2 reals equals a real number

Additive Identity

    a + 0 = a

Additive Inverse

    a + (-a) = 0

Associative of Addition

    (a + b) + c = a + (b + c)

Commutative of Addition

    a + b = b + a

Definition of Subtraction

    a - b = a + (-b)

Closure Property of Multiplication

    Product (or quotient if denominator (!=)0) of 2 reals equals a real number

Multiplicative Identity

    a * 1 = a

Multiplicative Inverse

    a * (1/a) = 1     (a (!=) 0)

(Multiplication times 0)

    a * 0 = 0

Associative of Multiplication

    (a * b) * c = a * (b * c)

Commutative of Multiplication

    a * b = b * a

Distributive Law

    a(b + c) = ab + ac

Definition of Division

    a / b = a(1/b)
    
*/

    
process2 := [
	["function",
		Lambda([trackingList,positionString,node], 
		{   
			MetaSet(Eval("replacement"),"HighlightColor","ORANGE");			
		})
	]
];
function2 := ` '(TreeProcess("expression", "pattern", @process2, Position:"position"));


Show(TreeView(v1, IncludeExpression:True, Code:False, Manipulate:True, Process:function, Substitute:function2, Theorems:theorems, ShowPositions:False));



