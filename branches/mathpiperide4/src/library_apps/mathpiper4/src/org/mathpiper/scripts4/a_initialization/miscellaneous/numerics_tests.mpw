%mathpiper,name="numerics",subtype="automatic_test"

/* Numerical testers - all confirmed with various programs */
Testing(" *** TESTING NUMERICS *** ");

BuiltinPrecisionSet(10);   //Echo("BIP set to ",10);
NumericEqual(NM(Sqrt(2),6), 1.41421,6);
NumericEqual(NM(NM(1+Pi,20)-Pi,20),1,20);     
// Should "NM" have "HoldArgument" in some way, so inner "NM" is 
// evaluated with outer precision 20?

Testing("Pi");
/* 
   Got the first digits of Pi from the following page:
   http://www.cecm.sfu.ca/projects/ISC/dataB/isc/C/pi10000.txt
   Just checking that MathPiper agrees.
   First, however, we need to set BuiltinPrecision way higher than 10 !!
*/
BuiltinPrecisionSet(90);//Echo("BIP set to ",90);


NumericEqual(
RoundToPrecision(NM(Pi), 50)
, 3.14159265358979323846264338327950288419716939937511
, 50);
NumericEqual(NM(Pi,70),3.141592653589793238462643383279502884197169399375105820974944592307816,70);
BuiltinPrecisionSet(10);//Echo("BIP set to ",10);

Testing("Trig, Hyperbolic, Log, and Exp functions");
NumericEqual( NM(Sec(2),10), -2.402997962, 9);
NumericEqual( NM(Csc(2),9),  1.09975017,9);
NumericEqual( NM(Cot(2),9), -0.457657554, 9);
NumericEqual( NM(Sinh(2),10), 3.626860408,10); 
    // matter of discussion whether rounding should be to nearest

NumericEqual( NM(ArcSin(2), 9), Complex(1.570796327,1.316957897),9);
NumericEqual( NM(ArcCos(2),9), Complex(0,-1.316957897),9);
NumericEqual( NM(ArcTan(2*I), 12), NM(Complex(1.5707963267950,0.54930614433405),12),11); 
    // calculating to precision+1 because RoundToPrecision rounds... cluttering the last digit with round-off
NumericEqual( NM(ArcSinh(2), 10), 1.443635475,9);
NumericEqual( NM(ArcCosh(2), 10), 1.316957897,9);
NumericEqual( NM(ArcCosh(-2), 8), Complex(-1.3169579,3.14159265),8);
NumericEqual( NM(ArcTanh(2), 9), Complex(0.549306144,1.570796327),9);

/* more Numerical tests - all confirmed with Maple */
BuiltinPrecisionSet(55);//Echo("BIP set to ",55);
/*
 (hso,100311) BuiltinPrecisionSet MUST specify a value higher
 than any of the precisions to be used in tests below.
 Otherwise, false errors are reported.  I have changed
 the value from 50 to 55, to satisfy this requirement.
*/
NumericEqual(
RoundToPrecision(NM(Sin(2.0)), 49)
, 0.9092974268256816953960198659117448427022549714479
,48);

NumericEqual(
RoundToPrecision(NM(Sin(2.0)), 50)
, 0.90929742682568169539601986591174484270225497144789
,49);

NumericEqual(
RoundToPrecision(NM(Sin(2.0)), 51)
, 0.90929742682568169539601986591174484270225497144789
,50);

NumericEqual(
RoundToPrecision(NM(Cos(20.0)), 49)
, 0.4080820618133919860622678609276449570992995103163
, 48);

NumericEqual(
RoundToPrecision(NM(Tan(20.0)), 49)
, 2.2371609442247422652871732477303491783724839749188
, 48);  

NumericEqual(
RoundToPrecision(NM(Exp(10.32),54), 54)
, 30333.2575962246035600343483350109621778376486335450125
,48);   

NumericEqual(
RoundToPrecision(NM(Ln(10.32/4.07)), 50)
, 0.93044076059891305468974486564632598071134270468002
, 50);   

NumericEqual(
RoundToPrecision(NM(1.3^10.32), 48)
, 14.99323664825717956473936947123246987802978985306
, 48);

NumericEqual(
RoundToPrecision(NM(Sqrt(5.3),51), 51)
, 2.302172886644267644194841586420201850185830282633675
,51); 

NumericEqual(
RoundToPrecision(NM(Sqrt(25.3)), 50)
, 5.0299105359837166789719353820984438468186649281130
,50);

NumericEqual(
RoundToPrecision(NM(PowerN(13, -23)), 50)
, 0.23949855470974885180294666343025235387321690490245e-25
, 50);


/* todo:tk:commenting out for the minimal version of the scripts.
Testing("Newton");
NumericEqual(
RoundToPrecision({Local(x);x:=Newton(x*Exp(x)-4,x,1,10^(-49)); NM(x*Exp(x));}, 49)
, 4
,49);

Verify(Newton(x^2+1,x,1,0.1,-3,3), Fail);
NumericEqual(Newton(x^2-1,x,1,0.1,-3,3), 1,BuiltinPrecisionGet());
*/


Testing("Trig functions compounded with their Inverses");
NumericEqual(
RoundToPrecision(NM(ArcSin(0.32)), 49)
, 0.3257294872946301593103199105324500784354180998122808003
,49);

NumericEqual(
RoundToPrecision(NM(Sin(NM(ArcSin(0.1234567)))), 49)
, 0.1234567
,49);

/* ArcSin(x) for x close to 1 */

NumericEqual(
RoundToPrecision(NM( (1-Sin(NM(ArcSin(1-10^(-25)))))*10^25), 25)
, 1
, 25);

NumericEqual(
NM(ArcSin(NM(Sin(1.234567),50)),50)
, NM(1.234567,50)
, 49);  // calculating to precision+1 because RoundToPrecision rounds... cluttering the last digit with round-off

NumericEqual(
RoundToPrecision(NM(ArcCos(0.32)), 49)
, 1.2450668395002664599210017811073013636631665998753
, 49);

NumericEqual(
RoundToPrecision(NM(ArcTan(0.32)), 49)
, 0.3097029445424561999173808103924156700884366304804
, 49);

NumericEqual(
RoundToPrecision(NM(Cos(NM(ArcCos(0.1234567)))), 49)
, 0.1234567
, 49);

NumericEqual(
RoundToPrecision(NM(ArcCos(NM(Cos(1.234567)))), 49)
, 1.234567
, 49);

NumericEqual(
RoundToPrecision(NM(Tan(NM(ArcTan(20)))), 46)        // large roundoff error on Tan() calculation due to subtraction from Pi/2 -- unavoidable loss of precision
, 20
, 46);
//KnownFailure(
NumericEqual(
RoundToPrecision(NM(Tan(NM(ArcTan(500000)))), 38)
, 500000
//)
, 38);

BuiltinPrecisionSet(60); //Echo("BIP set to ",60); // obviously, 50 is not enough for the following
//KnownFailure(
NumericEqual(
RoundToPrecision(NM((Pi/2-ArcTan(NM(Tan(NM(Pi/2)-10^(-24)))))*10^24 ), 25)
, 1
//)
, 25);

/// special functions
BuiltinPrecisionSet(50); //Echo("BIP set to ",50); // needs a pretty high value for Gamma


/* todo:tk:commenting out for the minimal version of the scripts.
Testing("Gamma function");
TestMathPiper(
Gamma(10.5)
, (654729075*Sqrt(Pi))/1024
);

TestMathPiper(
Gamma(9/2)
, (105*Sqrt(Pi))/16
);

TestMathPiper(
Gamma(-10.5)
, (-2048*Sqrt(Pi))/13749310575
);

TestMathPiper(
Gamma(-7/2)
, (16*Sqrt(Pi))/105
);

NumericEqual(RoundToPrecision(NM( InternalGammaNum(10.5) ), 13), 1133278.3889487855673, 13);

KnownFailure(
NumericEqual(RoundToPrecision(NM( InternalGammaNum(-11.5) ), 20), 0.00000002295758104824, 20)
);
// our gamma is wrong

KnownFailure(
NumericEqual(RoundToPrecision(NM( InternalGammaNum(-12.5) ), 20), -0.00000000183660648386, 20)
);
//our gamma is wrong

// Check for one example that NM(Gamma(x)) returns the same as InternalGammaNum
NumericEqual(RoundToPrecision(NM( Gamma(10.5) ), 13), 1133278.3889487855673, 13);

Testing("Zeta function");
KnownFailure(
NumericEqual(    
RoundToPrecision(NM( Zeta(-11.5) ), 18), 0.020396978715942792,18)
);

TestMathPiper(
Zeta(40)
, (261082718496449122051*Pi^40)/20080431172289638826798401128390556640625
);

TestMathPiper(
Zeta(-11)
, 691/32760
);

TestMathPiper(
Zeta(-12)
, 0
);

NumericEqual(
RoundToPrecision(NM(Zeta(40)), 19)
, 1.0000000000009094948
,19);

NumericEqual(
RoundToPrecision(NM(Zeta(1.5)), 19)
, 2.6123753486854883433
,19);

// test correctness of Zeta(3)
NumericEqual(
RoundToPrecision(InternalZetaNum(3)-NM(Zeta(3)), 20)
, 0
,20);

Testing("Bernoulli number");
TestMathPiper(
Bernoulli(40)
, -261082718496449122051/13530
);

Testing("Continued Fraction");
Verify(
ContFracList(355/113)
, [3,7,16]
);

Verify(
ContFracList(-24, 4)
, [-24]
);

Verify(
ContFracList(-355/113)
, [-4,1,6,16]
);


/*
//BuiltinPrecisionSet(7);//Echo("BIP set to ",7);

Verify(
NearRational(NM(Pi),3)
, 201/64
);

/*
  For the NearRational test, perhaps better would be a real test that
  checks that the result is correct up to the required number of digits
  accuracy.
*/
BuiltinPrecisionSet(10);//Echo("BIP set to ",10);
Verify(
NearRational(NM(Pi))
, 355/113,
);


/* todo:tk:commenting out for the minimal version of the scripts.
// Lambert's W function
Testing("Lambert W function");
BuiltinPrecisionSet(20);

NumericEqual(
NM(RoundToPrecision(LambertW(-0.24),20)),-0.33576116478890275173,20);

NumericEqual(
NM(RoundToPrecision(LambertW(10),20)),1.7455280027406993831,20);

// Bessel Functions
Testing("Bessel functions");
BuiltinPrecisionSet(50);//Echo("BIP set to ",50);
NumericEqual( NM(BesselJ(0,.5)), RoundToPrecision(.93846980724081290422840467359971262556892679709682,50),50 );
NumericEqual( NM(BesselJ(0,.9)), RoundToPrecision(.80752379812254477730240904228745534863542363027564,50),50 );
NumericEqual( NM(BesselJ(0,.99999)), RoundToPrecision(.76520208704756659155313775543958045290339472808482,50),50 );
NumericEqual( NM(BesselJ(10,.75)), RoundToPrecision(.000000000014962171311759681469871248362168283485781647202136,50),50 );
NumericEqual( NM(BesselJ(5,1)), RoundToPrecision(.00024975773021123443137506554098804519815836777698007,50),50 );
NumericEqual( NM(BesselJ(4,2)), RoundToPrecision(.033995719807568434145759211288531044714832968346313,50),50 );
NumericEqual( NM(BesselJ(10,3)), RoundToPrecision( .000012928351645715883777534530802580170743420832844164,50),50 );

NumericEqual( NM(BesselJ(11,11)), RoundToPrecision( .20101400990926940339478738551009382430831534125484,50),50 );
NumericEqual( NM(BesselJ(-11,11)), RoundToPrecision( -.20101400990926940339478738551009382430831534125484,50),50 );
NumericEqual( RoundToPrecision(NM(BesselJ(1,10)),50), RoundToPrecision( .043472746168861436669748768025859288306272867118594, 50),50 );
NumericEqual( NM(BesselJ(10,10)), RoundToPrecision( .20748610663335885769727872351875342803274461128682, 50 ),50 );
NumericEqual( RoundToPrecision(NM(BesselJ(1,3.6)),50), RoundToPrecision( .095465547177876403845706744226060986019432754908851, 50 ),50) ;

BuiltinPrecisionSet(20);//Echo("BIP set to ",20);
Verify( RoundToPrecision(NM(Erf(Sqrt(0.8)),20),19),
RoundToPrecision(.79409678926793169113034892342, 19)
);

Verify( RoundToPrecision(NM(Erf(50*I+20)/10^910,22),19),
RoundToPrecision(1.09317119002909585408+I*0.00475463306931818955275, 19)
);

// testing GammaConstNum against Maple
Testing("Gamma constant");
BuiltinPrecisionSet(41);//Echo("BIP set to ",41);
NumericEqual(RoundToPrecision(Internalgamma(),40), 0.5772156649015328606065120900824024310422,BuiltinPrecisionGet());
BuiltinPrecisionSet(20);//Echo("BIP set to ",20);

Verify(gamma,ToAtom("gamma"));

NumericEqual(RoundToPrecision(Internalgamma()+0,19), 0.5772156649015328606,19);

NumericEqual(RoundToPrecision(NM(1/2+gamma+Pi), 19), 4.2188083184913260991,19);

// From GSL 1.0
//NumericEqual( NM(PolyLog(2,-0.001),20), -0.00099975011104865108, 20 );
// PolyLog I didn't write PolyLog, but it seems to not always calculate correctly up to the last digit.
Verify( RoundToPrecision(NM(PolyLog(2,-0.001)+0.00099975011104865108,20),20),0);

*/

// Round-off errors
NM({
  Local(a,b);
  a:= 77617;
  b:= 33096;
  // this expression gives a wrong answer on any hardware floating-point platform
  NumericEqual( 333.75*b^6 + a^2*(11*a^2*b^2-b^6-121*b^4-2)+5.5*b^8 +a/(2*b), -0.827396,6);
},40);

%/mathpiper

