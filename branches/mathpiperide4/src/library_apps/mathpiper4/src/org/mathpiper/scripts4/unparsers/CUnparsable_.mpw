%mathpiper,def="CUnparsable?"

//////////////////////////////////////////////////
/// CUnparsable?
//////////////////////////////////////////////////
Retract("CUnparsable?", All);
LocalSymbols(UnparseCAllFunctions) {

  /// predicate to test whether an expression can be successfully exported to C code

  /// interface with empty extra function list
  // need the backquote stuff b/c we have HoldArgument now
  CUnparsable?(expr_) <-- `CUnparsable?(@expr, []);

  // need to check that expr contains only allowed functions
  CUnparsable?(expr_, funclist_List?) <--
  {
    Local(badfunctions);
    badfunctions := Difference(`FuncList(@expr), Concat(UnparseCAllFunctions, funclist));
    Decide(Length(badfunctions)=?0,
      True,
      {
        Decide(Verbose?(),
          Echo("CUnparsable?: Info: unexportable function(s): ", badfunctions)
        );
        False;
      }
    );
  };
  HoldArgumentNumber("CUnparsable?", 1, 1);
  HoldArgumentNumber("CUnparsable?", 2, 1);

  /// This is a list of all function atoms which UnparseC can safely handle
  UnparseCAllFunctions := Concat(AssociationIndices(UnparseCMathFunctions()), AssociationIndices(UnparseCRegularOps()),
  // list of "other" (non-math) functions supported by UnparseC: needs to be updated when UnparseC is extended to handle new functions
  [
    "For",
    "While",
    "Sequence",
    "Nth",
    "Modulo",
    "Complex",
    "If",
    "Else",
    "++",
    "--",
  ]
  );


}; // LocalSymbols(UnparseCAllFunctions)

%/mathpiper





%mathpiper_docs,name="CUnparsable?",categories="Programming Functions;Input/Output;Predicates"
*CMD CUnparsable? --- check possibility to export expression to C++ code
*STD
*CALL
        CUnparsable?(expr)
        CUnparsable?(expr, funclist)
        
*PARMS

{expr} -- expression to be exported (this argument is not evaluated)

{funclist} -- list of "allowed" function names

*DESC

{CUnparsable?} returns {True} if the MathPiper expression {expr} can be exported
into C++ code. This is a check whether the C++ exporter {UnparseC} can be safely
used on the expression.

A MathPiper expression is considered exportable if it contains only functions that can be translated into C++ (e.g. {ListToFunction} cannot be exported). All variables and constants are considered exportable.

The verbose option prints names of functions that are not exportable.

The second calling format of {CUnparsable?} can be used to "allow" certain function names that will be available in the C++ code.

*E.G.
In> CUnparsable?(Sine(a1)+2*Cosine(b1))
Result: True

Verbose(CUnparsable?(1+func123(b1)))
Result: False
Side Effects:
CUnparsable?: Info: unexportable function(s): func123

This returned {False} because the function {func123} is not available in C++. We can
explicitly allow this function and then the expression will be considered
exportable:

In> CUnparsable?(1+func123(b1), [func123])
Result: True;

*SEE UnparseC, VM                                                        
%/mathpiper_docs
                         




%mathpiper,name="CUnparsable?",subtype="automatic_test"
Verify(
	CUnparsable?(e+Pi*Cosine(A-B)/3-Floor(3.14)*2)
	, True
);

Verify(
	CUnparsable?(e+Pi*Cosine(A-B)/3-Floor(3.14)*2+badfunc(x+y))
	, False
);

Verify(
	CUnparsable?(e+Pi*Cosine(A-B)/3-Floor(3.14)*2+badfunc(x+y), ["badfunc"])
	, True
);

Verify(
	CUnparsable?({i:=0;While(i<?10){i++; a:=a+i;};})
	, True
);

Verify(
	CUnparsable?({i:=0;While(i<?10){i++; a:=a+i; [];};})
	, False
);
%/mathpiper

    %output,parent="CUnparsable?",sequence="92",timestamp="2015-01-23 02:03:57.651",preserve="false"
      Result: True
.   %/output


