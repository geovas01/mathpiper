%mathpiper,def="Function"

/* Defining a macro-like function that declares a function
 * with only one rule.
 */
RulebaseHoldArguments("Function",[_oper,_args,_body]);



// function with variable number of arguments: Function("func",[x,y, ...])body;
RuleHoldArguments("Function",3,2047,
        And?(GreaterThan?(Length(args), 1), Equal?( MathNth(args, Length(args)), ToAtom("...") ))
)
{
  DestructiveDelete(args,Length(args));        // remove trailing "..."
  Retract(oper,Length(args));
  RulebaseListedEvaluateArguments(oper,args);
  RuleEvaluateArguments(oper,Length(args),1025,True) body;        // at precedence 1025, for flexibility
};

// function with a fixed number of arguments
RuleHoldArguments("Function",3,2048,True)
{
  Retract(oper,Length(args));
  RulebaseEvaluateArguments(oper,args);
  RuleEvaluateArguments(oper,Length(args),1025,True) body;
};


/// shorthand function declarations
RulebaseHoldArguments("Function",[_oper]);
// function with variable number of arguments: Function() f(x,y, ...)
RuleHoldArguments("Function",1,2047,
        And?(Function?(oper), GreaterThan?(Length(oper), 1), Equal?( MathNth(oper, Length(oper)), ToAtom("...") ))
)
{
        Local(args);
        Assign(args,Rest(FunctionToList(oper)));
        DestructiveDelete(args,Length(args));        // remove trailing "..."
        Decide(RulebaseDefined(Type(oper),Length(args)),
                False,        // do nothing
                RulebaseListedEvaluateArguments(Type(oper),args)
        );
};


// function with a fixed number of arguments
RuleHoldArguments("Function",1,2048,
        And?(Function?(oper))
)
{
        Local(args);
        Assign(args,Rest(FunctionToList(oper)));
        Decide(RulebaseDefined(Type(oper),Length(args)),
                False,        // do nothing
                RulebaseEvaluateArguments(Type(oper),args)
        );
};


HoldArgument("Function","oper");
HoldArgument("Function","args");
HoldArgument("Function","body");

%/mathpiper



%mathpiper_docs,name="Function",categories="Programming Functions;Programming"
*CMD Function --- declare or define a function
*STD
*CALL
        Function() func(arglist)
        Function() func(arglist, ...)
        Function("op", [arglist]) body
        Function("op", [arglist, ...]) body

*PARMS

{func(args)} -- function declaration, e.g. {f(x,y)}

{"op"} -- string, name of the function

{[arglist]} -- list of atoms, formal arguments to the function

{...} -- literal ellipsis symbol "{...}" used to denote a variable number of arguments

{body} -- expression comprising the body of the function

*DESC

This command can be used to define a new function with named arguments.


The number of arguments of the new function and their names are determined 
by the list {arglist}. If the ellipsis "{...}" follows the last atom in 
{arglist}, a function with a variable number of arguments is declared 
(using {RulebaseListedHoldArguments}). Note that the ellipsis cannot be 
the only element of {arglist} and <i>must</i> be preceded by an atom.

A function with variable number of arguments can take more arguments than 
elements in {arglist}; in this case, it obtains its last argument as a list 
containing all extra arguments.

The short form of the {Function} call merely declares a {RulebaseHoldArguments} 
for the new function but does not define any function body. This is a convenient 
shorthand for {RulebaseHoldArguments} and {RulebaseListedHoldArguments}, when 
definitions of the function are to be supplied by rules. If the new function 
has been already declared with the same number of arguments (with or without 
variable arguments), {Function} returns false and does nothing.

The second, longer form of the {Function} call declares a function and also 
defines a function body. It is equivalent to a
single rule such as {op(arg1_, arg2_) <-- body}. The rule will be declared at
precedence 1025. Any previous rules associated with {"op"} (with the same
arity) will be discarded. More complicated functions (with more than one body)
can be defined by adding more rules.

*E.G. notest

This will declare a new function with two or more arguments, but define no rules for it. This is equivalent to [Rulebase ("f1", [x, y, ...])].

In> Function() f1(_x,_y,...);
Result: True

In> f1(3,4,5,[1,2,3])
Result: f1(3,[4,5,[1,2,3]])

In> Function() f1(_x,_y);
Result: False;

This defines a function FirstOf which returns the
first element of a list. Equivalent definitions would be
FirstOf(list_) <-- list[1] or FirstOf(list) := list[1].
In> Function("FirstOf", [list])  list[1];
Result: True;

In> FirstOf([_a,_b,_c]);
Result: _a;

The following function will print all arguments to a string:

In> Function("PrintAll",[x_, ...]) Decide(List?(x),
          PrintList(x), PipeToString()Write(x));
Result: True;

In> PrintAll(1):
Result: "1";

In> PrintAll(1,2,3);
Result: "1 2 3";

*SEE TemplateFunction, Rule, Rulebase,  RulebaseListedHoldArguments, :=, Retract
%/mathpiper_docs





%mathpiper,name="Function",subtype="automatic_test"

Function("count",[_from,_to])
{
   Local(i);
   Local(sum);
   Assign(sum,0);
   For(i:=from,i<?to,i:=i+1)
   {
     Assign(sum,sum+i);
   };
   sum;
};

Testing("Function definitions");
Verify(count(1,11),55);

Retract("count", All);

%/mathpiper