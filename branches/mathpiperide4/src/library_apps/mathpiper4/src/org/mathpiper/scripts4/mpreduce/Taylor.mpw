%mathpiper,title="For Taylor  expansions by PKHG"

MathPiperToTaylorPKHG(exp) :=
{ 
    Local(expString);
    expString := ToString(exp);
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), "replace", "_", "pkhg_"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), "replace", "==", "=")); 
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcCosine", "acos"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcCotangent", "acot"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcCosecant", "acsc"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcSecant", "asec"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcSine", "asin"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])ArcTangent", "atan"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Cosine", "cos"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Cotangent", "cot"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Cosecant", "csc"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Secant", "sec"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Sine", "sin"));
    expString := ToString(JavaAccess(JavaNew("java.lang.String", expString), 
    	      "replaceAll", "(?<![a-zA-Z])Tangent", "tan"));
};

TaylorToMathPiperPKHG(exp) :=
{
    Local(result);
    expString := ToString(exp);
    result := JavaAccess(JavaNew("java.lang.String", expString), "replace", "$", "");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replace", "pkhg", "");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replace", "**", "^");
    result := JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])sqrt", "Sqrt");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replaceAll", "(?<![a-zA-Z])pi", "Pi");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replaceAll", "(?<![a-zA-Z])log", "Log");
    result := JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])arbint", "Arbint");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replace", "{", "[");
    result := JavaAccess(JavaNew("java.lang.String", result),
    	    "replace", "}", "]");
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])acos", "ArcCosine"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])acot", "ArcCotangent"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])acsc", "ArcCosecant"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])asec", "ArcSecant"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])asin", "ArcSine"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])atan", "ArcTangent"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])cos", "Cosine"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])cot", "Cotangent"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])csc", "Cosecant"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])sec", "Secant"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])sin", "Sine"));
    result := ToString(JavaAccess(JavaNew("java.lang.String", result), 
    	   "replaceAll", "(?<![a-zA-Z])tan", "Tangent"));
    Check(Not? JavaAccess(JavaNew("java.lang.String", result), 
    	       "contains", "*****"),"",result);
    PipeFromString(ToString(result) ~ ";") ParseMathPiper();
};

removeCrLf(str) := {
    str := ToString(JavaAccess(JavaNew("java.lang.String", str),"replaceAll", "\\n", ""));
    str := ToString(JavaAccess(JavaNew("java.lang.String", str),"replaceAll", "\\r", ""));
};


Function("Taylor", [_argsList, _function])
{
	Local(redArgs, lenRedArgs, redExpr, firstComma, result, mpRED);
	
	//transform the arguments to Reduce variables
	redArgs := MathPiperToTaylorPKHG(argsList);
	//Echo(redArgs);
	
	//replace [ bij an , and the ] bij an )
	redArgs := StringMidSet(1,",",redArgs);
	lenRedArgs := Length(redArgs);
	redArgs := StringMidSet(lenRedArgs,")",redArgs);
   	//Echo(redArgs);

    //expression (the function) has to be changed too
    redExpr := MathPiperToTaylorPKHG(function);
    //Echo(redExpr);
    
    //prepare the Reduce taylor command
    redCommand := ConcatStrings("taylor(",redExpr,redArgs,";");
    
	//for an Reduce interpeter let it use NOT 2d output: off factor needed!!
	mpRED := JavaCall("org.mathpiper.mpreduce.Interpreter2", "getInstance");
	JavaAccess(mpRED,"evaluate","off factor");    
    result := removeCrLf(JavaAccess(mpRED, "evaluate", Eval(redCommand)));
    //Reduce dit its work: done

    //now  prepare for MathPiper-conversion
    //remove taylor( and the development parameters at the end 
	//and make a trailing semicolon
    //Search for a first comma needed, because Reduce converts decimal fractions 
    //into an equal valued fraction!
    firstComma := FindFirst(StringToList(result),","); 
    
    result := result[8 .. firstComma];
    result := StringMidSet(firstComma - 7,";",result);
    //Echo(" shortened result");
    //Echo(result);

    //backtransformation of variables and functionnames
    TaylorToMathPiperPKHG(result);    
    //Finished ;-)
};


%/mathpiper 

    %output,sequence="12",timestamp="2014-03-03 12:39:14.306",preserve="false"
      Result: True
.   %/output

  
    

%mathpiper,title="test 1 maybe REMOVE this"    
helpCosine:= Taylor([_xx,Pi,5,_y,1.1,5]) Cosine(_xx) + _y^6 ;
Echo(helpCosine);
help1 := Taylor([_xx,3.14,4]) _xx^4;
//Echo(help1);
help2 := Expand(help1);
tmp := help2 =? _xx^4 ;

%/mathpiper

    %output,sequence="18",timestamp="2014-03-03 13:02:11.383",preserve="false"
      Result: True
      
      Side Effects:
      771561/1000000+483153/50000*(_y-11/10)+43923/2000*(_y-11/10)^2+1331/50*(_y-11/10)^3+363/20*(_y-11/10)^4+33/5*(_y-11/10)^5+1/2*(_xx-Pi)^2-1/24*(_xx-Pi)^4 
      
.   %/output

 

