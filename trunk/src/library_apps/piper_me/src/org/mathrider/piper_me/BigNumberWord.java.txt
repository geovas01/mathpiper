package net.sf.yacas;

/*
This is Ayal's original implementation of the BigNumber interface. 
*/

class BigNumber
{
  public static boolean NumericSupportForMantissa()
  {
    return true;
  }


  //constructors
  static public BigNumber create( String aString,int aBasePrecision,int aBase/*=10*/) {
	  return new BigNumber(aString, aBasePrecision, aBase);
  }
  
  private BigNumber( String aString,int aBasePrecision,int aBase/*=10*/)
  {
    SetTo(aString, aBasePrecision, aBase);
  }
  
  private BigNumber( BigNumber aOther)
  {
    SetTo(aOther);
  }
  
  // no constructors from int or double to avoid automatic conversions
  private BigNumber(int aPrecision/* = 20*/)
  {
    iPrecision = aPrecision;
    integer = 0;
  }
  
  static public BigNumber create(int aPrecision/* = 20*/)
  {
	return new BigNumber(aPrecision);
  }
  
  // assign from another number
  private void SetTo( BigNumber aOther)
  {
    iPrecision = aOther.GetPrecision();
    integer  = aOther.integer;
  }
  
  public boolean IsFloat(String aString,int aBase)
  {
    if (aString.indexOf('.')>=0)
      return true;
    if (aBase>10)
      return false;
    if (aString.indexOf('e')>=0)
      return true;
    if (aString.indexOf('E')>=0)
      return true;
    return false;
  }
  // assign from string, precision in base digits
  private void SetTo( String aString,int aPrecision,int aBase/*=10*/)
  {
    integer = Long.parseLong(aString);
    iPrecision = aPrecision;
  }
  
  static public BigNumber create(int pPrecision, long value) {
	  return new BigNumber(pPrecision, value);
  }
  
  static public BigNumber create(int pPrecision, int value) {
	  return new BigNumber(pPrecision, value);
  }
  
  static public BigNumber create(int pPrecision, double value) {
	  return new BigNumber(pPrecision, value);
  }
  
  private void SetTo(double value)
  {
    SetTo(""+value,iPrecision,10);
  }
  
  
  private BigNumber(int pPrecision, double value) {
	  iPrecision = pPrecision;
	  integer = (long) value;
	  SetTo(value);
  }
  
  // Convert back to other types
  /// ToString : return string representation of number in aResult to given precision (base digits)
  public String ToString(int aPrecision, int aBase/*=10*/)
  {
	return Long.toString(integer);  
  }
  /// Give approximate representation as a double number
  public double Double()
  {
    return integer;
  }
  public long Long()
  {
    return integer;
  }

  //basic object manipulation
  public boolean Equals( BigNumber aOther)
  {
	return (this.integer == aOther.integer);
  } 
  
  public boolean IsInt()
  {
    return true;
    
  }
  public boolean IsSmall()
  {
	return ((integer > -65535) && (integer < 65535));
  }
 
  
  public BigNumber becomeFloat()
  {
	return null;
  }
  
  public boolean LessThan( BigNumber aOther)
  {
	return this.integer < aOther.integer;
  }
  
   
  public BigNumber multiply(BigNumber b, int aPrecision) {
		  BigNumber x = new BigNumber(aPrecision);
		  x.integer = this.integer*b.integer;
		  return x;
	  }
   
  
  public BigNumber negate(int aPrecision ) throws Exception
  {
	  BigNumber x = new BigNumber(aPrecision);
	  x.integer = -this.integer;
	  return x;
  }

  
  public BigNumber add(BigNumber b, int aPrecision) {
	  BigNumber x = new BigNumber(aPrecision);
	  x.integer = this.integer + b.integer;
	  return x;
  }

  public BigNumber divide(BigNumber b, int aPrecision) {
	  return null;
  }

  public BigNumber mod(BigNumber b, int aPrecision) throws Exception {
	  return null;
  }

  /// For debugging purposes, dump internal state of this object into a string
  public void DumpDebugInfo(LispOutput aOutput) throws Exception
  {
  }


  public BigNumber floor(int aPrecesion) {
	  return this;
  }
  
  public BigNumber setPrecision(int aPrecision) {
	  BigNumber x = new BigNumber(this);
	  x.iPrecision = aPrecision;
	  return x;
  }
  
  public BigNumber shiftLeft(int aNrToShift, int aPrecision ) throws Exception
  {
	  return null;
  }

  public BigNumber shiftRight(int aNrToShift, int aPrecision ) throws Exception
  {
	  return null;
  }
 
  BigNumber gcd(BigNumber b, int aPrecision ) throws Exception
  {
	  return null;
  }

  public BigNumber bitAnd(BigNumber b, int aPrecision ) throws Exception
  {
	  return null;
  }
  
  public BigNumber bitOr(BigNumber b, int aPrecision ) throws Exception
  {
	  return null;
  }
  
  
  public BigNumber bitXor(BigNumber b, int aPrecision ) throws Exception
  {
	  return null;
  }
  
  public BigNumber bitNot(int aPrecision ) throws Exception
  {
	  return null;
  }
  
  public long BitCount()
  {
	return  0;
  }
 
  /// Give sign (-1, 0, 1)
  public int Sign()
  {
    return Long.signum(integer);
  }

  public int GetPrecision()
  {
    return iPrecision;
  }

  int iPrecision;
  long integer;
}
