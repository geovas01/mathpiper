Turning stack tracing on: Result: True

Side Effects:
Stack tracing is on.

***** Thu Mar 25 20:44:12 EST 2010 *****
***** Using a new interpreter instance for each test file. *****
***** MathPiper version: .78u *****

===========================
arithmetic.mpt: 

Result: True

Side Effects:

Test suite for Test arithmetic : 

Test suite for Basic calculations : 

Test suite for Testing math stuff : 
--IntegerOperations
--PowerN
--Rounding
--Bases
--Factorization

===========================
binaryfactors.mpt: 

Result: True

===========================
calculus.mpt: 

Result: True

Side Effects:
--UnaryFunctionInverses
--Derivatives
--Limits
Known failure: Limit(k,Infinity)((k-phi)/k)^(k+1/2)=Exp(-phi) 
--Pslq

===========================
canprove.mpt: 

Result: True

Side Effects:

Test suite for Propositional logic theorem prover : 

===========================
comments.mpt: 

Result: True

Side Effects:

Test suite for Checking comment syntax supported : 

===========================
complex.mpt: 

Result: True

Side Effects:
Known failure: (Limit(n,Infinity)(n^2*I^n)/(n^3+1))=0 

===========================
c_tex_form.mpt: 

Result: True

Side Effects:

Test suite for TeXForm()... : 
--IsCFormable

===========================
cyclotomic.mpt: 

Result: True

Side Effects:

Test suite for Cyclotomic Polynomials : 

===========================
deriv.mpt: 

Result: True

===========================
dimensions.mpt: 

Result: True

Side Effects:
---- Dimensions (Tensor Rank)

===========================
dot.mpt: 

Result: True

Side Effects:
---- Dot

===========================
GaussianIntegers.mpt: 

Result: True

Side Effects:

Test suite for Gaussian Integers : 

===========================
includetestfiles: is not a MathPiper test file.

===========================
integrate.mpt: 

Result: True

===========================
issues.mpt: 

Result: True

Side Effects:

Test suite for Problems reported as Issues : 

===========================
io.mpt: 

Result: True

Side Effects:
--Error reporting

===========================
journal.mpt: 

Result: True

===========================
linalg.mpt: 

Result: True

Side Effects:
--LeviCivita
--VectorProducts

Test suite for Inproduct : 

Test suite for Identity matrices : 

Test suite for Check linear algebra : 
--Normalize
--DiagonalMatrix
--ZeroMatrix
--Transpose
--Determinant
--CoFactor
--Minor
--Inverse
--SolveMatrix
--Trace

===========================
lists.mpt: 

Result: True

Side Effects:

Test suite for VarList : 
--BubbleSort
--HeapSort
--ListOperations
--Length
--Nth
--Concat
--Binary searching
--AssocDelete
---- Arithmetic Operations

===========================
logic_simplify_test.mpt: 

Result: True

Side Effects:

Test suite for CNF : 

===========================
macro.mpt: 

Result: True

===========================
mathpiper_tests.log: is not a MathPiper test file.

===========================
matrixpower.mpt: 

Result: True

Side Effects:
---- MatrixPower

===========================
multivar.mpt: 

Result: True

Side Effects:

Test suite for Test arithmetic : 

===========================
nthroot.mpt: 

Result: True

Side Effects:
---- NthRoot

===========================
numbers.mpt: 

Result: True

Side Effects:
--Integer logarithms and roots
--Factorial
--Random numbers

===========================
numerics.mpt: 

Result: True

Side Effects:
******************
tests/scripts4/numerics.mpt: 7 

newrepI[1]-newrepD[1]
 evaluates to 
-9999999999000000000
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 25 

newrepL[1]-newrepR[1]
 evaluates to 
-49437552990
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 193 

newrepL[1]-newrepR[1]
 evaluates to 
-53768446116670000000
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 195 

newrepL[1]-newrepR[1]
 evaluates to 
-6282627216100000000
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 205 

newrepL[1]-newrepR[1]
 evaluates to 
-467315088652157285
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 263 

NearRational(N(Pi))
 evaluates to 
201/64
 which differs from 
355/113
******************
******************
tests/scripts4/numerics.mpt: 285 

newrepL[1]-newrepR[1]
 evaluates to 
-15709752024
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 290 

newrepL[1]-newrepR[1]
 evaluates to 
-1
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 291 

newrepL[1]-newrepR[1]
 evaluates to 
-1
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 292 

newrepL[1]-newrepR[1]
 evaluates to 
-1
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 293 

newrepL[1]-newrepR[1]
 evaluates to 
1647202136
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 294 

newrepL[1]-newrepR[1]
 evaluates to 
7
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 295 

newrepL[1]-newrepR[1]
 evaluates to 
3
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 296 

newrepL[1]-newrepR[1]
 evaluates to 
4164
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 298 

newrepL[1]-newrepR[1]
 evaluates to 
-1
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 301 

newrepL[1]-newrepR[1]
 evaluates to 
-1
 which differs from 
0
******************
--Gamma constant
******************
tests/scripts4/numerics.mpt: 316 

newrepL[1]-newrepR[1]
 evaluates to 
2
 which differs from 
0
******************
******************
tests/scripts4/numerics.mpt: 321 

newrepL[1]-newrepR[1]
 evaluates to 
1
 which differs from 
0
******************

===========================
nummethods.mpt: 

Result: True

===========================
ode.mpt: 

Result: True

Side Effects:
**** THE ODE TEST HAS BEEN TEMPORARILY REMOVED BECAUSE IT CAUSED AN INFINITE RECURSION ****

===========================
openmath.mpt: 

Result: True

Side Effects:

Test suite for Converting to and from OpenMath expressions : 

===========================
orthopoly.mpt: 

Result: True

Side Effects:

Test suite for Testing orthogonal polynomials : 

===========================
outer.mpt: 

Result: True

Side Effects:
---- Outer

===========================
piper_test.bat: is not a MathPiper test file.

===========================
plots.mpt: 

Result: True

Side Effects:
******************
tests/scripts4/plots.mpt: 6 

PipeToString()Write(Plot2D(a,-1:1,output->data,points->4,depth->0))
 evaluates to 
"{{{-1,-1},{-0.5,-0.5},{0.0,0.0},{0.5,0.5},{1,1}}}"
 which differs from 
"{{{-1,-1},{-0.5,-0.5},{0,0},{0.5,0.5},{1.,1.}}}"
******************
******************
tests/scripts4/plots.mpt: 7 

PipeToString()Write(Plot2D(b,b->-1:1,output->data,points->4))
 evaluates to 
"{{{-1,-1},{-0.5,-0.5},{0.0,0.0},{0.5,0.5},{1,1}}}"
 which differs from 
"{{{-1,-1},{-0.5,-0.5},{0,0},{0.5,0.5},{1.,1.}}}"
******************
******************
tests/scripts4/plots.mpt: 14 

PipeToString()Write(Plot3DS(a,-1:1,-1:1,output->data,points->2))
 evaluates to 
"{{{-1,-1,-1},{-1,0,-1},{-1,1,-1},{0,-1,0},{0,0,0},{0,1,0},{1,-1,1},{1,0,1},{1,1,1}}}"
 which differs from 
"{{{-1,-1,-1},{-1,0,-1},{-1,1.,-1},{0,-1,0},{0,0,0},{0,1.,0},{1.,-1,1.},{1.,0,1.},{1.,1.,1.}}}"
******************
******************
tests/scripts4/plots.mpt: 14 

PipeToString()Write(Plot3DS(x1,x1->-1:1,x2->-1:1,output->data,points->2))
 evaluates to 
"{{{-1,-1,0.1011417762},{-1,0,0.1011417762},{-1,1,0.1011417762},{0,-1,0.1011417762},{0,0,0.1011417762},{0,1,0.1011417762},{1,-1,0.1011417762},{1,0,0.1011417762},{1,1,0.1011417762}}}"
 which differs from 
"{{{-1,-1,-1},{-1,0,-1},{-1,1.,-1},{0,-1,0},{0,0,0},{0,1.,0},{1.,-1,1.},{1.,0,1.},{1.,1.,1.}}}"
******************

===========================
poly.mpt: 

Result: True

Side Effects:

Test suite for Polynomials : 

===========================
predicates.mpt: 

Result: True

Side Effects:
--Predicates
--Boolean Operations
--NumberCompares
--comparisons in exponential notation
--Matrix predicates
******************
tests/scripts4/predicates.mpt: 123 

HasFuncArith(a*b+f({b,c}),List)
 evaluates to 
True
 which differs from 
False
******************
--IsConstant
---- IsScalar
---- IsVector
---- IsVector(IsNumber)
---- Matrix Predicates
------ IsMatrix
------ IsMatrix(IsInteger)
------ IsSquareMatrix

===========================
programming.mpt: 

Result: True

Side Effects:
--Apply
--ThreadingListables
--MapSingle
--Function definitions
--LocalVariables

===========================
radsimp.mpt: 

Result: True

Side Effects:

Test suite for Testing simplifying nested radicals : 

===========================
regress.mpt: 

Result: True

Side Effects:

Test suite for Regression on bug reports : 
******************
tests/scripts4/regress.mpt: 328 

(Integrate(x,a,b)Cos(x)^2)-((b-Sin((-2)*b)/2)/2-(a-Sin((-2)*a)/2)/2)
 evaluates to 
(Sin(2*b)/2+b)/2-(Sin(2*a)/2+a)/2-((b-(-Sin(2*b))/2)/2-(a-(-Sin(2*a))/2)/2)
 which differs from 
0
******************
Known failure: (Limit(x,Infinity)x^n/Ln(x))=Infinity 
Known failure: (Limit(x,0,Right)x^(Ln(a)/(1+Ln(x))))=a 
Known failure: Gcd(10,3.3)!=3.3AndGcd(10,3.3)!=1 
Known failure: (Differentiate(z)Conjugate(z))=Undefined 
Known failure: ArcCos(Cos(beta))!=beta 
Known failure: (Limit(n,Infinity)n^5/2^n)=0 
Known failure: RoundTo(RoundTo(N(Cot(2),9),9),N(Cot(2),9),9)=0 

===========================
scopestack.mpt: 

Result: True

===========================
simplify.mpt: 

Result: True

Side Effects:

Test suite for Simplify : 

===========================
solve.mpt: 

Result: True

Side Effects:
--Solve

Exception:In function "IsLessThan" : 
bad argument number 1(counting from 1) : 
The first argument must be a non-complex decimal number or a string.
The offending argument N(Eval(result-n)) evaluated to Complex(0,-1)


========================================= Start Of Built In Function Stack Trace
0: LoadScript
   1: -> "tests/scripts4/solve.mpt"
-----------------------------------------
2: If
   3: -> VerifySolve'Equal(Eval(e1),Eval(e2))
   4: -> True
   5: -> [
    WriteString("******************");
    NewLine();
    ShowLine();
    NewLine();
    Write(e1);
    NewLine();
    WriteString(" evaluates to ");
    NewLine();
    Write(Eval(e1));
    NewLine();
    WriteString(" which differs from ");
    NewLine();
    Write(e2);
    NewLine();
    WriteString("******************");
    NewLine();
    False;
]

-----------------------------------------
6: Solve(ArcTan(x^4)==Pi/4,x)
-----------------------------------------
7: Prog
   8: -> Check(NotIsNumber(aLeftAssign),"Only a variable can be placed on the left side of an := operator.")
   9: -> MacroBind(aLeftAssign,Eval(aRightAssign))
   10: -> Eval(aLeftAssign)
-----------------------------------------
11: Eval(aRightAssign)
-----------------------------------------
12: Eval
   13: -> aRightAssign
-----------------------------------------
14: Prog
   15: -> ClearError("Solve'Fails")
   16: -> Local(context,expr2,var2,res,sol,sol2,i)
   17: -> context:=Solve'Context(expr,var)
   18: -> If(context=False,res:=Failed,[
    expr2:=Eval(Subst(context,var2)expr);
    If(CanBeUni(var2,expr2)And(Degree(expr2,var2)=0OrDegree(expr2,var2)=1AndCoef(expr2,var2,1)=1),res:=Failed,[
        sol2:=Solve(expr2,var2);
        If(IsError("Solve'Fails"),[
            ClearError("Solve'Fails");
            res:=Failed;
]
,[
            res:={};
            i:=1;
            While(i<=Length(sol2)Andres!=Failed)[
                sol:=Solve(context==(var2Wheresol2[i]),var);
                If(IsError("Solve'Fails"),[
                    ClearError("Solve'Fails");
                    res:=Failed;
]
,res:=Union(res,sol));
                i++;
]
;
]
);
]
);
]
)
   19: -> res
-----------------------------------------
20: {expr2:=Eval(Subst(context,var2)expr),If(CanBeUni(var2,expr2)And(Degree(expr2,var2)=0OrDegree(expr2,var2)=1AndCoef(expr2,var2,1)=1),res:=Failed,[
    sol2:=Solve(expr2,var2);
    If(IsError("Solve'Fails"),[
        ClearError("Solve'Fails");
        res:=Failed;
]
,[
        res:={};
        i:=1;
        While(i<=Length(sol2)Andres!=Failed)[
            sol:=Solve(context==(var2Wheresol2[i]),var);
            If(IsError("Solve'Fails"),[
                ClearError("Solve'Fails");
                res:=Failed;
]
,res:=Union(res,sol));
            i++;
]
;
]
);
]
)}
-----------------------------------------
21: If
   22: -> CanBeUni(var2,expr2)And(Degree(expr2,var2)=0OrDegree(expr2,var2)=1AndCoef(expr2,var2,1)=1)
   23: -> res:=Failed
   24: -> [
    sol2:=Solve(expr2,var2);
    If(IsError("Solve'Fails"),[
        ClearError("Solve'Fails");
        res:=Failed;
]
,[
        res:={};
        i:=1;
        While(i<=Length(sol2)Andres!=Failed)[
            sol:=Solve(context==(var2Wheresol2[i]),var);
            If(IsError("Solve'Fails"),[
                ClearError("Solve'Fails");
                res:=Failed;
]
,res:=Union(res,sol));
            i++;
]
;
]
);
]

-----------------------------------------
25: {sol2:=Solve(expr2,var2),If(IsError("Solve'Fails"),[
    ClearError("Solve'Fails");
    res:=Failed;
]
,[
    res:={};
    i:=1;
    While(i<=Length(sol2)Andres!=Failed)[
        sol:=Solve(context==(var2Wheresol2[i]),var);
        If(IsError("Solve'Fails"),[
            ClearError("Solve'Fails");
            res:=Failed;
]
,res:=Union(res,sol));
        i++;
]
;
]
)}
-----------------------------------------
26: If
   27: -> IsError("Solve'Fails")
   28: -> [
    ClearError("Solve'Fails");
    res:=Failed;
]

   29: -> [
    res:={};
    i:=1;
    While(i<=Length(sol2)Andres!=Failed)[
        sol:=Solve(context==(var2Wheresol2[i]),var);
        If(IsError("Solve'Fails"),[
            ClearError("Solve'Fails");
            res:=Failed;
]
,res:=Union(res,sol));
        i++;
]
;
]

-----------------------------------------
30: {res:={},i:=1,While(i<=Length(sol2)Andres!=Failed)[
    sol:=Solve(context==(var2Wheresol2[i]),var);
    If(IsError("Solve'Fails"),[
        ClearError("Solve'Fails");
        res:=Failed;
]
,res:=Union(res,sol));
    i++;
]
}
-----------------------------------------
31: While
   32: -> i<=Length(sol2)Andres!=Failed
   33: -> [
    sol:=Solve(context==(var2Wheresol2[i]),var);
    If(IsError("Solve'Fails"),[
        ClearError("Solve'Fails");
        res:=Failed;
]
,res:=Union(res,sol));
    i++;
]

-----------------------------------------
34: Prog
   35: -> sol:=Solve(context==(var2Wheresol2[i]),var)
   36: -> If(IsError("Solve'Fails"),[
    ClearError("Solve'Fails");
    res:=Failed;
]
,res:=Union(res,sol))
   37: -> i++
-----------------------------------------
38: MacroBind
   39: -> aLeftAssign
   40: -> Eval(aRightAssign)
-----------------------------------------
41: Eval
   42: -> aRightAssign
-----------------------------------------
43: Prog
   44: -> Check(NotIsNumber(aLeftAssign),"Only a variable can be placed on the left side of an := operator.")
   45: -> MacroBind(aLeftAssign,Eval(aRightAssign))
   46: -> Eval(aLeftAssign)
-----------------------------------------
47: Eval(aRightAssign)
-----------------------------------------
48: Eval
   49: -> aRightAssign
-----------------------------------------
50: LocalSymbols
   51: -> x
   52: -> [
    Local(roots);
    roots:=PSolve(expr,var);
    If(Type(roots)="PSolve",Failed,If(Type(roots)="List",MapSingle({{x},var==x},roots),{var==roots}));
]

-----------------------------------------
53: {Local(roots),roots:=PSolve(expr,var),If(Type(roots)="PSolve",Failed,If(Type(roots)="List",MapSingle({{$x877},var==$x877},roots),{var==roots}))}
-----------------------------------------
54: Prog
   55: -> Check(NotIsNumber(aLeftAssign),"Only a variable can be placed on the left side of an := operator.")
   56: -> MacroBind(aLeftAssign,Eval(aRightAssign))
   57: -> Eval(aLeftAssign)
-----------------------------------------
58: Eval(aRightAssign)
-----------------------------------------
59: Eval
   60: -> aRightAssign
-----------------------------------------
61: Prog
   62: -> YacasPSolve(MakeUni(uni,var))
-----------------------------------------
63: Prog
   64: -> Local(coef4,a1,a2,a3,a4,y,y1,z,t,s)
   65: -> coef4:=Coef(uni,4)
   66: -> a1:=Coef(uni,3)/coef4
   67: -> a2:=Coef(uni,2)/coef4
   68: -> a3:=Coef(uni,1)/coef4
   69: -> a4:=Coef(uni,0)/coef4
   70: -> y1:=First(YacasPSolve(y^3-a2*y^2+(a1*a3-4*a4)*y+4*a2*a4-a3^2-a1^2*a4,y))
   71: -> t:=Sqrt(y1^2/4-a4)
   72: -> If(t=0,s:=Sqrt(y1+a1^2/4-a2),s:=(a1*y1-2*a3)/(4*t))
   73: -> Concat(YacasPSolve(z^2+(a1/2+s)*z+y1/2+t,z),YacasPSolve(z^2+(a1/2-s)*z+y1/2-t,z))
-----------------------------------------
74: MacroBind
   75: -> aLeftAssign
   76: -> Eval(aRightAssign)
-----------------------------------------
77: Eval
   78: -> aRightAssign
-----------------------------------------
79: Prog
   80: -> Local(max,result)
   81: -> Bind(max,CeilN(N(Eval(n^2))))
   82: -> Bind(result,0)
   83: -> Bind(result,RadSimpTry(n,0,1,max))
   84: -> if(CheckRadicals(n,result))resultelsen
-----------------------------------------
85: {if(IsLessThan(N(Eval(result-n)),0))[
    Local(i);
    i:=BSearch(max,Hold({{try},ClampRadicals(N(Eval(result+Sqrt(try)-n),20))}));
    If(i>0,[
        Bind(result,result+Sqrt(i));
        Bind(i,AddN(max,1));
        Bind(current,AddN(max,1));
]
);
    if(IsLessThan(N(Eval(result-n)),0))[
        For(Bind(i,current),i<=max,Bind(i,AddN(i,1)))[
            Local(new,test);
            Bind(test,result+Sqrt(i));
            Bind(new,RadSimpTry(n,test,i,max));
            if(CheckRadicals(n,new))[
                Bind(result,new);
                Bind(i,AddN(max,1));
]
;
]
;
]
;
]
,result}
-----------------------------------------
86: IsLessThan
   87: -> N(Eval(result-n))
   88: -> 0
========================================= End Of Built In Function Stack Trace



========================================= Start Of User Function Stack Trace
0: Prog
   1: -> max = -1
   2: -> current = 1
   3: -> result = 0
   4: -> n = Complex(0,1)
   5: -> arg4 = -1
   6: -> arg3 = 1
   7: -> arg2 = 0
   8: -> arg1 = Complex(0,1)
-----------------------------------------
9: RadSimpTry
   10: -> max = -1
   11: -> current = 1
   12: -> result = 0
   13: -> n = Complex(0,1)
   14: -> arg4 = -1
   15: -> arg3 = 1
   16: -> arg2 = 0
   17: -> arg1 = Complex(0,1)
-----------------------------------------
18: Prog
   19: -> result = 0
   20: -> max = -1
   21: -> n = Complex(0,1)
   22: -> arg1 = Complex(0,1)
-----------------------------------------
23: RadSimp
   24: -> n = Complex(0,1)
   25: -> arg1 = Complex(0,1)
-----------------------------------------
26: Prog
   27: -> aRightAssign = RadSimp(Sqrt(d)/(2*a))
   28: -> aLeftAssign = q
   29: -> r = NULL
   30: -> q = NULL
   31: -> d = -4
   32: -> c = 1
   33: -> b = 0
   34: -> a = 1
   35: -> uni = UniVariate(z,0,{1,0,1})
-----------------------------------------
36: :=
   37: -> aRightAssign = RadSimp(Sqrt(d)/(2*a))
   38: -> aLeftAssign = q
   39: -> r = NULL
   40: -> q = NULL
   41: -> d = -4
   42: -> c = 1
   43: -> b = 0
   44: -> a = 1
   45: -> uni = UniVariate(z,0,{1,0,1})
-----------------------------------------
46: Prog
   47: -> r = NULL
   48: -> q = NULL
   49: -> d = -4
   50: -> c = 1
   51: -> b = 0
   52: -> a = 1
   53: -> uni = UniVariate(z,0,{1,0,1})
-----------------------------------------
54: YacasPSolve
   55: -> uni = UniVariate(z,0,{1,0,1})
-----------------------------------------
56: Prog
   57: -> var = z
   58: -> uni = z^2+1
-----------------------------------------
59: YacasPSolve
   60: -> var = z
   61: -> uni = z^2+1
-----------------------------------------
62: Prog
   63: -> s = 0
   64: -> t = 1
   65: -> z = NULL
   66: -> y1 = 0
   67: -> y = NULL
   68: -> a4 = -1
   69: -> a3 = 0
   70: -> a2 = 0
   71: -> a1 = 0
   72: -> coef4 = 1
   73: -> uni = UniVariate(x,0,{-1,0,0,0,1})
-----------------------------------------
74: YacasPSolve
   75: -> uni = UniVariate(x,0,{-1,0,0,0,1})
-----------------------------------------
76: Prog
   77: -> var = x
   78: -> uni = x^4-1
-----------------------------------------
79: YacasPSolve
   80: -> var = x
   81: -> uni = x^4-1
-----------------------------------------
82: PSolve
   83: -> var = x
   84: -> uni = x^4-1
   85: -> arg2 = x
   86: -> arg1 = x^4-1
-----------------------------------------
87: Prog
   88: -> aRightAssign = PSolve(expr,var)
   89: -> aLeftAssign = roots
   90: -> roots = NULL
   91: -> var = x
   92: -> expr = x^4-1
   93: -> arg2 = x
   94: -> arg1 = x^4-1
-----------------------------------------
95: :=
   96: -> aRightAssign = PSolve(expr,var)
   97: -> aLeftAssign = roots
   98: -> roots = NULL
   99: -> var = x
   100: -> expr = x^4-1
   101: -> arg2 = x
   102: -> arg1 = x^4-1
-----------------------------------------
103: Prog
   104: -> roots = NULL
   105: -> var = x
   106: -> expr = x^4-1
   107: -> arg2 = x
   108: -> arg1 = x^4-1
-----------------------------------------
109: Solve'Poly
   110: -> var = x
   111: -> expr = x^4-1
   112: -> arg2 = x
   113: -> arg1 = x^4-1
-----------------------------------------
114: Prog
   115: -> aRightAssign = Solve'Poly(expr,var)
   116: -> aLeftAssign = $res79
   117: -> var = x
   118: -> expr = x^4-1
   119: -> arg2 = x
   120: -> arg1 = x^4-1
-----------------------------------------
121: :=
   122: -> aRightAssign = Solve'Poly(expr,var)
   123: -> aLeftAssign = $res79
   124: -> var = x
   125: -> expr = x^4-1
   126: -> arg2 = x
   127: -> arg1 = x^4-1
-----------------------------------------
128: Pattern
   129: -> var = x
   130: -> expr = x^4-1
   131: -> arg2 = x
   132: -> arg1 = x^4-1
-----------------------------------------
133: Solve
   134: -> arg2 = x
   135: -> arg1 = x^4-1
-----------------------------------------
136: Solve
   137: -> var = x
   138: -> rhs = 1
   139: -> lhs = x^4
   140: -> arg2 = x
   141: -> arg1 = x^4==1
-----------------------------------------
142: Prog
   143: -> aRightAssign = Solve(context==(var2Wheresol2[i]),var)
   144: -> aLeftAssign = sol
   145: -> i = 1
   146: -> sol2 = {var2==1}
   147: -> sol = NULL
   148: -> res = {}
   149: -> var2 = NULL
   150: -> expr2 = ArcTan(var2)-Pi/4
   151: -> context = x^4
   152: -> var = x
   153: -> expr = ArcTan(x^4)-Pi/4
   154: -> arg2 = x
   155: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
156: :=
   157: -> aRightAssign = Solve(context==(var2Wheresol2[i]),var)
   158: -> aLeftAssign = sol
   159: -> i = 1
   160: -> sol2 = {var2==1}
   161: -> sol = NULL
   162: -> res = {}
   163: -> var2 = NULL
   164: -> expr2 = ArcTan(var2)-Pi/4
   165: -> context = x^4
   166: -> var = x
   167: -> expr = ArcTan(x^4)-Pi/4
   168: -> arg2 = x
   169: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
170: Prog
   171: -> i = 1
   172: -> sol2 = {var2==1}
   173: -> sol = NULL
   174: -> res = {}
   175: -> var2 = NULL
   176: -> expr2 = ArcTan(var2)-Pi/4
   177: -> context = x^4
   178: -> var = x
   179: -> expr = ArcTan(x^4)-Pi/4
   180: -> arg2 = x
   181: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
182: Prog
   183: -> i = 1
   184: -> sol2 = {var2==1}
   185: -> sol = NULL
   186: -> res = {}
   187: -> var2 = NULL
   188: -> expr2 = ArcTan(var2)-Pi/4
   189: -> context = x^4
   190: -> var = x
   191: -> expr = ArcTan(x^4)-Pi/4
   192: -> arg2 = x
   193: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
194: Prog
   195: -> i = 1
   196: -> sol2 = {var2==1}
   197: -> sol = NULL
   198: -> res = {}
   199: -> var2 = NULL
   200: -> expr2 = ArcTan(var2)-Pi/4
   201: -> context = x^4
   202: -> var = x
   203: -> expr = ArcTan(x^4)-Pi/4
   204: -> arg2 = x
   205: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
206: Prog
   207: -> i = 1
   208: -> sol2 = {var2==1}
   209: -> sol = NULL
   210: -> res = {}
   211: -> var2 = NULL
   212: -> expr2 = ArcTan(var2)-Pi/4
   213: -> context = x^4
   214: -> var = x
   215: -> expr = ArcTan(x^4)-Pi/4
   216: -> arg2 = x
   217: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
218: Prog
   219: -> i = 1
   220: -> sol2 = {var2==1}
   221: -> sol = NULL
   222: -> res = {}
   223: -> var2 = NULL
   224: -> expr2 = ArcTan(var2)-Pi/4
   225: -> context = x^4
   226: -> var = x
   227: -> expr = ArcTan(x^4)-Pi/4
   228: -> arg2 = x
   229: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
230: Solve'Reduce
   231: -> var = x
   232: -> expr = ArcTan(x^4)-Pi/4
   233: -> arg2 = x
   234: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
235: Prog
   236: -> aRightAssign = Solve'Reduce(expr,var)
   237: -> aLeftAssign = $res79
   238: -> var = x
   239: -> expr = ArcTan(x^4)-Pi/4
   240: -> arg2 = x
   241: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
242: :=
   243: -> aRightAssign = Solve'Reduce(expr,var)
   244: -> aLeftAssign = $res79
   245: -> var = x
   246: -> expr = ArcTan(x^4)-Pi/4
   247: -> arg2 = x
   248: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
249: Pattern
   250: -> var = x
   251: -> expr = ArcTan(x^4)-Pi/4
   252: -> arg2 = x
   253: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
254: Solve
   255: -> arg2 = x
   256: -> arg1 = ArcTan(x^4)-Pi/4
-----------------------------------------
257: Solve
   258: -> var = x
   259: -> rhs = Pi/4
   260: -> lhs = ArcTan(x^4)
   261: -> arg2 = x
   262: -> arg1 = ArcTan(x^4)==Pi/4
-----------------------------------------
263: VerifySolve
   264: -> e2 = {x==1,x==(-1),x==Complex(0,1),x==Complex(0,-1)}
   265: -> e1 = Solve(ArcTan(x^4)==Pi/4,x)
   266: -> arg2 = {x==1,x==(-1),x==Complex(0,1),x==Complex(0,-1)}
   267: -> arg1 = Solve(ArcTan(x^4)==Pi/4,x)
-----------------------------------------
268: <START>
   269: -> x3 = Complex(0.5781546763,-0.3863831141)
   270: -> x2 = 0.3227530534
   271: -> x1 = 0.1011417762
   272: -> r3 = {"GaussianRNGDist","RNGEngine'L'Ecuyer",{2709829563,3749000831,434400621,2940752160,2658879708,999726441}}
   273: -> r2 = {"FlatRNGDist","RNGEngine'LCG'2",{1386213809}}
   274: -> r1 = {"FlatRNGDist","RNGEngine'LCG'2",{4023360633}}
========================================= End Of User Function Stack Trace

 In function: RadSimpTry, Source file: tests/scripts4/solve.mpt Line number: 76
===========================
sturm.mpt: 

Result: True

===========================
sums.mpt: 

Result: True

Side Effects:
--Taylor
******************
tests/scripts4/sums.mpt: 339 

$pp2278
 evaluates to 
Taylor'LPS(1,{-2,0,1/3,0},t,Taylor'LPS'ScalarMult(-1,Taylor'LPS(1,{2,0,(-1)/3,0},t,Taylor'LPS'ScalarMult(2,Taylor'LPS(1,{1,0,(-1)/6,0},t,Sin(t))))))
 which differs from 
Taylor'LPS(1,{-2,0,1/3,0},t,Taylor'LPS'ScalarMult(-2,Taylor'LPS(1,{1,0,(-1)/6,0},t,Sin(t))))
******************

===========================
tensors.mpt: 

Result: True

Side Effects:

Test suite for Tensors : 

===========================
test-yacas-c-version: is not a MathPiper test file.

===========================
trace.mpt: 

Result: True

Side Effects:
---- Trace

===========================
transforms.mpt: 

Result: True

===========================
: is not a MathPiper test file.


***** Tests complete *****

Exception Count: 1

GlobalVariables: Result: True

Side Effects:
{$a73,$a851,$b73,$b851,$bernoulli1Threshold56,$CacheOfConstantsN1,$CFormAllFunctions63,$cformMathFunctions61,$cformRegularOps60,$cindent62,$ClearScreenString34,$complexReduce48,$Debug'FileLines34,$Debug'FileLoaded34,$Debug'NrLines34,$ErrorTableau59,$formulaMaxWidth64,$GlobalStack20,$intpred72,$knownOrthoPoly71,$knownRNGDists44,$knownRNGEngines44,$lastcoef42,$LocResult74,$mathExpThreshold46,$mNum27,$n'max58,$nNum27,$NthRoot'Table256,$numericMode2,$omindent66,$omsymbol68,$omsymbolreverse68,$omtoken67,$options846,$p02278,$p12278,$p22278,$p32278,$p36,$p42278,$p850,$pc242278,$pc352278,$pc462278,$pc572278,$pc682278,$pj2278,$pj402278,$pj502278,$pj512278,$pj522278,$pj532278,$pj542278,$pju02278,$pp2278,$RandSeed45,$res30,$res79,$rFormMathFunctions39,$rFormRegularOps38,$RIndent40,$simple851,$st870,$TeXFormGreekLetters69,$TeXFormMathFunctions270,$TeXFormMathFunctions70,$TeXFormRegularOps69,$TeXFormRegularPrefixOps69,$TeXFormSpecialNames69,$Verbose35,%,ans,I,iDebug,ii,isHomogeneous,LoadResult,ppfactors,preassem} 
