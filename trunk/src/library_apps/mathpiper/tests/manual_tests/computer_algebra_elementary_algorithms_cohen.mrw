
%mathpiper
CASCompare(expressions) :=
[
    Local(count,e,me, answer);

    count := 1;
    
    ForEach(e,expressions)
    [
        If(IsList(e), [answer := e[2]; e := e[1];]);
        
        Echo("#",count ,"Problem:   ",e, If(IsBound(answer),ToString()[WriteString("  Answer: " );Write(answer);Clear(answer);],"") );
        
        
        //Echo("MathPiper:    ",Simplify(Eval(FromString(e:";") Read())));
        Echo("MathPiper:    ",Eval(FromString(e:";") Read()));
        
        //me := ToString()[WriteString("ratsimp(");Write(Atom(e));WriteString(")");];
        me := ToString()[WriteString("(");Write(Atom(e));WriteString(")");];
        Echo("Maxima:",Maxima(me));
        
        count := count + 1;
    
    ];

];
%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output



%mathpiper,title="page 55 exercises 1a.
Echo("pp.55 exercises. 1a  ");
NewLine();

expressions :={
{"x^2*x^3","x^5"},
{"x^(1/2)*x^(1/3)","x^(5/6)"},
{"x^a*x^b","x^(a+b)"},
{"(x^2)^3","x^6"},
{"(x^a)^2","x^(2*a)"},
{"(x^2)^(1/2)","|x|"},
{"(x^(1/2))^2","x"},
{"(x^2)^a","x^(2*a)"},
{"(x*y)^2","x^2*y^2"},
{"(x*y)^(1/3)","x^(1/3)*y^(1/3)"},
{"(x*y)^a","x^a*y^a"},

};

CASCompare(expressions);

%/mathpiper

    %output,preserve="false"
      Result: True
      
      Side Effects:
      pp.55 exercises. 1a  
      
      #1 Problem:   x^2*x^3  Answer: "x^5"
      MathPiper:    x^5 
      Maxima:(%o689) x^5
       
      #2 Problem:   x^(1/2)*x^(1/3)  Answer: "x^(5/6)"
      MathPiper:    Sqrt(x)*x^(1/3) 
      Maxima:(%o690) x^(5/6)
       
      #3 Problem:   x^a*x^b  Answer: "x^(a+b)"
      MathPiper:    x^(b+a) 
      Maxima:(%o691) x^(b+a)
       
      #4 Problem:   (x^2)^3  Answer: "x^6"
      MathPiper:    x^6 
      Maxima:(%o692) x^6
       
      #5 Problem:   (x^a)^2  Answer: "x^(2*a)"
      MathPiper:    x^a^2 
      Maxima:(%o693) x^(2*a)
       
      #6 Problem:   (x^2)^(1/2)  Answer: "|x|"
      MathPiper:    Sqrt(x^2) 
      Maxima:(%o694) abs(x)
       
      #7 Problem:   (x^(1/2))^2  Answer: "x"
      MathPiper:    x 
      Maxima:(%o695) x
       
      #8 Problem:   (x^2)^a  Answer: "x^(2*a)"
      MathPiper:    x^2^a 
      Maxima:(%o696) abs(x)^(2*a)
       
      #9 Problem:   (x*y)^2  Answer: "x^2*y^2"
      MathPiper:    (x*y)^2 
      Maxima:(%o697) x^2*y^2
       
      #10 Problem:   (x*y)^(1/3)  Answer: "x^(1/3)*y^(1/3)"
      MathPiper:    (x*y)^(1/3) 
      Maxima:(%o698) x^(1/3)*y^(1/3)
       
      #11 Problem:   (x*y)^a  Answer: "x^a*y^a"
      MathPiper:    (x*y)^a 
      Maxima:(%o699) (x*y)^a
.   %/output





%mathpiper,output="trace"
TraceOn();
x^(1/2)*x^(1/3);
TraceOff();
%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: True
      
      Side Effects:
      Tracing is on.
      Leave<builtin>}(TraceOn(),True);
      Enter<user>{(*,x^(1/2)*x^(1/3));
      Enter<user>{(^,x^(1/2));
          Enter<user>{(/,1/2);
              Arg(1,1);
              Arg(2,2);
              Enter<builtin>{(IsNumber,IsNumber(y));
              Leave<builtin>}(IsNumber(y),True);
              Enter<user>{(IsZero,IsZero(y));
                  Arg(y,2);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),True);
                  **** Rule in function (IsZero) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet())
                  Enter<builtin>{(Or,MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet()));
                      Enter<builtin>{(=,MathSign(x)=0);
                          Enter<builtin>{(MathSign,MathSign(x));
                          Leave<builtin>}(MathSign(x),1);
                      Leave<builtin>}(MathSign(x)=0,False);
                      Enter<user>{(<,AbsN(x)<PowerN(10,-BuiltinPrecisionGet()));
                          Enter<builtin>{(AbsN,AbsN(x));
                          Leave<builtin>}(AbsN(x),2);
                          Enter<user>{(PowerN,PowerN(10,-BuiltinPrecisionGet()));
                              Enter<user>{(-,-BuiltinPrecisionGet());
                                  Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                  Leave<builtin>}(BuiltinPrecisionGet(),10);
                                  Arg(BuiltinPrecisionGet(),10);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  **** Rule in function (-) matched: Precedence: 55, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: SubtractN(0,x)
                                  Enter<builtin>{(SubtractN,SubtractN(0,x));
                                  Leave<builtin>}(SubtractN(0,x),-10);
                              Leave<user>}(-BuiltinPrecisionGet(),-10);
                              Arg(10,10);
                              Arg(-BuiltinPrecisionGet(),-10);
                              **** Rule in function (PowerN) matched: Precedence: 0, Parameters: x<hold=false>, y<hold=false>, Predicates: None., Body: If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)))
                              Enter<builtin>{(If,If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False))));
                                  Enter<builtin>{(Equals,Equals(x,0));
                                  Leave<builtin>}(Equals(x,0),False);
                                  Enter<builtin>{(If,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)));
                                      Enter<builtin>{(Equals,Equals(x,1));
                                      Leave<builtin>}(Equals(x,1),False);
                                      Enter<builtin>{(If,If(IsInteger(y),MathIntPower(x,y),False));
                                          Enter<builtin>{(IsInteger,IsInteger(y));
                                          Leave<builtin>}(IsInteger(y),True);
                                          Enter<user>{(MathIntPower,MathIntPower(x,y));
                                              Arg(x,10);
                                              Arg(y,-10);
                                              **** Rule in function (MathIntPower) matched: Precedence: 0, Parameters: x<hold=false>, y<hold=false>, Predicates: None., Body: If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)))
                                              Enter<builtin>{(If,If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False))));
                                                  Enter<builtin>{(Equals,Equals(x,0));
                                                  Leave<builtin>}(Equals(x,0),False);
                                                  Enter<builtin>{(If,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)));
                                                      Enter<builtin>{(Equals,Equals(x,1));
                                                      Leave<builtin>}(Equals(x,1),False);
                                                      Enter<builtin>{(If,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False));
                                                          Enter<builtin>{(IsInteger,IsInteger(y));
                                                          Leave<builtin>}(IsInteger(y),True);
                                                          Enter<builtin>{(If,If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)));
                                                              Enter<builtin>{(LessThan,LessThan(y,0));
                                                              Leave<builtin>}(LessThan(y,0),True);
                                                              Enter<builtin>{(DivideN,DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))));
                                                                  Enter<user>{(PositiveIntPower,PositiveIntPower(AddN(x,0.),MathNegate(y)));
                                                                      Enter<builtin>{(AddN,AddN(x,0.));
                                                                      Leave<builtin>}(AddN(x,0.),10);
                                                                      Enter<builtin>{(MathNegate,MathNegate(y));
                                                                      Leave<builtin>}(MathNegate(y),10);
                                                                      Arg(AddN(x,0.),10);
                                                                      Arg(MathNegate(y),10);
                                                                      **** Rule in function (PositiveIntPower) matched: Precedence: 0, Parameters: x<hold=false>, n<hold=false>, Predicates: None., Body: [    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);]
                                                                      Enter<builtin>{(Prog,[    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);]);
                                                                          Enter<builtin>{(Local,Local(result,unit));
                                                                          Leave<builtin>}(Local(result,unit),True);
                                                                          Enter<builtin>{(If,If(LessThan(n,0),False,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]));
                                                                              Enter<builtin>{(LessThan,LessThan(n,0));
                                                                              Leave<builtin>}(LessThan(n,0),False);
                                                                              Enter<builtin>{(Prog,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]);
                                                                                  Enter<builtin>{(Set,Set(unit,1));
                                                                                  Leave<builtin>}(Set(unit,1),True);
                                                                                  Enter<builtin>{(Set,Set(result,unit));
                                                                                  Leave<builtin>}(Set(result,unit),True);
                                                                                  Enter<builtin>{(If,If(Equals(n,0),unit,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;])));
                                                                                      Enter<builtin>{(Equals,Equals(n,0));
                                                                                      Leave<builtin>}(Equals(n,0),False);
                                                                                      Enter<builtin>{(If,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]));
                                                                                          Enter<builtin>{(Equals,Equals(n,1));
                                                                                          Leave<builtin>}(Equals(n,1),False);
                                                                                          Enter<builtin>{(Prog,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]);
                                                                                              Enter<builtin>{(While,While(GreaterThan(n,0))[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),0);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),False);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),False);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),100);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),5);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),1);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),True);
                                                                                                          Enter<builtin>{(Set,Set(result,MultiplyN(result,x)));
                                                                                                              Enter<builtin>{(MultiplyN,MultiplyN(result,x));
                                                                                                              Leave<builtin>}(MultiplyN(result,x),100);
                                                                                                          Leave<builtin>}(Set(result,MultiplyN(result,x)),True);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),True);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),10000);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),2);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),0);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),False);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),False);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),100000000);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),1);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),1);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),True);
                                                                                                          Enter<builtin>{(Set,Set(result,MultiplyN(result,x)));
                                                                                                              Enter<builtin>{(MultiplyN,MultiplyN(result,x));
                                                                                                              Leave<builtin>}(MultiplyN(result,x),1.000000000E10);
                                                                                                          Leave<builtin>}(Set(result,MultiplyN(result,x)),True);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),True);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),1.000000000E16);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),0);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),False);
                                                                                              Leave<builtin>}(While(GreaterThan(n,0))[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                          Leave<builtin>}([    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;],1.000000000E10);
                                                                                      Leave<builtin>}(If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]),1.000000000E10);
                                                                                  Leave<builtin>}(If(Equals(n,0),unit,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;])),1.000000000E10);
                                                                              Leave<builtin>}([    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));],1.000000000E10);
                                                                          Leave<builtin>}(If(LessThan(n,0),False,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]),1.000000000E10);
                                                                      Leave<builtin>}([    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);],1.000000000E10);
                                                                  Leave<user>}(PositiveIntPower(AddN(x,0.),MathNegate(y)),1.000000000E10);
                                                              Leave<builtin>}(DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),1E-10);
                                                          Leave<builtin>}(If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),1E-10);
                                                      Leave<builtin>}(If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False),1E-10);
                                                  Leave<builtin>}(If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)),1E-10);
                                              Leave<builtin>}(If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False))),1E-10);
                                          Leave<user>}(MathIntPower(x,y),1E-10);
                                      Leave<builtin>}(If(IsInteger(y),MathIntPower(x,y),False),1E-10);
                                  Leave<builtin>}(If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)),1E-10);
                              Leave<builtin>}(If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False))),1E-10);
                          Leave<user>}(PowerN(10,-BuiltinPrecisionGet()),1E-10);
                          Arg(AbsN(x),2);
                          Arg(PowerN(10,-BuiltinPrecisionGet()),1E-10);
                          Enter<builtin>{(IsNumber,IsNumber(n));
                          Leave<builtin>}(IsNumber(n),True);
                          Enter<builtin>{(IsNumber,IsNumber(m));
                          Leave<builtin>}(IsNumber(m),True);
                          **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                          Enter<builtin>{(LessThan,LessThan(n-m,0));
                              Enter<user>{(-,n-m);
                                  Arg(n,2);
                                  Arg(m,1E-10);
                                  Enter<builtin>{(IsList,IsList($x8));
                                  Leave<builtin>}(IsList($x8),False);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  Enter<builtin>{(IsNumber,IsNumber(y));
                                  Leave<builtin>}(IsNumber(y),True);
                                  **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                                  Enter<builtin>{(SubtractN,SubtractN(x,y));
                                  Leave<builtin>}(SubtractN(x,y),2.000000000);
                              Leave<user>}(n-m,2.000000000);
                          Leave<builtin>}(LessThan(n-m,0),False);
                      Leave<user>}(AbsN(x)<PowerN(10,-BuiltinPrecisionGet()),False);
                  Leave<builtin>}(MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet()),False);
              Leave<user>}(IsZero(y),False);
              Enter<user>{(IsNonZeroInteger,IsNonZeroInteger(x));
                  Arg(x,1);
                  **** Rule in function (IsNonZeroInteger) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsInteger(x)Andx!=0
                  Enter<builtin>{(And,IsInteger(x)Andx!=0);
                      Enter<builtin>{(IsInteger,IsInteger(x));
                      Leave<builtin>}(IsInteger(x),True);
                      Enter<user>{(!=,x!=0);
                          Arg(x,1);
                          Arg(0,0);
                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None., Body: NotaLeft=aRight
                          Enter<builtin>{(Not,NotaLeft=aRight);
                              Enter<builtin>{(=,aLeft=aRight);
                              Leave<builtin>}(aLeft=aRight,False);
                          Leave<builtin>}(NotaLeft=aRight,True);
                      Leave<user>}(x!=0,True);
                  Leave<builtin>}(IsInteger(x)Andx!=0,True);
              Leave<user>}(IsNonZeroInteger(x),True);
              Enter<user>{(IsNonZeroInteger,IsNonZeroInteger(y));
                  Arg(y,2);
                  **** Rule in function (IsNonZeroInteger) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsInteger(x)Andx!=0
                  Enter<builtin>{(And,IsInteger(x)Andx!=0);
                      Enter<builtin>{(IsInteger,IsInteger(x));
                      Leave<builtin>}(IsInteger(x),True);
                      Enter<user>{(!=,x!=0);
                          Arg(x,2);
                          Arg(0,0);
                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None., Body: NotaLeft=aRight
                          Enter<builtin>{(Not,NotaLeft=aRight);
                              Enter<builtin>{(=,aLeft=aRight);
                              Leave<builtin>}(aLeft=aRight,False);
                          Leave<builtin>}(NotaLeft=aRight,True);
                      Leave<user>}(x!=0,True);
                  Leave<builtin>}(IsInteger(x)Andx!=0,True);
              Leave<user>}(IsNonZeroInteger(y),True);
              Enter<user>{(>,GcdN(x,y)>1);
                  Enter<builtin>{(GcdN,GcdN(x,y));
                  Leave<builtin>}(GcdN(x,y),1);
                  Arg(GcdN(x,y),1);
                  Arg(1,1);
                  **** Rule in function (>) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) True,     Variables: n, m,    Types: Variable, Variable, Body: m<n
                  Enter<user>{(<,m<n);
                      Arg(m,1);
                      Arg(n,1);
                      Enter<builtin>{(IsNumber,IsNumber(n));
                      Leave<builtin>}(IsNumber(n),True);
                      Enter<builtin>{(IsNumber,IsNumber(m));
                      Leave<builtin>}(IsNumber(m),True);
                      **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                      Enter<builtin>{(LessThan,LessThan(n-m,0));
                          Enter<user>{(-,n-m);
                              Arg(n,1);
                              Arg(m,1);
                              Enter<builtin>{(IsList,IsList($x8));
                              Leave<builtin>}(IsList($x8),False);
                              Enter<builtin>{(IsNumber,IsNumber(x));
                              Leave<builtin>}(IsNumber(x),True);
                              Enter<builtin>{(IsNumber,IsNumber(y));
                              Leave<builtin>}(IsNumber(y),True);
                              **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                              Enter<builtin>{(SubtractN,SubtractN(x,y));
                              Leave<builtin>}(SubtractN(x,y),0);
                          Leave<user>}(n-m,0);
                      Leave<builtin>}(LessThan(n-m,0),False);
                  Leave<user>}(m<n,False);
              Leave<user>}(GcdN(x,y)>1,False);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),True);
              Enter<builtin>{(IsNumber,IsNumber(y));
              Leave<builtin>}(IsNumber(y),True);
              Enter<user>{(InNumericMode,InNumericMode());
                  **** Rule in function (InNumericMode) matched: Precedence: 1025, Parameters: , Predicates: None., Body: $Numeric2
              Leave<user>}(InNumericMode(),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsNegativeNumber,IsNegativeNumber(y));
                  Arg(y,2);
                  **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
                  Enter<builtin>{(And,IsNumber(x)Andx<0);
                      Enter<builtin>{(IsNumber,IsNumber(x));
                      Leave<builtin>}(IsNumber(x),True);
                      Enter<user>{(<,x<0);
                          Arg(x,2);
                          Arg(0,0);
                          Enter<builtin>{(IsNumber,IsNumber(n));
                          Leave<builtin>}(IsNumber(n),True);
                          Enter<builtin>{(IsNumber,IsNumber(m));
                          Leave<builtin>}(IsNumber(m),True);
                          **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                          Enter<builtin>{(LessThan,LessThan(n-m,0));
                              Enter<user>{(-,n-m);
                                  Arg(n,2);
                                  Arg(m,0);
                                  Enter<builtin>{(IsList,IsList($x8));
                                  Leave<builtin>}(IsList($x8),False);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  Enter<builtin>{(IsNumber,IsNumber(y));
                                  Leave<builtin>}(IsNumber(y),True);
                                  **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                                  Enter<builtin>{(SubtractN,SubtractN(x,y));
                                  Leave<builtin>}(SubtractN(x,y),2);
                              Leave<user>}(n-m,2);
                          Leave<builtin>}(LessThan(n-m,0),False);
                      Leave<user>}(x<0,False);
                  Leave<builtin>}(IsNumber(x)Andx<0,False);
              Leave<user>}(IsNegativeNumber(y),False);
              Enter<builtin>{(IsList,IsList(xlist));
              Leave<builtin>}(IsList(xlist),False);
              Enter<builtin>{(IsList,IsList(y));
              Leave<builtin>}(IsList(y),False);
              Enter<builtin>{(IsList,IsList(x));
              Leave<builtin>}(IsList(x),False);
          Leave<user>}(1/2,1/2);
          Arg(x,x);
          Arg(1/2,1/2);
          Enter<user>{(IsPositiveNumber,IsPositiveNumber(x));
              Arg(x,x);
              **** Rule in function (IsPositiveNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx>0
              Enter<builtin>{(And,IsNumber(x)Andx>0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx>0,False);
          Leave<user>}(IsPositiveNumber(x),False);
          **** Rule in function (^) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Sublist, Body: Sqrt(x)
          Enter<user>{(Sqrt,Sqrt(x));
              Arg(x,x);
              Enter<builtin>{(IsList,IsList(xlist));
              Leave<builtin>}(IsList(xlist),False);
              Enter<user>{(IsPositiveInteger,IsPositiveInteger(x));
                  Arg(x,x);
                  **** Rule in function (IsPositiveInteger) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsInteger(x)Andx>0
                  Enter<builtin>{(And,IsInteger(x)Andx>0);
                      Enter<builtin>{(IsInteger,IsInteger(x));
                      Leave<builtin>}(IsInteger(x),False);
                  Leave<builtin>}(IsInteger(x)Andx>0,False);
              Leave<user>}(IsPositiveInteger(x),False);
              Enter<user>{(IsNegativeNumber,IsNegativeNumber(x));
                  Arg(x,x);
                  **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
                  Enter<builtin>{(And,IsNumber(x)Andx<0);
                      Enter<builtin>{(IsNumber,IsNumber(x));
                      Leave<builtin>}(IsNumber(x),False);
                  Leave<builtin>}(IsNumber(x)Andx<0,False);
              Leave<user>}(IsNegativeNumber(x),False);
              Enter<user>{(IsPositiveNumber,IsPositiveNumber(x));
                  Arg(x,x);
                  **** Rule in function (IsPositiveNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx>0
                  Enter<builtin>{(And,IsNumber(x)Andx>0);
                      Enter<builtin>{(IsNumber,IsNumber(x));
                      Leave<builtin>}(IsNumber(x),False);
                  Leave<builtin>}(IsNumber(x)Andx>0,False);
              Leave<user>}(IsPositiveNumber(x),False);
              Enter<user>{(IsComplex,IsComplex(x));
                  Arg(x,x);
                  Enter<user>{(IsRationalOrNumber,IsRationalOrNumber(x));
                      Arg(x,x);
                      Enter<builtin>{(IsNumber,IsNumber(x));
                      Leave<builtin>}(IsNumber(x),False);
                      **** Rule in function (IsRationalOrNumber) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
                  Leave<user>}(IsRationalOrNumber(x),False);
                  **** Rule in function (IsComplex) matched: Precedence: 3, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsComplex(x),False);
              Enter<user>{(IsConstant,IsConstant(x));
                  Arg(x,x);
                  **** Rule in function (IsConstant) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: n,    Types: Variable, Body: VarList(n)={}
                  Enter<builtin>{(=,VarList(n)={});
                      Enter<user>{(VarList,VarList(n));
                          Arg(n,x);
                          **** Rule in function (VarList) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: expr,    Types: Variable, Body: VarList(expr,"IsVariable")
                          Enter<user>{(VarList,VarList(expr,IsVariable));
                              Arg(expr,x);
                              Arg(IsVariable,IsVariable);
                              **** Rule in function (VarList) matched: Precedence: 1025, Parameters: expr<hold=false>, filter<hold=false>, Predicates: None., Body: [    RemoveDuplicates(VarListAll(expr,filter));]
                              Enter<builtin>{(Prog,[    RemoveDuplicates(VarListAll(expr,filter));]);
                                  Enter<user>{(RemoveDuplicates,RemoveDuplicates(VarListAll(expr,filter)));
                                      Enter<user>{(VarListAll,VarListAll(expr,filter));
                                          Arg(expr,x);
                                          Arg(filter,IsVariable);
                                          Enter<builtin>{(=,Apply(filter,{expr})=True);
                                              Enter<user>{(Apply,Apply(filter,{expr}));
                                                  Enter<builtin>{(List,{expr});
                                                  Leave<builtin>}({expr},{x});
                                                  Arg(filter,IsVariable);
                                                  Arg({expr},{x});
                                                  Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                      Enter<builtin>{(IsString,IsString(applyoper));
                                                      Leave<builtin>}(IsString(applyoper),True);
                                                  Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                  **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                  Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                      Enter<user>{(IsVariable,IsVariable(x));
                                                          Arg(x,x);
                                                          **** Rule in function (IsVariable) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: expr,    Types: Variable, Body: IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr)))
                                                          Enter<builtin>{(And,IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                              Enter<builtin>{(IsAtom,IsAtom(expr));
                                                              Leave<builtin>}(IsAtom(expr),True);
                                                              Enter<builtin>{(And,Notexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                                  Enter<builtin>{(Not,Notexpr=Infinity);
                                                                      Enter<builtin>{(=,expr=Infinity);
                                                                      Leave<builtin>}(expr=Infinity,False);
                                                                  Leave<builtin>}(Notexpr=Infinity,True);
                                                                  Enter<builtin>{(And,Notexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                                      Enter<builtin>{(Not,Notexpr=-Infinity);
                                                                          Enter<builtin>{(=,expr=-Infinity);
                                                                              Enter<user>{(-,-Infinity);
                                                                                  Arg(Infinity,Infinity);
                                                                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                                                                  Leave<builtin>}(IsNumber(x),False);
                                                                                  Enter<builtin>{(IsList,IsList($x7));
                                                                                  Leave<builtin>}(IsList($x7),False);
                                                                              Leave<user>}(-Infinity,-Infinity);
                                                                          Leave<builtin>}(expr=-Infinity,False);
                                                                      Leave<builtin>}(Notexpr=-Infinity,True);
                                                                      Enter<builtin>{(And,Notexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                                          Enter<builtin>{(Not,Notexpr=Undefined);
                                                                              Enter<builtin>{(=,expr=Undefined);
                                                                              Leave<builtin>}(expr=Undefined,False);
                                                                          Leave<builtin>}(Notexpr=Undefined,True);
                                                                          Enter<builtin>{(Not,NotIsNumber(N(Eval(expr))));
                                                                              Enter<builtin>{(IsNumber,IsNumber(N(Eval(expr))));
                                                                                  Enter<macro>{(N,N(Eval(expr)));
                                                                                      Arg(Eval(expr),Eval(expr));
                                                                                      **** Rule in function (N) matched: Precedence: 1025, Parameters: expr<hold=true>, Predicates: None., Body: [    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(@expr));    `N(@$ex4,@$dig4);], Substituted Macro Body: [    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);]
                                                                                      Enter<builtin>{(Prog,[    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);]);
                                                                                          Enter<builtin>{(Local,Local($dig4,$ex4));
                                                                                          Leave<builtin>}(Local($dig4,$ex4),True);
                                                                                          Enter<builtin>{(Set,Set($dig4,BuiltinPrecisionGet()));
                                                                                              Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                                                                              Leave<builtin>}(BuiltinPrecisionGet(),10);
                                                                                          Leave<builtin>}(Set($dig4,BuiltinPrecisionGet()),True);
                                                                                          Enter<builtin>{(Set,Set($ex4,Hold(Eval(expr))));
                                                                                              Enter<builtin>{(Hold,Hold(Eval(expr)));
                                                                                              Leave<builtin>}(Hold(Eval(expr)),Eval(expr));
                                                                                          Leave<builtin>}(Set($ex4,Hold(Eval(expr))),True);
                                                                                          Enter<builtin>{(`,`N(@$ex4,@$dig4));
                                                                                              Enter<macro>{(N,N(Eval(expr),10));
                                                                                                  Arg(Eval(expr),Eval(expr));
                                                                                                  Arg(10,10);
                                                                                                  **** Rule in function (N) matched: Precedence: 1025, Parameters: expr<hold=true>, digits<hold=true>, Predicates: None., Body: [    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(@digits);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,"");    TrapError(Set($numeric'result3,Eval(@expr)),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString="",errorString);    $numeric'result3;], Substituted Macro Body: [    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,"");    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString="",errorString);    $numeric'result3;]
                                                                                                  Enter<builtin>{(Prog,[    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,);    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString=,errorString);    $numeric'result3;]);
                                                                                                      Enter<builtin>{(Local,Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString));
                                                                                                      Leave<builtin>}(Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString),True);
                                                                                                      Enter<builtin>{(Set,Set($prev'digits3,BuiltinPrecisionGet()));
                                                                                                          Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                                                                                          Leave<builtin>}(BuiltinPrecisionGet(),10);
                                                                                                      Leave<builtin>}(Set($prev'digits3,BuiltinPrecisionGet()),True);
                                                                                                      Enter<builtin>{(BuiltinPrecisionSet,BuiltinPrecisionSet(10));
                                                                                                      Leave<builtin>}(BuiltinPrecisionSet(10),True);
                                                                                                      Enter<user>{(AssignCachedConstantsN,AssignCachedConstantsN());
                                                                                                          **** Rule in function (AssignCachedConstantsN) matched: Precedence: 1025, Parameters: , Predicates: None., Body: [    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings("Internal'",var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];]
                                                                                                          Enter<builtin>{(Prog,[    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings(Internal',var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];]);
                                                                                                              Enter<builtin>{(Local,Local(var,fname));
                                                                                                              Leave<builtin>}(Local(var,fname),True);
                                                                                                              Enter<user>{(ForEach,ForEach(var,AssocIndices($CacheOfConstantsN1))[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                  Enter<user>{(AssocIndices,AssocIndices($CacheOfConstantsN1));
                                                                                                                      Arg($CacheOfConstantsN1,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                      Enter<builtin>{(IsList,IsList(associndiceslist));
                                                                                                                      Leave<builtin>}(IsList(associndiceslist),True);
                                                                                                                      **** Rule in function (AssocIndices) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) IsList(associndiceslist), True,     Variables: associndiceslist,    Types: Variable, Body: DestructiveReverse(MapSingle("Head",associndiceslist))
                                                                                                                      Enter<builtin>{(DestructiveReverse,DestructiveReverse(MapSingle(Head,associndiceslist)));
                                                                                                                          Enter<user>{(MapSingle,MapSingle(Head,associndiceslist));
                                                                                                                              Arg(Head,Head);
                                                                                                                              Arg(associndiceslist,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                              **** Rule in function (MapSingle) matched: Precedence: 1025, Parameters: $func17<hold=false>, $list17<hold=false>, Predicates: None., Body: [    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);]
                                                                                                                              Enter<builtin>{(Prog,[    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);]);
                                                                                                                                  Enter<builtin>{(Local,Local(mapsingleresult));
                                                                                                                                  Leave<builtin>}(Local(mapsingleresult),True);
                                                                                                                                  Enter<user>{(:=,mapsingleresult:={});
                                                                                                                                      Arg(mapsingleresult,mapsingleresult);
                                                                                                                                      Arg({},{});
                                                                                                                                      Enter<builtin>{(IsList,IsList(aLeftAssign));
                                                                                                                                      Leave<builtin>}(IsList(aLeftAssign),False);
                                                                                                                                      Enter<builtin>{(IsAtom,IsAtom(aLeftAssign));
                                                                                                                                      Leave<builtin>}(IsAtom(aLeftAssign),True);
                                                                                                                                      **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign), Body: [    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]
                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet(aLeftAssign,Eval(aRightAssign)));
                                                                                                                                              Enter<builtin>{(Eval,Eval(aRightAssign));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Eval(aRightAssign),{});
                                                                                                                                          Leave<builtin>}(MacroSet(aLeftAssign,Eval(aRightAssign)),True);
                                                                                                                                          Enter<builtin>{(Eval,Eval(aLeftAssign));
                                                                                                                                          Leave<builtin>}(Eval(aLeftAssign),{});
                                                                                                                                      Leave<builtin>}([    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);],{});
                                                                                                                                  Leave<user>}(mapsingleresult:={},{});
                                                                                                                                  Enter<user>{(ForEach,ForEach(mapsingleitem,$list17)[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                      Arg(mapsingleitem,mapsingleitem);
                                                                                                                                      Arg($list17,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                      Arg([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                      **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                                                      Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                                          Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                                              Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                                                      Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                                                      Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                                                  Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                                              Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                                              Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                                                  Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                                                  Leave<builtin>}(Local(foreachtail),True);
                                                                                                                                                  Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                                                      Enter<builtin>{(List,{$item22});
                                                                                                                                                      Leave<builtin>}({$item22},{mapsingleitem});
                                                                                                                                                  Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                                                  Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                                                  Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                              Leave<builtin>}(Head(foreachtail),{Catalan,0,0});
                                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                              Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                                  Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                      Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                          Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                          Leave<builtin>}({mapsingleitem},{{Catalan,0,0}});
                                                                                                                                                                          Arg($func17,Head);
                                                                                                                                                                          Arg({mapsingleitem},{{Catalan,0,0}});
                                                                                                                                                                          Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                              Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                              Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                          **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                          Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                              Enter<builtin>{(Head,Head({Catalan,0,0}));
                                                                                                                                                                                  Enter<builtin>{(List,{Catalan,0,0});
                                                                                                                                                                                  Leave<builtin>}({Catalan,0,0},{Catalan,0,0});
                                                                                                                                                                              Leave<builtin>}(Head({Catalan,0,0}),Catalan);
                                                                                                                                                                          Leave<builtin>}(ApplyPure(applyoper,applyargs),Catalan);
                                                                                                                                                                      Leave<user>}(Apply($func17,{mapsingleitem}),Catalan);
                                                                                                                                                                  Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{Catalan});
                                                                                                                                                              Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{Catalan});
                                                                                                                                                          Leave<builtin>}(Eval($body22),{Catalan});
                                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                              Leave<builtin>}(Head(foreachtail),{GoldenRatio,0,0});
                                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                              Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                                  Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                      Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                          Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                          Leave<builtin>}({mapsingleitem},{{GoldenRatio,0,0}});
                                                                                                                                                                          Arg($func17,Head);
                                                                                                                                                                          Arg({mapsingleitem},{{GoldenRatio,0,0}});
                                                                                                                                                                          Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                              Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                              Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                          **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                          Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                              Enter<builtin>{(Head,Head({GoldenRatio,0,0}));
                                                                                                                                                                                  Enter<builtin>{(List,{GoldenRatio,0,0});
                                                                                                                                                                                  Leave<builtin>}({GoldenRatio,0,0},{GoldenRatio,0,0});
                                                                                                                                                                              Leave<builtin>}(Head({GoldenRatio,0,0}),GoldenRatio);
                                                                                                                                                                          Leave<builtin>}(ApplyPure(applyoper,applyargs),GoldenRatio);
                                                                                                                                                                      Leave<user>}(Apply($func17,{mapsingleitem}),GoldenRatio);
                                                                                                                                                                  Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{GoldenRatio,Catalan});
                                                                                                                                                              Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}(Eval($body22),{GoldenRatio,Catalan});
                                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{gamma,0,0},{Pi,0,0}});
                                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                              Leave<builtin>}(Head(foreachtail),{gamma,0,0});
                                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                              Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                                  Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                      Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                          Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                          Leave<builtin>}({mapsingleitem},{{gamma,0,0}});
                                                                                                                                                                          Arg($func17,Head);
                                                                                                                                                                          Arg({mapsingleitem},{{gamma,0,0}});
                                                                                                                                                                          Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                              Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                              Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                          **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                          Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                              Enter<builtin>{(Head,Head({gamma,0,0}));
                                                                                                                                                                                  Enter<builtin>{(List,{gamma,0,0});
                                                                                                                                                                                  Leave<builtin>}({gamma,0,0},{gamma,0,0});
                                                                                                                                                                              Leave<builtin>}(Head({gamma,0,0}),gamma);
                                                                                                                                                                          Leave<builtin>}(ApplyPure(applyoper,applyargs),gamma);
                                                                                                                                                                      Leave<user>}(Apply($func17,{mapsingleitem}),gamma);
                                                                                                                                                                  Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{gamma,GoldenRatio,Catalan});
                                                                                                                                                              Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{gamma,GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}(Eval($body22),{gamma,GoldenRatio,Catalan});
                                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{Pi,0,0}});
                                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                              Leave<builtin>}(Head(foreachtail),{Pi,0,0});
                                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                              Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                                  Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                      Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                          Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                          Leave<builtin>}({mapsingleitem},{{Pi,0,0}});
                                                                                                                                                                          Arg($func17,Head);
                                                                                                                                                                          Arg({mapsingleitem},{{Pi,0,0}});
                                                                                                                                                                          Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                              Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                              Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                          **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                          Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                              Enter<builtin>{(Head,Head({Pi,0,0}));
                                                                                                                                                                                  Enter<builtin>{(List,{Pi,0,0});
                                                                                                                                                                                  Leave<builtin>}({Pi,0,0},{Pi,0,0});
                                                                                                                                                                              Leave<builtin>}(Head({Pi,0,0}),Pi);
                                                                                                                                                                          Leave<builtin>}(ApplyPure(applyoper,applyargs),Pi);
                                                                                                                                                                      Leave<user>}(Apply($func17,{mapsingleitem}),Pi);
                                                                                                                                                                  Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                              Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}(Eval($body22),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                                                  Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                              Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                                          Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                                                      Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                                                  Leave<user>}(ForEach(mapsingleitem,$list17)[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],True);
                                                                                                                                  Enter<builtin>{(DestructiveReverse,DestructiveReverse(mapsingleresult));
                                                                                                                                  Leave<builtin>}(DestructiveReverse(mapsingleresult),{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                              Leave<builtin>}([    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);],{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                          Leave<user>}(MapSingle(Head,associndiceslist),{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                      Leave<builtin>}(DestructiveReverse(MapSingle(Head,associndiceslist)),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                  Leave<user>}(AssocIndices($CacheOfConstantsN1),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                  Arg(var,var);
                                                                                                                  Arg(AssocIndices($CacheOfConstantsN1),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                  Arg([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                  **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                                  Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                      Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                          Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                              Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                                  Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                                  Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                              Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                          Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                          Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                              Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                              Leave<builtin>}(Local(foreachtail),True);
                                                                                                                              Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                                  Enter<builtin>{(List,{$item22});
                                                                                                                                  Leave<builtin>}({$item22},{var});
                                                                                                                              Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                              Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                              Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                          Leave<builtin>}(Head(foreachtail),Pi);
                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                          Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                                  Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                      Leave<builtin>}(Atom(var),Pi);
                                                                                                                                                  Leave<builtin>}({Atom(var)},{Pi});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                                  Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                      Enter<builtin>{(List,{Internal',var});
                                                                                                                                                      Leave<builtin>}({Internal',var},{Internal',Pi});
                                                                                                                                                  Leave<builtin>}(ConcatStrings(Internal',var),Internal'Pi);
                                                                                                                                              Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),Pi);
                                                                                                                                              Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                              Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(Pi,UnList({Atom(fname)})));
                                                                                                                                                      Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                          Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                              Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                              Leave<builtin>}(Atom(fname),Internal'Pi);
                                                                                                                                                          Leave<builtin>}({Atom(fname)},{Internal'Pi});
                                                                                                                                                      Leave<builtin>}(UnList({Atom(fname)}),Internal'Pi());
                                                                                                                                                  Leave<builtin>}(SetGlobalLazyVariable(Pi,UnList({Atom(fname)})),True);
                                                                                                                                              Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                      Leave<builtin>}(Eval($body22),True);
                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{gamma,GoldenRatio,Catalan});
                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                          Leave<builtin>}(Head(foreachtail),gamma);
                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                          Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                                  Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                      Leave<builtin>}(Atom(var),gamma);
                                                                                                                                                  Leave<builtin>}({Atom(var)},{gamma});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                                  Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                      Enter<builtin>{(List,{Internal',var});
                                                                                                                                                      Leave<builtin>}({Internal',var},{Internal',gamma});
                                                                                                                                                  Leave<builtin>}(ConcatStrings(Internal',var),Internal'gamma);
                                                                                                                                              Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),gamma);
                                                                                                                                              Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                              Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(gamma,UnList({Atom(fname)})));
                                                                                                                                                      Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                          Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                              Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                              Leave<builtin>}(Atom(fname),Internal'gamma);
                                                                                                                                                          Leave<builtin>}({Atom(fname)},{Internal'gamma});
                                                                                                                                                      Leave<builtin>}(UnList({Atom(fname)}),Internal'gamma());
                                                                                                                                                  Leave<builtin>}(SetGlobalLazyVariable(gamma,UnList({Atom(fname)})),True);
                                                                                                                                              Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                      Leave<builtin>}(Eval($body22),True);
                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{GoldenRatio,Catalan});
                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                          Leave<builtin>}(Head(foreachtail),GoldenRatio);
                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                          Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                                  Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                      Leave<builtin>}(Atom(var),GoldenRatio);
                                                                                                                                                  Leave<builtin>}({Atom(var)},{GoldenRatio});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                                  Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                      Enter<builtin>{(List,{Internal',var});
                                                                                                                                                      Leave<builtin>}({Internal',var},{Internal',GoldenRatio});
                                                                                                                                                  Leave<builtin>}(ConcatStrings(Internal',var),Internal'GoldenRatio);
                                                                                                                                              Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),GoldenRatio);
                                                                                                                                              Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                              Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(GoldenRatio,UnList({Atom(fname)})));
                                                                                                                                                      Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                          Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                              Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                              Leave<builtin>}(Atom(fname),Internal'GoldenRatio);
                                                                                                                                                          Leave<builtin>}({Atom(fname)},{Internal'GoldenRatio});
                                                                                                                                                      Leave<builtin>}(UnList({Atom(fname)}),Internal'GoldenRatio());
                                                                                                                                                  Leave<builtin>}(SetGlobalLazyVariable(GoldenRatio,UnList({Atom(fname)})),True);
                                                                                                                                              Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                      Leave<builtin>}(Eval($body22),True);
                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{Catalan});
                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                          Leave<builtin>}(Head(foreachtail),Catalan);
                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                          Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                                  Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                      Leave<builtin>}(Atom(var),Catalan);
                                                                                                                                                  Leave<builtin>}({Atom(var)},{Catalan});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                                  Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                      Enter<builtin>{(List,{Internal',var});
                                                                                                                                                      Leave<builtin>}({Internal',var},{Internal',Catalan});
                                                                                                                                                  Leave<builtin>}(ConcatStrings(Internal',var),Internal'Catalan);
                                                                                                                                              Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                              Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),Catalan);
                                                                                                                                              Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                              Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(Catalan,UnList({Atom(fname)})));
                                                                                                                                                      Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                          Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                              Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                              Leave<builtin>}(Atom(fname),Internal'Catalan);
                                                                                                                                                          Leave<builtin>}({Atom(fname)},{Internal'Catalan});
                                                                                                                                                      Leave<builtin>}(UnList({Atom(fname)}),Internal'Catalan());
                                                                                                                                                  Leave<builtin>}(SetGlobalLazyVariable(Catalan,UnList({Atom(fname)})),True);
                                                                                                                                              Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                      Leave<builtin>}(Eval($body22),True);
                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                              Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                          Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                      Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                                  Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                              Leave<user>}(ForEach(var,AssocIndices($CacheOfConstantsN1))[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                          Leave<builtin>}([    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings(Internal',var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];],True);
                                                                                                      Leave<user>}(AssignCachedConstantsN(),True);
                                                                                                      Enter<builtin>{(Set,Set($prev'Numeric3,$Numeric2));
                                                                                                      Leave<builtin>}(Set($prev'Numeric3,$Numeric2),True);
                                                                                                      Enter<builtin>{(Set,Set($Numeric2,True));
                                                                                                      Leave<builtin>}(Set($Numeric2,True),True);
                                                                                                      Enter<builtin>{(Set,Set(errorString,));
                                                                                                      Leave<builtin>}(Set(errorString,),True);
                                                                                                      Enter<builtin>{(TrapError,TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError())));
                                                                                                          Enter<builtin>{(Set,Set($numeric'result3,Eval(Eval(expr))));
                                                                                                              Enter<builtin>{(Eval,Eval(Eval(expr)));
                                                                                                                  Enter<builtin>{(Eval,Eval(expr));
                                                                                                                  Leave<builtin>}(Eval(expr),x);
                                                                                                              Leave<builtin>}(Eval(Eval(expr)),x);
                                                                                                          Leave<builtin>}(Set($numeric'result3,Eval(Eval(expr))),True);
                                                                                                      Leave<builtin>}(TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError())),True);
                                                                                                      Enter<builtin>{(Set,Set($Numeric2,$prev'Numeric3));
                                                                                                      Leave<builtin>}(Set($Numeric2,$prev'Numeric3),True);
                                                                                                      Enter<builtin>{(If,If(Not$Numeric2,[    ClearCachedConstantsN();]));
                                                                                                          Enter<builtin>{(Not,Not$Numeric2);
                                                                                                          Leave<builtin>}(Not$Numeric2,True);
                                                                                                          Enter<builtin>{(Prog,[    ClearCachedConstantsN();]);
                                                                                                              Enter<user>{(ClearCachedConstantsN,ClearCachedConstantsN());
                                                                                                                  **** Rule in function (ClearCachedConstantsN) matched: Precedence: 1025, Parameters: , Predicates: None., Body: [    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));]
                                                                                                                  Enter<builtin>{(Prog,[    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));]);
                                                                                                                      Enter<builtin>{(Local,Local(c'entry));
                                                                                                                      Leave<builtin>}(Local(c'entry),True);
                                                                                                                      Enter<user>{(ForEach,ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1])));
                                                                                                                          Arg(c'entry,c'entry);
                                                                                                                          Arg($CacheOfConstantsN1,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                          Arg(MacroClear(Atom(c'entry[1])),MacroClear(Atom(c'entry[1])));
                                                                                                                          **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                                          Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                              Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                                  Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                                      Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                                          Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                                          Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                                      Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                                  Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                                  Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                                      Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                                      Leave<builtin>}(Local(foreachtail),True);
                                                                                                                                      Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                                          Enter<builtin>{(List,{$item22});
                                                                                                                                          Leave<builtin>}({$item22},{c'entry});
                                                                                                                                      Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                                      Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                                      Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                          Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                          Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                              Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                  Leave<builtin>}(Head(foreachtail),{Catalan,0,0});
                                                                                                                                              Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                              Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                  Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                      Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                              Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                                  Arg(c'entry,{Catalan,0,0});
                                                                                                                                                                  Arg(1,1);
                                                                                                                                                                  Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                          Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                          Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                          Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                          Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                      Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                              Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                                  Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                                  Leave<builtin>}(Listify(alist),{List,Catalan,0,0});
                                                                                                                                                                              Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                          Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                      Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                                  Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                                  Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                                  Leave<builtin>}(MathNth(alist,aindex),Catalan);
                                                                                                                                                              Leave<user>}(c'entry[1],Catalan);
                                                                                                                                                          Leave<builtin>}(Atom(c'entry[1]),Catalan);
                                                                                                                                                      Leave<builtin>}({Atom(c'entry[1])},{Catalan});
                                                                                                                                                  Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                              Leave<builtin>}(Eval($body22),True);
                                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                  Leave<builtin>}(Tail(foreachtail),{{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                              Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                          Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                          Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                          Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                              Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                  Leave<builtin>}(Head(foreachtail),{GoldenRatio,0,0});
                                                                                                                                              Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                              Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                  Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                      Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                              Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                                  Arg(c'entry,{GoldenRatio,0,0});
                                                                                                                                                                  Arg(1,1);
                                                                                                                                                                  Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                          Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                          Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                          Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                          Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                      Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                              Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                                  Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                                  Leave<builtin>}(Listify(alist),{List,GoldenRatio,0,0});
                                                                                                                                                                              Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                          Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                      Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                                  Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                                  Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                                  Leave<builtin>}(MathNth(alist,aindex),GoldenRatio);
                                                                                                                                                              Leave<user>}(c'entry[1],GoldenRatio);
                                                                                                                                                          Leave<builtin>}(Atom(c'entry[1]),GoldenRatio);
                                                                                                                                                      Leave<builtin>}({Atom(c'entry[1])},{GoldenRatio});
                                                                                                                                                  Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                              Leave<builtin>}(Eval($body22),True);
                                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                  Leave<builtin>}(Tail(foreachtail),{{gamma,0,0},{Pi,0,0}});
                                                                                                                                              Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                          Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                          Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                          Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                              Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                  Leave<builtin>}(Head(foreachtail),{gamma,0,0});
                                                                                                                                              Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                              Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                  Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                      Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                              Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                                  Arg(c'entry,{gamma,0,0});
                                                                                                                                                                  Arg(1,1);
                                                                                                                                                                  Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                          Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                          Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                          Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                          Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                      Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                              Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                                  Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                                  Leave<builtin>}(Listify(alist),{List,gamma,0,0});
                                                                                                                                                                              Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                          Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                      Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                                  Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                                  Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                                  Leave<builtin>}(MathNth(alist,aindex),gamma);
                                                                                                                                                              Leave<user>}(c'entry[1],gamma);
                                                                                                                                                          Leave<builtin>}(Atom(c'entry[1]),gamma);
                                                                                                                                                      Leave<builtin>}({Atom(c'entry[1])},{gamma});
                                                                                                                                                  Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                              Leave<builtin>}(Eval($body22),True);
                                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                  Leave<builtin>}(Tail(foreachtail),{{Pi,0,0}});
                                                                                                                                              Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                          Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                          Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                          Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                              Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                  Leave<builtin>}(Head(foreachtail),{Pi,0,0});
                                                                                                                                              Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                              Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                  Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                      Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                              Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                                  Arg(c'entry,{Pi,0,0});
                                                                                                                                                                  Arg(1,1);
                                                                                                                                                                  Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                          Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                          Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                          Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                          Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                      Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                      Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                              Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                                  Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                                  Leave<builtin>}(Listify(alist),{List,Pi,0,0});
                                                                                                                                                                              Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                          Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                      Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                                  Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                                  Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                                  Leave<builtin>}(MathNth(alist,aindex),Pi);
                                                                                                                                                              Leave<user>}(c'entry[1],Pi);
                                                                                                                                                          Leave<builtin>}(Atom(c'entry[1]),Pi);
                                                                                                                                                      Leave<builtin>}({Atom(c'entry[1])},{Pi});
                                                                                                                                                  Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                              Leave<builtin>}(Eval($body22),True);
                                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                  Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                  Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                              Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                          Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                  Enter<builtin>{(List,{});
                                                                                                                                                  Leave<builtin>}({},{});
                                                                                                                                              Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                                          Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                                      Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                  Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                              Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                                          Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                                      Leave<user>}(ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1])),True);
                                                                                                                  Leave<builtin>}([    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));],True);
                                                                                                              Leave<user>}(ClearCachedConstantsN(),True);
                                                                                                          Leave<builtin>}([    ClearCachedConstantsN();],True);
                                                                                                      Leave<builtin>}(If(Not$Numeric2,[    ClearCachedConstantsN();]),True);
                                                                                                      Enter<builtin>{(BuiltinPrecisionSet,BuiltinPrecisionSet($prev'digits3));
                                                                                                      Leave<builtin>}(BuiltinPrecisionSet($prev'digits3),True);
                                                                                                      Enter<builtin>{(Check,Check(errorString=,errorString));
                                                                                                          Enter<builtin>{(=,errorString=);
                                                                                                          Leave<builtin>}(errorString=,True);
                                                                                                      Leave<builtin>}(Check(errorString=,errorString),True);
                                                                                                  Leave<builtin>}([    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,);    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString=,errorString);    $numeric'result3;],x);
                                                                                              Leave<macro>}(N(Eval(expr),10),x);
                                                                                          Leave<builtin>}(`N(@$ex4,@$dig4),x);
                                                                                      Leave<builtin>}([    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);],x);
                                                                                  Leave<macro>}(N(Eval(expr)),x);
                                                                              Leave<builtin>}(IsNumber(N(Eval(expr))),False);
                                                                          Leave<builtin>}(NotIsNumber(N(Eval(expr))),True);
                                                                      Leave<builtin>}(Notexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                                  Leave<builtin>}(Notexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                              Leave<builtin>}(Notexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                          Leave<builtin>}(IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                      Leave<user>}(IsVariable(x),True);
                                                  Leave<builtin>}(ApplyPure(applyoper,applyargs),True);
                                              Leave<user>}(Apply(filter,{expr}),True);
                                          Leave<builtin>}(Apply(filter,{expr})=True,True);
                                          **** Rule in function (VarListAll) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) Apply(filter,{expr})=True,     Variables: expr, filter,    Types: Variable, Variable, Body: {expr}
                                          Enter<builtin>{(List,{expr});
                                          Leave<builtin>}({expr},{x});
                                      Leave<user>}(VarListAll(expr,filter),{x});
                                      Arg(VarListAll(expr,filter),{x});
                                      **** Rule in function (RemoveDuplicates) matched: Precedence: 1025, Parameters: list<hold=false>, Predicates: None., Body: [    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;]
                                      Enter<builtin>{(Prog,[    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;]);
                                          Enter<builtin>{(Local,Local(result));
                                          Leave<builtin>}(Local(result),True);
                                          Enter<builtin>{(Set,Set(result,{}));
                                              Enter<builtin>{(List,{});
                                              Leave<builtin>}({},{});
                                          Leave<builtin>}(Set(result,{}),True);
                                          Enter<user>{(ForEach,ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item)));
                                              Arg(item,item);
                                              Arg(list,{x});
                                              Arg(If(NotContains(result,item),DestructiveAppend(result,item)),If(NotContains(result,item),DestructiveAppend(result,item)));
                                              **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                              Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                  Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                      Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                          Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                              Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                              Leave<builtin>}(IsGeneric($list22),False);
                                                          Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                      Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                      Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                          Enter<builtin>{(Local,Local(foreachtail));
                                                          Leave<builtin>}(Local(foreachtail),True);
                                                          Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                              Enter<builtin>{(List,{$item22});
                                                              Leave<builtin>}({$item22},{item});
                                                          Leave<builtin>}(MacroLocal($item22),True);
                                                          Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                          Leave<builtin>}(Set(foreachtail,$list22),True);
                                                          Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                      Enter<builtin>{(List,{});
                                                                      Leave<builtin>}({},{});
                                                                  Leave<builtin>}(Equals(foreachtail,{}),False);
                                                              Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                              Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                  Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                      Enter<builtin>{(Head,Head(foreachtail));
                                                                      Leave<builtin>}(Head(foreachtail),x);
                                                                  Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                  Enter<builtin>{(Eval,Eval($body22));
                                                                      Enter<builtin>{(If,If(NotContains(result,item),DestructiveAppend(result,item)));
                                                                          Enter<builtin>{(Not,NotContains(result,item));
                                                                              Enter<user>{(Contains,Contains(result,item));
                                                                                  Arg(result,{});
                                                                                  Arg(item,x);
                                                                                  **** Rule in function (Contains) matched: Precedence: 1025, Parameters: list<hold=false>, element<hold=false>, Predicates: None., Body: [    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;]
                                                                                  Enter<builtin>{(Prog,[    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;]);
                                                                                      Enter<builtin>{(Local,Local(result));
                                                                                      Leave<builtin>}(Local(result),True);
                                                                                      Enter<builtin>{(Set,Set(result,False));
                                                                                      Leave<builtin>}(Set(result,False),True);
                                                                                      Enter<builtin>{(While,While(NotresultAndNotEquals(list,{}))[    If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));]);
                                                                                          Enter<builtin>{(And,NotresultAndNotEquals(list,{}));
                                                                                              Enter<builtin>{(Not,Notresult);
                                                                                              Leave<builtin>}(Notresult,True);
                                                                                              Enter<builtin>{(Not,NotEquals(list,{}));
                                                                                                  Enter<builtin>{(Equals,Equals(list,{}));
                                                                                                      Enter<builtin>{(List,{});
                                                                                                      Leave<builtin>}({},{});
                                                                                                  Leave<builtin>}(Equals(list,{}),True);
                                                                                              Leave<builtin>}(NotEquals(list,{}),False);
                                                                                          Leave<builtin>}(NotresultAndNotEquals(list,{}),False);
                                                                                      Leave<builtin>}(While(NotresultAndNotEquals(list,{}))[    If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));],True);
                                                                                  Leave<builtin>}([    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;],False);
                                                                              Leave<user>}(Contains(result,item),False);
                                                                          Leave<builtin>}(NotContains(result,item),True);
                                                                          Enter<user>{(DestructiveAppend,DestructiveAppend(result,item));
                                                                              Arg(result,{});
                                                                              Arg(item,x);
                                                                              **** Rule in function (DestructiveAppend) matched: Precedence: 1025, Parameters: list<hold=false>, element<hold=false>, Predicates: None., Body: [    DestructiveInsert(list,Length(list)+1,element);]
                                                                              Enter<builtin>{(Prog,[    DestructiveInsert(list,Length(list)+1,element);]);
                                                                                  Enter<builtin>{(DestructiveInsert,DestructiveInsert(list,Length(list)+1,element));
                                                                                      Enter<user>{(+,Length(list)+1);
                                                                                          Enter<builtin>{(Length,Length(list));
                                                                                          Leave<builtin>}(Length(list),0);
                                                                                          Arg(Length(list),0);
                                                                                          Arg(1,1);
                                                                                          Enter<builtin>{(IsNumber,IsNumber(x));
                                                                                          Leave<builtin>}(IsNumber(x),True);
                                                                                          Enter<builtin>{(IsNumber,IsNumber(y));
                                                                                          Leave<builtin>}(IsNumber(y),True);
                                                                                          **** Rule in function (+) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: AddN(x,y)
                                                                                          Enter<builtin>{(AddN,AddN(x,y));
                                                                                          Leave<builtin>}(AddN(x,y),1);
                                                                                      Leave<user>}(Length(list)+1,1);
                                                                                  Leave<builtin>}(DestructiveInsert(list,Length(list)+1,element),{x});
                                                                              Leave<builtin>}([    DestructiveInsert(list,Length(list)+1,element);],{x});
                                                                          Leave<user>}(DestructiveAppend(result,item),{x});
                                                                      Leave<builtin>}(If(NotContains(result,item),DestructiveAppend(result,item)),{x});
                                                                  Leave<builtin>}(Eval($body22),{x});
                                                                  Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                      Enter<builtin>{(Tail,Tail(foreachtail));
                                                                      Leave<builtin>}(Tail(foreachtail),{});
                                                                  Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                              Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                      Enter<builtin>{(List,{});
                                                                      Leave<builtin>}({},{});
                                                                  Leave<builtin>}(Equals(foreachtail,{}),True);
                                                              Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                          Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                      Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                  Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                              Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                          Leave<user>}(ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item)),True);
                                      Leave<builtin>}([    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;],{x});
                                  Leave<user>}(RemoveDuplicates(VarListAll(expr,filter)),{x});
                              Leave<builtin>}([    RemoveDuplicates(VarListAll(expr,filter));],{x});
                          Leave<user>}(VarList(expr,IsVariable),{x});
                      Leave<user>}(VarList(n),{x});
                      Enter<builtin>{(List,{});
                      Leave<builtin>}({},{});
                  Leave<builtin>}(VarList(n)={},False);
              Leave<user>}(IsConstant(x),False);
              Enter<builtin>{(IsInteger,IsInteger(x));
              Leave<builtin>}(IsInteger(x),False);
          Leave<user>}(Sqrt(x),Sqrt(x));
      Leave<user>}(x^(1/2),Sqrt(x));
      Enter<user>{(^,x^(1/3));
          Enter<user>{(/,1/3);
              Arg(1,1);
              Arg(3,3);
              Enter<builtin>{(IsNumber,IsNumber(y));
              Leave<builtin>}(IsNumber(y),True);
              Enter<user>{(IsZero,IsZero(y));
                  Arg(y,3);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),True);
                  **** Rule in function (IsZero) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet())
                  Enter<builtin>{(Or,MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet()));
                      Enter<builtin>{(=,MathSign(x)=0);
                          Enter<builtin>{(MathSign,MathSign(x));
                          Leave<builtin>}(MathSign(x),1);
                      Leave<builtin>}(MathSign(x)=0,False);
                      Enter<user>{(<,AbsN(x)<PowerN(10,-BuiltinPrecisionGet()));
                          Enter<builtin>{(AbsN,AbsN(x));
                          Leave<builtin>}(AbsN(x),3);
                          Enter<user>{(PowerN,PowerN(10,-BuiltinPrecisionGet()));
                              Enter<user>{(-,-BuiltinPrecisionGet());
                                  Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                  Leave<builtin>}(BuiltinPrecisionGet(),10);
                                  Arg(BuiltinPrecisionGet(),10);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  **** Rule in function (-) matched: Precedence: 55, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: SubtractN(0,x)
                                  Enter<builtin>{(SubtractN,SubtractN(0,x));
                                  Leave<builtin>}(SubtractN(0,x),-10);
                              Leave<user>}(-BuiltinPrecisionGet(),-10);
                              Arg(10,10);
                              Arg(-BuiltinPrecisionGet(),-10);
                              **** Rule in function (PowerN) matched: Precedence: 0, Parameters: x<hold=false>, y<hold=false>, Predicates: None., Body: If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)))
                              Enter<builtin>{(If,If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False))));
                                  Enter<builtin>{(Equals,Equals(x,0));
                                  Leave<builtin>}(Equals(x,0),False);
                                  Enter<builtin>{(If,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)));
                                      Enter<builtin>{(Equals,Equals(x,1));
                                      Leave<builtin>}(Equals(x,1),False);
                                      Enter<builtin>{(If,If(IsInteger(y),MathIntPower(x,y),False));
                                          Enter<builtin>{(IsInteger,IsInteger(y));
                                          Leave<builtin>}(IsInteger(y),True);
                                          Enter<user>{(MathIntPower,MathIntPower(x,y));
                                              Arg(x,10);
                                              Arg(y,-10);
                                              **** Rule in function (MathIntPower) matched: Precedence: 0, Parameters: x<hold=false>, y<hold=false>, Predicates: None., Body: If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)))
                                              Enter<builtin>{(If,If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False))));
                                                  Enter<builtin>{(Equals,Equals(x,0));
                                                  Leave<builtin>}(Equals(x,0),False);
                                                  Enter<builtin>{(If,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)));
                                                      Enter<builtin>{(Equals,Equals(x,1));
                                                      Leave<builtin>}(Equals(x,1),False);
                                                      Enter<builtin>{(If,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False));
                                                          Enter<builtin>{(IsInteger,IsInteger(y));
                                                          Leave<builtin>}(IsInteger(y),True);
                                                          Enter<builtin>{(If,If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)));
                                                              Enter<builtin>{(LessThan,LessThan(y,0));
                                                              Leave<builtin>}(LessThan(y,0),True);
                                                              Enter<builtin>{(DivideN,DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))));
                                                                  Enter<user>{(PositiveIntPower,PositiveIntPower(AddN(x,0.),MathNegate(y)));
                                                                      Enter<builtin>{(AddN,AddN(x,0.));
                                                                      Leave<builtin>}(AddN(x,0.),10);
                                                                      Enter<builtin>{(MathNegate,MathNegate(y));
                                                                      Leave<builtin>}(MathNegate(y),10);
                                                                      Arg(AddN(x,0.),10);
                                                                      Arg(MathNegate(y),10);
                                                                      **** Rule in function (PositiveIntPower) matched: Precedence: 0, Parameters: x<hold=false>, n<hold=false>, Predicates: None., Body: [    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);]
                                                                      Enter<builtin>{(Prog,[    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);]);
                                                                          Enter<builtin>{(Local,Local(result,unit));
                                                                          Leave<builtin>}(Local(result,unit),True);
                                                                          Enter<builtin>{(If,If(LessThan(n,0),False,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]));
                                                                              Enter<builtin>{(LessThan,LessThan(n,0));
                                                                              Leave<builtin>}(LessThan(n,0),False);
                                                                              Enter<builtin>{(Prog,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]);
                                                                                  Enter<builtin>{(Set,Set(unit,1));
                                                                                  Leave<builtin>}(Set(unit,1),True);
                                                                                  Enter<builtin>{(Set,Set(result,unit));
                                                                                  Leave<builtin>}(Set(result,unit),True);
                                                                                  Enter<builtin>{(If,If(Equals(n,0),unit,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;])));
                                                                                      Enter<builtin>{(Equals,Equals(n,0));
                                                                                      Leave<builtin>}(Equals(n,0),False);
                                                                                      Enter<builtin>{(If,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]));
                                                                                          Enter<builtin>{(Equals,Equals(n,1));
                                                                                          Leave<builtin>}(Equals(n,1),False);
                                                                                          Enter<builtin>{(Prog,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]);
                                                                                              Enter<builtin>{(While,While(GreaterThan(n,0))[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),0);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),False);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),False);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),100);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),5);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),1);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),True);
                                                                                                          Enter<builtin>{(Set,Set(result,MultiplyN(result,x)));
                                                                                                              Enter<builtin>{(MultiplyN,MultiplyN(result,x));
                                                                                                              Leave<builtin>}(MultiplyN(result,x),100);
                                                                                                          Leave<builtin>}(Set(result,MultiplyN(result,x)),True);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),True);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),10000);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),2);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),0);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),False);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),False);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),100000000);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),1);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),True);
                                                                                                  Enter<builtin>{(Prog,[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));]);
                                                                                                      Enter<builtin>{(If,If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))));
                                                                                                          Enter<builtin>{(Equals,Equals(BitAnd(n,1),1));
                                                                                                              Enter<builtin>{(BitAnd,BitAnd(n,1));
                                                                                                              Leave<builtin>}(BitAnd(n,1),1);
                                                                                                          Leave<builtin>}(Equals(BitAnd(n,1),1),True);
                                                                                                          Enter<builtin>{(Set,Set(result,MultiplyN(result,x)));
                                                                                                              Enter<builtin>{(MultiplyN,MultiplyN(result,x));
                                                                                                              Leave<builtin>}(MultiplyN(result,x),1.000000000E10);
                                                                                                          Leave<builtin>}(Set(result,MultiplyN(result,x)),True);
                                                                                                      Leave<builtin>}(If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x))),True);
                                                                                                      Enter<builtin>{(Set,Set(x,MultiplyN(x,x)));
                                                                                                          Enter<builtin>{(MultiplyN,MultiplyN(x,x));
                                                                                                          Leave<builtin>}(MultiplyN(x,x),1.000000000E16);
                                                                                                      Leave<builtin>}(Set(x,MultiplyN(x,x)),True);
                                                                                                      Enter<builtin>{(Set,Set(n,ShiftRight(n,1)));
                                                                                                          Enter<builtin>{(ShiftRight,ShiftRight(n,1));
                                                                                                          Leave<builtin>}(ShiftRight(n,1),0);
                                                                                                      Leave<builtin>}(Set(n,ShiftRight(n,1)),True);
                                                                                                  Leave<builtin>}([    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                                  Enter<builtin>{(GreaterThan,GreaterThan(n,0));
                                                                                                  Leave<builtin>}(GreaterThan(n,0),False);
                                                                                              Leave<builtin>}(While(GreaterThan(n,0))[    If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));    Set(x,MultiplyN(x,x));    Set(n,ShiftRight(n,1));],True);
                                                                                          Leave<builtin>}([    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;],1.000000000E10);
                                                                                      Leave<builtin>}(If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;]),1.000000000E10);
                                                                                  Leave<builtin>}(If(Equals(n,0),unit,If(Equals(n,1),x,[    While(GreaterThan(n,0))[        If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));        Set(x,MultiplyN(x,x));        Set(n,ShiftRight(n,1));];    result;])),1.000000000E10);
                                                                              Leave<builtin>}([    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));],1.000000000E10);
                                                                          Leave<builtin>}(If(LessThan(n,0),False,[    Set(unit,1);    Set(result,unit);    If(Equals(n,0),unit,If(Equals(n,1),x,[        While(GreaterThan(n,0))[            If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));            Set(x,MultiplyN(x,x));            Set(n,ShiftRight(n,1));];        result;]));]),1.000000000E10);
                                                                      Leave<builtin>}([    Local(result,unit);    If(LessThan(n,0),False,[        Set(unit,1);        Set(result,unit);        If(Equals(n,0),unit,If(Equals(n,1),x,[            While(GreaterThan(n,0))[                If(Equals(BitAnd(n,1),1),Set(result,MultiplyN(result,x)));                Set(x,MultiplyN(x,x));                Set(n,ShiftRight(n,1));];            result;]));]);],1.000000000E10);
                                                                  Leave<user>}(PositiveIntPower(AddN(x,0.),MathNegate(y)),1.000000000E10);
                                                              Leave<builtin>}(DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),1E-10);
                                                          Leave<builtin>}(If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),1E-10);
                                                      Leave<builtin>}(If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False),1E-10);
                                                  Leave<builtin>}(If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False)),1E-10);
                                              Leave<builtin>}(If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),If(LessThan(y,0),DivideN(1,PositiveIntPower(AddN(x,0.),MathNegate(y))),PositiveIntPower(x,y)),False))),1E-10);
                                          Leave<user>}(MathIntPower(x,y),1E-10);
                                      Leave<builtin>}(If(IsInteger(y),MathIntPower(x,y),False),1E-10);
                                  Leave<builtin>}(If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False)),1E-10);
                              Leave<builtin>}(If(Equals(x,0),0,If(Equals(x,1),1,If(IsInteger(y),MathIntPower(x,y),False))),1E-10);
                          Leave<user>}(PowerN(10,-BuiltinPrecisionGet()),1E-10);
                          Arg(AbsN(x),3);
                          Arg(PowerN(10,-BuiltinPrecisionGet()),1E-10);
                          Enter<builtin>{(IsNumber,IsNumber(n));
                          Leave<builtin>}(IsNumber(n),True);
                          Enter<builtin>{(IsNumber,IsNumber(m));
                          Leave<builtin>}(IsNumber(m),True);
                          **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                          Enter<builtin>{(LessThan,LessThan(n-m,0));
                              Enter<user>{(-,n-m);
                                  Arg(n,3);
                                  Arg(m,1E-10);
                                  Enter<builtin>{(IsList,IsList($x8));
                                  Leave<builtin>}(IsList($x8),False);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  Enter<builtin>{(IsNumber,IsNumber(y));
                                  Leave<builtin>}(IsNumber(y),True);
                                  **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                                  Enter<builtin>{(SubtractN,SubtractN(x,y));
                                  Leave<builtin>}(SubtractN(x,y),3.000000000);
                              Leave<user>}(n-m,3.000000000);
                          Leave<builtin>}(LessThan(n-m,0),False);
                      Leave<user>}(AbsN(x)<PowerN(10,-BuiltinPrecisionGet()),False);
                  Leave<builtin>}(MathSign(x)=0OrAbsN(x)<PowerN(10,-BuiltinPrecisionGet()),False);
              Leave<user>}(IsZero(y),False);
              Enter<user>{(IsNonZeroInteger,IsNonZeroInteger(x));
                  Arg(x,1);
                  **** Rule in function (IsNonZeroInteger) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsInteger(x)Andx!=0
                  Enter<builtin>{(And,IsInteger(x)Andx!=0);
                      Enter<builtin>{(IsInteger,IsInteger(x));
                      Leave<builtin>}(IsInteger(x),True);
                      Enter<user>{(!=,x!=0);
                          Arg(x,1);
                          Arg(0,0);
                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None., Body: NotaLeft=aRight
                          Enter<builtin>{(Not,NotaLeft=aRight);
                              Enter<builtin>{(=,aLeft=aRight);
                              Leave<builtin>}(aLeft=aRight,False);
                          Leave<builtin>}(NotaLeft=aRight,True);
                      Leave<user>}(x!=0,True);
                  Leave<builtin>}(IsInteger(x)Andx!=0,True);
              Leave<user>}(IsNonZeroInteger(x),True);
              Enter<user>{(IsNonZeroInteger,IsNonZeroInteger(y));
                  Arg(y,3);
                  **** Rule in function (IsNonZeroInteger) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsInteger(x)Andx!=0
                  Enter<builtin>{(And,IsInteger(x)Andx!=0);
                      Enter<builtin>{(IsInteger,IsInteger(x));
                      Leave<builtin>}(IsInteger(x),True);
                      Enter<user>{(!=,x!=0);
                          Arg(x,3);
                          Arg(0,0);
                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None., Body: NotaLeft=aRight
                          Enter<builtin>{(Not,NotaLeft=aRight);
                              Enter<builtin>{(=,aLeft=aRight);
                              Leave<builtin>}(aLeft=aRight,False);
                          Leave<builtin>}(NotaLeft=aRight,True);
                      Leave<user>}(x!=0,True);
                  Leave<builtin>}(IsInteger(x)Andx!=0,True);
              Leave<user>}(IsNonZeroInteger(y),True);
              Enter<user>{(>,GcdN(x,y)>1);
                  Enter<builtin>{(GcdN,GcdN(x,y));
                  Leave<builtin>}(GcdN(x,y),1);
                  Arg(GcdN(x,y),1);
                  Arg(1,1);
                  **** Rule in function (>) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) True,     Variables: n, m,    Types: Variable, Variable, Body: m<n
                  Enter<user>{(<,m<n);
                      Arg(m,1);
                      Arg(n,1);
                      Enter<builtin>{(IsNumber,IsNumber(n));
                      Leave<builtin>}(IsNumber(n),True);
                      Enter<builtin>{(IsNumber,IsNumber(m));
                      Leave<builtin>}(IsNumber(m),True);
                      **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                      Enter<builtin>{(LessThan,LessThan(n-m,0));
                          Enter<user>{(-,n-m);
                              Arg(n,1);
                              Arg(m,1);
                              Enter<builtin>{(IsList,IsList($x8));
                              Leave<builtin>}(IsList($x8),False);
                              Enter<builtin>{(IsNumber,IsNumber(x));
                              Leave<builtin>}(IsNumber(x),True);
                              Enter<builtin>{(IsNumber,IsNumber(y));
                              Leave<builtin>}(IsNumber(y),True);
                              **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                              Enter<builtin>{(SubtractN,SubtractN(x,y));
                              Leave<builtin>}(SubtractN(x,y),0);
                          Leave<user>}(n-m,0);
                      Leave<builtin>}(LessThan(n-m,0),False);
                  Leave<user>}(m<n,False);
              Leave<user>}(GcdN(x,y)>1,False);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),True);
              Enter<builtin>{(IsNumber,IsNumber(y));
              Leave<builtin>}(IsNumber(y),True);
              Enter<user>{(InNumericMode,InNumericMode());
                  **** Rule in function (InNumericMode) matched: Precedence: 1025, Parameters: , Predicates: None., Body: $Numeric2
              Leave<user>}(InNumericMode(),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsInfinity,IsInfinity(x));
                  Arg(x,1);
                  **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
              Leave<user>}(IsInfinity(x),False);
              Enter<user>{(IsNegativeNumber,IsNegativeNumber(y));
                  Arg(y,3);
                  **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
                  Enter<builtin>{(And,IsNumber(x)Andx<0);
                      Enter<builtin>{(IsNumber,IsNumber(x));
                      Leave<builtin>}(IsNumber(x),True);
                      Enter<user>{(<,x<0);
                          Arg(x,3);
                          Arg(0,0);
                          Enter<builtin>{(IsNumber,IsNumber(n));
                          Leave<builtin>}(IsNumber(n),True);
                          Enter<builtin>{(IsNumber,IsNumber(m));
                          Leave<builtin>}(IsNumber(m),True);
                          **** Rule in function (<) matched: Precedence: 5, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(n), IsNumber(m), True,     Variables: n, m,    Types: Variable, Variable, Body: LessThan(n-m,0)
                          Enter<builtin>{(LessThan,LessThan(n-m,0));
                              Enter<user>{(-,n-m);
                                  Arg(n,3);
                                  Arg(m,0);
                                  Enter<builtin>{(IsList,IsList($x8));
                                  Leave<builtin>}(IsList($x8),False);
                                  Enter<builtin>{(IsNumber,IsNumber(x));
                                  Leave<builtin>}(IsNumber(x),True);
                                  Enter<builtin>{(IsNumber,IsNumber(y));
                                  Leave<builtin>}(IsNumber(y),True);
                                  **** Rule in function (-) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: SubtractN(x,y)
                                  Enter<builtin>{(SubtractN,SubtractN(x,y));
                                  Leave<builtin>}(SubtractN(x,y),3);
                              Leave<user>}(n-m,3);
                          Leave<builtin>}(LessThan(n-m,0),False);
                      Leave<user>}(x<0,False);
                  Leave<builtin>}(IsNumber(x)Andx<0,False);
              Leave<user>}(IsNegativeNumber(y),False);
              Enter<builtin>{(IsList,IsList(xlist));
              Leave<builtin>}(IsList(xlist),False);
              Enter<builtin>{(IsList,IsList(y));
              Leave<builtin>}(IsList(y),False);
              Enter<builtin>{(IsList,IsList(x));
              Leave<builtin>}(IsList(x),False);
          Leave<user>}(1/3,1/3);
          Arg(x,x);
          Arg(1/3,1/3);
          Enter<user>{(IsZero,IsZero(x));
              Arg(x,x);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),False);
              **** Rule in function (IsZero) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
          Leave<user>}(IsZero(x),False);
          Enter<user>{(IsZero,IsZero(x));
              Arg(x,x);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),False);
              **** Rule in function (IsZero) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
          Leave<user>}(IsZero(x),False);
          Enter<user>{(IsZero,IsZero(x));
              Arg(x,x);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),False);
              **** Rule in function (IsZero) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
          Leave<user>}(IsZero(x),False);
          Enter<user>{(IsPositiveNumber,IsPositiveNumber(x));
              Arg(x,x);
              **** Rule in function (IsPositiveNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx>0
              Enter<builtin>{(And,IsNumber(x)Andx>0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx>0,False);
          Leave<user>}(IsPositiveNumber(x),False);
          Enter<user>{(IsPositiveNumber,IsPositiveNumber(x));
              Arg(x,x);
              **** Rule in function (IsPositiveNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx>0
              Enter<builtin>{(And,IsNumber(x)Andx>0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx>0,False);
          Leave<user>}(IsPositiveNumber(x),False);
          Enter<user>{(IsPositiveNumber,IsPositiveNumber(x));
              Arg(x,x);
              **** Rule in function (IsPositiveNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx>0
              Enter<builtin>{(And,IsNumber(x)Andx>0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx>0,False);
          Leave<user>}(IsPositiveNumber(x),False);
          Enter<user>{(IsNegativeNumber,IsNegativeNumber(x));
              Arg(x,x);
              **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
              Enter<builtin>{(And,IsNumber(x)Andx<0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx<0,False);
          Leave<user>}(IsNegativeNumber(x),False);
          Enter<user>{(IsNegativeNumber,IsNegativeNumber(x));
              Arg(x,x);
              **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
              Enter<builtin>{(And,IsNumber(x)Andx<0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx<0,False);
          Leave<user>}(IsNegativeNumber(x),False);
          Enter<user>{(IsConstant,IsConstant(x));
              Arg(x,x);
              **** Rule in function (IsConstant) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: n,    Types: Variable, Body: VarList(n)={}
              Enter<builtin>{(=,VarList(n)={});
                  Enter<user>{(VarList,VarList(n));
                      Arg(n,x);
                      **** Rule in function (VarList) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: expr,    Types: Variable, Body: VarList(expr,"IsVariable")
                      Enter<user>{(VarList,VarList(expr,IsVariable));
                          Arg(expr,x);
                          Arg(IsVariable,IsVariable);
                          **** Rule in function (VarList) matched: Precedence: 1025, Parameters: expr<hold=false>, filter<hold=false>, Predicates: None., Body: [    RemoveDuplicates(VarListAll(expr,filter));]
                          Enter<builtin>{(Prog,[    RemoveDuplicates(VarListAll(expr,filter));]);
                              Enter<user>{(RemoveDuplicates,RemoveDuplicates(VarListAll(expr,filter)));
                                  Enter<user>{(VarListAll,VarListAll(expr,filter));
                                      Arg(expr,x);
                                      Arg(filter,IsVariable);
                                      Enter<builtin>{(=,Apply(filter,{expr})=True);
                                          Enter<user>{(Apply,Apply(filter,{expr}));
                                              Enter<builtin>{(List,{expr});
                                              Leave<builtin>}({expr},{x});
                                              Arg(filter,IsVariable);
                                              Arg({expr},{x});
                                              Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                  Enter<builtin>{(IsString,IsString(applyoper));
                                                  Leave<builtin>}(IsString(applyoper),True);
                                              Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                              **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                              Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                  Enter<user>{(IsVariable,IsVariable(x));
                                                      Arg(x,x);
                                                      **** Rule in function (IsVariable) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: expr,    Types: Variable, Body: IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr)))
                                                      Enter<builtin>{(And,IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                          Enter<builtin>{(IsAtom,IsAtom(expr));
                                                          Leave<builtin>}(IsAtom(expr),True);
                                                          Enter<builtin>{(And,Notexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                              Enter<builtin>{(Not,Notexpr=Infinity);
                                                                  Enter<builtin>{(=,expr=Infinity);
                                                                  Leave<builtin>}(expr=Infinity,False);
                                                              Leave<builtin>}(Notexpr=Infinity,True);
                                                              Enter<builtin>{(And,Notexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                                  Enter<builtin>{(Not,Notexpr=-Infinity);
                                                                      Enter<builtin>{(=,expr=-Infinity);
                                                                          Enter<user>{(-,-Infinity);
                                                                              Arg(Infinity,Infinity);
                                                                              Enter<builtin>{(IsNumber,IsNumber(x));
                                                                              Leave<builtin>}(IsNumber(x),False);
                                                                              Enter<builtin>{(IsList,IsList($x7));
                                                                              Leave<builtin>}(IsList($x7),False);
                                                                          Leave<user>}(-Infinity,-Infinity);
                                                                      Leave<builtin>}(expr=-Infinity,False);
                                                                  Leave<builtin>}(Notexpr=-Infinity,True);
                                                                  Enter<builtin>{(And,Notexpr=UndefinedAndNotIsNumber(N(Eval(expr))));
                                                                      Enter<builtin>{(Not,Notexpr=Undefined);
                                                                          Enter<builtin>{(=,expr=Undefined);
                                                                          Leave<builtin>}(expr=Undefined,False);
                                                                      Leave<builtin>}(Notexpr=Undefined,True);
                                                                      Enter<builtin>{(Not,NotIsNumber(N(Eval(expr))));
                                                                          Enter<builtin>{(IsNumber,IsNumber(N(Eval(expr))));
                                                                              Enter<macro>{(N,N(Eval(expr)));
                                                                                  Arg(Eval(expr),Eval(expr));
                                                                                  **** Rule in function (N) matched: Precedence: 1025, Parameters: expr<hold=true>, Predicates: None., Body: [    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(@expr));    `N(@$ex4,@$dig4);], Substituted Macro Body: [    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);]
                                                                                  Enter<builtin>{(Prog,[    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);]);
                                                                                      Enter<builtin>{(Local,Local($dig4,$ex4));
                                                                                      Leave<builtin>}(Local($dig4,$ex4),True);
                                                                                      Enter<builtin>{(Set,Set($dig4,BuiltinPrecisionGet()));
                                                                                          Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                                                                          Leave<builtin>}(BuiltinPrecisionGet(),10);
                                                                                      Leave<builtin>}(Set($dig4,BuiltinPrecisionGet()),True);
                                                                                      Enter<builtin>{(Set,Set($ex4,Hold(Eval(expr))));
                                                                                          Enter<builtin>{(Hold,Hold(Eval(expr)));
                                                                                          Leave<builtin>}(Hold(Eval(expr)),Eval(expr));
                                                                                      Leave<builtin>}(Set($ex4,Hold(Eval(expr))),True);
                                                                                      Enter<builtin>{(`,`N(@$ex4,@$dig4));
                                                                                          Enter<macro>{(N,N(Eval(expr),10));
                                                                                              Arg(Eval(expr),Eval(expr));
                                                                                              Arg(10,10);
                                                                                              **** Rule in function (N) matched: Precedence: 1025, Parameters: expr<hold=true>, digits<hold=true>, Predicates: None., Body: [    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(@digits);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,"");    TrapError(Set($numeric'result3,Eval(@expr)),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString="",errorString);    $numeric'result3;], Substituted Macro Body: [    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,"");    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString="",errorString);    $numeric'result3;]
                                                                                              Enter<builtin>{(Prog,[    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,);    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString=,errorString);    $numeric'result3;]);
                                                                                                  Enter<builtin>{(Local,Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString));
                                                                                                  Leave<builtin>}(Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString),True);
                                                                                                  Enter<builtin>{(Set,Set($prev'digits3,BuiltinPrecisionGet()));
                                                                                                      Enter<builtin>{(BuiltinPrecisionGet,BuiltinPrecisionGet());
                                                                                                      Leave<builtin>}(BuiltinPrecisionGet(),10);
                                                                                                  Leave<builtin>}(Set($prev'digits3,BuiltinPrecisionGet()),True);
                                                                                                  Enter<builtin>{(BuiltinPrecisionSet,BuiltinPrecisionSet(10));
                                                                                                  Leave<builtin>}(BuiltinPrecisionSet(10),True);
                                                                                                  Enter<user>{(AssignCachedConstantsN,AssignCachedConstantsN());
                                                                                                      **** Rule in function (AssignCachedConstantsN) matched: Precedence: 1025, Parameters: , Predicates: None., Body: [    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings("Internal'",var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];]
                                                                                                      Enter<builtin>{(Prog,[    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings(Internal',var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];]);
                                                                                                          Enter<builtin>{(Local,Local(var,fname));
                                                                                                          Leave<builtin>}(Local(var,fname),True);
                                                                                                          Enter<user>{(ForEach,ForEach(var,AssocIndices($CacheOfConstantsN1))[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                              Enter<user>{(AssocIndices,AssocIndices($CacheOfConstantsN1));
                                                                                                                  Arg($CacheOfConstantsN1,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                  Enter<builtin>{(IsList,IsList(associndiceslist));
                                                                                                                  Leave<builtin>}(IsList(associndiceslist),True);
                                                                                                                  **** Rule in function (AssocIndices) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) IsList(associndiceslist), True,     Variables: associndiceslist,    Types: Variable, Body: DestructiveReverse(MapSingle("Head",associndiceslist))
                                                                                                                  Enter<builtin>{(DestructiveReverse,DestructiveReverse(MapSingle(Head,associndiceslist)));
                                                                                                                      Enter<user>{(MapSingle,MapSingle(Head,associndiceslist));
                                                                                                                          Arg(Head,Head);
                                                                                                                          Arg(associndiceslist,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                          **** Rule in function (MapSingle) matched: Precedence: 1025, Parameters: $func17<hold=false>, $list17<hold=false>, Predicates: None., Body: [    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);]
                                                                                                                          Enter<builtin>{(Prog,[    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);]);
                                                                                                                              Enter<builtin>{(Local,Local(mapsingleresult));
                                                                                                                              Leave<builtin>}(Local(mapsingleresult),True);
                                                                                                                              Enter<user>{(:=,mapsingleresult:={});
                                                                                                                                  Arg(mapsingleresult,mapsingleresult);
                                                                                                                                  Arg({},{});
                                                                                                                                  Enter<builtin>{(IsList,IsList(aLeftAssign));
                                                                                                                                  Leave<builtin>}(IsList(aLeftAssign),False);
                                                                                                                                  Enter<builtin>{(IsAtom,IsAtom(aLeftAssign));
                                                                                                                                  Leave<builtin>}(IsAtom(aLeftAssign),True);
                                                                                                                                  **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign), Body: [    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]
                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet(aLeftAssign,Eval(aRightAssign)));
                                                                                                                                          Enter<builtin>{(Eval,Eval(aRightAssign));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Eval(aRightAssign),{});
                                                                                                                                      Leave<builtin>}(MacroSet(aLeftAssign,Eval(aRightAssign)),True);
                                                                                                                                      Enter<builtin>{(Eval,Eval(aLeftAssign));
                                                                                                                                      Leave<builtin>}(Eval(aLeftAssign),{});
                                                                                                                                  Leave<builtin>}([    MacroSet(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);],{});
                                                                                                                              Leave<user>}(mapsingleresult:={},{});
                                                                                                                              Enter<user>{(ForEach,ForEach(mapsingleitem,$list17)[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                  Arg(mapsingleitem,mapsingleitem);
                                                                                                                                  Arg($list17,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                  Arg([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                  **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                                                  Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                                      Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                                          Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                                              Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                                                  Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                                                  Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                                              Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                                          Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                                          Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                                              Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                                              Leave<builtin>}(Local(foreachtail),True);
                                                                                                                                              Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                                                  Enter<builtin>{(List,{$item22});
                                                                                                                                                  Leave<builtin>}({$item22},{mapsingleitem});
                                                                                                                                              Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                                              Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                                              Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                                              Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                          Leave<builtin>}(Head(foreachtail),{Catalan,0,0});
                                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                          Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                              Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                  Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                      Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                      Leave<builtin>}({mapsingleitem},{{Catalan,0,0}});
                                                                                                                                                                      Arg($func17,Head);
                                                                                                                                                                      Arg({mapsingleitem},{{Catalan,0,0}});
                                                                                                                                                                      Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                          Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                      Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                      **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                      Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                          Enter<builtin>{(Head,Head({Catalan,0,0}));
                                                                                                                                                                              Enter<builtin>{(List,{Catalan,0,0});
                                                                                                                                                                              Leave<builtin>}({Catalan,0,0},{Catalan,0,0});
                                                                                                                                                                          Leave<builtin>}(Head({Catalan,0,0}),Catalan);
                                                                                                                                                                      Leave<builtin>}(ApplyPure(applyoper,applyargs),Catalan);
                                                                                                                                                                  Leave<user>}(Apply($func17,{mapsingleitem}),Catalan);
                                                                                                                                                              Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{Catalan});
                                                                                                                                                          Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{Catalan});
                                                                                                                                                      Leave<builtin>}(Eval($body22),{Catalan});
                                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                          Leave<builtin>}(Head(foreachtail),{GoldenRatio,0,0});
                                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                          Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                              Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                  Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                      Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                      Leave<builtin>}({mapsingleitem},{{GoldenRatio,0,0}});
                                                                                                                                                                      Arg($func17,Head);
                                                                                                                                                                      Arg({mapsingleitem},{{GoldenRatio,0,0}});
                                                                                                                                                                      Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                          Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                      Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                      **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                      Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                          Enter<builtin>{(Head,Head({GoldenRatio,0,0}));
                                                                                                                                                                              Enter<builtin>{(List,{GoldenRatio,0,0});
                                                                                                                                                                              Leave<builtin>}({GoldenRatio,0,0},{GoldenRatio,0,0});
                                                                                                                                                                          Leave<builtin>}(Head({GoldenRatio,0,0}),GoldenRatio);
                                                                                                                                                                      Leave<builtin>}(ApplyPure(applyoper,applyargs),GoldenRatio);
                                                                                                                                                                  Leave<user>}(Apply($func17,{mapsingleitem}),GoldenRatio);
                                                                                                                                                              Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{GoldenRatio,Catalan});
                                                                                                                                                      Leave<builtin>}(Eval($body22),{GoldenRatio,Catalan});
                                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{{gamma,0,0},{Pi,0,0}});
                                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                          Leave<builtin>}(Head(foreachtail),{gamma,0,0});
                                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                          Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                              Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                  Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                      Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                      Leave<builtin>}({mapsingleitem},{{gamma,0,0}});
                                                                                                                                                                      Arg($func17,Head);
                                                                                                                                                                      Arg({mapsingleitem},{{gamma,0,0}});
                                                                                                                                                                      Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                          Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                      Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                      **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                      Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                          Enter<builtin>{(Head,Head({gamma,0,0}));
                                                                                                                                                                              Enter<builtin>{(List,{gamma,0,0});
                                                                                                                                                                              Leave<builtin>}({gamma,0,0},{gamma,0,0});
                                                                                                                                                                          Leave<builtin>}(Head({gamma,0,0}),gamma);
                                                                                                                                                                      Leave<builtin>}(ApplyPure(applyoper,applyargs),gamma);
                                                                                                                                                                  Leave<user>}(Apply($func17,{mapsingleitem}),gamma);
                                                                                                                                                              Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{gamma,GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{gamma,GoldenRatio,Catalan});
                                                                                                                                                      Leave<builtin>}(Eval($body22),{gamma,GoldenRatio,Catalan});
                                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{{Pi,0,0}});
                                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                                  Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                                      Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                                          Leave<builtin>}(Head(foreachtail),{Pi,0,0});
                                                                                                                                                      Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                                      Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                                          Enter<builtin>{(Prog,[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));]);
                                                                                                                                                              Enter<builtin>{(DestructiveInsert,DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})));
                                                                                                                                                                  Enter<user>{(Apply,Apply($func17,{mapsingleitem}));
                                                                                                                                                                      Enter<builtin>{(List,{mapsingleitem});
                                                                                                                                                                      Leave<builtin>}({mapsingleitem},{{Pi,0,0}});
                                                                                                                                                                      Arg($func17,Head);
                                                                                                                                                                      Arg({mapsingleitem},{{Pi,0,0}});
                                                                                                                                                                      Enter<builtin>{(Or,IsString(applyoper)OrIsList(applyoper));
                                                                                                                                                                          Enter<builtin>{(IsString,IsString(applyoper));
                                                                                                                                                                          Leave<builtin>}(IsString(applyoper),True);
                                                                                                                                                                      Leave<builtin>}(IsString(applyoper)OrIsList(applyoper),True);
                                                                                                                                                                      **** Rule in function (Apply) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsString(applyoper)OrIsList(applyoper),     Variables: applyoper, applyargs,    Types: Variable, Variable, Body: ApplyPure(applyoper,applyargs)
                                                                                                                                                                      Enter<builtin>{(ApplyPure,ApplyPure(applyoper,applyargs));
                                                                                                                                                                          Enter<builtin>{(Head,Head({Pi,0,0}));
                                                                                                                                                                              Enter<builtin>{(List,{Pi,0,0});
                                                                                                                                                                              Leave<builtin>}({Pi,0,0},{Pi,0,0});
                                                                                                                                                                          Leave<builtin>}(Head({Pi,0,0}),Pi);
                                                                                                                                                                      Leave<builtin>}(ApplyPure(applyoper,applyargs),Pi);
                                                                                                                                                                  Leave<user>}(Apply($func17,{mapsingleitem}),Pi);
                                                                                                                                                              Leave<builtin>}(DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem})),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                          Leave<builtin>}([    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                      Leave<builtin>}(Eval($body22),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                                                                      Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                                          Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                                          Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                                      Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                                  Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                                  Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                                      Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                                          Enter<builtin>{(List,{});
                                                                                                                                                          Leave<builtin>}({},{});
                                                                                                                                                      Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                                                  Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                                              Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                          Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                                      Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                                                  Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                                              Leave<user>}(ForEach(mapsingleitem,$list17)[    DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));],True);
                                                                                                                              Enter<builtin>{(DestructiveReverse,DestructiveReverse(mapsingleresult));
                                                                                                                              Leave<builtin>}(DestructiveReverse(mapsingleresult),{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                          Leave<builtin>}([    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem,$list17)[        DestructiveInsert(mapsingleresult,1,Apply($func17,{mapsingleitem}));];    DestructiveReverse(mapsingleresult);],{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                      Leave<user>}(MapSingle(Head,associndiceslist),{Catalan,GoldenRatio,gamma,Pi});
                                                                                                                  Leave<builtin>}(DestructiveReverse(MapSingle(Head,associndiceslist)),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                              Leave<user>}(AssocIndices($CacheOfConstantsN1),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                              Arg(var,var);
                                                                                                              Arg(AssocIndices($CacheOfConstantsN1),{Pi,gamma,GoldenRatio,Catalan});
                                                                                                              Arg([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                              **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                              Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                  Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                      Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                          Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                              Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                              Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                          Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                      Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                      Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                          Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                          Leave<builtin>}(Local(foreachtail),True);
                                                                                                                          Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                              Enter<builtin>{(List,{$item22});
                                                                                                                              Leave<builtin>}({$item22},{var});
                                                                                                                          Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                          Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                          Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(List,{});
                                                                                                                                      Leave<builtin>}({},{});
                                                                                                                                  Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                              Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                              Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                  Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                      Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                      Leave<builtin>}(Head(foreachtail),Pi);
                                                                                                                                  Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                  Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                      Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                          Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                              Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),Pi);
                                                                                                                                              Leave<builtin>}({Atom(var)},{Pi});
                                                                                                                                          Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                              Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                  Enter<builtin>{(List,{Internal',var});
                                                                                                                                                  Leave<builtin>}({Internal',var},{Internal',Pi});
                                                                                                                                              Leave<builtin>}(ConcatStrings(Internal',var),Internal'Pi);
                                                                                                                                          Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                              Enter<builtin>{(Atom,Atom(var));
                                                                                                                                              Leave<builtin>}(Atom(var),Pi);
                                                                                                                                          Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                          Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                              Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(Pi,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                      Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                          Leave<builtin>}(Atom(fname),Internal'Pi);
                                                                                                                                                      Leave<builtin>}({Atom(fname)},{Internal'Pi});
                                                                                                                                                  Leave<builtin>}(UnList({Atom(fname)}),Internal'Pi());
                                                                                                                                              Leave<builtin>}(SetGlobalLazyVariable(Pi,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                      Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                  Leave<builtin>}(Eval($body22),True);
                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                      Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                      Leave<builtin>}(Tail(foreachtail),{gamma,GoldenRatio,Catalan});
                                                                                                                                  Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                              Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(List,{});
                                                                                                                                      Leave<builtin>}({},{});
                                                                                                                                  Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                              Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                              Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                  Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                      Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                      Leave<builtin>}(Head(foreachtail),gamma);
                                                                                                                                  Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                  Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                      Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                          Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                              Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),gamma);
                                                                                                                                              Leave<builtin>}({Atom(var)},{gamma});
                                                                                                                                          Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                              Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                  Enter<builtin>{(List,{Internal',var});
                                                                                                                                                  Leave<builtin>}({Internal',var},{Internal',gamma});
                                                                                                                                              Leave<builtin>}(ConcatStrings(Internal',var),Internal'gamma);
                                                                                                                                          Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                              Enter<builtin>{(Atom,Atom(var));
                                                                                                                                              Leave<builtin>}(Atom(var),gamma);
                                                                                                                                          Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                          Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                              Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(gamma,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                      Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                          Leave<builtin>}(Atom(fname),Internal'gamma);
                                                                                                                                                      Leave<builtin>}({Atom(fname)},{Internal'gamma});
                                                                                                                                                  Leave<builtin>}(UnList({Atom(fname)}),Internal'gamma());
                                                                                                                                              Leave<builtin>}(SetGlobalLazyVariable(gamma,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                      Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                  Leave<builtin>}(Eval($body22),True);
                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                      Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                      Leave<builtin>}(Tail(foreachtail),{GoldenRatio,Catalan});
                                                                                                                                  Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                              Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(List,{});
                                                                                                                                      Leave<builtin>}({},{});
                                                                                                                                  Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                              Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                              Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                  Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                      Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                      Leave<builtin>}(Head(foreachtail),GoldenRatio);
                                                                                                                                  Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                  Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                      Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                          Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                              Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),GoldenRatio);
                                                                                                                                              Leave<builtin>}({Atom(var)},{GoldenRatio});
                                                                                                                                          Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                              Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                  Enter<builtin>{(List,{Internal',var});
                                                                                                                                                  Leave<builtin>}({Internal',var},{Internal',GoldenRatio});
                                                                                                                                              Leave<builtin>}(ConcatStrings(Internal',var),Internal'GoldenRatio);
                                                                                                                                          Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                              Enter<builtin>{(Atom,Atom(var));
                                                                                                                                              Leave<builtin>}(Atom(var),GoldenRatio);
                                                                                                                                          Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                          Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                              Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(GoldenRatio,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                      Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                          Leave<builtin>}(Atom(fname),Internal'GoldenRatio);
                                                                                                                                                      Leave<builtin>}({Atom(fname)},{Internal'GoldenRatio});
                                                                                                                                                  Leave<builtin>}(UnList({Atom(fname)}),Internal'GoldenRatio());
                                                                                                                                              Leave<builtin>}(SetGlobalLazyVariable(GoldenRatio,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                      Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                  Leave<builtin>}(Eval($body22),True);
                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                      Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                      Leave<builtin>}(Tail(foreachtail),{Catalan});
                                                                                                                                  Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                              Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(List,{});
                                                                                                                                      Leave<builtin>}({},{});
                                                                                                                                  Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                              Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                              Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                  Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                      Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                      Leave<builtin>}(Head(foreachtail),Catalan);
                                                                                                                                  Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                  Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                      Enter<builtin>{(Prog,[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));]);
                                                                                                                                          Enter<builtin>{(MacroClear,MacroClear(Atom(var)));
                                                                                                                                              Enter<builtin>{(List,{Atom(var)});
                                                                                                                                                  Enter<builtin>{(Atom,Atom(var));
                                                                                                                                                  Leave<builtin>}(Atom(var),Catalan);
                                                                                                                                              Leave<builtin>}({Atom(var)},{Catalan});
                                                                                                                                          Leave<builtin>}(MacroClear(Atom(var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(fname,ConcatStrings(Internal',var)));
                                                                                                                                              Enter<builtin>{(ConcatStrings,ConcatStrings(Internal',var));
                                                                                                                                                  Enter<builtin>{(List,{Internal',var});
                                                                                                                                                  Leave<builtin>}({Internal',var},{Internal',Catalan});
                                                                                                                                              Leave<builtin>}(ConcatStrings(Internal',var),Internal'Catalan);
                                                                                                                                          Leave<builtin>}(Set(fname,ConcatStrings(Internal',var)),True);
                                                                                                                                          Enter<builtin>{(Set,Set(var,Atom(var)));
                                                                                                                                              Enter<builtin>{(Atom,Atom(var));
                                                                                                                                              Leave<builtin>}(Atom(var),Catalan);
                                                                                                                                          Leave<builtin>}(Set(var,Atom(var)),True);
                                                                                                                                          Enter<builtin>{(`,`SetGlobalLazyVariable(@var,UnList({Atom(fname)})));
                                                                                                                                              Enter<builtin>{(SetGlobalLazyVariable,SetGlobalLazyVariable(Catalan,UnList({Atom(fname)})));
                                                                                                                                                  Enter<builtin>{(UnList,UnList({Atom(fname)}));
                                                                                                                                                      Enter<builtin>{(List,{Atom(fname)});
                                                                                                                                                          Enter<builtin>{(Atom,Atom(fname));
                                                                                                                                                          Leave<builtin>}(Atom(fname),Internal'Catalan);
                                                                                                                                                      Leave<builtin>}({Atom(fname)},{Internal'Catalan});
                                                                                                                                                  Leave<builtin>}(UnList({Atom(fname)}),Internal'Catalan());
                                                                                                                                              Leave<builtin>}(SetGlobalLazyVariable(Catalan,UnList({Atom(fname)})),True);
                                                                                                                                          Leave<builtin>}(`SetGlobalLazyVariable(@var,UnList({Atom(fname)})),True);
                                                                                                                                      Leave<builtin>}([    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                                                  Leave<builtin>}(Eval($body22),True);
                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                      Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                      Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                  Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                              Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                              Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                  Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                      Enter<builtin>{(List,{});
                                                                                                                                      Leave<builtin>}({},{});
                                                                                                                                  Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                              Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                          Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                      Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                  Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                              Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                          Leave<user>}(ForEach(var,AssocIndices($CacheOfConstantsN1))[    MacroClear(Atom(var));    Set(fname,ConcatStrings(Internal',var));    Set(var,Atom(var));    `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));],True);
                                                                                                      Leave<builtin>}([    Local(var,fname);    ForEach(var,AssocIndices($CacheOfConstantsN1))[        MacroClear(Atom(var));        Set(fname,ConcatStrings(Internal',var));        Set(var,Atom(var));        `SetGlobalLazyVariable(@var,UnList({Atom(fname)}));];],True);
                                                                                                  Leave<user>}(AssignCachedConstantsN(),True);
                                                                                                  Enter<builtin>{(Set,Set($prev'Numeric3,$Numeric2));
                                                                                                  Leave<builtin>}(Set($prev'Numeric3,$Numeric2),True);
                                                                                                  Enter<builtin>{(Set,Set($Numeric2,True));
                                                                                                  Leave<builtin>}(Set($Numeric2,True),True);
                                                                                                  Enter<builtin>{(Set,Set(errorString,));
                                                                                                  Leave<builtin>}(Set(errorString,),True);
                                                                                                  Enter<builtin>{(TrapError,TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError())));
                                                                                                      Enter<builtin>{(Set,Set($numeric'result3,Eval(Eval(expr))));
                                                                                                          Enter<builtin>{(Eval,Eval(Eval(expr)));
                                                                                                              Enter<builtin>{(Eval,Eval(expr));
                                                                                                              Leave<builtin>}(Eval(expr),x);
                                                                                                          Leave<builtin>}(Eval(Eval(expr)),x);
                                                                                                      Leave<builtin>}(Set($numeric'result3,Eval(Eval(expr))),True);
                                                                                                  Leave<builtin>}(TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError())),True);
                                                                                                  Enter<builtin>{(Set,Set($Numeric2,$prev'Numeric3));
                                                                                                  Leave<builtin>}(Set($Numeric2,$prev'Numeric3),True);
                                                                                                  Enter<builtin>{(If,If(Not$Numeric2,[    ClearCachedConstantsN();]));
                                                                                                      Enter<builtin>{(Not,Not$Numeric2);
                                                                                                      Leave<builtin>}(Not$Numeric2,True);
                                                                                                      Enter<builtin>{(Prog,[    ClearCachedConstantsN();]);
                                                                                                          Enter<user>{(ClearCachedConstantsN,ClearCachedConstantsN());
                                                                                                              **** Rule in function (ClearCachedConstantsN) matched: Precedence: 1025, Parameters: , Predicates: None., Body: [    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));]
                                                                                                              Enter<builtin>{(Prog,[    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));]);
                                                                                                                  Enter<builtin>{(Local,Local(c'entry));
                                                                                                                  Leave<builtin>}(Local(c'entry),True);
                                                                                                                  Enter<user>{(ForEach,ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1])));
                                                                                                                      Arg(c'entry,c'entry);
                                                                                                                      Arg($CacheOfConstantsN1,{{Catalan,0,0},{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                      Arg(MacroClear(Atom(c'entry[1])),MacroClear(Atom(c'entry[1])));
                                                                                                                      **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                                                                                                      Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                                                                                                          Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                                                                                              Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                                                                                                  Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                                                                                                      Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                                                                                                      Leave<builtin>}(IsGeneric($list22),False);
                                                                                                                                  Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                                                                                              Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                                                                                              Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                                                                                                  Enter<builtin>{(Local,Local(foreachtail));
                                                                                                                                  Leave<builtin>}(Local(foreachtail),True);
                                                                                                                                  Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                                                                                                      Enter<builtin>{(List,{$item22});
                                                                                                                                      Leave<builtin>}({$item22},{c'entry});
                                                                                                                                  Leave<builtin>}(MacroLocal($item22),True);
                                                                                                                                  Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                                                                                                  Leave<builtin>}(Set(foreachtail,$list22),True);
                                                                                                                                  Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                              Leave<builtin>}(Head(foreachtail),{Catalan,0,0});
                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                  Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                          Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                              Arg(c'entry,{Catalan,0,0});
                                                                                                                                                              Arg(1,1);
                                                                                                                                                              Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                      Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                      Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                      Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                      Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                  Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                              Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                              Leave<builtin>}(Listify(alist),{List,Catalan,0,0});
                                                                                                                                                                          Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                      Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                  Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                              Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                              **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                              Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                              Leave<builtin>}(MathNth(alist,aindex),Catalan);
                                                                                                                                                          Leave<user>}(c'entry[1],Catalan);
                                                                                                                                                      Leave<builtin>}(Atom(c'entry[1]),Catalan);
                                                                                                                                                  Leave<builtin>}({Atom(c'entry[1])},{Catalan});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                          Leave<builtin>}(Eval($body22),True);
                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{GoldenRatio,0,0},{gamma,0,0},{Pi,0,0}});
                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                              Leave<builtin>}(Head(foreachtail),{GoldenRatio,0,0});
                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                  Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                          Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                              Arg(c'entry,{GoldenRatio,0,0});
                                                                                                                                                              Arg(1,1);
                                                                                                                                                              Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                      Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                      Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                      Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                      Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                  Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                              Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                              Leave<builtin>}(Listify(alist),{List,GoldenRatio,0,0});
                                                                                                                                                                          Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                      Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                  Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                              Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                              **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                              Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                              Leave<builtin>}(MathNth(alist,aindex),GoldenRatio);
                                                                                                                                                          Leave<user>}(c'entry[1],GoldenRatio);
                                                                                                                                                      Leave<builtin>}(Atom(c'entry[1]),GoldenRatio);
                                                                                                                                                  Leave<builtin>}({Atom(c'entry[1])},{GoldenRatio});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                          Leave<builtin>}(Eval($body22),True);
                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{gamma,0,0},{Pi,0,0}});
                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                              Leave<builtin>}(Head(foreachtail),{gamma,0,0});
                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                  Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                          Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                              Arg(c'entry,{gamma,0,0});
                                                                                                                                                              Arg(1,1);
                                                                                                                                                              Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                      Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                      Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                      Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                      Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                  Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                              Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                              Leave<builtin>}(Listify(alist),{List,gamma,0,0});
                                                                                                                                                                          Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                      Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                  Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                              Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                              **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                              Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                              Leave<builtin>}(MathNth(alist,aindex),gamma);
                                                                                                                                                          Leave<user>}(c'entry[1],gamma);
                                                                                                                                                      Leave<builtin>}(Atom(c'entry[1]),gamma);
                                                                                                                                                  Leave<builtin>}({Atom(c'entry[1])},{gamma});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                          Leave<builtin>}(Eval($body22),True);
                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{{Pi,0,0}});
                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),False);
                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                                                                                                      Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                                                                                                          Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                                                                                              Enter<builtin>{(Head,Head(foreachtail));
                                                                                                                                              Leave<builtin>}(Head(foreachtail),{Pi,0,0});
                                                                                                                                          Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                                                                                                          Enter<builtin>{(Eval,Eval($body22));
                                                                                                                                              Enter<builtin>{(MacroClear,MacroClear(Atom(c'entry[1])));
                                                                                                                                                  Enter<builtin>{(List,{Atom(c'entry[1])});
                                                                                                                                                      Enter<builtin>{(Atom,Atom(c'entry[1]));
                                                                                                                                                          Enter<user>{(Nth,c'entry[1]);
                                                                                                                                                              Arg(c'entry,{Pi,0,0});
                                                                                                                                                              Arg(1,1);
                                                                                                                                                              Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)));
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                                                                                                                                                                      Enter<builtin>{(IsFunction,IsFunction(alist));
                                                                                                                                                                      Leave<builtin>}(IsFunction(alist),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsFunction(alist),True),True);
                                                                                                                                                                  Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                                                                                                                                                                      Enter<builtin>{(IsInteger,IsInteger(aindex));
                                                                                                                                                                      Leave<builtin>}(IsInteger(aindex),True);
                                                                                                                                                                  Leave<builtin>}(Equals(IsInteger(aindex),True),True);
                                                                                                                                                                  Enter<builtin>{(Not,NotEquals(Head(Listify(alist)),Nth));
                                                                                                                                                                      Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                                                                                                                                                          Enter<builtin>{(Head,Head(Listify(alist)));
                                                                                                                                                                              Enter<builtin>{(Listify,Listify(alist));
                                                                                                                                                                              Leave<builtin>}(Listify(alist),{List,Pi,0,0});
                                                                                                                                                                          Leave<builtin>}(Head(Listify(alist)),List);
                                                                                                                                                                      Leave<builtin>}(Equals(Head(Listify(alist)),Nth),False);
                                                                                                                                                                  Leave<builtin>}(NotEquals(Head(Listify(alist)),Nth),True);
                                                                                                                                                              Leave<builtin>}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)),True);
                                                                                                                                                              **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),NotEquals(Head(Listify(alist)),Nth)), Body: MathNth(alist,aindex)
                                                                                                                                                              Enter<builtin>{(MathNth,MathNth(alist,aindex));
                                                                                                                                                              Leave<builtin>}(MathNth(alist,aindex),Pi);
                                                                                                                                                          Leave<user>}(c'entry[1],Pi);
                                                                                                                                                      Leave<builtin>}(Atom(c'entry[1]),Pi);
                                                                                                                                                  Leave<builtin>}({Atom(c'entry[1])},{Pi});
                                                                                                                                              Leave<builtin>}(MacroClear(Atom(c'entry[1])),True);
                                                                                                                                          Leave<builtin>}(Eval($body22),True);
                                                                                                                                          Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                                                                                              Enter<builtin>{(Tail,Tail(foreachtail));
                                                                                                                                              Leave<builtin>}(Tail(foreachtail),{});
                                                                                                                                          Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                                                                                                      Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                                      Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                                                                                                          Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                                                                                              Enter<builtin>{(List,{});
                                                                                                                                              Leave<builtin>}({},{});
                                                                                                                                          Leave<builtin>}(Equals(foreachtail,{}),True);
                                                                                                                                      Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                                                                                                  Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                                                                                              Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                                                                                                          Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                                                                                                      Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                                                                                                  Leave<user>}(ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1])),True);
                                                                                                              Leave<builtin>}([    Local(c'entry);    ForEach(c'entry,$CacheOfConstantsN1)MacroClear(Atom(c'entry[1]));],True);
                                                                                                          Leave<user>}(ClearCachedConstantsN(),True);
                                                                                                      Leave<builtin>}([    ClearCachedConstantsN();],True);
                                                                                                  Leave<builtin>}(If(Not$Numeric2,[    ClearCachedConstantsN();]),True);
                                                                                                  Enter<builtin>{(BuiltinPrecisionSet,BuiltinPrecisionSet($prev'digits3));
                                                                                                  Leave<builtin>}(BuiltinPrecisionSet($prev'digits3),True);
                                                                                                  Enter<builtin>{(Check,Check(errorString=,errorString));
                                                                                                      Enter<builtin>{(=,errorString=);
                                                                                                      Leave<builtin>}(errorString=,True);
                                                                                                  Leave<builtin>}(Check(errorString=,errorString),True);
                                                                                              Leave<builtin>}([    Local($prev'Numeric3,$prev'digits3,$numeric'result3,errorString);    Set($prev'digits3,BuiltinPrecisionGet());    BuiltinPrecisionSet(10);    AssignCachedConstantsN();    Set($prev'Numeric3,$Numeric2);    Set($Numeric2,True);    Set(errorString,);    TrapError(Set($numeric'result3,Eval(Eval(expr))),Set(errorString,GetCoreError()));    Set($Numeric2,$prev'Numeric3);    If(Not$Numeric2,[        ClearCachedConstantsN();]);    BuiltinPrecisionSet($prev'digits3);    Check(errorString=,errorString);    $numeric'result3;],x);
                                                                                          Leave<macro>}(N(Eval(expr),10),x);
                                                                                      Leave<builtin>}(`N(@$ex4,@$dig4),x);
                                                                                  Leave<builtin>}([    Local($dig4,$ex4);    Set($dig4,BuiltinPrecisionGet());    Set($ex4,Hold(Eval(expr)));    `N(@$ex4,@$dig4);],x);
                                                                              Leave<macro>}(N(Eval(expr)),x);
                                                                          Leave<builtin>}(IsNumber(N(Eval(expr))),False);
                                                                      Leave<builtin>}(NotIsNumber(N(Eval(expr))),True);
                                                                  Leave<builtin>}(Notexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                              Leave<builtin>}(Notexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                          Leave<builtin>}(Notexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                      Leave<builtin>}(IsAtom(expr)AndNotexpr=InfinityAndNotexpr=-InfinityAndNotexpr=UndefinedAndNotIsNumber(N(Eval(expr))),True);
                                                  Leave<user>}(IsVariable(x),True);
                                              Leave<builtin>}(ApplyPure(applyoper,applyargs),True);
                                          Leave<user>}(Apply(filter,{expr}),True);
                                      Leave<builtin>}(Apply(filter,{expr})=True,True);
                                      **** Rule in function (VarListAll) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) Apply(filter,{expr})=True,     Variables: expr, filter,    Types: Variable, Variable, Body: {expr}
                                      Enter<builtin>{(List,{expr});
                                      Leave<builtin>}({expr},{x});
                                  Leave<user>}(VarListAll(expr,filter),{x});
                                  Arg(VarListAll(expr,filter),{x});
                                  **** Rule in function (RemoveDuplicates) matched: Precedence: 1025, Parameters: list<hold=false>, Predicates: None., Body: [    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;]
                                  Enter<builtin>{(Prog,[    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;]);
                                      Enter<builtin>{(Local,Local(result));
                                      Leave<builtin>}(Local(result),True);
                                      Enter<builtin>{(Set,Set(result,{}));
                                          Enter<builtin>{(List,{});
                                          Leave<builtin>}({},{});
                                      Leave<builtin>}(Set(result,{}),True);
                                      Enter<user>{(ForEach,ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item)));
                                          Arg(item,item);
                                          Arg(list,{x});
                                          Arg(If(NotContains(result,item),DestructiveAppend(result,item)),If(NotContains(result,item),DestructiveAppend(result,item)));
                                          **** Rule in function (ForEach) matched: Precedence: 1025, Parameters: $item22<hold=true>, $list22<hold=false>, $body22<hold=true>, Predicates: None., Body: [    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),"Array"),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]
                                          Enter<builtin>{(Prog,[    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);]);
                                              Enter<builtin>{(If,If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]));
                                                  Enter<builtin>{(And,Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array));
                                                      Enter<builtin>{(Equals,Equals(IsGeneric($list22),True));
                                                          Enter<builtin>{(IsGeneric,IsGeneric($list22));
                                                          Leave<builtin>}(IsGeneric($list22),False);
                                                      Leave<builtin>}(Equals(IsGeneric($list22),True),False);
                                                  Leave<builtin>}(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),False);
                                                  Enter<builtin>{(Prog,[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]);
                                                      Enter<builtin>{(Local,Local(foreachtail));
                                                      Leave<builtin>}(Local(foreachtail),True);
                                                      Enter<builtin>{(MacroLocal,MacroLocal($item22));
                                                          Enter<builtin>{(List,{$item22});
                                                          Leave<builtin>}({$item22},{item});
                                                      Leave<builtin>}(MacroLocal($item22),True);
                                                      Enter<builtin>{(Set,Set(foreachtail,$list22));
                                                      Leave<builtin>}(Set(foreachtail,$list22),True);
                                                      Enter<builtin>{(While,While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                  Enter<builtin>{(List,{});
                                                                  Leave<builtin>}({},{});
                                                              Leave<builtin>}(Equals(foreachtail,{}),False);
                                                          Leave<builtin>}(NotEquals(foreachtail,{}),True);
                                                          Enter<builtin>{(Prog,[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));]);
                                                              Enter<builtin>{(MacroSet,MacroSet($item22,Head(foreachtail)));
                                                                  Enter<builtin>{(Head,Head(foreachtail));
                                                                  Leave<builtin>}(Head(foreachtail),x);
                                                              Leave<builtin>}(MacroSet($item22,Head(foreachtail)),True);
                                                              Enter<builtin>{(Eval,Eval($body22));
                                                                  Enter<builtin>{(If,If(NotContains(result,item),DestructiveAppend(result,item)));
                                                                      Enter<builtin>{(Not,NotContains(result,item));
                                                                          Enter<user>{(Contains,Contains(result,item));
                                                                              Arg(result,{});
                                                                              Arg(item,x);
                                                                              **** Rule in function (Contains) matched: Precedence: 1025, Parameters: list<hold=false>, element<hold=false>, Predicates: None., Body: [    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;]
                                                                              Enter<builtin>{(Prog,[    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;]);
                                                                                  Enter<builtin>{(Local,Local(result));
                                                                                  Leave<builtin>}(Local(result),True);
                                                                                  Enter<builtin>{(Set,Set(result,False));
                                                                                  Leave<builtin>}(Set(result,False),True);
                                                                                  Enter<builtin>{(While,While(NotresultAndNotEquals(list,{}))[    If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));]);
                                                                                      Enter<builtin>{(And,NotresultAndNotEquals(list,{}));
                                                                                          Enter<builtin>{(Not,Notresult);
                                                                                          Leave<builtin>}(Notresult,True);
                                                                                          Enter<builtin>{(Not,NotEquals(list,{}));
                                                                                              Enter<builtin>{(Equals,Equals(list,{}));
                                                                                                  Enter<builtin>{(List,{});
                                                                                                  Leave<builtin>}({},{});
                                                                                              Leave<builtin>}(Equals(list,{}),True);
                                                                                          Leave<builtin>}(NotEquals(list,{}),False);
                                                                                      Leave<builtin>}(NotresultAndNotEquals(list,{}),False);
                                                                                  Leave<builtin>}(While(NotresultAndNotEquals(list,{}))[    If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));],True);
                                                                              Leave<builtin>}([    Local(result);    Set(result,False);    While(NotresultAndNotEquals(list,{}))[        If(Equals(Head(list),element),Set(result,True),Set(list,Tail(list)));];    result;],False);
                                                                          Leave<user>}(Contains(result,item),False);
                                                                      Leave<builtin>}(NotContains(result,item),True);
                                                                      Enter<user>{(DestructiveAppend,DestructiveAppend(result,item));
                                                                          Arg(result,{});
                                                                          Arg(item,x);
                                                                          **** Rule in function (DestructiveAppend) matched: Precedence: 1025, Parameters: list<hold=false>, element<hold=false>, Predicates: None., Body: [    DestructiveInsert(list,Length(list)+1,element);]
                                                                          Enter<builtin>{(Prog,[    DestructiveInsert(list,Length(list)+1,element);]);
                                                                              Enter<builtin>{(DestructiveInsert,DestructiveInsert(list,Length(list)+1,element));
                                                                                  Enter<user>{(+,Length(list)+1);
                                                                                      Enter<builtin>{(Length,Length(list));
                                                                                      Leave<builtin>}(Length(list),0);
                                                                                      Arg(Length(list),0);
                                                                                      Arg(1,1);
                                                                                      Enter<builtin>{(IsNumber,IsNumber(x));
                                                                                      Leave<builtin>}(IsNumber(x),True);
                                                                                      Enter<builtin>{(IsNumber,IsNumber(y));
                                                                                      Leave<builtin>}(IsNumber(y),True);
                                                                                      **** Rule in function (+) matched: Precedence: 50, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) IsNumber(x), IsNumber(y), True,     Variables: x, y,    Types: Variable, Variable, Body: AddN(x,y)
                                                                                      Enter<builtin>{(AddN,AddN(x,y));
                                                                                      Leave<builtin>}(AddN(x,y),1);
                                                                                  Leave<user>}(Length(list)+1,1);
                                                                              Leave<builtin>}(DestructiveInsert(list,Length(list)+1,element),{x});
                                                                          Leave<builtin>}([    DestructiveInsert(list,Length(list)+1,element);],{x});
                                                                      Leave<user>}(DestructiveAppend(result,item),{x});
                                                                  Leave<builtin>}(If(NotContains(result,item),DestructiveAppend(result,item)),{x});
                                                              Leave<builtin>}(Eval($body22),{x});
                                                              Enter<builtin>{(Set,Set(foreachtail,Tail(foreachtail)));
                                                                  Enter<builtin>{(Tail,Tail(foreachtail));
                                                                  Leave<builtin>}(Tail(foreachtail),{});
                                                              Leave<builtin>}(Set(foreachtail,Tail(foreachtail)),True);
                                                          Leave<builtin>}([    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                          Enter<builtin>{(Not,NotEquals(foreachtail,{}));
                                                              Enter<builtin>{(Equals,Equals(foreachtail,{}));
                                                                  Enter<builtin>{(List,{});
                                                                  Leave<builtin>}({},{});
                                                              Leave<builtin>}(Equals(foreachtail,{}),True);
                                                          Leave<builtin>}(NotEquals(foreachtail,{}),False);
                                                      Leave<builtin>}(While(NotEquals(foreachtail,{}))[    MacroSet($item22,Head(foreachtail));    Eval($body22);    Set(foreachtail,Tail(foreachtail));],True);
                                                  Leave<builtin>}([    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];],True);
                                              Leave<builtin>}(If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[    Local(foreachtail);    MacroLocal($item22);    Set(foreachtail,$list22);    While(NotEquals(foreachtail,{}))[        MacroSet($item22,Head(foreachtail));        Eval($body22);        Set(foreachtail,Tail(foreachtail));];]),True);
                                          Leave<builtin>}([    If(Equals(IsGeneric($list22),True)AndEquals(GenericTypeName($list22),Array),`ForEachInArray(@$item22,$list22,@$body22),[        Local(foreachtail);        MacroLocal($item22);        Set(foreachtail,$list22);        While(NotEquals(foreachtail,{}))[            MacroSet($item22,Head(foreachtail));            Eval($body22);            Set(foreachtail,Tail(foreachtail));];]);],True);
                                      Leave<user>}(ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item)),True);
                                  Leave<builtin>}([    Local(result);    Set(result,{});    ForEach(item,list)If(NotContains(result,item),DestructiveAppend(result,item));    result;],{x});
                              Leave<user>}(RemoveDuplicates(VarListAll(expr,filter)),{x});
                          Leave<builtin>}([    RemoveDuplicates(VarListAll(expr,filter));],{x});
                      Leave<user>}(VarList(expr,IsVariable),{x});
                  Leave<user>}(VarList(n),{x});
                  Enter<builtin>{(List,{});
                  Leave<builtin>}({},{});
              Leave<builtin>}(VarList(n)={},False);
          Leave<user>}(IsConstant(x),False);
          Enter<user>{(IsNegativeNumber,IsNegativeNumber(x));
              Arg(x,x);
              **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
              Enter<builtin>{(And,IsNumber(x)Andx<0);
                  Enter<builtin>{(IsNumber,IsNumber(x));
                  Leave<builtin>}(IsNumber(x),False);
              Leave<builtin>}(IsNumber(x)Andx<0,False);
          Leave<user>}(IsNegativeNumber(x),False);
          Enter<builtin>{(IsNumber,IsNumber(x));
          Leave<builtin>}(IsNumber(x),False);
          Enter<user>{(IsUniVar,IsUniVar(aLeft));
              Arg(aLeft,x);
              **** Rule in function (IsUniVar) matched: Precedence: 20, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: anything,    Types: Variable, Body: False
          Leave<user>}(IsUniVar(aLeft),False);
          Enter<user>{(IsMatrix,IsMatrix(x));
              Arg(x,x);
              **** Rule in function (IsMatrix) matched: Precedence: 1025, Parameters: $x27<hold=false>, Predicates: None., Body: If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False)
              Enter<builtin>{(If,If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False));
                  Enter<builtin>{(And,IsList($x27)AndLength($x27)>0);
                      Enter<builtin>{(IsList,IsList($x27));
                      Leave<builtin>}(IsList($x27),False);
                  Leave<builtin>}(IsList($x27)AndLength($x27)>0,False);
              Leave<builtin>}(If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False),False);
          Leave<user>}(IsMatrix(x),False);
          Enter<builtin>{(IsList,IsList(xlist));
          Leave<builtin>}(IsList(xlist),False);
          Enter<builtin>{(IsList,IsList(xlist));
          Leave<builtin>}(IsList(xlist),False);
          Enter<builtin>{(IsList,IsList(n));
          Leave<builtin>}(IsList(n),False);
      Leave<user>}(x^(1/3),x^(1/3));
      Arg(x^(1/2),Sqrt(x));
      Arg(x^(1/3),x^(1/3));
      Enter<builtin>{(IsNumber,IsNumber(x));
      Leave<builtin>}(IsNumber(x),False);
      Enter<user>{(IsMatrix,IsMatrix(x));
          Arg(x,Sqrt(x));
          **** Rule in function (IsMatrix) matched: Precedence: 1025, Parameters: $x27<hold=false>, Predicates: None., Body: If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False)
          Enter<builtin>{(If,If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False));
              Enter<builtin>{(And,IsList($x27)AndLength($x27)>0);
                  Enter<builtin>{(IsList,IsList($x27));
                  Leave<builtin>}(IsList($x27),False);
              Leave<builtin>}(IsList($x27)AndLength($x27)>0,False);
          Leave<builtin>}(If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False),False);
      Leave<user>}(IsMatrix(x),False);
      Enter<user>{(IsMatrix,IsMatrix(x));
          Arg(x,Sqrt(x));
          **** Rule in function (IsMatrix) matched: Precedence: 1025, Parameters: $x27<hold=false>, Predicates: None., Body: If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False)
          Enter<builtin>{(If,If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False));
              Enter<builtin>{(And,IsList($x27)AndLength($x27)>0);
                  Enter<builtin>{(IsList,IsList($x27));
                  Leave<builtin>}(IsList($x27),False);
              Leave<builtin>}(IsList($x27)AndLength($x27)>0,False);
          Leave<builtin>}(If(IsList($x27)AndLength($x27)>0,[    Local(n);    n:=Length($x27);    If(Length(Select(IsVector,$x27))=n,MapSingle(Length,$x27)=Length($x27[1])+ZeroVector(n),False);],False),False);
      Leave<user>}(IsMatrix(x),False);
      Enter<builtin>{(IsList,IsList(x));
      Leave<builtin>}(IsList(x),False);
      Enter<user>{(IsNonObject,IsNonObject(x));
          Arg(x,Sqrt(x));
          **** Rule in function (IsNonObject) matched: Precedence: 20, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: True
      Leave<user>}(IsNonObject(x),True);
      Enter<builtin>{(IsList,IsList(y));
      Leave<builtin>}(IsList(y),False);
      Enter<builtin>{(IsNumber,IsNumber(y));
      Leave<builtin>}(IsNumber(y),False);
      Enter<builtin>{(=,f=-1);
          Enter<user>{(-,-1);
              Arg(1,1);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),True);
              **** Rule in function (-) matched: Precedence: 55, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: SubtractN(0,x)
              Enter<builtin>{(SubtractN,SubtractN(0,x));
              Leave<builtin>}(SubtractN(0,x),-1);
          Leave<user>}(-1,-1);
      Leave<builtin>}(f=-1,False);
      Enter<builtin>{(=,f=-1);
          Enter<user>{(-,-1);
              Arg(1,1);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),True);
              **** Rule in function (-) matched: Precedence: 55, Parameters: arg1<hold=false>, Predicates: (Pattern) IsNumber(x), True,     Variables: x,    Types: Variable, Body: SubtractN(0,x)
              Enter<builtin>{(SubtractN,SubtractN(0,x));
              Leave<builtin>}(SubtractN(0,x),-1);
          Leave<user>}(-1,-1);
      Leave<builtin>}(f=-1,False);
      Enter<user>{(IsNegativeNumber,IsNegativeNumber(f));
          Arg(f,x^(1/3));
          **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
          Enter<builtin>{(And,IsNumber(x)Andx<0);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),False);
          Leave<builtin>}(IsNumber(x)Andx<0,False);
      Leave<user>}(IsNegativeNumber(f),False);
      Enter<user>{(IsNegativeNumber,IsNegativeNumber(f));
          Arg(f,Sqrt(x));
          **** Rule in function (IsNegativeNumber) matched: Precedence: 1025, Parameters: x<hold=false>, Predicates: None., Body: IsNumber(x)Andx<0
          Enter<builtin>{(And,IsNumber(x)Andx<0);
              Enter<builtin>{(IsNumber,IsNumber(x));
              Leave<builtin>}(IsNumber(x),False);
          Leave<builtin>}(IsNumber(x)Andx<0,False);
      Leave<user>}(IsNegativeNumber(f),False);
      Enter<user>{(IsUniVar,IsUniVar(aLeft));
          Arg(aLeft,Sqrt(x));
          **** Rule in function (IsUniVar) matched: Precedence: 20, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: anything,    Types: Variable, Body: False
      Leave<user>}(IsUniVar(aLeft),False);
      Enter<builtin>{(IsList,IsList(aLeft));
      Leave<builtin>}(IsList(aLeft),False);
      Enter<user>{(IsInfinity,IsInfinity(x));
          Arg(x,Sqrt(x));
          **** Rule in function (IsInfinity) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
      Leave<user>}(IsInfinity(x),False);
      Enter<builtin>{(IsNumber,IsNumber(x));
      Leave<builtin>}(IsNumber(x),False);
      Enter<user>{(IsRationalOrNumber,IsRationalOrNumber(y));
          Arg(y,x);
          Enter<builtin>{(IsNumber,IsNumber(x));
          Leave<builtin>}(IsNumber(x),False);
          **** Rule in function (IsRationalOrNumber) matched: Precedence: 60000, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: x,    Types: Variable, Body: False
      Leave<user>}(IsRationalOrNumber(y),False);
      Leave<user>}(x^(1/2)*x^(1/3),Sqrt(x)*x^(1/3));
      Enter<builtin>{(TraceOff,TraceOff());
      Tracing is off.
.   %/mathpiper_trace


