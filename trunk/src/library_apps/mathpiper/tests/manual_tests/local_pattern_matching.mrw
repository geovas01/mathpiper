%mathpiper
E := A(x,y) + B(x,y,z);
F := Deriv(z) E;
Echo("F: ",F);
G := ( F /: { (Deriv(_var)(_w))_(IsFreeOf(var,w)) <- 0 } );

//G := ( (Deriv(z)A(x,y)) /:  {(Deriv(_var)(_w))_(IsFreeOf(var,w)) <- Echo("KALI ",,,var,,,w)}  );
//G := ( (Deriv(z)A(x,y)) /:  {(Deriv(_var)(_w)) <- Echo("KALI ",,,var,,,w)}  );
                                         // (Deriv(_var)(_x / _y))_(IsFreeOf(var,y)) <-- (Deriv(var) x) / y;
//WriteString("E = ");  Echo(E);
//WriteString("F = ");  Echo(F);
WriteString("G = ");  Echo(G);

/*1 # (Deriv(_var)(_w))_(IsFreeOf(var,w)) <-- 0;
G := Eval(F) ;
WriteString("G = ");  Echo(G);NewLine();
*/


%/mathpiper

    %output,preserve="false"
      Result: True
      
      Side Effects:
      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = 0+(Deriv(z)B(x,y,z))
.   %/output


      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z))

      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = 0+(Deriv(z)B(x,y,z)) 
      G = Deriv(z)B(x,y,z)





%mathpiper
(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};
%/mathpiper






%mathpiper,output="trace"

//(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};

Retract("LocProcessSingle",*);

40 # LocProcessSingle(pat_IsFunction <- _exp) <-- 
[
    Local(justPattern, postPredicate);
    
    If(Type(pat) = "_",
        [
            justPattern := pat[1];
            postPredicate := pat[2];
        ],
        [
            justPattern := pat;
            postPredicate := True;
        ]
    );
    
    { {justPattern[0],Pattern'Create(justPattern,postPredicate)},exp };
];


//TraceExcept("MacroLocal,ApplyPure,Apply,MapSingle,+,ForEach,*,++,>=,<=,:=,IsUniVar,IsNumber,IsNegativeNumber,For,IsInfinity,IsMatrix,IsNonObject,SubtractN,-,MathSign,IsGeneric,Or,IsString,AbsN,UnFence,LocalSymbols,GreaterThan,Retract,=,UnList,Hold,Equals,IsFunction,Listify,Head,Nth,MathNth,Type,Prog,And,NotEquals,Local,Tail,DefLoadFunction,Not,IsInteger,Set,String,Length,If,List,MakeVector,IsList,LessThan,While,DestructiveReverse,MacroSet,Eval,DestructiveInsert,AddN,IsAtom,Atom,ConcatStrings",  (b + c) * (d + e) /: {(x_IsAtom + _y)_(IsZero(0)) <- Echo(x,,,y)} );


%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: True
.   %/mathpiper_trace







%mathpiper,output="trace"

//(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};

Retract("LocProcessSingle",*);

40 # LocProcessSingle(pat_IsFunction <- _exp) <-- 
[
    { {pat[0],Pattern'Create(pat,True)},exp };
];

//10 # LocProcessSingle({_pat,_post,_exp}) <-- { {pat[0],Pattern'Create(pat,post)},exp };

//20 # LocProcessSingle({pat_IsFunction,_exp}) <-- { {pat[0],Pattern'Create(pat,True)},exp };

//30 # LocProcessSingle({pat_IsAtom,_exp}) <-- { pat,exp };

//50 # LocProcessSingle(pat_IsAtom <- _exp) <-- { pat,exp };

TraceExcept("MacroLocal,ApplyPure,Apply,MapSingle,+,ForEach,*,++,>=,<=,:=,IsUniVar,IsNumber,IsNegativeNumber,For,IsInfinity,IsMatrix,IsNonObject,SubtractN,-,MathSign,IsGeneric,Or,IsString,AbsN,UnFence,LocalSymbols,GreaterThan,Retract,=,UnList,Hold,Equals,IsFunction,Listify,Head,Nth,MathNth,Type,Prog,And,NotEquals,Local,Tail,DefLoadFunction,Not,IsInteger,Set,String,Length,If,List,MakeVector,IsList,LessThan,While,DestructiveReverse,MacroSet,Eval,DestructiveInsert,AddN,IsAtom,Atom,ConcatStrings",  (b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)} );


%/mathpiper







%mathpiper

E := A(x,y) + B(x,y,z);
F := Deriv(z) E;
G := ( Eval(F) /: { (Deriv(_var)(_w))_(IsFreeOf(var,w)) <- 0 } );
WriteString("E = ");  Echo(E);
WriteString("F = ");  Echo(F);
WriteString("G = ");  Echo(G);
WriteString("G  simplified = ");  Echo(Simplify(G));

1 # (Deriv(_var)(_w))_(IsFreeOf(var,w)) <-- 0;
G := Eval(F) ;
WriteString("G = ");  Echo(G);NewLine();

%/mathpiper

    %output,preserve="false"
      Result: True
      
      Side Effects:
      E = A(x,y)+B(x,y,z) 
      F = Deriv(z)B(x,y,z) 
      G = Deriv(z)B(x,y,z) 
      G  simplified = Deriv(z)B(x,y,z) 
      G = Deriv(z)B(x,y,z)
.   %/output





(x_IsBound + y_IsOdd) <- m1,
      (x_IsBound + y_IsEven) <- m3,
      

%mathpiper

Hold((a + b) * (1 + 2) * (2 + 1) * (1/2 + c) * (3/4 + d) ) /: 
    {
      (x_IsOdd + y_IsEven) <- m1,
      (x_IsEven + y_IsOdd) <- m2,
      (x_IsRational + y_IsAtom)_(Denom(x) = 2) <- m3,
    };

%/mathpiper

    %output,preserve="false"
      Result: (a+b)*m1*m2*m3*(3/4+d)
.   %/output



%mathpiper

Hold( (b + c) * (d + 1) * (4 + d) ) /: 
    {
      
      (x_IsBound + y_IsBound) <- m2,

    };
    
%/mathpiper

    %output,preserve="false"
      Result: m2*m2*m2
.   %/output


%mathpiper,output="trace"
//(b + c) * (d + e) /: {(x_IsAtom + y_IsAtom) <- m1};

functions := "MacroLocal,ApplyPure,Apply,MapSingle,+,ForEach,*,++,>=,<=,<,:=,IsUniVar,IsNumber,IsNegativeNumber,For,IsInfinity,IsMatrix,IsNonObject,SubtractN,-,MathSign,IsGeneric,Or,IsString,AbsN,UnFence,LocalSymbols,GreaterThan,Retract,=,UnList,Hold,Equals,IsFunction,Listify,Head,Nth,MathNth,Type,Prog,And,NotEquals,Local,Tail,DefLoadFunction,Not,IsInteger,Set,String,Length,If,List,MakeVector,IsList,LessThan,While,DestructiveReverse,MacroSet,Eval,DestructiveInsert,AddN,IsAtom,Atom,ConcatStrings";
TraceExcept(functions,(b + c) * (d + 1) * (4 + d) /: 
    {
      
      (x_IsBound + y_IsBound) <- m2,

    }
    );

%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: m2*m2*m2
      
      Side Effects:
      Enter<**** user rulebase>{(/:, (b+c)*(d+1)*(4+d)/:{x_IsBound+y_IsBound<-m2});
          Enter<**** user rulebase>{(<-, x_IsBound+y_IsBound<-m2);
              Arg(left -> x_IsBound+y_IsBound);
              Arg(right -> m2);
          Leave<**** user rulebase>}(x_IsBound+y_IsBound<-m2 -> x_IsBound+y_IsBound<-m2,    Local variables: right -> m2, left -> (+ (_ x IsBound )(_ y IsBound ))m2, );
          Arg(arg1 -> (b+c)*(d+1)*(d+4));
          Arg(arg2 -> {x_IsBound+y_IsBound<-m2});
          **** Rule in function (/:) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=false>, Predicates: (Pattern) True,     Variables: expression, patterns,     Types: Variable, Variable,    Body: [    Set(patterns, LocProcess(patterns));    MacroSubstitute(expression, "LocPredicate", "LocChange");]
          Enter<**** user rulebase>{(LocProcess, LocProcess(patterns));
              Arg(patterns -> {x_IsBound+y_IsBound<-m2});
              **** Rule in function (LocProcess) matched: Precedence: 1025, Parameters: patterns<hold=false>, Predicates: None.,    Body: [    MapSingle("LocProcessSingle", patterns);]
              Enter<**** user rulebase>{(LocProcessSingle, LocProcessSingle(x_IsBound+y_IsBound<-m2));
                  Enter<**** user rulebase>{(<-, x_IsBound+y_IsBound<-m2);
                      Arg(left -> x_IsBound+y_IsBound);
                      Arg(right -> m2);
                  Leave<**** user rulebase>}(x_IsBound+y_IsBound<-m2 -> x_IsBound+y_IsBound<-m2,    Local variables: right -> m2, left -> (+ (_ x IsBound )(_ y IsBound ))m2, );
                  Arg(arg1 -> x_IsBound+y_IsBound<-m2);
                  **** Rule in function (LocProcessSingle) matched: Precedence: 40, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(pat), True,     Variables: pat, exp,     Types: Sublist,    Body: [    Local(justPattern, postPredicate);    If(Type(pat)="_", [        justPattern:=pat[1];        postPredicate:=pat[2];], [        justPattern:=pat;        postPredicate:=True;]);    {{justPattern[0], Pattern'Create(justPattern, postPredicate)}, exp};]
                  Enter<builtin>{(Pattern'Create, Pattern'Create(justPattern,postPredicate));
                      Arg(parameter1 -> x_IsBound+y_IsBound);
                      Arg(parameter2 -> True);
                  Leave<builtin>}(Pattern'Create(justPattern,postPredicate) -> Pattern,    Local variables: postPredicate -> True, justPattern -> (+ (_ x IsBound )(_ y IsBound )), exp -> m2, pat -> (+ (_ x IsBound )(_ y IsBound ))m2, arg1 -> (<- (+ (_ x IsBound )(_ y IsBound ))m2 ), );
              Leave<**** user rulebase>}(LocProcessSingle(x_IsBound+y_IsBound<-m2) -> {{+,Pattern},m2},    Local variables: exp -> m2, pat -> (+ (_ x IsBound )(_ y IsBound ))m2, arg1 -> (<- (+ (_ x IsBound )(_ y IsBound ))m2 ), );
          Leave<**** user rulebase>}(LocProcess(patterns) -> {{{+,Pattern},m2}},    Local variables: patterns -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), );
          Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(expression,LocPredicate,LocChange));
              Arg(body -> (b+c)*(d+1)*(d+4));
              Arg(predicate -> LocPredicate);
              Arg(change -> LocChange);
              **** Rule in function (MacroSubstitute) matched: Precedence: 1025, Parameters: body<hold=false>, predicate<hold=true>, change<hold=true>, Predicates: None.,    Body: [    `MacroSubstitute(Hold(@body));]
              Enter<builtin>{(`, `MacroSubstitute(Hold(@body)));
                  Arg(parameter1 -> MacroSubstitute(Hold(@body)));
                  Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(Hold((b+c)*(d+1)*(d+4))));
                      Arg(body -> (b+c)*(d+1)*(d+4));
                      Enter<builtin>{(`, `ApplyPure(predicate,{Hold(Hold(@body))}));
                          Arg(parameter1 -> ApplyPure(predicate,{Hold(Hold(@body))}));
                          Enter<**** user rulebase>{(LocPredicate, LocPredicate(Hold((b+c)*(d+1)*(d+4))));
                              Arg(arg1 -> (b+c)*(d+1)*(d+4));
                              **** Rule in function (LocPredicate) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(exp), True,     Variables: exp,     Types: Variable,    Body: [    Local(tr, result, head);    tr:=patterns;    result:=False;    While(tr!={})[        Set(head, Head(Head(tr)));        If(NotIsAtom(head)Andexp[0]=head[1]AndPattern'Matches(head[2], exp), [            Set($LocResult12, Eval(Head(Tail(Head(tr)))));            Set(result, True);            Set(tr, {});], [            Set(tr, Tail(tr));]);];    result;]
                              Enter<**** user rulebase>{(!=, tr!={});
                                  Arg(aLeft -> {{{+,Pattern},m2}});
                                  Arg(aRight -> {});
                                  **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                              Leave<**** user rulebase>}(tr!={} -> True,    Local variables: aRight -> (List ), aLeft -> (List (List (List + [BuiltinObject])m2 )), );
                              Enter<**** user rulebase>{(!=, tr!={});
                                  Arg(aLeft -> {});
                                  Arg(aRight -> {});
                                  **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                              Leave<**** user rulebase>}(tr!={} -> False,    Local variables: aRight -> (List ), aLeft -> (List ), );
                          Leave<**** user rulebase>}(LocPredicate(Hold((b+c)*(d+1)*(d+4))) -> False,    Local variables: exp -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                      Leave<builtin>}(`ApplyPure(predicate,{Hold(Hold(@body))}) -> False,    Local variables: body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                      Enter<builtin>{(`, `IsFunction(Hold(@body)));
                          Arg(parameter1 -> IsFunction(Hold(@body)));
                      Leave<builtin>}(`IsFunction(Hold(@body)) -> True,    Local variables: body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                      **** Rule in function (MacroSubstitute) matched: Precedence: 2, Parameters: body<hold=false>, Predicates: `IsFunction(Hold(@body)),    Body: [    `ApplyPure("MacroMapArgs", {Hold(Hold(@body)), "MacroSubstitute"});]
                      Enter<builtin>{(`, `ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}));
                          Arg(parameter1 -> ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}));
                          Enter<macro>{(MacroMapArgs, MacroMapArgs(Hold((b+c)*(d+1)*(d+4)),MacroSubstitute));
                              Arg(expr -> Hold((b+c)*(d+1)*(d+4)));
                              Arg(oper -> MacroSubstitute);
                              **** Rule in function (MacroMapArgs) matched: Precedence: 1025, Parameters: expr<hold=true>, oper<hold=true>, Predicates: None.,    Body: [    Local(ex, tl, op);    Set(op, @oper);    Set(ex, Listify(@expr));    Set(tl, Tail(ex));    UnList(Concat({ex[1]}, `MacroMapSingle(@op, Hold(@tl))));], Substituted Macro Body: [    Local(ex,tl,op);    Set(op,"MacroSubstitute");    Set(ex,Listify(Hold((b+c)*(d+1)*(d+4))));    Set(tl,Tail(ex));    UnList(Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))));]
                              Enter<builtin>{(Concat, Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))));
                                  Enter<builtin>{(`, `MacroMapSingle(@op,Hold(@tl)));
                                      Arg(parameter1 -> MacroMapSingle(@op,Hold(@tl)));
                                      Enter<**** user rulebase>{(MacroMapSingle, MacroMapSingle(MacroSubstitute,Hold({(b+c)*(d+1),d+4})));
                                          Arg($func15 -> MacroSubstitute);
                                          Arg($list15 -> {(b+c)*(d+1),d+4});
                                          **** Rule in function (MacroMapSingle) matched: Precedence: 1025, Parameters: $func15<hold=false>, $list15<hold=false>, Predicates: None.,    Body: [    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem, $list15)[        DestructiveInsert(mapsingleresult, 1, `ApplyPure($func15, {Hold(Hold(@mapsingleitem))}));];    DestructiveReverse(mapsingleresult);]
                                          Enter<builtin>{(`, `ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                              Arg(parameter1 -> ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                              Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(Hold((b+c)*(d+1))));
                                                  Arg(body -> (b+c)*(d+1));
                                                  Enter<builtin>{(`, `ApplyPure(predicate,{Hold(Hold(@body))}));
                                                      Arg(parameter1 -> ApplyPure(predicate,{Hold(Hold(@body))}));
                                                      Enter<**** user rulebase>{(LocPredicate, LocPredicate(Hold((b+c)*(d+1))));
                                                          Arg(arg1 -> (b+c)*(d+1));
                                                          **** Rule in function (LocPredicate) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(exp), True,     Variables: exp,     Types: Variable,    Body: [    Local(tr, result, head);    tr:=patterns;    result:=False;    While(tr!={})[        Set(head, Head(Head(tr)));        If(NotIsAtom(head)Andexp[0]=head[1]AndPattern'Matches(head[2], exp), [            Set($LocResult12, Eval(Head(Tail(Head(tr)))));            Set(result, True);            Set(tr, {});], [            Set(tr, Tail(tr));]);];    result;]
                                                          Enter<**** user rulebase>{(!=, tr!={});
                                                              Arg(aLeft -> {{{+,Pattern},m2}});
                                                              Arg(aRight -> {});
                                                              **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                          Leave<**** user rulebase>}(tr!={} -> True,    Local variables: aRight -> (List ), aLeft -> (List (List (List + [BuiltinObject])m2 )), );
                                                          Enter<**** user rulebase>{(!=, tr!={});
                                                              Arg(aLeft -> {});
                                                              Arg(aRight -> {});
                                                              **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                          Leave<**** user rulebase>}(tr!={} -> False,    Local variables: aRight -> (List ), aLeft -> (List ), );
                                                      Leave<**** user rulebase>}(LocPredicate(Hold((b+c)*(d+1))) -> False,    Local variables: exp -> (* (+ b c )(+ d 1 )), arg1 -> (* (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  Leave<builtin>}(`ApplyPure(predicate,{Hold(Hold(@body))}) -> False,    Local variables: body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  Enter<builtin>{(`, `IsFunction(Hold(@body)));
                                                      Arg(parameter1 -> IsFunction(Hold(@body)));
                                                  Leave<builtin>}(`IsFunction(Hold(@body)) -> True,    Local variables: body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  **** Rule in function (MacroSubstitute) matched: Precedence: 2, Parameters: body<hold=false>, Predicates: `IsFunction(Hold(@body)),    Body: [    `ApplyPure("MacroMapArgs", {Hold(Hold(@body)), "MacroSubstitute"});]
                                                  Enter<builtin>{(`, `ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}));
                                                      Arg(parameter1 -> ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}));
                                                      Enter<macro>{(MacroMapArgs, MacroMapArgs(Hold((b+c)*(d+1)),MacroSubstitute));
                                                          Arg(expr -> Hold((b+c)*(d+1)));
                                                          Arg(oper -> MacroSubstitute);
                                                          **** Rule in function (MacroMapArgs) matched: Precedence: 1025, Parameters: expr<hold=true>, oper<hold=true>, Predicates: None.,    Body: [    Local(ex, tl, op);    Set(op, @oper);    Set(ex, Listify(@expr));    Set(tl, Tail(ex));    UnList(Concat({ex[1]}, `MacroMapSingle(@op, Hold(@tl))));], Substituted Macro Body: [    Local(ex,tl,op);    Set(op,"MacroSubstitute");    Set(ex,Listify(Hold((b+c)*(d+1))));    Set(tl,Tail(ex));    UnList(Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))));]
                                                          Enter<builtin>{(Concat, Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))));
                                                              Enter<builtin>{(`, `MacroMapSingle(@op,Hold(@tl)));
                                                                  Arg(parameter1 -> MacroMapSingle(@op,Hold(@tl)));
                                                                  Enter<**** user rulebase>{(MacroMapSingle, MacroMapSingle(MacroSubstitute,Hold({b+c,d+1})));
                                                                      Arg($func15 -> MacroSubstitute);
                                                                      Arg($list15 -> {b+c,d+1});
                                                                      **** Rule in function (MacroMapSingle) matched: Precedence: 1025, Parameters: $func15<hold=false>, $list15<hold=false>, Predicates: None.,    Body: [    Local(mapsingleresult);    mapsingleresult:={};    ForEach(mapsingleitem, $list15)[        DestructiveInsert(mapsingleresult, 1, `ApplyPure($func15, {Hold(Hold(@mapsingleitem))}));];    DestructiveReverse(mapsingleresult);]
                                                                      Enter<builtin>{(`, `ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                                                          Arg(parameter1 -> ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                                                          Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(Hold(b+c)));
                                                                              Arg(body -> b+c);
                                                                              Enter<builtin>{(`, `ApplyPure(predicate,{Hold(Hold(@body))}));
                                                                                  Arg(parameter1 -> ApplyPure(predicate,{Hold(Hold(@body))}));
                                                                                  Enter<**** user rulebase>{(LocPredicate, LocPredicate(Hold(b+c)));
                                                                                      Arg(arg1 -> b+c);
                                                                                      **** Rule in function (LocPredicate) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(exp), True,     Variables: exp,     Types: Variable,    Body: [    Local(tr, result, head);    tr:=patterns;    result:=False;    While(tr!={})[        Set(head, Head(Head(tr)));        If(NotIsAtom(head)Andexp[0]=head[1]AndPattern'Matches(head[2], exp), [            Set($LocResult12, Eval(Head(Tail(Head(tr)))));            Set(result, True);            Set(tr, {});], [            Set(tr, Tail(tr));]);];    result;]
                                                                                      Enter<**** user rulebase>{(!=, tr!={});
                                                                                          Arg(aLeft -> {{{+,Pattern},m2}});
                                                                                          Arg(aRight -> {});
                                                                                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                                                      Leave<**** user rulebase>}(tr!={} -> True,    Local variables: aRight -> (List ), aLeft -> (List (List (List + [BuiltinObject])m2 )), );
                                                                                      Enter<builtin>{(Pattern'Matches, Pattern'Matches(head[2],exp));
                                                                                          Arg(parameter1 -> Pattern);
                                                                                          Arg(parameter2 -> b+c);
                                                                                          Enter<builtin>{(IsBound, IsBound(x));
                                                                                              Arg(parameter1 -> x);
                                                                                          Leave<builtin>}(IsBound(x) -> True,    Local variables: y -> c, x -> b c, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ b c ), arg1 -> (+ b c ), body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                          Enter<builtin>{(IsBound, IsBound(y));
                                                                                              Arg(parameter1 -> y);
                                                                                          Leave<builtin>}(IsBound(y) -> True,    Local variables: y -> c, x -> b c, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ b c ), arg1 -> (+ b c ), body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                      Leave<builtin>}(Pattern'Matches(head[2],exp) -> True,    Local variables: y -> c, x -> b c, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ b c ), arg1 -> (+ b c ), body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                      Enter<**** user rulebase>{(!=, tr!={});
                                                                                          Arg(aLeft -> {});
                                                                                          Arg(aRight -> {});
                                                                                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                                                      Leave<**** user rulebase>}(tr!={} -> False,    Local variables: aRight -> (List ), aLeft -> (List ), );
                                                                                  Leave<**** user rulebase>}(LocPredicate(Hold(b+c)) -> True,    Local variables: exp -> (+ b c ), arg1 -> (+ b c ), body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              Leave<builtin>}(`ApplyPure(predicate,{Hold(Hold(@body))}) -> True,    Local variables: body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              **** Rule in function (MacroSubstitute) matched: Precedence: 1, Parameters: body<hold=false>, Predicates: `ApplyPure(predicate,{Hold(Hold(@body))})=True,    Body: [    `ApplyPure(change, {Hold(Hold(@body))});]
                                                                              Enter<builtin>{(`, `ApplyPure(change,{Hold(Hold(@body))}));
                                                                                  Arg(parameter1 -> ApplyPure(change,{Hold(Hold(@body))}));
                                                                                  Enter<**** user rulebase>{(LocChange, LocChange(Hold(b+c)));
                                                                                      Arg(arg1 -> b+c);
                                                                                      **** Rule in function (LocChange) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: exp,     Types: Variable,    Body: $LocResult12
                                                                                  Leave<**** user rulebase>}(LocChange(Hold(b+c)) -> m2,    Local variables: exp -> (+ b c ), arg1 -> (+ b c ), body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              Leave<builtin>}(`ApplyPure(change,{Hold(Hold(@body))}) -> m2,    Local variables: body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                          Leave<**** user rulebase>}(MacroSubstitute(Hold(b+c)) -> m2,    Local variables: body -> (+ b c ), mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                      Leave<builtin>}(`ApplyPure($func15,{Hold(Hold(@mapsingleitem))}) -> m2,    Local variables: mapsingleitem -> (+ b c ), foreachtail -> (List (+ b c )(+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                      Enter<builtin>{(`, `ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                                                          Arg(parameter1 -> ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                                                          Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(Hold(d+1)));
                                                                              Arg(body -> d+1);
                                                                              Enter<builtin>{(`, `ApplyPure(predicate,{Hold(Hold(@body))}));
                                                                                  Arg(parameter1 -> ApplyPure(predicate,{Hold(Hold(@body))}));
                                                                                  Enter<**** user rulebase>{(LocPredicate, LocPredicate(Hold(d+1)));
                                                                                      Arg(arg1 -> d+1);
                                                                                      **** Rule in function (LocPredicate) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(exp), True,     Variables: exp,     Types: Variable,    Body: [    Local(tr, result, head);    tr:=patterns;    result:=False;    While(tr!={})[        Set(head, Head(Head(tr)));        If(NotIsAtom(head)Andexp[0]=head[1]AndPattern'Matches(head[2], exp), [            Set($LocResult12, Eval(Head(Tail(Head(tr)))));            Set(result, True);            Set(tr, {});], [            Set(tr, Tail(tr));]);];    result;]
                                                                                      Enter<**** user rulebase>{(!=, tr!={});
                                                                                          Arg(aLeft -> {{{+,Pattern},m2}});
                                                                                          Arg(aRight -> {});
                                                                                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                                                      Leave<**** user rulebase>}(tr!={} -> True,    Local variables: aRight -> (List ), aLeft -> (List (List (List + [BuiltinObject])m2 )), );
                                                                                      Enter<builtin>{(Pattern'Matches, Pattern'Matches(head[2],exp));
                                                                                          Arg(parameter1 -> Pattern);
                                                                                          Arg(parameter2 -> d+1);
                                                                                          Enter<builtin>{(IsBound, IsBound(x));
                                                                                              Arg(parameter1 -> x);
                                                                                          Leave<builtin>}(IsBound(x) -> True,    Local variables: y -> 1, x -> d 1, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 1 ), arg1 -> (+ d 1 ), body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                          Enter<builtin>{(IsBound, IsBound(y));
                                                                                              Arg(parameter1 -> y);
                                                                                          Leave<builtin>}(IsBound(y) -> True,    Local variables: y -> 1, x -> d 1, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 1 ), arg1 -> (+ d 1 ), body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                      Leave<builtin>}(Pattern'Matches(head[2],exp) -> True,    Local variables: y -> 1, x -> d 1, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 1 ), arg1 -> (+ d 1 ), body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                                      Enter<**** user rulebase>{(!=, tr!={});
                                                                                          Arg(aLeft -> {});
                                                                                          Arg(aRight -> {});
                                                                                          **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                                                      Leave<**** user rulebase>}(tr!={} -> False,    Local variables: aRight -> (List ), aLeft -> (List ), );
                                                                                  Leave<**** user rulebase>}(LocPredicate(Hold(d+1)) -> True,    Local variables: exp -> (+ d 1 ), arg1 -> (+ d 1 ), body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              Leave<builtin>}(`ApplyPure(predicate,{Hold(Hold(@body))}) -> True,    Local variables: body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              **** Rule in function (MacroSubstitute) matched: Precedence: 1, Parameters: body<hold=false>, Predicates: `ApplyPure(predicate,{Hold(Hold(@body))})=True,    Body: [    `ApplyPure(change, {Hold(Hold(@body))});]
                                                                              Enter<builtin>{(`, `ApplyPure(change,{Hold(Hold(@body))}));
                                                                                  Arg(parameter1 -> ApplyPure(change,{Hold(Hold(@body))}));
                                                                                  Enter<**** user rulebase>{(LocChange, LocChange(Hold(d+1)));
                                                                                      Arg(arg1 -> d+1);
                                                                                      **** Rule in function (LocChange) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: exp,     Types: Variable,    Body: $LocResult12
                                                                                  Leave<**** user rulebase>}(LocChange(Hold(d+1)) -> m2,    Local variables: exp -> (+ d 1 ), arg1 -> (+ d 1 ), body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                              Leave<builtin>}(`ApplyPure(change,{Hold(Hold(@body))}) -> m2,    Local variables: body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                          Leave<**** user rulebase>}(MacroSubstitute(Hold(d+1)) -> m2,    Local variables: body -> (+ d 1 ), mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                      Leave<builtin>}(`ApplyPure($func15,{Hold(Hold(@mapsingleitem))}) -> m2,    Local variables: mapsingleitem -> (+ d 1 ), foreachtail -> (List (+ d 1 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (+ b c )(+ d 1 )), $item22 -> mapsingleitem, mapsingleresult -> (List m2 ), $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                                  Leave<**** user rulebase>}(MacroMapSingle(MacroSubstitute,Hold({b+c,d+1})) -> {m2,m2},    Local variables: $list15 -> (List (+ b c )(+ d 1 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                              Leave<builtin>}(`MacroMapSingle(@op,Hold(@tl)) -> {m2,m2},    Local variables: op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                              Arg(parameter1 -> {ex[1]});
                                                              Arg(parameter2 -> `MacroMapSingle(@op,Hold(@tl)));
                                                          Leave<builtin>}(Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))) -> {*,m2,m2},    Local variables: op -> "MacroSubstitute", tl -> (List (+ b c )(+ d 1 )), ex -> (List * (+ b c )(+ d 1 )), body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                      Leave<macro>}(MacroMapArgs(Hold((b+c)*(d+1)),MacroSubstitute) -> m2*m2,    Local variables: body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  Leave<builtin>}(`ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}) -> m2*m2,    Local variables: body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                              Leave<**** user rulebase>}(MacroSubstitute(Hold((b+c)*(d+1))) -> m2*m2,    Local variables: body -> (* (+ b c )(+ d 1 )), mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                          Leave<builtin>}(`ApplyPure($func15,{Hold(Hold(@mapsingleitem))}) -> m2*m2,    Local variables: mapsingleitem -> (* (+ b c )(+ d 1 )), foreachtail -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List ), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                          Enter<builtin>{(`, `ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                              Arg(parameter1 -> ApplyPure($func15,{Hold(Hold(@mapsingleitem))}));
                                              Enter<**** user rulebase>{(MacroSubstitute, MacroSubstitute(Hold(d+4)));
                                                  Arg(body -> d+4);
                                                  Enter<builtin>{(`, `ApplyPure(predicate,{Hold(Hold(@body))}));
                                                      Arg(parameter1 -> ApplyPure(predicate,{Hold(Hold(@body))}));
                                                      Enter<**** user rulebase>{(LocPredicate, LocPredicate(Hold(d+4)));
                                                          Arg(arg1 -> d+4);
                                                          **** Rule in function (LocPredicate) matched: Precedence: 10, Parameters: arg1<hold=false>, Predicates: (Pattern) IsFunction(exp), True,     Variables: exp,     Types: Variable,    Body: [    Local(tr, result, head);    tr:=patterns;    result:=False;    While(tr!={})[        Set(head, Head(Head(tr)));        If(NotIsAtom(head)Andexp[0]=head[1]AndPattern'Matches(head[2], exp), [            Set($LocResult12, Eval(Head(Tail(Head(tr)))));            Set(result, True);            Set(tr, {});], [            Set(tr, Tail(tr));]);];    result;]
                                                          Enter<**** user rulebase>{(!=, tr!={});
                                                              Arg(aLeft -> {{{+,Pattern},m2}});
                                                              Arg(aRight -> {});
                                                              **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                          Leave<**** user rulebase>}(tr!={} -> True,    Local variables: aRight -> (List ), aLeft -> (List (List (List + [BuiltinObject])m2 )), );
                                                          Enter<builtin>{(Pattern'Matches, Pattern'Matches(head[2],exp));
                                                              Arg(parameter1 -> Pattern);
                                                              Arg(parameter2 -> d+4);
                                                              Enter<builtin>{(IsBound, IsBound(x));
                                                                  Arg(parameter1 -> x);
                                                              Leave<builtin>}(IsBound(x) -> True,    Local variables: y -> 4, x -> d 4, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 4 ), arg1 -> (+ d 4 ), body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                              Enter<builtin>{(IsBound, IsBound(y));
                                                                  Arg(parameter1 -> y);
                                                              Leave<builtin>}(IsBound(y) -> True,    Local variables: y -> 4, x -> d 4, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 4 ), arg1 -> (+ d 4 ), body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                          Leave<builtin>}(Pattern'Matches(head[2],exp) -> True,    Local variables: y -> 4, x -> d 4, head -> (List + [BuiltinObject]), result -> False, tr -> (List (List (List + [BuiltinObject])m2 )), exp -> (+ d 4 ), arg1 -> (+ d 4 ), body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                          Enter<**** user rulebase>{(!=, tr!={});
                                                              Arg(aLeft -> {});
                                                              Arg(aRight -> {});
                                                              **** Rule in function (!=) matched: Precedence: 1025, Parameters: aLeft<hold=false>, aRight<hold=false>, Predicates: None.,    Body: NotaLeft=aRight
                                                          Leave<**** user rulebase>}(tr!={} -> False,    Local variables: aRight -> (List ), aLeft -> (List ), );
                                                      Leave<**** user rulebase>}(LocPredicate(Hold(d+4)) -> True,    Local variables: exp -> (+ d 4 ), arg1 -> (+ d 4 ), body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  Leave<builtin>}(`ApplyPure(predicate,{Hold(Hold(@body))}) -> True,    Local variables: body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  **** Rule in function (MacroSubstitute) matched: Precedence: 1, Parameters: body<hold=false>, Predicates: `ApplyPure(predicate,{Hold(Hold(@body))})=True,    Body: [    `ApplyPure(change, {Hold(Hold(@body))});]
                                                  Enter<builtin>{(`, `ApplyPure(change,{Hold(Hold(@body))}));
                                                      Arg(parameter1 -> ApplyPure(change,{Hold(Hold(@body))}));
                                                      Enter<**** user rulebase>{(LocChange, LocChange(Hold(d+4)));
                                                          Arg(arg1 -> d+4);
                                                          **** Rule in function (LocChange) matched: Precedence: 0, Parameters: arg1<hold=false>, Predicates: (Pattern) True,     Variables: exp,     Types: Variable,    Body: $LocResult12
                                                      Leave<**** user rulebase>}(LocChange(Hold(d+4)) -> m2,    Local variables: exp -> (+ d 4 ), arg1 -> (+ d 4 ), body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                                  Leave<builtin>}(`ApplyPure(change,{Hold(Hold(@body))}) -> m2,    Local variables: body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                              Leave<**** user rulebase>}(MacroSubstitute(Hold(d+4)) -> m2,    Local variables: body -> (+ d 4 ), mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                          Leave<builtin>}(`ApplyPure($func15,{Hold(Hold(@mapsingleitem))}) -> m2,    Local variables: mapsingleitem -> (+ d 4 ), foreachtail -> (List (+ d 4 )), $body22 -> (Prog (DestructiveInsert mapsingleresult 1 (` (ApplyPure $func15 (List (Hold (Hold (@ mapsingleitem )))))))), $list22 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $item22 -> mapsingleitem, mapsingleresult -> (List (* m2 m2 )), $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                      Leave<**** user rulebase>}(MacroMapSingle(MacroSubstitute,Hold({(b+c)*(d+1),d+4})) -> {m2*m2,m2},    Local variables: $list15 -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), $func15 -> "MacroSubstitute", op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                  Leave<builtin>}(`MacroMapSingle(@op,Hold(@tl)) -> {m2*m2,m2},    Local variables: op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                                  Arg(parameter1 -> {ex[1]});
                                  Arg(parameter2 -> `MacroMapSingle(@op,Hold(@tl)));
                              Leave<builtin>}(Concat({ex[1]},`MacroMapSingle(@op,Hold(@tl))) -> {*,m2*m2,m2},    Local variables: op -> "MacroSubstitute", tl -> (List (* (+ b c )(+ d 1 ))(+ d 4 )), ex -> (List * (* (+ b c )(+ d 1 ))(+ d 4 )), body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                          Leave<macro>}(MacroMapArgs(Hold((b+c)*(d+1)*(d+4)),MacroSubstitute) -> m2*m2*m2,    Local variables: body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                      Leave<builtin>}(`ApplyPure(MacroMapArgs,{Hold(Hold(@body)),MacroSubstitute}) -> m2*m2*m2,    Local variables: body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
                  Leave<**** user rulebase>}(MacroSubstitute(Hold((b+c)*(d+1)*(d+4))) -> m2*m2*m2,    Local variables: body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
              Leave<builtin>}(`MacroSubstitute(Hold(@body)) -> m2*m2*m2,    Local variables: change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
          Leave<**** user rulebase>}(MacroSubstitute(expression,LocPredicate,LocChange) -> m2*m2*m2,    Local variables: change -> "LocChange", predicate -> "LocPredicate", body -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
      Leave<**** user rulebase>}((b+c)*(d+1)*(4+d)/:{x_IsBound+y_IsBound<-m2} -> m2*m2*m2,    Local variables: patterns -> (List (List (List + [BuiltinObject])m2 )), expression -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), arg2 -> (List (<- (+ (_ x IsBound )(_ y IsBound ))m2 )), arg1 -> (* (* (+ b c )(+ d 1 ))(+ d 4 )), );
.   %/mathpiper_trace



