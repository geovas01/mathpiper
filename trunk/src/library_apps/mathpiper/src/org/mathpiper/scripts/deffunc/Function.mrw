%mathpiper,def="true"

/* Defining a macro-like function that declares a function
 * with only one rule.
 */
RuleBase("Function",{oper,args,body});
HoldArg("Function",oper);
HoldArg("Function",args);
HoldArg("Function",body);


// function with variable number of arguments: Function("func",{x,y, ...})body;
Rule("Function",3,2047,
	And(GreaterThan(Length(args), 1), Equals( MathNth(args, Length(args)), Atom("...") ))
)
[
  DestructiveDelete(args,Length(args));	// remove trailing "..."
  Retract(oper,Length(args));
  MacroRuleBaseListed(oper,args);
  MacroRule(oper,Length(args),1025,True) body;	// at precedence 1025, for flexibility
];

// function with a fixed number of arguments
Rule("Function",3,2048,True)
[
  Retract(oper,Length(args));
  MacroRuleBase(oper,args);
  MacroRule(oper,Length(args),1025,True) body;
];


/// shorthand function declarations
RuleBase("Function",{oper});
// function with variable number of arguments: Function() f(x,y, ...)
Rule("Function",1,2047,
	And(IsFunction(oper), GreaterThan(Length(oper), 1), Equals( MathNth(oper, Length(oper)), Atom("...") ))
)
[
	Local(args);
	Set(args,Tail(Listify(oper)));
	DestructiveDelete(args,Length(args));	// remove trailing "..."
	If(RuleBaseDefined(Type(oper),Length(args)),
		False,	// do nothing
		MacroRuleBaseListed(Type(oper),args)
	);
];


// function with a fixed number of arguments
Rule("Function",1,2048,
	And(IsFunction(oper))
)
[
	Local(args);
	Set(args,Tail(Listify(oper)));
	If(RuleBaseDefined(Type(oper),Length(args)),
		False,	// do nothing
		MacroRuleBase(Type(oper),args)
	);
];


%/mathpiper