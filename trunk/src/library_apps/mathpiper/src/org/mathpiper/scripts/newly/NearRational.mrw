%mathpiper,def="NearRational"

//////////////////////////////////////////////////
/// NearRational, GuessRational
//////////////////////////////////////////////////

/// find rational number with smallest num./denom. near a given number x
/// See: HAKMEM, MIT AI Memo 239, 02/29/1972, Item 101C
NearRational(_x) <-- NearRational(x, Floor(1/2*BuiltinPrecisionGet()));
NearRational(x_IsRationalOrNumber, prec_IsInteger) <-- [
	Local(x1, x2, i,  old'prec);
	old'prec := BuiltinPrecisionGet();
  BuiltinPrecisionSet(prec + 8);	// 8 guard digits (?)
	x1 := ContFracList(N(Eval(x+10^(-prec))));
	x2 := ContFracList(N(Eval(x-10^(-prec))));

	If(InVerboseMode(), Echo("NearRational: x      = ", N(Eval(x           ))));
	If(InVerboseMode(), Echo("NearRational: xplus  = ", N(Eval(x+10^(-prec)))));
	If(InVerboseMode(), Echo("NearRational: xmin   = ", N(Eval(x-10^(-prec)))));

	If(InVerboseMode(), Echo("NearRational: Length(x1) = ", Length(x1)," ",x1));
	If(InVerboseMode(), Echo("NearRational: Length(x2) = ", Length(x2)," ",x1));
	// find where the continued fractions for "x1" and "x2" differ
	// prepare result in "x1" and length of result in "i"
	For (i:=1, i<=Length(x1) And i<=Length(x2) And x1[i]=x2[i], i++ ) True;
	If(
		i>Length(x1),
		// "x1" ended but matched, so use "x2" as "x1"
		x1:=x2,
		If(
			i>Length(x2),
		// "x2" ended but matched, so use "x1"
			True,
		// neither "x1" nor "x2" ended and there is a mismatch at "i"
		// apply recipe: select the smalest of the differing terms
			x1[i]:=Min(x1[i],x2[i])
		)
	);
	// recipe: x1dd 1 to the lx1st term unless it's the lx1st in the originx1l sequence
	//Ayal added this line, i could become bigger than Length(x1)!
	If(InVerboseMode(), Echo({"NearRational: using ", i, "terms of the continued fraction"}));
	If(i>Length(x1),i:=Length(x1));
	x1[i] := x1[i] + If(i=Length(x1), 0, 1);
	BuiltinPrecisionSet(old'prec);
	ContFracEval(Take(x1, i));
];

%/mathpiper