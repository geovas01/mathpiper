%mathpiper,def="true"

0 # Mod(_n,m_IsRationalOrNumber)_(m<0) <-- `Hold(Mod(@n,@m));

1 # Mod(n_IsNegativeInteger,m_IsPositiveInteger) <--
[
  Local(result);
  result := ModN(n,m);
  If (result < 0,result := result + m);
  result;
];
1 # Mod(n_IsPositiveInteger,m_IsPositiveInteger) <-- ModN(n,m);
2 # Mod(0,_m) <-- 0;
2 # Mod(n_IsPositiveInteger,Infinity) <-- n;
3 # Mod(n_IsInteger,m_IsInteger) <-- ModN(n,m);
4 # Mod(n_IsNumber,m_IsNumber) <-- NonN(Mod(Rationalize(n),Rationalize(m)));

5 # Mod(n_IsRationalOrNumber,m_IsRationalOrNumber)/*_(n>0 And m>0)*/ <--
[
  Local(n1,n2,m1,m2);
  n1:=Numer(n);
  n2:=Denom(n);
  m1:=Numer(m);
  m2:=Denom(m);
  Mod(n1*m2,m1*n2)/(n2*m2);
];

6 # Mod(n_IsList,m_IsList) <-- Map("Mod",{n,m});
7 # Mod(n_IsList,_m) <-- Map("Mod",{n,FillList(m,Length(n))});


30 # Mod(n_CanBeUni,m_CanBeUni) <--
[
  Local(vars);
  vars:=VarList(n+m);
  NormalForm(Mod(MakeUni(n,vars),MakeUni(m,vars)));
];

%/mathpiper