%mathpiper,def="Nth;NrArgs;IsNonObject;Numer;Denom;NormalForm;==;!==;+-;/-;*-;^-;:=-;:=+;&;|;%;if;else;N;NonN;InNumericMode;V;InVerboseMode"

/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */


/* Implementation of Nth that allows extending. */
RuleBase("Nth",{alist,aindex});
Rule("Nth",2,10,
    And(Equals(IsFunction(alist),True),
            Equals(IsInteger(aindex),True),
            Not(Equals(Head(Listify(alist)),Nth))
            ))
     MathNth(alist,aindex);




Rule("Nth",2,14,
     And(Equals(IsString(alist),True),IsList(aindex))
    )
[
  Local(result);
  result:="";
  ForEach(i,aindex) [ result := result : StringMidGet(i,1,alist); ];
  result;
];

Rule("Nth",2,15,Equals(IsString(alist),True))
[
  StringMidGet(aindex,1,alist);
];


Rule("Nth",2,20,Equals(IsList(aindex),True))
[
  Map({{ii},alist[ii]},{aindex});
];

Rule("Nth",2,30,
   And(
           Equals(IsGeneric(alist),True),
           Equals(GenericTypeName(alist),"Array"),
           Equals(IsInteger(aindex),True)
          )
    )
[
  ArrayGet(alist,aindex);
];



Rule("Nth",2,40,Equals(IsString(aindex),True))
[
  Local(as);
  as := Assoc(aindex,alist);
  If (Not(Equals(as,Empty)),Set(as,Nth(as,2)));
  as;
];

Function("NrArgs",{aLeft}) Length(Listify(aLeft))-1;

10 # IsNonObject(Object(_x)) <-- False;
20 # IsNonObject(_x)         <-- True;

1 # Numer(_x / _y)      <-- x;
2 # Numer(x_IsNumber)   <-- x;
1 # Denom(_x / _y)      <-- y;
2 # Denom(x_IsNumber)   <-- 1;

/* Implementation of numeric mode */
LocalSymbols(Numeric) [
  Set(Numeric,False);



  // evaluate numerically with given precision
  LocalSymbols(prev'Numeric, prev'digits, numeric'result) Macro("N",{expr,digits})
  [ // we were in non-numeric mode
      Local(prev'Numeric, prev'digits, numeric'result,errorString);
      Set(prev'digits, BuiltinPrecisionGet());
      BuiltinPrecisionSet(@digits);
      AssignCachedConstantsN();
      Set(prev'Numeric,Numeric);
      Set(Numeric, True);
      Set(errorString,"");
      TrapError(Set(numeric'result, Eval(@expr)),Set(errorString,GetCoreError()));
      Set(Numeric,prev'Numeric);
      If(Not Numeric,[
          // clear constants
          ClearCachedConstantsN();
      ]);
      BuiltinPrecisionSet(prev'digits);
      Check(errorString="",errorString);
      numeric'result;
  ];

  LocalSymbols(dig,ex) Macro("N",{expr})
  [
    Local(dig,ex);
    Set(dig,BuiltinPrecisionGet());
    Set(ex,Hold(@expr));
    `N(@ex,@dig);
  ];






  LocalSymbols(result) Macro("NonN",{expr})
  [
    Local(result);
    GlobalPush(Numeric);
    Numeric := False;
    result := (@expr);
    Numeric := GlobalPop();
    result;
  ];

  Function("InNumericMode",{}) Numeric;

]; //LocalSymbols(Numeric)

LocalSymbols(Verbose) [
  Set(Verbose,False);
  Function("V",{aNumberBody})
  [
    Local(prevVerbose,result);
    Set(prevVerbose,Verbose);
    Set(Verbose,True);
    Set(result,Eval(aNumberBody));
    Set(Verbose,prevVerbose);
    result;
  ];
  Function("InVerboseMode",{}) Verbose;

]; // LocalSymbols(Verbose)
HoldArg("V",aNumberBody);
UnFence("V",1);

Function("++",{aVar})
[
   MacroSet(aVar,AddN(Eval(aVar),1));
];
UnFence("++",1);
HoldArg("++",aVar);


Function("--",{aVar})
[
   MacroSet(aVar,SubtractN(Eval(aVar),1));
];
UnFence("--",1);
HoldArg("--",aVar);


Function("TableForm",{list})
[
  Local(i);
  ForEach(i,list)
  [
    Write(i);
    NewLine();
  ];
  True;
];

RuleBase("NormalForm",{expression});
Rule("NormalForm",1,1000,True) expression;




RuleBase("==",{left,right});
RuleBase("!==",{left,right});


a_IsNonNegativeInteger & b_IsNonNegativeInteger <-- BitAnd(a,b);
a_IsNonNegativeInteger | b_IsNonNegativeInteger <-- BitOr(a,b);
a_IsNonNegativeInteger % b_IsPositiveInteger <-- Mod(a,b);

RuleBase("if",{predicate,body});
(if(True) _body) <-- Eval(body);
HoldArg("if",body);
UnFence("if",2);

RuleBase("else",{ifthen,otherwise});
0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) = True) <--
     Eval(body);
0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) = False) <--
     Eval(otherwise);
1 # (if (_predicate) _body else _otherwise) <--
    UnList({Atom("else"),
            UnList({Atom("if"), (Eval(predicate)), body}),
            otherwise});
HoldArg("else",ifthen);
HoldArg("else",otherwise);
UnFence("else",2);

%/mathpiper



%mathpiper_docs,name="N"
*CMD N --- try determine numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {Yacas} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make Yacas
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only 
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Pi
%/mathpiper_docs



%mathpiper_docs,name="Numer"
*CMD Numer --- numerator of an expression
*STD
*CALL
	Numer(expr)

*PARMS

{expr} -- expression to determine numerator of

*DESC

This function determines the numerator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns this number. If "expr" is neither
rational nor numeric, the function returns unevaluated.

*E.G.

	In> Numer(2/7)
	Out> 2;
	In> Numer(a / x^2)
	Out> a;
	In> Numer(5)
	Out> 5;

*SEE Denom, IsRational, IsNumber
%/mathpiper_docs



%mathpiper_docs,name="Denom"
*CMD Denom --- denominator of an expression
*STD
*CALL
	Denom(expr)

*PARMS

{expr} -- expression to determine denominator of

*DESC

This function determines the denominator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns {1}. If "expr" is
neither rational nor numeric, the function returns unevaluated.

*E.G.

	In> Denom(2/7)
	Out> 7;
	In> Denom(a / x^2)
	Out> x^2;
	In> Denom(5)
	Out> 1;

*SEE Numer, IsRational, IsNumber
%/mathpiper_docs



%mathpiper_docs,name="V;InVerboseMode"
*CMD V, InVerboseMode --- set verbose output mode
*STD
*CALL
	V(expression)
	InVerboseMode()

*PARMS

{expression} -- expression to be evaluated in verbose mode

*DESC

The function {V(expression)} will evaluate the expression in 
verbose mode. Various parts of Yacas can show extra information
about the work done while doing a calculation when using {V}.

In verbose mode, {InVerboseMode()} will return {True}, otherwise
it will return {False}.

*E.G. notest

	In> OldSolve({x+2==0},{x})
	Out> {{-2}};
	In> V(OldSolve({x+2==0},{x}))
	Entering OldSolve
	From  x+2==0  it follows that  x  = -2 
	   x+2==0  simplifies to  True 
	Leaving OldSolve
	Out> {{-2}};
	In> InVerboseMode()
	Out> False
	In> V(InVerboseMode())
	Out> True

*SEE Echo, N, OldSolve
%/mathpiper_docs




