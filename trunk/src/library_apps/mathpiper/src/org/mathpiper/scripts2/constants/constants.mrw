%mathpiper,def="I;CachedConstant;AssignCachedConstants;ClearCachedConstants"

/* def file definitions.
I
CachedConstant
AssignCachedConstants
ClearCachedConstants
*/

/* Definition of constants. */

/* TODO:
 * There is a problem with defining I this way: if I is used, but the
 * file "complex" has not been loaded, the interpreter can not deal
 * with "Complex".
 */

SetGlobalLazyVariable(I,Complex(0,1));

//////////////////////////////////////////////////
/// Cached constants support and definition of Pi
//////////////////////////////////////////////////

//TODO: here we wrap the entire file in LocalSymbols, this is inefficient in that it slows loading of this file. Needs optimization.
LocalSymbols(CacheOfConstantsN) [

/// declare a new cached constant C'atom and its associated function C'atom().
/// C'atom() will call C'func() at current precision to evaluate C'atom if it has not yet been cached at that precision. (note: any arguments to C'func() must be included)
RuleBase("CachedConstant", {C'cache, C'atom, C'func});
UnFence("CachedConstant", 3);	// not sure if this is useful
HoldArg("CachedConstant", C'func);
HoldArg("CachedConstant", C'cache);	// name of the cache
// check syntax: must be called on an atom and a function
Rule("CachedConstant", 3, 10, And(IsAtom(C'atom), IsFunction(C'func)))
[
 	Local(C'name,C'functionName);
	Set(C'name, String(C'atom));	// this is for later conveniences
  Set(C'functionName,ConcatStrings("Internal'",C'name));

	If(	// create the cache it if it does not already exist
		IsAtom(Eval(C'cache)),
		MacroSet(Eval(C'cache), {})
	);
//	Write({"debug step 0: ", C'cache, Eval(C'cache), C'atom, C'func, C'name});
	// check that the constant is not already defined
	If(
	  Equals(Builtin'Assoc(C'name, Eval(C'cache)), Empty),	// the constant is not already defined, so need to define "C'atom" and the corresponding function "C'atom"()
	  [	// e.g. C'atom evaluates to Pi, C'cache to a name e.g. CacheOfConstantsN, which is bound to a hash
		MacroClear(C'atom);
//		Write({"debug step 1: ", Cache'name, C'cache, Eval(C'cache)});
		// add the new constant to the cache
//		MacroSet(Cache'name, Insert(Eval(C'cache), 1, {C'name, 0, 0}));
		DestructiveInsert(Eval(C'cache), 1, {C'name, 0, 0});
//		Write({"debug step 2: ", Cache'name, C'cache, Eval(C'cache)});
		// define the new function "C'atom"()
		// note: this should not use N() because it may be called from inside N() itself

		MacroRuleBase(C'functionName, {});
		`( Rule(@C'functionName, 0, 1024, True)
		[
			Local(new'prec, new'C, cached'C);
			Set(new'prec, BuiltinPrecisionGet());
			// fetch the cache entry for this constant
			// note that this procedure will store the name of the cache here in this statement as Eval(C'cache)
			Set(cached'C, Builtin'Assoc(@C'name, @C'cache));
			If(
			  LessThan(MathNth(cached'C, 2), new'prec),
			  [	// need to recalculate at current precision
				If(Equals(InVerboseMode(),True), Echo("CachedConstant: Info: constant ", @C'name, " is being recalculated at precision ", new'prec));
				Set(new'C, Eval(@C'func));
				DestructiveReplace(cached'C, 2, new'prec);
				DestructiveReplace(cached'C, 3, new'C);
				new'C;
			  ],
			  // return cached value of C'atom
			  MathNth(cached'C, 3)
			);
		]);

		// calculate C'atom at current precision for the first time
//		Eval(UnList({C'atom}));	// "C'name"();
		// we do not need this until the constant is used; it will just slow us down
	  ],
	  // the constant is defined
	  Echo("CachedConstant: Warning: constant ", C'atom, " already defined")
	);
];

Rule("CachedConstant", 3, 20, True)
	Echo("CachedConstant: Error: ", C'atom, " must be an atom and ", C'func, " must be a function.");

/// assign numerical values to all cached constants: using fixed cache "CacheOfConstantsN"
// this is called from N()
Function("AssignCachedConstantsN", {})
[
	Local(var,fname);
	ForEach(var, AssocIndices(CacheOfConstantsN))
	[
		MacroClear(Atom(var));
    Set(fname,ConcatStrings("Internal'",var));
    Set(var,Atom(var));
		// this way the routine Internal'Pi() will be actually called only when the variable 'Pi' is used, etcetera.
    `SetGlobalLazyVariable((@var), UnList({Atom(fname)}));
	];
];
UnFence("AssignCachedConstantsN", 0);

/// clear values from all cached constants: using fixed cache "CacheOfConstantsN"
// this is called from N()
Function("ClearCachedConstantsN", {})
[
	Local(c'entry);
	ForEach(c'entry, CacheOfConstantsN)
		MacroClear(Atom(c'entry[1]));
];
UnFence("ClearCachedConstantsN", 0);

/// declare some constants now
CachedConstant(CacheOfConstantsN, Pi,
[// it seems necessary to precompute Pi to a few more digits
// so that Cos(0.5*Pi)=0 at precision 10
// FIXME: find a better solution
	Local(result,old'prec);
  Set(old'prec,BuiltinPrecisionGet());
If(Equals(InVerboseMode(),True), Echo("Recalculating Pi at precision ",old'prec+5));
	BuiltinPrecisionSet(BuiltinPrecisionGet()+5);
	result := MathPi();
If(Equals(InVerboseMode(),True),Echo("Switching back to precision ",old'prec));
	BuiltinPrecisionSet(old'prec);
	result;
]
);
CachedConstant(CacheOfConstantsN, gamma, GammaConstNum());
CachedConstant(CacheOfConstantsN, GoldenRatio, N( (1+Sqrt(5))/2 ) );
CachedConstant(CacheOfConstantsN, Catalan, CatalanConstNum() );

]; // LocalSymbols(CacheOfConstantsN)

%/mathpiper



%mathpiper_docs,name="I"
*CMD I --- imaginary unit
*STD
*CALL
	I

*DESC

This symbol represents the imaginary unit, which equals the square
root of -1. It evaluates to {Complex(0,1)}.

*E.G.

	In> I
	Out> Complex(0,1);
	In> I = Sqrt(-1)
	Out> True;

*SEE Complex
%/mathpiper_docs



%mathpiper_docs,name="Subfactorial"
*CMD !  --- factorial
*CMD !!  --- factorial and related functions
*CMD ***  --- factorial and related functions
*CMD Subfactorial  --- factorial and related functions
*STD
*CALL
	n!
	n!!
	a *** b
	Subfactorial(m)

*PARMS

{m} -- integer
{n} -- integer, half-integer, or list
{a}, {b} -- numbers

*DESC

The factorial function {n!} calculates the factorial of integer or half-integer numbers. For
nonnegative integers, $n! := n*(n-1)*(n-2)*...*1$. The factorial of
half-integers is defined via Euler's Gamma function, $z! := Gamma(z+1)$. If $n=0$ the function returns $1$.

The "double factorial" function {n!!} calculates $n*(n-2)*(n-4)*...$. This product terminates either with $1$ or with $2$ depending on whether $n$ is odd or even. If $n=0$ the function returns $1$.

The "partial factorial" function {a *** b} calculates the product $a*(a+1)*...$ which is terminated at the least integer not greater than $b$. The arguments $a$ and $b$ do not have to be integers; for integer arguments, {a *** b} = $b! / (a-1)!$. This function is sometimes a lot faster than evaluating the two factorials, especially if $a$ and $b$ are close together. If $a>b$ the function returns $1$.

The {Subfactorial} function can be interpreted as the  number of permutations of {m} objects in which no object 
appears in its natural place, also called "derangements." 

The factorial functions are threaded, meaning that if the argument {n} is a
list, the function will be applied to each element of the list.

Note: For reasons of Yacas syntax, the factorial sign {!} cannot precede other
non-letter symbols such as {+} or {*}. Therefore, you should enter a space
after {!} in expressions such as {x! +1}.

The factorial functions terminate and print an error message if the arguments are too large (currently the limit is $n < 65535$) because exact factorials of such large numbers are computationally expensive and most probably not useful. One can call {Internal'LnGammaNum()} to evaluate logarithms of such factorials to desired precision.

*E.G.

	In> 5!
	Out> 120;
	In> 1 * 2 * 3 * 4 * 5
	Out> 120;
	In> (1/2)!
	Out> Sqrt(Pi)/2;
	In> 7!!;
	Out> 105;
	In> 1/3 *** 10;
	Out> 17041024000/59049;
	In> Subfactorial(10)
	Out> 1334961;


*SEE Bin, Factorize, Gamma, !!, ***, Subfactorial
%/mathpiper_docs
