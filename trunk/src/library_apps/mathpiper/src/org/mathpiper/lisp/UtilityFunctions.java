/* {{{ License.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */ //}}}

// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=0:
package org.mathpiper.lisp;

import org.mathpiper.lisp.collections.OperatorMap;
import org.mathpiper.lisp.DefFile;
import org.mathpiper.lisp.cons.ConsTraverser;
import org.mathpiper.lisp.cons.SubListCons;
import org.mathpiper.lisp.cons.AtomCons;
import org.mathpiper.lisp.cons.ConsPointer;
import org.mathpiper.lisp.cons.Cons;
import java.io.InputStreamReader;
import java.util.Iterator;
import org.mathpiper.io.MathPiperInputStream;
import org.mathpiper.exceptions.EvaluationException;
import org.mathpiper.io.InputStatus;
import org.mathpiper.builtin.BigNumber;
import org.mathpiper.builtin.BuiltinFunction;
import org.mathpiper.io.InputDirectories;
import org.mathpiper.lisp.behaviours.Substitute;
import org.mathpiper.lisp.tokenizers.MathPiperTokenizer;
import org.mathpiper.lisp.userfunctions.MultipleArityUserFunction;
import org.mathpiper.lisp.printers.MathPiperPrinter;
import org.mathpiper.lisp.parsers.MathPiperParser;
import org.mathpiper.io.JarFileInputStream;
import org.mathpiper.io.StandardFileInputStream;
import org.mathpiper.io.StringOutputStream;
import org.mathpiper.lisp.parametermatchers.Pattern;
import org.mathpiper.lisp.parametermatchers.PatternParameter;
import org.mathpiper.lisp.userfunctions.Branch;
import org.mathpiper.lisp.userfunctions.FunctionParameter;
import org.mathpiper.lisp.userfunctions.PatternBranch;
import org.mathpiper.lisp.userfunctions.SingleArityBranchingUserFunction;

public class UtilityFunctions {

    static int log2_table_size = 32;    // A lookup table of Ln(n)/Ln(2) for n = 1 .. 32.
    // With this we don't have to use math.h if all we need is to convert the number of digits from one base to another. This is also faster.
    // Generated by: PrintList(N(Ln(1 .. 32)/Ln(2)), ",") at getPrecision 40.
    static double log2_table[] = {
        0.,
        1.,
        1.5849625007211561814537389439478165087598,
        2.,
        2.3219280948873623478703194294893901758648,
        2.5849625007211561814537389439478165087598,
        2.807354922057604107441969317231830808641,
        3.,
        3.1699250014423123629074778878956330175196,
        3.3219280948873623478703194294893901758648,
        3.4594316186372972561993630467257929587032,
        3.5849625007211561814537389439478165087598,
        3.7004397181410921603968126542566947336284,
        3.807354922057604107441969317231830808641,
        3.9068905956085185293240583734372066846246,
        4.,
        4.0874628412503394082540660108104043540112,
        4.1699250014423123629074778878956330175196,
        4.2479275134435854937935194229068344226935,
        4.3219280948873623478703194294893901758648,
        4.3923174227787602888957082611796473174008,
        4.4594316186372972561993630467257929587032,
        4.5235619560570128722941482441626688444988,
        4.5849625007211561814537389439478165087598,
        4.6438561897747246957406388589787803517296,
        4.7004397181410921603968126542566947336284,
        4.7548875021634685443612168318434495262794,
        4.807354922057604107441969317231830808641,
        4.8579809951275721207197733246279847624768,
        4.9068905956085185293240583734372066846246,
        4.9541963103868752088061235991755544235489,
        5.
    };
    public static java.util.zip.ZipFile zipFile = null;

    public static boolean isNumber(String ptr, boolean aAllowFloat) {
        int pos = 0;
        if (ptr.charAt(pos) == '-' || ptr.charAt(pos) == '+') {
            pos++;
        }
        int nrDigits = 0;
        int index = 0;
        if (pos + index == ptr.length()) {
            return false;
        }
        while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
            nrDigits++;
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
        }
        if (ptr.charAt(pos + index) == '.') {
            if (!aAllowFloat) {
                return false;
            }
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
            while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
                nrDigits++;
                index++;
                if (pos + index == ptr.length()) {
                    return true;
                }
            }
        }
        if (nrDigits == 0) {
            return false;
        }
        if (ptr.charAt(pos + index) == 'e' || ptr.charAt(pos + index) == 'E') {
            if (!aAllowFloat) {
                return false;
            }
            if (!BigNumber.numericSupportForMantissa()) {
                return false;
            }
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
            if (ptr.charAt(pos + index) == '-' || ptr.charAt(pos + index) == '+') {
                index++;
            }
            while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
                index++;
                if (pos + index == ptr.length()) {
                    return true;
                }
            }
        }
        if (ptr.length() != (pos + index)) {
            return false;
        }
        return true;
    }

    public static int listLength(ConsPointer aOriginal) throws Exception {
        ConsTraverser consTraverser = new ConsTraverser(aOriginal);
        int length = 0;
        while (consTraverser.getCons() != null) {
            consTraverser.goNext();
            length++;
        }
        return length;
    }

    public static void internalReverseList(ConsPointer aResult, ConsPointer aOriginal) {
        //ConsPointer iter = new ConsPointer(aOriginal);
        ConsPointer iter = new ConsPointer();
        iter.setCons(aOriginal.getCons());
        ConsPointer previous = new ConsPointer();
        ConsPointer tail = new ConsPointer();
        tail.setCons(aOriginal.getCons());

        while (iter.getCons() != null) {
            tail.setCons(iter.getCons().getRestPointer().getCons());
            iter.getCons().getRestPointer().setCons(previous.getCons());
            previous.setCons(iter.getCons());
            iter.setCons(tail.getCons());
        }
        aResult.setCons(previous.getCons());
    }

    public static void returnUnEvaluated(ConsPointer aResult, ConsPointer aArguments, Environment aEnvironment) throws Exception {
        ConsPointer full = new ConsPointer();
        full.setCons(aArguments.getCons().copy(false));
        aResult.setCons(SubListCons.getInstance(full.getCons()));

        ConsTraverser consTraverser = new ConsTraverser(aArguments);
        consTraverser.goNext();

        while (consTraverser.getCons() != null) {
            ConsPointer next = new ConsPointer();
            aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, next, consTraverser.getPointer());
            full.getCons().getRestPointer().setCons(next.getCons());
            full.setCons(next.getCons());
            consTraverser.goNext();
        }
        full.getCons().getRestPointer().setCons(null);
    }

    public static void internalApplyString(Environment aEnvironment, ConsPointer aResult,
            String aOperator, ConsPointer aArgs) throws Exception {
        LispError.check(internalIsString(aOperator), LispError.KLispErrNotString);

        Cons head =
                AtomCons.getInstance(aEnvironment, getSymbolName(aEnvironment, aOperator));
        head.getRestPointer().setCons(aArgs.getCons());
        ConsPointer body = new ConsPointer();
        body.setCons(SubListCons.getInstance(head));
        aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aResult, body);
    }

    public static void internalApplyPure(ConsPointer oper, ConsPointer args2, ConsPointer aResult, Environment aEnvironment) throws Exception {
        LispError.check(oper.getCons().getSublistPointer() != null, LispError.KLispErrInvalidArg);
        LispError.check(oper.getCons().getSublistPointer().getCons() != null, LispError.KLispErrInvalidArg);
        ConsPointer oper2 = new ConsPointer();
        oper2.setCons(oper.getCons().getSublistPointer().getCons().getRestPointer().getCons());
        LispError.check(oper2.getCons() != null, LispError.KLispErrInvalidArg);

        ConsPointer body = new ConsPointer();
        body.setCons(oper2.getCons().getRestPointer().getCons());
        LispError.check(body.getCons() != null, LispError.KLispErrInvalidArg);

        LispError.check(oper2.getCons().getSublistPointer() != null, LispError.KLispErrInvalidArg);
        LispError.check(oper2.getCons().getSublistPointer().getCons() != null, LispError.KLispErrInvalidArg);
        oper2.setCons(oper2.getCons().getSublistPointer().getCons().getRestPointer().getCons());

        aEnvironment.pushLocalFrame(false);
        try {
            while (oper2.getCons() != null) {
                LispError.check(args2.getCons() != null, LispError.KLispErrInvalidArg);

                String var = oper2.getCons().string();
                LispError.check(var != null, LispError.KLispErrInvalidArg);
                ConsPointer newly = new ConsPointer();
                newly.setCons(args2.getCons().copy(false));
                aEnvironment.newLocalVariable(var, newly.getCons());
                oper2.setCons(oper2.getCons().getRestPointer().getCons());
                args2.setCons(args2.getCons().getRestPointer().getCons());
            }
            LispError.check(args2.getCons() == null, LispError.KLispErrInvalidArg);
            aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aResult, body);
        } catch (EvaluationException e) {
            throw e;
        } finally {
            aEnvironment.popLocalFrame();
        }

    }

    public static void internalTrue(Environment aEnvironment, ConsPointer aResult) throws Exception {
        aResult.setCons(aEnvironment.iTrueAtom.copy(false));
    }

    public static void internalFalse(Environment aEnvironment, ConsPointer aResult) throws Exception {
        aResult.setCons(aEnvironment.iFalseAtom.copy(false));
    }

    public static void internalBoolean(Environment aEnvironment, ConsPointer aResult, boolean aValue) throws Exception {
        if (aValue) {
            internalTrue(aEnvironment, aResult);
        } else {
            internalFalse(aEnvironment, aResult);
        }
    }

    public static void internalNth(ConsPointer aResult, ConsPointer aArg, int n) throws Exception {
        LispError.check(aArg.getCons() != null, LispError.KLispErrInvalidArg);
        LispError.check(aArg.getCons().getSublistPointer() != null, LispError.KLispErrInvalidArg);
        LispError.check(n >= 0, LispError.KLispErrInvalidArg);
        ConsTraverser consTraverser = new ConsTraverser(aArg.getCons().getSublistPointer());

        while (n > 0) {
            LispError.check(consTraverser.getCons() != null, LispError.KLispErrInvalidArg);
            consTraverser.goNext();
            n--;
        }
        LispError.check(consTraverser.getCons() != null, LispError.KLispErrInvalidArg);
        aResult.setCons(consTraverser.getCons().copy(false));
    }

    public static void internalTail(ConsPointer aResult, ConsPointer aArg) throws Exception {
        LispError.check(aArg.getCons() != null, LispError.KLispErrInvalidArg);
        LispError.check(aArg.getCons().getSublistPointer() != null, LispError.KLispErrInvalidArg);

        ConsPointer iter = aArg.getCons().getSublistPointer();

        LispError.check(iter.getCons() != null, LispError.KLispErrInvalidArg);
        aResult.setCons(SubListCons.getInstance(iter.getCons().getRestPointer().getCons()));
    }

    public static boolean isTrue(Environment aEnvironment, ConsPointer aExpression) throws Exception {
        LispError.lispAssert(aExpression.getCons() != null);

        //return aExpression.getCons().string() == aEnvironment.iTrueAtom.string();
        String expressionString = aExpression.getCons().string();

//return expressionString == aEnvironment.iTrueString;

        if (expressionString == aEnvironment.iTrueString) {
            return true;
        } else if (internalIsList(aExpression)) {
            if (listLength(aExpression.getCons().getSublistPointer()) == 1) {
                //Empty list.
                return false;
            } else {
                //Non-empty list.
                return true;
            }
        } else {
            //Anything other than False returns true.
            return expressionString != null && expressionString != aEnvironment.iFalseString;
        }

    }//end method.

    public static boolean isFalse(Environment aEnvironment, ConsPointer aExpression) throws Exception {
        LispError.lispAssert(aExpression.getCons() != null);
        //return aExpression.getCons().string() == aEnvironment.iFalseString;

        return aExpression.getCons().string() == aEnvironment.iFalseString || (internalIsList(aExpression) && (listLength(aExpression.getCons().getSublistPointer()) == 1));
    }

    public static String getSymbolName(Environment aEnvironment, String aSymbol) {
        if (aSymbol.charAt(0) == '\"') {
            return aEnvironment.getTokenHash().lookUpUnStringify(aSymbol);
        } else {
            return (String) aEnvironment.getTokenHash().lookUp(aSymbol);
        }
    }

    public static boolean internalIsList(ConsPointer aPtr) throws Exception {
        if (aPtr.getCons() == null) {
            return false;
        }
        if (aPtr.getCons().getSublistPointer() == null) {
            return false;
        }
        if (aPtr.getCons().getSublistPointer().getCons() == null) {
            return false;
        //TODO this StrEqual is far from perfect. We could pass in a Environment object...
        }
        if (!aPtr.getCons().getSublistPointer().getCons().string().equals("List")) {
            return false;
        }
        return true;
    }

    public static boolean internalIsString(String aOriginal) {
        if (aOriginal != null) {
            if (aOriginal.charAt(0) == '\"') {
                if (aOriginal.charAt(aOriginal.length() - 1) == '\"') {
                    return true;
                }
            }
        }
        return false;
    }

    public static void internalNot(ConsPointer aResult, Environment aEnvironment, ConsPointer aExpression) throws Exception {
        if (isTrue(aEnvironment, aExpression)) {
            internalFalse(aEnvironment, aResult);
        } else {
            LispError.check(isFalse(aEnvironment, aExpression), LispError.KLispErrInvalidArg);
            internalTrue(aEnvironment, aResult);
        }
    }

    public static void internalFlatCopy(ConsPointer aResult, ConsPointer aOriginal) throws Exception {
        ConsTraverser orig = new ConsTraverser(aOriginal);
        ConsTraverser res = new ConsTraverser(aResult);

        while (orig.getCons() != null) {
            res.getPointer().setCons(orig.getCons().copy(false));
            orig.goNext();
            res.goNext();
        }
    }

    public static boolean internalEquals(Environment aEnvironment, ConsPointer aExpression1, ConsPointer aExpression2) throws Exception {
        // Handle pointers to same, or null
        if (aExpression1.getCons() == aExpression2.getCons()) {
            return true;
        }

        BigNumber n1 = aExpression1.getCons().getNumber(aEnvironment.getPrecision());
        BigNumber n2 = aExpression2.getCons().getNumber(aEnvironment.getPrecision());
        if (!(n1 == null && n2 == null)) {
            if (n1 == n2) {
                return true;
            }
            if (n1 == null) {
                return false;
            }
            if (n2 == null) {
                return false;
            }
            if (n1.equals(n2)) {
                return true;
            }
            return false;
        }

        //Pointers to strings should be the same
        if (aExpression1.getCons().string() != aExpression2.getCons().string()) {
            return false;
        }

        // Handle same sublists, or null
        if (aExpression1.getCons().getSublistPointer() == aExpression2.getCons().getSublistPointer()) {
            return true;
        }

        // Now check the sublists
        if (aExpression1.getCons().getSublistPointer() != null) {
            if (aExpression2.getCons().getSublistPointer() == null) {
                return false;
            }
            ConsTraverser consTraverser1 = new ConsTraverser(aExpression1.getCons().getSublistPointer());
            ConsTraverser consTraverser2 = new ConsTraverser(aExpression2.getCons().getSublistPointer());

            while (consTraverser1.getCons() != null && consTraverser2.getCons() != null) {
                // compare two list elements
                if (!internalEquals(aEnvironment, consTraverser1.getPointer(), consTraverser2.getPointer())) {
                    return false;
                }

                // Step to rest
                consTraverser1.goNext();
                consTraverser2.goNext();
            }
            // Lists don't have the same length
            if (consTraverser1.getCons() != consTraverser2.getCons()) {
                return false;            // Same!
            }
            return true;
        }

        // expressions sublists are not the same!
        return false;
    }

    public static void substitute(ConsPointer aTarget, ConsPointer aSource, Substitute aBehaviour) throws Exception {
        Cons object = aSource.getCons();
        LispError.lispAssert(object != null);
        if (!aBehaviour.matches(aTarget, aSource)) {
            ConsPointer oldList = object.getSublistPointer();
            if (oldList != null) {
                ConsPointer newList = new ConsPointer();
                ConsPointer next = newList;
                while (oldList.getCons() != null) {
                    substitute(next, oldList, aBehaviour);
                    oldList = oldList.getCons().getRestPointer();
                    next = next.getCons().getRestPointer();
                }
                aTarget.setCons(SubListCons.getInstance(newList.getCons()));
            } else {
                aTarget.setCons(object.copy(false));
            }
        }
    }

    public static String internalUnstringify(String aOriginal) throws Exception {
        LispError.check(aOriginal != null, LispError.KLispErrInvalidArg);
        LispError.check(aOriginal.charAt(0) == '\"', LispError.KLispErrInvalidArg);
        int nrc = aOriginal.length() - 1;
        LispError.check(aOriginal.charAt(nrc) == '\"', LispError.KLispErrInvalidArg);
        return aOriginal.substring(1, nrc);
    }

    private static void doInternalLoad(Environment aEnvironment, MathPiperInputStream aInput) throws Exception {
        MathPiperInputStream previous = aEnvironment.iCurrentInput;
        try {
            aEnvironment.iCurrentInput = aInput;
            // TODO make "EndOfFile" a global thing
            // read-parse-evaluate to the end of file
            String eof = (String) aEnvironment.getTokenHash().lookUp("EndOfFile");
            boolean endoffile = false;
            MathPiperParser parser = new MathPiperParser(new MathPiperTokenizer(),
                    aEnvironment.iCurrentInput, aEnvironment,
                    aEnvironment.iPrefixOperators, aEnvironment.iInfixOperators,
                    aEnvironment.iPostfixOperators, aEnvironment.iBodiedOperators);
            ConsPointer readIn = new ConsPointer();
            while (!endoffile) {
                // Read expression
                parser.parse(readIn);

                LispError.check(readIn.getCons() != null, LispError.KLispErrReadingFile);
                // check for end of file
                if (readIn.getCons().string() == eof) {
                    endoffile = true;
                } // Else evaluate
                else {
                    ConsPointer result = new ConsPointer();
                    aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, result, readIn);
                    aEnvironment.setGlobalVariable("LoadResult", result, false);//Note:tk:added to make getResult of executing Loaded code available.
                }
            }
        } catch (Exception e) {
            throw e;
        } finally {
            aEnvironment.iCurrentInput = previous;
        }
    }

    /**
     * Searches for a file on the classpath then in the default directories.  If the file is found, it is loaded.
     * @param aEnvironment
     * @param aFileName
     * @throws java.lang.Exception
     */
    public static void internalLoad(Environment aEnvironment, String aFileName) throws Exception {
        String oper = internalUnstringify(aFileName);

        String hashedname = (String) aEnvironment.getTokenHash().lookUp(oper);

        InputStatus oldstatus = new InputStatus(aEnvironment.iInputStatus);
        aEnvironment.iInputStatus.setTo(hashedname);

        MathPiperInputStream newInput = null;

        /*java.io.MathPiperInputStream scriptStream = Scripts.getScriptStream(oper);
        if (scriptStream != null) {
        newInput = new StandardFileInputStream(scriptStream, aEnvironment.iInputStatus);
        LispError.check(newInput != null, LispError.KLispErrFileNotFound);
        doInternalLoad(aEnvironment, newInput);
        } else {*/
//System.out.println("Loading: " + oper);
        java.net.URL fileURL = java.lang.ClassLoader.getSystemResource(oper);
        if (fileURL != null) //File is on the classpath.
        {
            newInput = new StandardFileInputStream(new InputStreamReader(fileURL.openStream()), aEnvironment.iInputStatus);
            LispError.check(newInput != null, LispError.KLispErrFileNotFound);
            doInternalLoad(aEnvironment, newInput);
        } else { //File may be in the filesystem.
            try {
                // Open file
                newInput = // new StandardFileInputStream(hashedname, aEnvironment.iInputStatus);
                        openInputFile(aEnvironment, aEnvironment.iInputDirectories, hashedname, aEnvironment.iInputStatus);

                LispError.check(newInput != null, LispError.KLispErrFileNotFound);
                doInternalLoad(aEnvironment, newInput);
            } catch (Exception e) {
                throw e;
            } finally {
                aEnvironment.iInputStatus.restoreFrom(oldstatus);
            }
        }//end else.*/


        aEnvironment.iInputStatus.restoreFrom(oldstatus);


    }

    public static void internalUse(Environment aEnvironment, String aFileName) throws Exception {
        DefFile def = aEnvironment.iDefFiles.getFile(aFileName);
        if (!def.isLoaded()) {
            def.setLoaded();
            internalLoad(aEnvironment, aFileName);
        }
    }

    public static String printExpression(ConsPointer aExpression,
            Environment aEnvironment,
            int aMaxChars) throws Exception {
        StringBuffer result = new StringBuffer();
        StringOutputStream newOutput = new StringOutputStream(result);
        MathPiperPrinter infixprinter = new MathPiperPrinter(aEnvironment.iPrefixOperators,
                aEnvironment.iInfixOperators,
                aEnvironment.iPostfixOperators,
                aEnvironment.iBodiedOperators);
        infixprinter.print(aExpression, newOutput, aEnvironment);
        if (aMaxChars > 0 && result.length() > aMaxChars) {
            result.delete(aMaxChars, result.length());
            result.append((char) '.');
            result.append((char) '.');
            result.append((char) '.');
        }
        return result.toString();
    }

    public static MathPiperInputStream openInputFile(String aFileName, InputStatus aInputStatus) throws Exception {//Note:tk:primary method for file opening.
        try {
            if (zipFile != null) {
                java.util.zip.ZipEntry e = zipFile.getEntry(aFileName);
                if (e != null) {
                    java.io.InputStream s = zipFile.getInputStream(e);
                    return new StandardFileInputStream(new InputStreamReader(s), aInputStatus);
                }
            }

            if (aFileName.substring(0, 4).equals("jar:")) {
                return new JarFileInputStream(aFileName, aInputStatus);
            } else {
                return new StandardFileInputStream(aFileName, aInputStatus);
            }
        } catch (Exception e) {
        }
        return null;

    //return new StandardFileInputStream(aFileName, aInputStatus);
    }

    public static MathPiperInputStream openInputFile(Environment aEnvironment,
            InputDirectories aInputDirectories, String aFileName,
            InputStatus aInputStatus) throws Exception {
        String othername = aFileName;
        int i = 0;
        MathPiperInputStream f = openInputFile(othername, aInputStatus);
        while (f == null && i < aInputDirectories.size()) {
            othername = ((String) aInputDirectories.get(i)) + aFileName;
            f = openInputFile(othername, aInputStatus);
            i++;
        }
        return f;
    }

    public static String internalFindFile(String aFileName, InputDirectories aInputDirectories) throws Exception {
        InputStatus inputStatus = new InputStatus();
        String othername = aFileName;
        int i = 0;
        MathPiperInputStream f = openInputFile(othername, inputStatus);
        if (f != null) {
            return othername;
        }
        while (i < aInputDirectories.size()) {
            othername = ((String) aInputDirectories.get(i)) + aFileName;
            f = openInputFile(othername, inputStatus);
            if (f != null) {
                return othername;
            }
            i++;
        }
        return "";
    }

    private static void doLoadDefFile(Environment aEnvironment, MathPiperInputStream aInput, DefFile def) throws Exception {
        MathPiperInputStream previous = aEnvironment.iCurrentInput;
        try {
            aEnvironment.iCurrentInput = aInput;
            String eof = (String) aEnvironment.getTokenHash().lookUp("EndOfFile");
            String end = (String) aEnvironment.getTokenHash().lookUp("}");
            boolean endoffile = false;

            MathPiperTokenizer tok = new MathPiperTokenizer();

            while (!endoffile) {
                // Read expression
                String token = tok.nextToken(aEnvironment.iCurrentInput, aEnvironment.getTokenHash());

                // check for end of file
                if (token == eof || token == end) {
                    endoffile = true;
                } // Else evaluate
                else {
                    String str = token;
                    MultipleArityUserFunction multiUser = aEnvironment.getMultipleArityUserFunction(str);
                    if (multiUser.iFileToOpen != null) {
                        throw new EvaluationException("[" + str + "]" + "] : def file already chosen: " + multiUser.iFileToOpen.iFileName, -1);
                    }
                    multiUser.iFileToOpen = def;
                    multiUser.iFileLocation = def.fileName();
                }
            }
        } catch (Exception e) {
            throw e;
        } finally {
            aEnvironment.iCurrentInput = previous;
        }
    }

    public static void loadDefFile(Environment aEnvironment, String aFileName) throws Exception {
        LispError.lispAssert(aFileName != null);

        String flatfile = internalUnstringify(aFileName) + ".def";
        DefFile def = aEnvironment.iDefFiles.getFile(aFileName);

        String hashedname = (String) aEnvironment.getTokenHash().lookUp(flatfile);

        InputStatus oldstatus = aEnvironment.iInputStatus;
        aEnvironment.iInputStatus.setTo(hashedname);



        MathPiperInputStream newInput = null;


        /* java.io.MathPiperInputStream scriptStream = Scripts.getScriptStream(flatfile);
        if (scriptStream != null) {
        newInput = new StandardFileInputStream(scriptStream, aEnvironment.iInputStatus);
        LispError.check(newInput != null, LispError.KLispErrFileNotFound);
        doLoadDefFile(aEnvironment, newInput, def);
        } else {*/
//System.out.println("Loading: " + flatfile);
        java.net.URL fileURL = java.lang.ClassLoader.getSystemResource(flatfile);
        if (fileURL != null) //File is on the classpath.
        {
            newInput = new StandardFileInputStream(new InputStreamReader(fileURL.openStream()), aEnvironment.iInputStatus);
            LispError.check(newInput != null, LispError.KLispErrFileNotFound);
            doLoadDefFile(aEnvironment, newInput, def);

        } else //File may be in the filesystem.
        {
            newInput = // new StandardFileInputStream(hashedname, aEnvironment.iInputStatus);
                    openInputFile(aEnvironment, aEnvironment.iInputDirectories, hashedname, aEnvironment.iInputStatus);
            LispError.check(newInput != null, LispError.KLispErrFileNotFound);
            doLoadDefFile(aEnvironment, newInput, def);
        }

        aEnvironment.iInputStatus.restoreFrom(oldstatus);
    }
    //////////////////////////////////////////////////
    ///// bits_to_digits and digits_to_bits implementation
    //////////////////////////////////////////////////

    // lookup table for transforming the number of digits
    // report the table size
    int log2TableRange() {
        return log2_table_size;
    }
    // table look-up of small integer logarithms, for converting the number of digits to binary and back

    static double log2TableLookup(int n) throws Exception {
        if (n <= log2_table_size && n >= 2) {
            return log2_table[n - 1];
        } else {
            throw new EvaluationException("log2_table_lookup: error: invalid argument " + n, -1);
        }
    }

    /**
     * Convert the number of digits in given base to the number of bits.  To make sure there is no hysteresis, the returned
     * value is rounded up.
     * 
     * @param digits
     * @param base
     * @return the number of bits
     * @throws java.lang.Exception
     */
    public static long digitsToBits(long digits, int base) throws Exception {
        return (long) Math.ceil(((double) digits) * log2TableLookup(base));
    }

    /**
     * Convert the  number of bits in a given base to the number of digits.  To make sure there is no hysteresis, the returned
     * value is rounded down.
     * 
     * @param bits
     * @param base
     * @return the number of digits
     * @throws java.lang.Exception
     */
    public static long bitsToDigits(long bits, int base) throws Exception {
        return (long) Math.floor(((double) bits) / log2TableLookup(base));
    }

    //************************* The following methods were taken from the Functions class.
    /**
     * Construct a {@link BigNumber}.
     * @param aEnvironment the current {@link Environment}.
     * @param aStackTop points to the the top of the argument stack.
     * @param aArgNr the index of the argument to be converted.
     * @return a BigNumber.
     * @throws java.lang.Exception
     */
    public static BigNumber getNumber(Environment aEnvironment, int aStackTop, int aArgNr) throws Exception {
        BigNumber x = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, aArgNr).getCons().getNumber(aEnvironment.getPrecision());
        LispError.checkArgument(aEnvironment, aStackTop, x != null, aArgNr);
        return x;
    }

    public static void multiFix(Environment aEnvironment, int aStackTop, OperatorMap aOps) throws Exception {
        // Get operator
        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        String orig = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);

        ConsPointer precedence = new ConsPointer();
        aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, precedence, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2));
        LispError.checkArgument(aEnvironment, aStackTop, precedence.getCons().string() != null, 2);
        int prec = Integer.parseInt(precedence.getCons().string(), 10);
        LispError.checkArgument(aEnvironment, aStackTop, prec <= MathPiperPrinter.KMaxPrecedence, 2);
        aOps.setOperator(prec, UtilityFunctions.getSymbolName(aEnvironment, orig));
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static void singleFix(int aPrecedence, Environment aEnvironment, int aStackTop, OperatorMap aOps) throws Exception {
        // Get operator
        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        String orig = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);
        aOps.setOperator(aPrecedence, UtilityFunctions.getSymbolName(aEnvironment, orig));
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static InfixOperator operatorInfo(Environment aEnvironment, int aStackTop, OperatorMap aOperators) throws Exception {
        // Get operator
        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);

        ConsPointer evaluated = new ConsPointer();
        evaluated.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons());

        String orig = evaluated.getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);
        //
        InfixOperator op = (InfixOperator) aOperators.lookUp(UtilityFunctions.getSymbolName(aEnvironment, orig));
        return op;
    }

    /**
     * Sets a variable in the current {@link Environment}.
     * @param aEnvironment holds the execution environment of the program.
     * @param aStackTop 
     * @param aMacroMode boolean which determines whether the first argument should be evaluated.
     * @param aGlobalLazyVariable
     * @throws java.lang.Exception
     */
    public static void internalSetVar(Environment aEnvironment, int aStackTop, boolean aMacroMode, boolean aGlobalLazyVariable) throws Exception {
        String variableString = null;
        if (aMacroMode) {
            ConsPointer result = new ConsPointer();
            aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, result, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1));
            variableString = result.getCons().string();
        } else {
            variableString = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        }
        LispError.checkArgument(aEnvironment, aStackTop, variableString != null, 1);
        LispError.checkArgument(aEnvironment, aStackTop, !UtilityFunctions.isNumber(variableString, true), 1);

        ConsPointer result = new ConsPointer();
        aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, result, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2));
        aEnvironment.setGlobalVariable(variableString, result, aGlobalLazyVariable); //Variable setting is deligated to Environment.
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static void internalDelete(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {
        ConsPointer evaluated = new ConsPointer();
        evaluated.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons());
        LispError.checkIsList(aEnvironment, aStackTop, evaluated, 1);

        ConsPointer copied = new ConsPointer();
        if (aDestructive) {
            copied.setCons(evaluated.getCons().getSublistPointer().getCons());
        } else {
            UtilityFunctions.internalFlatCopy(copied, evaluated.getCons().getSublistPointer());
        }

        ConsPointer index = new ConsPointer();
        index.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons().string() != null, 2);
        int ind = Integer.parseInt(index.getCons().string(), 10);
        LispError.checkArgument(aEnvironment, aStackTop, ind > 0, 2);

        ConsTraverser consTraverser = new ConsTraverser(copied);
        while (ind > 0) {
            consTraverser.goNext();
            ind--;
        }
        LispError.check(aEnvironment, aStackTop, consTraverser.getCons() != null, LispError.KLispErrListNotLongEnough);
        ConsPointer next = new ConsPointer();
        next.setCons(consTraverser.getCons().getRestPointer().getCons());
        consTraverser.getPointer().setCons(next.getCons());
        BuiltinFunction.getResult(aEnvironment, aStackTop).setCons(SubListCons.getInstance(copied.getCons()));
    }

    public static void internalInsert(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {
        ConsPointer evaluated = new ConsPointer();
        evaluated.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons());
        LispError.checkIsList(aEnvironment, aStackTop, evaluated, 1);

        ConsPointer copied = new ConsPointer();
        if (aDestructive) {
            copied.setCons(evaluated.getCons().getSublistPointer().getCons());
        } else {
            UtilityFunctions.internalFlatCopy(copied, evaluated.getCons().getSublistPointer());
        }

        ConsPointer index = new ConsPointer();
        index.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons().string() != null, 2);
        int ind = Integer.parseInt(index.getCons().string(), 10);
        LispError.checkArgument(aEnvironment, aStackTop, ind > 0, 2);

        ConsTraverser consTraverser = new ConsTraverser(copied);
        while (ind > 0) {
            consTraverser.goNext();
            ind--;
        }

        ConsPointer toInsert = new ConsPointer();
        toInsert.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 3).getCons());
        toInsert.getCons().getRestPointer().setCons(consTraverser.getCons());
        consTraverser.getPointer().setCons(toInsert.getCons());
        BuiltinFunction.getResult(aEnvironment, aStackTop).setCons(SubListCons.getInstance(copied.getCons()));
    }

    public static void internalReplace(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {
        ConsPointer evaluated = new ConsPointer();
        evaluated.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons());
        // Ok, so lets not check if it is a list, but it needs to be at least a 'function'
        LispError.checkArgument(aEnvironment, aStackTop, evaluated.getCons().getSublistPointer() != null, 1);

        ConsPointer index = new ConsPointer();
        index.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, index.getCons().string() != null, 2);
        int ind = Integer.parseInt(index.getCons().string(), 10);

        ConsPointer copied = new ConsPointer();
        if (aDestructive) {
            copied.setCons(evaluated.getCons().getSublistPointer().getCons());
        } else {
            UtilityFunctions.internalFlatCopy(copied, evaluated.getCons().getSublistPointer());
        }
        LispError.checkArgument(aEnvironment, aStackTop, ind > 0, 2);

        ConsTraverser consTraverser = new ConsTraverser(copied);
        while (ind > 0) {
            consTraverser.goNext();
            ind--;
        }

        ConsPointer toInsert = new ConsPointer();
        toInsert.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 3).getCons());
        LispError.checkArgument(aEnvironment, aStackTop, consTraverser.getPointer() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, consTraverser.getPointer().getCons() != null, 2);
        toInsert.getCons().getRestPointer().setCons(consTraverser.getPointer().getCons().getRestPointer().getCons());
        consTraverser.getPointer().setCons(toInsert.getCons());
        BuiltinFunction.getResult(aEnvironment, aStackTop).setCons(SubListCons.getInstance(copied.getCons()));
    }

    /**
     *Implements the MathPiper functions RuleBase and MacroRuleBase .
     * The real work is done by Environment.declareRulebase().
     */
    public static void internalRuleDatabase(Environment aEnvironment, int aStackTop, boolean aListed) throws Exception {
        //TESTARGS(3);

        // Get operator
        ConsPointer argsPointer = new ConsPointer();
        String functionName = null;

        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        functionName = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, functionName != null, 1);
        argsPointer.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());

        // Check the arguments.
        LispError.checkIsList(aEnvironment, aStackTop, argsPointer, 2);

        // Finally define the rule database.
        aEnvironment.declareRulebase(UtilityFunctions.getSymbolName(aEnvironment, functionName),
                argsPointer.getCons().getSublistPointer().getCons().getRestPointer(), aListed);

        // Return true
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static void internalNewRule(Environment aEnvironment, int aStackTop) throws Exception {
        //TESTARGS(6);

        int arity;
        int precedence;

        ConsPointer ar = new ConsPointer();
        ConsPointer pr = new ConsPointer();
        ConsPointer predicate = new ConsPointer();
        ConsPointer body = new ConsPointer();
        String orig = null;

        // Get operator
        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        orig = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);
        ar.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        pr.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 3).getCons());
        predicate.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 4).getCons());
        body.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 5).getCons());

        // The arity
        LispError.checkArgument(aEnvironment, aStackTop, ar.getCons() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, ar.getCons().string() != null, 2);
        arity = Integer.parseInt(ar.getCons().string(), 10);

        // The precedence
        LispError.checkArgument(aEnvironment, aStackTop, pr.getCons() != null, 3);
        LispError.checkArgument(aEnvironment, aStackTop, pr.getCons().string() != null, 3);
        precedence = Integer.parseInt(pr.getCons().string(), 10);

        // Finally define the rule base
        aEnvironment.defineRule(UtilityFunctions.getSymbolName(aEnvironment, orig),
                arity,
                precedence,
                predicate,
                body);

        // Return true
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static void internalDefMacroRuleBase(Environment aEnvironment, int aStackTop, boolean aListed) throws Exception {
        // Get operator
        ConsPointer args = new ConsPointer();
        ConsPointer body = new ConsPointer();
        String orig = null;

        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        orig = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);

        // The arguments
        args.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        LispError.checkIsList(aEnvironment, aStackTop, args, 2);

        // Finally define the rule base
        aEnvironment.declareMacroRulebase(UtilityFunctions.getSymbolName(aEnvironment, orig),
                args.getCons().getSublistPointer().getCons().getRestPointer(), aListed);

        // Return true
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static void internalNewRulePattern(Environment aEnvironment, int aStackTop, boolean aMacroMode) throws Exception {
        int arity;
        int precedence;

        ConsPointer arityPointer = new ConsPointer();
        ConsPointer precedencePointer = new ConsPointer();
        ConsPointer predicatePointer = new ConsPointer();
        ConsPointer bodyPointer = new ConsPointer();
        String orig = null;

        // Get operator
        LispError.checkArgument(aEnvironment, aStackTop, BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons() != null, 1);
        orig = BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 1).getCons().string();
        LispError.checkArgument(aEnvironment, aStackTop, orig != null, 1);
        arityPointer.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 2).getCons());
        precedencePointer.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 3).getCons());
        predicatePointer.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 4).getCons());
        bodyPointer.setCons(BuiltinFunction.getArgumentPointer(aEnvironment, aStackTop, 5).getCons());

        // The arity
        LispError.checkArgument(aEnvironment, aStackTop, arityPointer.getCons() != null, 2);
        LispError.checkArgument(aEnvironment, aStackTop, arityPointer.getCons().string() != null, 2);
        arity = Integer.parseInt(arityPointer.getCons().string(), 10);

        // The precedence
        LispError.checkArgument(aEnvironment, aStackTop, precedencePointer.getCons() != null, 3);
        LispError.checkArgument(aEnvironment, aStackTop, precedencePointer.getCons().string() != null, 3);
        precedence = Integer.parseInt(precedencePointer.getCons().string(), 10);

        // Finally define the rule base
        aEnvironment.defineRulePattern(UtilityFunctions.getSymbolName(aEnvironment, orig),
                arity,
                precedence,
                predicatePointer,
                bodyPointer);

        // Return true
        UtilityFunctions.internalTrue(aEnvironment, BuiltinFunction.getResult(aEnvironment, aStackTop));
    }

    public static String dumpRule(Branch branch, Environment aEnvironment, SingleArityBranchingUserFunction userFunction) {
        StringBuilder dumpResult = new StringBuilder();
        try {
            int precedence = branch.getPrecedence();
            ConsPointer predicatePointer1 = branch.getPredicatePointer();
            String predicate = "";
            String predicatePointerString = predicatePointer1.toString();
            if (predicatePointerString == null || predicatePointerString.equalsIgnoreCase("Empty.")) {
                predicate = "None.";
            } else {
                predicate = UtilityFunctions.printExpression(predicatePointer1, aEnvironment, 0);
            }

            if (predicate.equalsIgnoreCase("\"Pattern\"")) {
                predicate = "(Pattern) ";
                PatternBranch branchPattern = (PatternBranch) branch;
                Pattern pattern = branchPattern.getPattern();

                Iterator variablesIterator = pattern.getVariables().iterator();
                String patternVariables = "";
                while (variablesIterator.hasNext()) {
                    String patternVariable = (String) variablesIterator.next();
                    patternVariables += patternVariable + ", ";
                }
                if (patternVariables.contains(",")) {
                    patternVariables = patternVariables.substring(0, patternVariables.lastIndexOf(","));
                }


                Iterator parameterMatchersIterator = pattern.getParameterMatchers().iterator();
                String parameterTypes = "";
                while (parameterMatchersIterator.hasNext()) {
                    PatternParameter parameter = (PatternParameter) parameterMatchersIterator.next();
                    String parameterType = (String) parameter.getType();
                    parameterTypes += parameterType + ", ";
                }
                if (parameterTypes.contains(",")) {
                    parameterTypes = parameterTypes.substring(0, parameterTypes.lastIndexOf(","));
                }



                Iterator patternPredicatesIterator = pattern.getPredicates().iterator();
                while (patternPredicatesIterator.hasNext()) {
                    ConsPointer predicatePointer = (ConsPointer) patternPredicatesIterator.next();
                    String patternPredicate = UtilityFunctions.printExpression(predicatePointer, aEnvironment, 0);
                    predicate += patternPredicate + ", ";
                }
                /*if (predicate.contains(",")) {
                    predicate = predicate.substring(0, predicate.lastIndexOf(","));
                }*/
                predicate += "\n    Variables: " + patternVariables + ",";
                predicate += "\n    Types: " + parameterTypes;


            }//end if.

            Iterator paremetersIterator = userFunction.getParameters();
            String parameters = "";
            boolean isHold = false;
            while (paremetersIterator.hasNext()) {
                FunctionParameter branchParameter = (FunctionParameter) paremetersIterator.next();
                String parameter = branchParameter.getParameter();
                isHold = branchParameter.isHold();
                parameters += parameter + "<hold=" + isHold + ">, ";
            }
            if (parameters.contains(",")) {
                parameters = parameters.substring(0, parameters.lastIndexOf(","));
            }

            String body = UtilityFunctions.printExpression(branch.getBodyPointer(), aEnvironment, 0);
            //System.out.println(data);

            dumpResult.append("Precedence: " + precedence +", ");
            dumpResult.append("\n" + "Parameters: " + parameters +", ");
            dumpResult.append("\n" + "Predicates: " + predicate +", ");
            dumpResult.append("\n" + "Body: \n" + body + "\n");


        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return dumpResult.toString();

    }//end method.
}//end class.


