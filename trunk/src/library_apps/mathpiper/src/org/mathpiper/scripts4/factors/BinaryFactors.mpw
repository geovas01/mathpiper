%mathpiper,def="BinaryFactors",public="todo"

LocalSymbols(lastcoef,OrdBuild, AddFoundSolutionSingle , AddFoundSolution, Fct, MkfactD,p)
[

LastCoef(_vector,_p) <--
[
  Local(n);
  n:=Length(vector);
  Add(vector*p^(0 .. (n-1)));
];

/*
Ord(vector,q):=
[
  Local(n);
  n:=Length(vector);
  q*Coef(Simplify(LastCoef(vector,p+q)-LastCoef(vector,p)),q,1);
];
*/

OrdBuild(vector,q):=
[
  Local(i,result,n);
  SetVariable(i,2);
  SetVariable(result, 0);
  SetVariable(n, Length(vector));
  While (i<=n)
  [
    SetVariable(result,result+(i-1)*vector[i]*p^(i-2));
    SetVariable(i, i+2);
  ];
  q*result;
];


Function(AddFoundSolutionSingle,{p})
[
  Local(calc);
//  If ( Not Contains(result,p),
//  [
    SetVariable(calc, Eval(lastcoef));
    If (IsEqual(calc, 0),
    [
      Local(newlist,count,root);
      count:=0;
      root := p;
      Local(rem);

      rem:={-root,1};
      {testpoly,rem}:=MkfactD(testpoly,rem);

      rem:={-root,1};
      {newlist,rem}:=MkfactD(poly,rem);
      While (rem = {})
      [
        count++;
        SetVariable(poly,newlist);
        rem:={-root,1};
        {newlist,rem}:=MkfactD(poly,rem);
      ];

      Local(lgcd,lc);
      SetVariable(lgcd,Gcd({andiv,an,root}));
      SetVariable(lc,Quotient(an,lgcd));
      SetVariable(result,{var+ (-(Quotient(root,lgcd)/lc)),count}:result);
      SetVariable(andiv,Quotient(andiv,lgcd^count));
      SetVariable(anmul,anmul*lc^count);

//      factor:=(x-root);
//      SetVariable(result,{factor,count}:result);

      Local(p,q);
      SetVariable(lastcoef, LastCoef(testpoly,p));
      SetVariable(ord, OrdBuild(testpoly,q));
    ]);
//  ]);
];
UnFence(AddFoundSolutionSingle,1);

Function(AddFoundSolution,{p})
[
  AddFoundSolutionSingle(p);
  AddFoundSolutionSingle(-2*q+p);
];
UnFence(AddFoundSolution,1);

Function(Fct,{poly,var})
[
  Local(maxNrRoots,result,ord,p,q,accu,calc,twoq,mask);

  Local(gcd);
  [
    SetVariable(gcd,Gcd(poly));
    If(poly[Length(poly)] < 0,SetVariable(gcd, gcd * -1));
    SetVariable(poly,poly/gcd);
  ];

  Local(unrat);
  SetVariable(unrat,Lcm(MapSingle("Denominator",poly)));
  SetVariable(poly,unrat*poly);

  Local(origdegree);
  SetVariable(origdegree,Length(poly)-1);

  Local(an,andiv,anmul);
  SetVariable(an,poly[Length(poly)]);
  SetVariable(poly,poly* (an^((origdegree-1) .. -1)));
  SetVariable(andiv,an^(origdegree-1));
  SetVariable(anmul,1);

  Local(leadingcoef,lowestcoef);
  SetVariable(leadingcoef,poly[Length(poly)]);
  [
    Local(i);
    SetVariable(i,1);
    SetVariable(lowestcoef,Abs(poly[i]));
    While (lowestcoef = 0 And i<=Length(poly))
    [
      SetVariable(i,i+1);
      SetVariable(lowestcoef,Abs(poly[i]));
    ];
  ];
  // testpoly is the square-free version of the polynomial, used for finding
  // the factors. the original polynomials is kept around to find the
  // multiplicity of the factor.
  Local(testpoly);
//  SetVariable(testpoly,Mkc(Quotient(polynom,Monic(Gcd(polynom,Deriv(var)polynom))),var));
  Local(deriv);
  // First determine a derivative of the original polynomial
  deriv:=Rest(poly);
  [
    Local(i);
    For (i:=1,i<=Length(deriv),i++)
    [
      deriv[i] := deriv[i]*i;
    ];
//    Echo("POLY = ",poly);
//    Echo("DERIV = ",deriv);
  ];
  [
    Local(q,r,next);
    q:=poly;
    r:=deriv;
    While(r != {})
    [
//Echo(q,r);
      next := MkfactD(q,r)[2];
      q:=r;
      r:=next;
    ];
    // now q is the gcd of the polynomial and its first derivative.

    // Make it monic
    q:=q/q[Length(q)];
    testpoly:=MkfactD(poly,q)[1];
//Echo("TESTPOLY = ",testpoly);
  ];

//  SetVariable(testpoly,poly); //@@@

  SetVariable(maxNrRoots,Length(testpoly)-1);
  SetVariable(result, {});

  SetVariable(lastcoef, LastCoef(testpoly,p));
  SetVariable(ord, OrdBuild(testpoly,q));

  SetVariable(accu,{});
  SetVariable(q,1);
  SetVariable(twoq,MultiplyN(q,2));
  SetVariable(mask,AddN(twoq,MathNegate(1)));
  if (IsEven(testpoly[1]))
  [
    SetVariable(accu,0:accu);
    AddFoundSolutionSingle(0);
  ];
  SetVariable(p,1);
  SetVariable(calc, Eval(lastcoef));
  If (IsEven(calc),
  [
    SetVariable(accu,1:accu);
    AddFoundSolution(1);
  ]);
  SetVariable(q,twoq);
  SetVariable(twoq,MultiplyN(q,2));
  SetVariable(mask,AddN(twoq,MathNegate(1)));
  While(Length(result)<maxNrRoots And Length(accu)>0 And q<=Abs(testpoly[1]))
  [
    Local(newaccu);
    SetVariable(newaccu,{});
    ForEach(p,accu)
    [
      SetVariable(calc,Eval(lastcoef));
      If (IsLessThan(calc,0),
        SetVariable(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))
         );
      SetVariable(calc, BitAnd(calc, mask));
      If ( IsEqual(calc, 0),
      [
        SetVariable(newaccu, p:newaccu);
        AddFoundSolutionSingle(-2*q+p);
      ]);
      SetVariable(calc, AddN(calc, Eval(ord)));
      If (IsLessThan(calc,0),
        SetVariable(calc, AddN(calc,MultiplyN(twoq,QuotientN(AddN(MathNegate(calc),twoq),twoq))))
         );
      SetVariable(calc, BitAnd(calc, mask));
      If ( IsEqual(calc, 0),
      [
        SetVariable(newaccu, AddN(p,q):newaccu);
        AddFoundSolution(AddN(p,q));
      ]);
    ];
    SetVariable(accu, newaccu);
    SetVariable(q,twoq);
    SetVariable(twoq,MultiplyN(q,2));
    SetVariable(mask,AddN(twoq,MathNegate(1)));

//Echo("q = ",q);
//Echo("Length is",Length(accu),"accu = ",accu);
//Echo("result = ",result);
  ];

  // If the polynom is not one, it is a polynomial which is not reducible any further
  // with this algorithm, return as is.
  SetVariable(poly,poly*an^(0 .. (Length(poly)-1)));
  SetVariable(poly,gcd*anmul*poly);
  //TODO had to add this if statement, what was andiv again, and why would it become zero? This happens with for example Factor(2*x^2)
  If(Not IsZero(unrat * andiv ),SetVariable(poly,poly/(unrat * andiv )));
  If(poly != {1},
  [
    result:={(Add(poly*var^(0 .. (Length(poly)-1)))),1}:result;
  ]);
  result;
];



BinaryFactors(expr):=
[
  Local(result,uni,coefs);
  uni:=MakeUni(expr,VarList(expr)[1]);
  uni:=FunctionToList(uni);
  coefs:=uni[4];
  coefs:=Concat(ZeroVector(uni[3]),coefs);
  result:=Fct(coefs,uni[2]);
//  Echo(result,list);
//  Echo((Add(list*x^(0 .. (Length(list)-1)))));
//  Product(x-result)*(Add(list*x^(0 .. (Length(list)-1))));
  result;
];



MkfactD(numer,denom):=
[
  Local(q,r,i,j,ln,ld,nq);
  DropEndZeroes(numer);
  DropEndZeroes(denom);
  SetVariable(numer,Reverse(numer));
  SetVariable(denom,Reverse(denom));
  SetVariable(ln,Length(numer));
  SetVariable(ld,Length(denom));
  SetVariable(q,FillList(0,ln));
  SetVariable(r,FillList(0,ln));

  SetVariable(i,1);
  If(ld>0,
  [
    While(Length(numer)>=Length(denom))
    [
      SetVariable(nq,numer[1]/denom[1]);
      q[ln-(Length(numer)-ld)] := nq;
      For(j:=1,j<=Length(denom),j++)
      [
        numer[j] := (numer[j] - nq*denom[j]);
      ];
      r[i] := r[1] + numer[1];

      SetVariable(numer, Rest(numer));
      i++;
    ];
  ]);
  For(j:=0,j<Length(numer),j++)
  [
    r[i+j] := r[i+j] + numer[j+1];
  ];
  SetVariable(q,Reverse(q));
  SetVariable(r,Reverse(r));
  DropEndZeroes(q);
  DropEndZeroes(r);
  {q,r};
];

]; //LocalSymbols


%/mathpiper