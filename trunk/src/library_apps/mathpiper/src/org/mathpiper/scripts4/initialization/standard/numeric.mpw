%mathpiper,def="N;NonN;InNumericMode"

//"+-;/-;*-;^-;:=-;:=+" These were in the def list.

/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */

/* Implementation of numeric mode */

Retract("N",*);

LocalSymbols(numericMode)
[

  numericMode := False;

  // N function: evaluate numerically with given precision.
  LocalSymbols(previousNumericMode, previousPrecision, numericResult) 
  Macro("N",{expression, precision})
  [
    //If(InVerboseMode(),
    //    [Tell("N",{expression,precision}); Tell("  ",{@expression,@precision});]
    //);
    
    // we were in non-numeric mode
    Local(previousNumericMode, previousPrecision, numericResult, errorString);

    previousPrecision := BuiltinPrecisionGet();
    //If(InVerboseMode(),Tell("  ",previousPrecision));
    BuiltinPrecisionSet(@precision+2);

    AssignCachedConstantsN();

    previousNumericMode := numericMode;
    numericMode         := True;
    errorString         := "";

    //TrapError(Bind(numericResult, Eval(@expression)),Bind(errorString,GetCoreError()));
    TrapError( numericResult:=Eval(@expression), errorString:= GetCoreError() );
    //If(InVerboseMode(),Tell("  1",numericResult));

    If(IsDecimal(numericResult), numericResult := RoundToN(numericResult, @precision));
    //If(InVerboseMode(),Tell("  2",numericResult));

    numericMode := previousNumericMode;

    If(Not numericMode, [ ClearCachedConstantsN(); ] );

    BuiltinPrecisionSet(previousPrecision);

    Check(errorString="",errorString);

    numericResult;

  ];




  // N function: evaluate numerically with default precision.
  LocalSymbols(precision,heldExpression) 
  Macro("N",{expression})
  [
     Local(precision, heldExpression);
     precision      :=  BuiltinPrecisionGet();
     heldExpression :=  Hold(@expression);

     `N(@heldExpression, @precision);
  ];

  
  // NoN function.
  LocalSymbols(result) 
  Macro("NonN",{expression})
  [
    Local(result);
    GlobalPush(numericMode);
    numericMode := False;
    result      := (@expression);
    numericMode := GlobalPop();
    result;
  ];


  // InNumericMode function.
  Function("InNumericMode",{}) numericMode;

]; //LocalSymbols(numericMode)

%/mathpiper

   





%mathpiper_docs,name="N",categories="User Functions;Numbers (Operations)"
*CMD N --- try to determine an numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {MathPiper} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make MathPiper
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.1415926535897932385

*SEE Pi
%/mathpiper_docs

    %output,preserve="false"
      
.   %/output




%mathpiper_docs,name="InNumericMode;NonN"
*CMD InNumericMode --- determine if currently in numeric mode
*CMD NonN --- calculate part in non-numeric mode

*STD
*CALL
	NonN(expr)
	InNumericMode()
*PARMS

{expr} -- expression to evaluate

{prec} -- integer, precision to use

*DESC

When in numeric mode, {InNumericMode()} will return {True}, else it will
return {False}. {MathPiper} is in numeric mode when evaluating an expression
with the function {N}. Thus when calling {N(expr)}, {InNumericMode()} will
return {True} while {expr} is being evaluated.

{InNumericMode()} would typically be used to define a transformation rule
that defines how to get a numeric approximation of some expression. One
could define a transformation rule

	f(_x)_InNumericMode() <- [... some code to get a numeric approximation of f(x) ... ];

{InNumericMode()} usually returns {False}, so transformation rules that check for this
predicate are usually left alone.

When in numeric mode, {NonN} can be called to switch back to non-numeric
mode temporarily.

{NonN} is a macro. Its argument {expr} will only
be evaluated after the numeric mode has been set appropriately.

*E.G.

	In> InNumericMode()
	Out> False
	In> N(InNumericMode())
	Out> True
	In> N(NonN(InNumericMode()))
	Out> False

*SEE N, BuiltinPrecisionSet, BuiltinPrecisionGet, Pi, CachedConstant
%/mathpiper_docs


