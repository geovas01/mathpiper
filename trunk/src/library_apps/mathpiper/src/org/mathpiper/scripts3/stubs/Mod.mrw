%mathpiper,def="Mod"

0 # Mod(_n,m_IsRationalOrNumber)_(m<0) <-- `Hold(Mod(@n,@m));

1 # Mod(n_IsNegativeInteger,m_IsPositiveInteger) <--
[
  Local(result);
  result := ModN(n,m);
  If (result < 0,result := result + m);
  result;
];
1 # Mod(n_IsPositiveInteger,m_IsPositiveInteger) <-- ModN(n,m);
2 # Mod(0,_m) <-- 0;
2 # Mod(n_IsPositiveInteger,Infinity) <-- n;
3 # Mod(n_IsInteger,m_IsInteger) <-- ModN(n,m);
4 # Mod(n_IsNumber,m_IsNumber) <-- NonN(Mod(Rationalize(n),Rationalize(m)));

5 # Mod(n_IsRationalOrNumber,m_IsRationalOrNumber)/*_(n>0 And m>0)*/ <--
[
  Local(n1,n2,m1,m2);
  n1:=Numer(n);
  n2:=Denom(n);
  m1:=Numer(m);
  m2:=Denom(m);
  Mod(n1*m2,m1*n2)/(n2*m2);
];

6 # Mod(n_IsList,m_IsList) <-- Map("Mod",{n,m});
7 # Mod(n_IsList,_m) <-- Map("Mod",{n,FillList(m,Length(n))});


30 # Mod(n_CanBeUni,m_CanBeUni) <--
[
  Local(vars);
  vars:=VarList(n+m);
  NormalForm(Mod(MakeUni(n,vars),MakeUni(m,vars)));
];


//Note:tk:moved here from univariate.rep.
0 # Mod(n_IsUniVar,m_IsUniVar)_(Degree(n) < Degree(m)) <-- n;
1 # Mod(n_IsUniVar,m_IsUniVar)_
    (n[1] == m[1] And Degree(n) >= Degree(m)) <--
[
    UniVariate(n[1],0,
               UniDivide(Concat(ZeroVector(n[2]),n[3]),
                         Concat(ZeroVector(m[2]),m[3]))[2]);
];

%/mathpiper


%mathpiper_docs,name="Div;Mod"
*CMD Div --- Determine divisor of two mathematical objects
*CMD Mod --- Determine remainder of two mathematical objects after dividing one by the other

*STD
*CALL
	Div(x,y)
	Mod(x,y)

*PARMS

{x}, {y} -- integers or univariate polynomials

*DESC

{Div} performs integer division and {Mod} returns the remainder after division. {Div} and
{Mod} are also defined for polynomials.

If {Div(x,y)} returns "a" and {Mod(x,y)} equals "b", then these numbers satisfy $x =a*y + b$ and $0 <= b < y$.

*E.G.

	In> Div(5,3)
	Out> 1;
	In> Mod(5,3)
	Out> 2;

*SEE Gcd, Lcm
%/mathpiper_docs