%mathpiper,def="xFactors"

/*------------------------------------------------------------------------
 *  NEW VERSION 
 *    Started 091222
 *------------------------------------------------------------------------*/

Retract("xFactors",*);
Retract("xPolyFactors",*);
Retract("xFactorsMultivariateSpecialCases",*);
Retract("xFactorsSomethingElse",*);
Retract("CombineNumericalFactors",*);
//Retract("CommonMonomialFactors",*);
//Retract("MakeUniPoly",*);
//Retract("HeuristicUniPoly",*);

/* -------------    LISTS    --------------*/

10 # xFactors( L_IsList ) <-- xFactors /@ L;


/* -------------    NUMBERS    --------------*/

10 # xFactors(p_IsPositiveInteger) <--  
[
    If( p < 1600, FactorsSmallInteger(p), FactorizeInt(p) );
];

10 # xFactors(p_IsNegativeInteger) <-- xFactors(-p);

10 # xFactors(p_IsRational)_(Denominator(p) != 1) <-- 
             { {xFactor(Numerator(p)) / xFactor(Denominator(p) ) , 1} }; 

10 # xFactors(p_IsGaussianInteger)	<-- GaussianFactors(p);



/* -------------    POLYNOMIALS -- CAN BE UNI   --------------*/

21 # xFactors( poly_CanBeUni ) <--
[
    If(InVerboseMode(),Tell("xFactors_can_be_uni",poly));
    Local(content,pp,vars,nvars,ppFactors,monomialFactors,result);
    
    // First step: get Content and Primitive Part
    Clear(content);
    pp := xPrimitivePart( poly, content );
    If(InVerboseMode(),Tell("  ",{content,pp}));
    
    //  Now we can concentrate on factoring the Primitive Part, which
    //  will hopefully be simpler
    vars  := VarList(pp);
    nvars := Length(vars);
    //If( nvars > 1, vars := Reverse(vars) );  //  for heuristic purposes
    If(InVerboseMode(),Tell("  ",vars));
    ppFactors := xPolyFactors( pp );
    If(InVerboseMode(),Tell("  ",ppFactors));
    If( ppFactors = True, ReturnFromBlock(-9999) ); // signals an incomplete result
    
    // Next, include the factors of the Content, if any
    monomialFactors := FactorsMonomial(content);
    If(InVerboseMode(),Tell("  ",monomialFactors));
    If( monomialFactors[1][1] = 1,
        result := ppFactors,        
        result := Concat(monomialFactors,ppFactors)
    );
    If(InVerboseMode(),Tell("  ",result));
    result;
];

// ----------------  UNIVARIATE POLYNOMIALS  -----------------

10 # xPolyFactors( _poly )_(nvars=1) <--
[
    Local(factrs,uni,deg,coeffs,hasRealCoeffs);
    If(InVerboseMode(),Tell("xFactors_uni",poly));
    
    // What kind of univariate polynomial is this?
    uni := MakeUni(poly);
    If(InVerboseMode(),Tell("  ",uni));
    coeffs := uni[3]; 
    deg    := Length(coeffs)-1;
    If(InVerboseMode(),Tell("       ",{deg,coeffs}));
    hasRealCoeffs := Length(Select("IsDecimal",coeffs)) > 0;
    If(InVerboseMode(),Tell("       ",hasRealCoeffs));
    
    // If it has Real coefficients, convert to Q then Z
    If( hasRealCoeffs,
      [
          coeffs := Rationalize(coeffs);
          If(InVerboseMode(),Tell("      Z",coeffs));
          gcd    := Gcd(coeffs);
          If(InVerboseMode(),Tell("       ",gcd));
          If( gcd != 1,
            [
              coeffs  := Simplify(coeffs/gcd);
              content := content * gcd;
              If(InVerboseMode(),Tell("          ",{content,coeffs}));
            ]
          );
          poly := NormalForm(UniVariate(uni[1],uni[2],coeffs));
          If(InVerboseMode(),Tell("   new",poly));
      ]
    );
    
    // OK, First, send it through MathPiper's basic factoring function
    // for univariate polynomials
    factrs := BinaryFactors(poly);
    If(InVerboseMode(),Tell("       ",Type(factrs)));
    factrs;
];


// ----------------  BIVARIATE POLYNOMIALS  -----------------

10 # xPolyFactors( _poly )_(nvars=2) <--
[
    If(InVerboseMode(),Tell("xFactors_bivariate",poly));
    Local(primeInteger,result1);
    If(InVerboseMode(),Tell("   ",vars));
    //primeInteger := NextPrime(RandomInteger(1000,10000));
    primeInteger := 7247;
    If(InVerboseMode(),Tell("    random",primeInteger));
    upoly := Subst(vars[2],primeInteger) poly;
    If(InVerboseMode(),Tell("   ",upoly));
    result1 := xFactors(upoly);
    If(InVerboseMode(),Tell(" ",result1));
    ForEach(s,result1)
    [
        If(InVerboseMode(),Tell("      ",s));
        //Tell("        ",s[1]);
        us := MakeUni(s[1]);
        //Tell("      ",us);
        cs := us[3];
        //Tell("      ",cs);
        fs := FactorizeInt /@ cs;
        //Tell("      ",fs);
        result2 := (Subst(primeInteger,vars[2])fs);
        //Tell("      ",result2);
        ii := Find(result2,{});
        //Tell("            ",ii);
        If(ii > 0, DestructiveDelete(result2,ii));
        //Tell("      ",result2[1]);
        s1 := FW(result2[1]);
        If(InVerboseMode(),Tell("      ",s1));
        
    ];
    //result2 := Subst(primeInteger,vars[2]) result1;
    //If(InVerboseMode(),Tell(" ",result2));
    
];


// ----------------  MULTIVARIATE POLYNOMIALS  -----------------

10 # xPolyFactors( _poly )_(nvars>2) <--
[
    If(InVerboseMode(),Tell("xFactors_multi",poly));
    If(InVerboseMode(),Tell("   ",vars));
    
];

UnFence("xPolyFactors",1);


//========================================================================


%/mathpiper

