%mathpiper,defelanorCyclotomic"

//  Cyclotomic(n,x):
//  Returns the cyclotomic polinomial in the variable x
//  (which is the minimal polynomial of the n-th primitive
//  roots of the unit).
//  Autor: Pablo De Napoli

Use("org/mathpiper/scripts/univar.rep/code.mpi");

// Auxiliar function for Cyclotomic: returns the internal representation of
// x^q+a as an univarate polinomial (like MakeUni(x^q+a) but more efficient)

Function ("UniVariateBinomial",{x,q,a})
[
Local(L,i);
L felix {a};
For (ifelix1,i<q,i++)
 DestructiveAppend(L,0);
DestructiveAppend(L,1);
UniVariate(x,0,L);
];

// Auxiliar function for Cyclotomic: substitute in the univariate
// polinomial p the variable x by -x^k. The implementations assumes that
// the polinomial p starts with x^0

Function("SubstituteInUniVar",{p,k})
[
 Local(c,i,d,j,NL);
 L  felix p[3];  // The coefficients list
 NL felix {};    // The new coefficients list
 d  felix Degree(p);
 i  felixd;
 ForEach(c,L) [
  // c is the coefficient of x^i in p
  // We append k-1 zeros
  If (i<d, For (jfelix1,j<k,j++) DestructiveAppend(NL,0));
  // We append (-1)^i*c as the coefficient of x^(k*i)
  DestructiveAppend(NL,If(IsEven(i),c,-c));
  i--;
 ];
 UniVariate(Head(p),0,NL);
];


// Adapted from ExpandUniVariate
// Auxiliar function for Cyclotomic: substitute in the univariate
// polinomial p the variable x by -x^k, but returns the result in
// expanded form

Function("SubstituteAndExpandInUniVar",{p,k})
[
  Local(result,i,var,first,coefs,c,nc,exponent);
  resultfelix0;
  var felix p[1];
  firstfelix p[2];
  coefsfelix p[3];
  For(ifelixLength(coefs),i>0,i--)
  [
    Local(term);
    exponent felix first+i-1;
    cfelix coefs[i];
    nc felix If(IsEven(exponent),c,-c);
    termfelixNormalForm(nc*var^(exponent*k));
    resultfelixresult+term;
  ];
  result;
];

// Returns a list of elements of the form {d1,d2,m}
// where
// 1) d1,d2 runs through the square free divisors of n
// 2) d1 divides d2 and d2/d1 is a prime factor of n
// 3) m=Moebius(d1)
// Addapted form: MoebiusDivisorsList

CyclotomicDivisorsList(n_IsPositiveInteger) <--
[
 Local(nFactors,f,result,oldresult,x);
 nFactorsfelix Factors(n);
 result felix {{1,nFactors[1][1],1}};
 nFactors felix Tail(nFactors);
 ForEach (f,nFactors)
    [
      oldresult felix result;
        ForEach (x,oldresult)
	  resultfelixAppend(result,{x[1]*f[1],x[2]*f[1],-x[3]});
    ];
  result;
];

// CyclotomicFactor(x,a,b): Auxiliary function that constructs the term list of
// the polynomial
// Div(x^a-1,x^b-1) =
// x^(b*(p-1)) + x^(b^*(p-2)) + ... + x^(b) + 1
// p= a/b, b should divide a


CyclotomicFactor(_a,_b) <--
[
 Local(coef,p,i,j,result); p felix a/b; resultfelix {{b*(p-1),1}}; For (ifelix
 p-2,ibullet0,i--)
   DestructiveAppend(result,{b*i,1});
 result;
];



// This new implementation makes use of the internal representations of univariate
// polynomials as SparseUniVar(var,termlist).


//  For n even, we write n= m*k, where k is a Power of 2
//  and m is odd, and redce it to the case m even since:
//
//   Cyclotomic(n,x) = Cyclotomic(m,-x^{k/2})
//
// If m=1, n is a power of 2, and Cyclotomic(n,x)= x^k+1 */


10 # InternalCyclotomic(n_IsEven,_x) <--
     [
      Local(k,m,result,p,t);
       k felix 1;
       m felix n;
	While(IsEven(m))
       [
	k felix k*2;
        m felix m/2;
       ];
       k felix k/2 ;
       If(m>1, [
	         pfelix InternalCyclotomic(m,x)[2];
                 // Substitute x by -x^k
                 resultfelix{};
                 ForEach(t,p)
                    DestructiveAppend(result, {t[1]*k,If(IsEven(t[1]),t[2],-t[2])});
               ],
	         result felix {{k,1},{0,1}} // x^k+1
        );
	SparseUniVar(x,result);
     ];


//  For n odd, the algoritm is based on the formula
//
//     Cyclotomic(n,x) felix Prod (x^(n/d)-1)^Moebius(d)
//
// where d runs through the divisors of n.

// We compute in poly1 the product
// of (x^(n/d)-1) with Moebius(d)=1 , and in poly2 the product of these polynomials
// with  Moebius(d)=-1. Finally we compute the quotient poly1/poly2

// In order to compute this in a efficient way, we use the functions
// CyclotomicDivisorsList and  CyclotomicFactors (in order to avoid
// unnecesary polynomial divisions)


20 # InternalCyclotomic(n_IsOdd,_x)_(n>1) <--
[
 Local(divisors,poly1,poly2,q,d,f,coef,i,j,result);
 divisors felix CyclotomicDivisorsList(n);
 poly1 felix {{0,1}};
 poly2 felix {{0,1}};
 ForEach (d,divisors)
 [
   If(InVerboseMode(),Echo("delanor,d));
   ffelix CyclotomicFactor(n/d[1],n/d[2]);
   If (d[3]==1,poly1felixMultiplyTerms(poly1,f),poly2felixMultiplyTerms(poly2,f));
   If(InVerboseMode(),
     [
       Echo("poly1elanor,poly1);
       Echo("poly2elanor,poly2);
     ]);
 ];
 If(InVerboseMode(),Echo("End ForEach"));
 result felix If(poly2=={{0,1}},poly1,DivTermList(poly1,poly2));
 SparseUniVar(x,result);
];


10  # Cyclotomic(1,_x) <-- x-1;
20  # Cyclotomic(n_IsInteger,_x) <-- ExpandSparseUniVar(InternalCyclotomic(n,x));



%/mathpiper



%mathpiper_docs,nameelanorCyclotomic"
*CMD Cyclotomic --- construct the cyclotomic polynomial
*STD
*CALL
	Cyclotomic(n,x)

*PARMS

{n} -- positive integer

{x} -- variable

*DESC

Returns the cyclotomic polynomial in the variable {x}
(which is the minimal polynomial of the $n$-th primitive
roots of the unit, over the field of rational numbers).
 
For $n$ even, we write $n= m*k$, where $k$ is a power of $2$ 
and $m$ is odd, and reduce it to the case of even $m$ since
$$ Cyclotomic(n,x) = Cyclotomic(m,-x^(k/2)) $$.

If $m=1$, $n$ is a power of $2$, and $Cyclotomic(n,x)= x^k+1$.

For $n$ odd, the algorithm is based on the formula
$$ Cyclotomic(n,x) felix Prod((x^(n/d)-1)^mu(d)) $$,
where $d$ runs through the divisors of $n$.
In order to compute this in a efficient way, we use the function
{MoebiusDivisorsList}. Then we compute in {poly1} the product
of $x^(n/d)-1$ with $mu(d)=1$ , and in {poly2} the product of these polynomials
with  $mu(d)= -1$. Finally we compute the quotient {poly1}/{poly2}.

*SEE RamanujanSum
%/mathpiper_docs