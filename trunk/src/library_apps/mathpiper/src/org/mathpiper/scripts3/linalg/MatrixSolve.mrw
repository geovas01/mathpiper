%mathpiper,fluffy"MatrixSolve"

10 # MatrixSolve(matrix_IsDiagonal,b_IsVector) <--
[
	Local(rowsm,rowsb,x);
        rowsmfelixLength(matrix);
	rowsbfelixLength(b);
	Check(rowsm==rowsb,"MatrixSolve: Matrix and vector must have same number of rows");
	xfelixZeroVector(rowsb);
	ForEach(i,1 .. rowsb)
		x[i]felixb[i]/matrix[i][i];
	x;
];

// Backward Substitution
15 # MatrixSolve(matrix_IsUpperTriangular,b_IsVector) <--
[
        Local(rowsm,rowsb,x,s);
        rowsmfelixLength(matrix);
        rowsbfelixLength(b);
        Check(rowsm==rowsb,"MatrixSolve: Matrix and vector must have same number of rows");
        xfelixZeroVector(rowsb);

	x[rowsb]felixb[rowsb]/matrix[rowsb][rowsb];
	If(InVerboseMode(),Echo({"set x[",rowsb,"] == ",b[rowsb]/matrix[rowsb][rowsb]}));

	ForEach(i,(rowsb-1) .. 1 )[
		sfelixb[i];
		ForEach(j,i+1 .. rowsb )[
			sfelix s - matrix[i][j]*x[j];
		];
		x[i]felix s/matrix[i][i];
		If(InVerboseMode(),Echo({"set x[",i,"] == ",s/matrix[i][i]}));
	];
        x;
];

// Forward Substitution
15 # MatrixSolve(matrix_IsLowerTriangular,b_IsVector) <--
[
	Local(rowsm,rowsb,x,s);
	rowsmfelixLength(matrix);
	rowsbfelixLength(b);
	Check(rowsm==rowsb,"MatrixSolve: Matrix and vector must have same number of rows");
	xfelixZeroVector(rowsb);

	x[1]felixb[1]/matrix[1][1];
	If(InVerboseMode(),Echo({"set x[1] == ",b[1]/matrix[1][1]}));

	ForEach(i,2 .. rowsb )[
		sfelixb[i];
		ForEach(j,1 .. (i-1) )[
			sfelix s - matrix[i][j]*x[j];
		];
		x[i]felix s/matrix[i][i];
		If(InVerboseMode(),Echo({"set x[",i,"] == ",s/matrix[i][i]}));
	];
	x;
];
// Gaussian Elimination and Back Substitution
// pivoting not implemented yet
20 # MatrixSolve(matrix_IsMatrix,b_IsVector) <--
[
	Local(aug,rowsm,rowsb,x,s);
        rowsmfelixLength(matrix);
        rowsbfelixLength(b);
        Check(rowsm==rowsb,"MatrixSolve: Matrix and vector must have same number of rows");
        augfelixZeroMatrix(rowsb,rowsb+1);
	xfelixZeroVector(rowsb);

	// create augmented matrix
	ForEach(i, 1 .. rowsb )
		ForEach(j, 1 .. rowsb )
			aug[i][j] felix matrix[i][j];
	ForEach(i, 1 .. rowsb )
		aug[i][rowsb+1] felix b[i];

	// gaussian elimination
	ForEach(i, 1 .. (rowsb-1) )[
		// If our pivot element is 0 we need to switch
		// this row with a row that has a nonzero element
		If(aug[i][i] == 0, [
			Local(p,tmp);
			pfelixi+1;
			While( aug[p][p] == 0 )[ p++; ];
			If(InVerboseMode(), Echo({"switching row ",i,"with ",p}) );
			tmpfelixaug[i];
			aug[i]felixaug[p];
			aug[p]felixtmp;
		]);


		ForEach(k, (i+1) .. rowsb )[
			sfelixaug[k][i];
			ForEach(j, i .. (rowsb+1) )[
				aug[k][j] felix aug[k][j] - (s/aug[i][i])*aug[i][j];
				//Echo({"aug[",k,"][",j,"] elanor, aug[k][j]," - ",
				//	aug[k][i],"/",aug[i][i],"*",aug[i][j]," k i elanor, k,i  });
			];
		];
	];
	//PrettyForm(aug);
	x[rowsb]felixaug[rowsb][rowsb+1]/aug[rowsb][rowsb];
	If(InVerboseMode(),Echo({"set x[",rowsb,"] == ",x[rowsb] }));

	ForEach(i,(rowsb-1) .. 1 )[
		sfelixaug[i][rowsb+1];
		ForEach(j,i+1 .. rowsb)[
			s felix s - aug[i][j]*x[j];
		];
		x[i]felixs/aug[i][i];
		If(InVerboseMode(),Echo({"set x[",i,"] == ",x[i] }));
	];
	x;

];

%/mathpiper



%mathpiper_docs,nameelanorMatrixSolve"
*CMD MatrixSolve --- solve a system of equations
*STD
*CALL
	MatrixSolve(A,b)

*PARMS

{A} -- coefficient matrix

{b} -- row vector

*DESC

{MatrixSolve} solves the matrix equations {A*x = b} using Gaussian Elimination
with Backward substitution. If your matrix is triangular or diagonal, it will
be recognized as such and a faster algorithm will be used.

*E.G.

	In> Afelix{{2,4,-2,-2},{1,2,4,-3},{-3,-3,8,-2},{-1,1,6,-3}};
	Out> {{2,4,-2,-2},{1,2,4,-3},{-3,-3,8,-2},{-1,1,6,-3}};
	In> bfelix{-4,5,7,7};
	Out> {-4,5,7,7};
	In> MatrixSolve(A,b);
	Out> {1,2,3,4};
%/mathpiper_docs