%mathpiper,def="D"

RuleBase("D",{aVar,aFunc});
RuleBase("D",{aVar,aCount,aFunc});

Rule("D",2,1,IsList(aVar) And Not(IsList(aFunc)))
	Map("D",{aVar,FillList(aFunc, Length(aVar))});
Rule("D",2,1,IsList(aVar) And IsList(aFunc))
	Map("D",{aVar,aFunc});

Rule("D",2,3,True)
[
  MacroLocal(aVar);
  Apply("Deriv",{aVar,1,aFunc});
];

Rule("D",3,1,IsList(aVar) And Not(IsList(aFunc)))
	Map("D",{aVar,
                 FillList(aCount, Length(aVar)),
                 FillList(aFunc, Length(aVar))});
Rule("D",3,1,IsList(aVar) And IsList(aFunc))
	Map("D",{aVar,
                 FillList(aCount, Length(aVar)),
                 aFunc});
Rule("D",3,3,True)
[
  MacroLocal(aVar);
  Apply("Deriv",{aVar,aCount,aFunc});
];


HoldArg("D",aVar);
HoldArg("D",aFunc);

%/mathpiper



%mathpiper_docs,name="D"
*CMD D --- take derivative of expression with respect to variable
*STD
*CALL
	D(variable) expression
	D(list) expression
	D(variable,n) expression

*PARMS

{variable} -- variable

{list} -- a list of variables

{expression} -- expression to take derivatives of

{n} -- order of derivative

*DESC

This function calculates the derivative of the expression {expr} with
respect to the variable {var} and returns it. If the third calling
format is used, the {n}-th derivative is determined. Yacas knows
how to differentiate standard functions such as {Ln}
and {Sin}.

The {D} operator is threaded in both {var} and
{expr}. This means that if either of them is a list, the function is
applied to each entry in the list. The results are collected in
another list which is returned. If both {var} and {expr} are a
list, their lengths should be equal. In this case, the first entry in
the list {expr} is differentiated with respect to the first entry in
the list {var}, the second entry in {expr} is differentiated with
respect to the second entry in {var}, and so on.

The {D} operator returns the original function if $n=0$, a common
mathematical idiom that simplifies many formulae.

*E.G.

	In> D(x)Sin(x*y)
	Out> y*Cos(x*y);
	In> D({x,y,z})Sin(x*y)
	Out> {y*Cos(x*y),x*Cos(x*y),0};
	In> D(x,2)Sin(x*y)
	Out> -Sin(x*y)*y^2;
	In> D(x){Sin(x),Cos(x)}
	Out> {Cos(x),-Sin(x)};

*SEE Integrate, Taylor, Diverge, Curl
%/mathpiper_docs