%mathpiper,def="Factors"

Retract("Factors",*);

Retract("FactorsMultivariateSpecialCases",*);   // helper function
Retract("FactorsSomethingElse",*);              // helper function

/*
 * This is the fundamental factorization algorithm.
 * It works for integers, rational numbers, Gaussian integers, and polynomials
 * When the argument is an integer, FactorizeInt() does the heavy lifting.
 * When the argument is a polynomial, BinaryFactors() is the workhorse.
 */
10 # Factors(p_IsInteger) <--  FactorizeInt(p);

12 # Factors(p_IsRational)_(Denominator(p) != 1) <-- {{Factor(Numerator(p)) /Factor(Denominator(p)) , 1}}; 
     //Added to handle rational numbers with denominators that are not 1

14 # Factors(p_IsGaussianInteger)	<-- GaussianFactors(p);

20 # Factors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  
[
    Local(x,coeffs,factorsList,result);
    x := VarList(p)[1];
    /*  p is the polynomial, x is its (only) variable */
    
    factorsList := BinaryFactors(p);
         // BinaryFactors is the internal MathPiper function that
         // creates a double list of factors and their multiplicities
    /*
     *  Now we check whether the input polynomial is "over the 
     *  integers", by examining all its coefficients
     */
    coeffs := Coef(p,x,0 .. Degree(p,x));
    If( AllSatisfy("IsInteger",coeffs),
        [
            // Yes -- all integer coefficients
            result := FactorsPolynomialOverIntegers(p,x);
        ],
        [
            // No -- at least one non-integer coefficient
            // Check for FLOAT or RATIONAL coefficients
            Local(notInt,rat,dd,lcm,newCoeffs,newPoly,facs);
            notInt := Select(Lambda({i},Not IsInteger(i)),coeffs);
            rat := Rationalize(coeffs);            
            dd  := MapSingle("Denominator",rat);
            lcm := Lcm(dd);
            newCoeffs := lcm * rat;
            newPoly := NormalForm(UniVariate(x,0,newCoeffs));
            facs := FactorsPolynomialOverIntegers(newPoly);
            If( InVerboseMode(), [
                  Echo("coeffs ",coeffs);
                  Echo("notInt ",notInt);
                  Echo("rat ",rat);
                  Echo("dd  ",dd);
                  Echo("lcm ",lcm);
                  Echo("newCoeffs ",newCoeffs);
                  Echo("newPoly ",newPoly);
                  Echo("facs ",facs);
                ]
              );
            result := {(1/lcm),1}:facs;
            // TODO:  NEEDS MORE POLISHING
        ]
      );
];


30 # Factors(p_CanBeUni) <--  
[
    /* 
     * This may be a multi-variate polynomial, or it may be something else.
     * Original YY function Factors() did not attempt to factor such.
     *    If it is a multivariate polynomial, we will try certain
     * Special cases which we can relatively easily factor.
     *    If it is "something else", we will have to check, on a
     * case-by-case basis.
     */
    Local(nvars);
    nvars := Length(VarList(p));
    If (nvars > 1, 
         [
            Echo("special ",p);
            Echo(Coef(p,x,0 .. 8));
            FactorsMultivariateSpecialCases(p);
         ], 
            FactorsSomethingElse(p) 
       );
];


40 # Factors(_p) <--
[
    /*
     * This may may be a polynomial with non-integer exponents.
     */
     //Echo(40,p);
     //  TODO:  NOT IMPLEMENTED YET
     {{p,1}};
     
];

//------------------------------------------------------------------------
//                    S P E C I A L     C A S E S
//------------------------------------------------------------------------

10 # FactorsMultivariateSpecialCases(x_IsAtom + y_IsAtom) <-- {{x+y,1}};

10 # FactorsMultivariateSpecialCases(x_IsAtom - y_IsAtom) <-- {{x-y,1}};

10 # FactorsMultivariateSpecialCases(_n*_x + _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x+y);

10 # FactorsMultivariateSpecialCases(_n*_x - _n*_y) <-- {n,1}:FactorsMultivariateSpecialCases(x-y);

10 # FactorsMultivariateSpecialCases(_x^2-_y^2) <-- {{x+y,1},{x-y,1}};

10 # FactorsMultivariateSpecialCases(_x^3-_y^3) <-- {{x-y,1},{x^2+y*x+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^3+_y^3) <-- {{x+y,1},{x^2-y*x+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^4-_y^4) <-- {{x+y,1},{x-y,1},{x^2+y^2,1}};

10 # FactorsMultivariateSpecialCases(_x^6-_y^6) <-- {{x+y,1},{x-y,1},{x^2+x*y+y^2,1},{x^2-x*y+y^2,1}};

20 # FactorsSomethingElse(_p) <-- p;

//------------------------------------------------------------------------

%/mathpiper







%mathpiper_docs,name="Factors",categories="User Functions;Number Theory"
*CMD Factors --- factorization
*STD
*CALL
	Factors(x)

*PARMS

{x} -- integer or univariate polynomial

*DESC

This function decomposes the integer number {x} into a product of
numbers. 
Alternatively, if {x} is a univariate polynomial, it is
decomposed into irreducible polynomials.  If {x} is a polynomial
"over the integers", the irreducible polynomial factors will also
be returned in the (unique) form with integer coefficients.

The factorization is returned as a list of pairs. The first member of
each pair is the factor, while the second member denotes the power to
which this factor should be raised. So the factorization
$x = p1^n1 * ... * p9^n9$
is returned as {{{p1,n1}, ..., {p9,n9}}}.

Programmer: Yacas Team + Sherm Ostrowsky

*E.G.
    In> Factors(24)
    Result: {{2,3},{3,1}}
    
    In> Factors(32*x^3+32*x^2-70*x-75)
    Result: {{4*x+5,2},{2*x-3,1}}

*SEE Factor, IsPrime, GaussianFactors

%/mathpiper_docs


