%mathpiper
Retract("GeoGebraPlot",*);
//MacroRuleBase("GeoGebraPlot",{function});
//HoldArg("GeoGebraPlot",function);

RuleBaseListed("GeoGebraPlot",{arg1,arg2});


5 # GeoGebraPlot(_arg1) <-- GeoGebraPlot(arg1,{});

20 # GeoGebraPlot(function_IsFunction, options_IsList)_(Not IsList(function)) <--
[
    function2 := (Subst(==,=) function);
    
    command := ConcatStrings(ToString()Write(function2));
    
    JavaCall("geogebra","evalCommand",command);
];


10 # GeoGebraPlot(list_IsList, options_IsList)_(IsEven(Length(list)And IsNumericList(list)) )  <--
[
    Write(options);
    Local();
    length := Length(list);
    index := 1;
    labelIndex := 1;
    template := "<element type=\"point\" label=\"A<?Write(labelIndex)?>\"> <show object=\"true\" label=\"false\"/><objColor r=\"0\" g=\"0\" b=\"255\" alpha=\"0.0\"/>	<layer val=\"0\"/>	<animation step=\"0.1\" speed=\"1\" type=\"0\" playing=\"false\"/>	<coords x=\"<?Write(x)?>\" y=\"<?Write(y)?>\" z=\"1.0\"/>	<pointSize val=\"3\"/></element>";

    
    While(index < length+1)
    [
        x := list[index];
        index++;
        y := list[index];
        index++;
        
        
        code := PatchString(template);
        Echo(code);
        //JavaCall("geogebra","evalXML",code);
       
        labelIndex++;
    ];

];


5 # GeoGebraPlot(list_IsList, options_IsList)_(IsMatrix(IsInteger,list)) <--
[
    flatList := {};
    
    ForEach(subList,list)
    [
        DestructiveAppend(flatList,subList[1]);
        DestructiveAppend(flatList, subList[2]);
    ];
    
    GeoGebraPlot(flatList);

];

HoldArg("GeoGebraPlot",arg2);

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output








%mathpiper
Retract("GeoGebraPoint",*);

10 # GeoGebraPoint(name_IsString, x_IsNumber, y_IsNumber)  <--
[
    command := PatchString("<?Write(Atom(name))?>=(<?Write(x)?>,<?Write(y)?>)");
    
    JavaCall("geogebra","evalCommand",command);
];

%/mathpiper







%mathpiper

// Histogram[{1, 2, 3, 4},{1.0, 1.1, 1.1, 1.2, 1.7, 2.2, 2.5, 4.0}]
GeoGebraHistogram(classBoundaries, data) := 
[
    //todo:tk: a check must be made to make sure that all data items fit into the class boundaries.
    // If they don't, GeoGebra will not accept them.
    
    command := PatchString("Histogram[<?Write(classBoundaries)?>,<?Write(data)?>]");
    JavaCall("geogebra", "evalCommand", command);
];
%/mathpiper





//************************************************************************************************



%mathpiper,output="trace"


TraceSome("GeoGebraPlot", GeoGebraPlot({5,5,10,10},test1=3,test2));

%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: True
      
      Side Effects:
      Enter<**** user rulebase>{(GeoGebraPlot, GeoGebraPlot({5,5,10,10},{test1=3,test2}));
          (User Function Call Stack: <START>, )
          Arg(arg1 -> {5,5,10,10});
          Arg(arg2 -> {test1=3,test2});
          **** Rule in function (GeoGebraPlot) matched: Precedence: 10, Parameters: arg1<hold=false>, arg2<hold=true>, Predicates: (Pattern) IsList(list), IsList(options), IsEven(Length(list)AndIsNumericList(list)),     Variables: list, options,     Types: Variable, Variable,    Body: [    Write(options);    Local();    length:=Length(list);    index:=1;    labelIndex:=1;    template:="<element type="point" label="A<?Write(labelIndex)?>"> <show object="true" label="false"/><objColor r="0" g="0" b="255" alpha="0.0"/>	<layer val="0"/>	<animation step="0.1" speed="1" type="0" playing="false"/>	<coords x="<?Write(x)?>" y="<?Write(y)?>" z="1.0"/>	<pointSize val="3"/></element>";    While(index<length+1)[        x:=list[index];        index++;        y:=list[index];        index++;        code:=PatchString(template);        Echo(code);        labelIndex++;];]
      {test1=3,test2}<element type="point" label="A1"> <show object="true" label="false"/><objColor r="0" g="0" b="255" alpha="0.0"/>	<layer val="0"/>	<animation step="0.1" speed="1" type="0" playing="false"/>	<coords x="5" y="5" z="1.0"/>	<pointSize val="3"/></element>
      <element type="point" label="A2"> <show object="true" label="false"/><objColor r="0" g="0" b="255" alpha="0.0"/>	<layer val="0"/>	<animation step="0.1" speed="1" type="0" playing="false"/>	<coords x="10" y="10" z="1.0"/>	<pointSize val="3"/></element>
      Leave<**** user rulebase>}(GeoGebraPlot({5,5,10,10},{test1=3,test2}) -> True,    Local variables: options -> (List (= test1 3 )test2 ), list -> (List 5 5 10 10 ), arg2 -> (List (= test1 3 )test2 ), arg1 -> (List 5 5 10 10 ), );
.   %/mathpiper_trace





%mathpiper
classBoundaries := N(Table(x,x,14,20,1/4));

E := N({16+3/8, 16+3/8, 17+1/8, 16, 14+3/8, 17+1/4, 16+5/8, 16, 17, 17+1/4, 17, 15+7/8, 16+5/8, 16+1/8, 17+1/8, 16+7/8, 16+3/8, 16+3/8, 16+7/8, 17+1/8, 17, 16+3/4, 17+1/4, 17+1/8, 15+3/8});

D := N({18+1/4, 19+1/4, 18+1/4, 15+5/8, 17+5/8, 17+1/2, 17+1/8, 17+1/8, 17+1/2, 14+1/2, 17+3/8, 16+7/8, 17+3/4, 18+7/8, 14+7/8, 19+1/4, 18+1/8, 16+1/4, 16+1/8, 16+3/4, 17+1/4, 17+3/8, 17+1/8, 17+1/2, 16+5/8});
GeoGebraHistogram(classBoundaries,Concat(D,E));


%/mathpiper








