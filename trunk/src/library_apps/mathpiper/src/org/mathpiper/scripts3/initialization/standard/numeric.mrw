%mathpiper,def="N;NonN;InNumericMode"

//"+-;/-;*-;^-;:=-;:=+" These were in the def list.

/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */







/* Implementation of numeric mode */
LocalSymbols(numericMode)
[

  Set(numericMode, False);


  // N function: evaluate numerically with given precision.
  LocalSymbols(previousNumericMode, previousPrecision, numericResult) Macro("N",{expression, precision})
  [ 
    // we were in non-numeric mode

    Local(previousNumericMode, previousPrecision, numericResult, errorString);

    Set(previousPrecision, BuiltinPrecisionGet());

    BuiltinPrecisionSet(@precision);

    AssignCachedConstantsN();

    Set(previousNumericMode, numericMode);

    Set(numericMode, True);

    Set(errorString,"");

    TrapError(Set(numericResult, Eval(@expression)),Set(errorString,GetCoreError()));

    Set(numericMode,previousNumericMode);

    If(Not numericMode,
    [
        // clear constants
        ClearCachedConstantsN();
    ]);

    BuiltinPrecisionSet(previousPrecision);

    Check(errorString="",errorString);

    numericResult;

  ];




  // N function: evaluate numerically with default precision.
  LocalSymbols(precision,heldExpression) Macro("N",{expression})
  [
    Local(precision, heldExpression);

    Set(precision, BuiltinPrecisionGet());

    Set(heldExpression, Hold(@expression));

    `N(@heldExpression, @precision);
  ];





  // NoN function.
  LocalSymbols(result) Macro("NonN",{expression})
  [
    Local(result);

    GlobalPush(numericMode);

    numericMode := False;

    result := (@expression);

    numericMode := GlobalPop();

    result;
  ];


  // InNumericMode function.
  Function("InNumericMode",{}) numericMode;



]; //LocalSymbols(numericMode)






%/mathpiper






%mathpiper_docs,name="N",categories="User Functions;Numbers (Operations)"
*CMD N --- try to determine an numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {MathPiper} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make MathPiper
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only 
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Pi
%/mathpiper_docs








%mathpiper_docs,name="InNumericMode;NonN"
*CMD InNumericMode --- determine if currently in numeric mode
*CMD NonN --- calculate part in non-numeric mode

*STD
*CALL
	NonN(expr)
	InNumericMode()
*PARMS

{expr} -- expression to evaluate

{prec} -- integer, precision to use

*DESC

When in numeric mode, {InNumericMode()} will return {True}, else it will
return {False}. {MathPiper} is in numeric mode when evaluating an expression
with the function {N}. Thus when calling {N(expr)}, {InNumericMode()} will
return {True} while {expr} is being evaluated.

{InNumericMode()} would typically be used to define a transformation rule 
that defines how to get a numeric approximation of some expression. One
could define a transformation rule

	f(_x)_InNumericMode() <- [... some code to get a numeric approximation of f(x) ... ];

{InNumericMode()} usually returns {False}, so transformation rules that check for this
predicate are usually left alone.

When in numeric mode, {NonN} can be called to switch back to non-numeric
mode temporarily.

{NonN} is a macro. Its argument {expr} will only 
be evaluated after the numeric mode has been set appropriately.

*E.G.

	In> InNumericMode()
	Out> False
	In> N(InNumericMode())
	Out> True
	In> N(NonN(InNumericMode()))
	Out> False

*SEE N, BuiltinPrecisionSet, BuiltinPrecisionGet, Pi, CachedConstant
%/mathpiper_docs
