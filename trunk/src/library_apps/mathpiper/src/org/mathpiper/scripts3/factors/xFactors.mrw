%mathpiper,def="xFactors"


Retract("xFactors",*);
Retract("xFactorsMultivariateSpecialCases",*);
Retract("xFactorsSomethingElse",*);
//Retract("CombineNumericalFactors",*);
//Retract("CommonMonomialFactors",*);
//Retract("MakeUniPoly",*);
//Retract("HeuristicUniPoly",*);


/*
 * This is the fundamental factorization algorithm.
 * It works for integers, rational numbers, Gaussian integers, and polynomials
 * When the argument is an integer, FactorizeInt() does the heavy lifting.
 * When the argument is a polynomial, BinaryFactors() is the workhorse.
 */
 

10 # xFactors(p_IsPositiveInteger) <--  
[
    If( p < 1600, xFactorsSmallInteger(p), FactorizeInt(p) );
];

11 # xFactors(p_IsInteger) <-- 
[
    If( (-p) < 1600, xFactorsSmallInteger(-p), FactorizeInt(-p) );
];

12 # xFactors(p_IsRational)_(Denominator(p) != 1) <-- {{Factor(Numerator(p)) /Factor(Denominator(p)) , 1}}; 
     //Added to handle rational numbers with denominators that are not 1

     
14 # xFactors(p_IsGaussianInteger)	<-- GaussianxFactors(p);


16 # xFactors( _x^n_IsPositiveInteger ) <-- {x,n};


18 # xFactors( L_IsList ) <-- xFactors /@ L;


20 # xFactors(p_CanBeUni)_(Length(VarList(p)) = 1) <--  
[
    If(InVerboseMode(),Tell("xFactors__uni",p));
    Local(x,d,comMonFacs,coeffs,nterms,FactorsList,result);
    x := VarList(p)[1];
    d := Degree(p,x);
    /*  p is the polynomial, x is its (only) variable.  It IS Univariate */
    
    /* First, remove any common monomial Factors  */
    //comMonFacs := CommonMonomialFactors(p,x);
    //comMonFacs := xContents(p);
    //Tell("  com mon facs",comMonFacs);
    //monFacList := {};
    //If( comMonFacs != {},
    //  [
    //      monFacList := comMonFacs;
    //      Tell("    1",comMonFacs);
    //      p := Simplify( p / comMonFacs[1][1] );
    //      Tell("  1new_p",p);
    //  ]
    //);
    
    /*  Let's find out how many terms this polynomial has.               */
    coeffs := Coef(p,x,0 .. d);
    nterms := Length(Select("IsNotZero",coeffs));
    If(InVerboseMode(),Tell("   ",{nterms,d}));
    /*  If nterms = 2, it is a binomial, and might be most easily
     *  factored by some special-purpose algorithms                      */
    If( nterms = 2 And d > 2, 
      [  result := FactorsBinomials(p);  ],    
      [  // nterms != 2, so try other techniques
         // BinaryFactors is the internal MathPiper function that
         // creates a double list of Factors and their multiplicities
        FactorsList := BinaryFactors(p);
        If(InVerboseMode(),Tell("   ",FactorsList));
        Lf := Length(FactorsList);
        ForEach( f, FactorsList )
        [
             f := NormalForm(f);
             Tell("      ",f);   
        ];
        Tell(HERE);
        /*
         *  Now we check whether the input polynomial is "over the 
         *  integers", by examining all its coefficients
         */
        If( AllSatisfy("IsInteger",coeffs),
          [
              // Yes -- all integer coefficients
              result := xFactorsPolynomialOverIntegers(p,x);
              If(InVerboseMode(),Tell("   Over Integers ",result));
          ],
          [
              // No -- at least one non-integer coefficient
              // Check for FLOAT or RATIONAL coefficients
              Local(notInt,rat,dd,lcm,newCoeffs,NewPoly,facs);
              notInt := Select(Lambda({i},Not IsInteger(i)),coeffs);
              rat := Rationalize(coeffs);            
              dd  := MapSingle("Denominator",rat);
              lcm := Lcm(dd);
              newCoeffs := lcm * rat;
              newPoly := NormalForm(UniVariate(x,0,newCoeffs));
              facs := xFactorsPolynomialOverIntegers(newPoly);
              If( InVerboseMode(), [
                  Echo("coeffs ",coeffs);
                  Echo("notInt ",notInt);
                  Echo("rat ",rat);
                  Echo("dd  ",dd);
                  Echo("lcm ",lcm);
                  Echo("newCoeffs ",newCoeffs);
                  Echo("newPoly ",newPoly);
                  Echo("facs ",facs);
                 ]
              );
              result := {(1/lcm),1}:facs;
              //NOT FINISHED YET
        ]
      );
    ]
   );
   If(InVerboseMode(),Tell(" ",result));
   residual := Simplify(p/FW(result));
   If(InVerboseMode(),Tell(" ",residual));
   nrr := If(IsConstant(residual),0,NumRealRoots(residual));
   If(InVerboseMode(),Tell(" ",nrr));
   DestructiveAppend(result,{residual,1});
   CombineNumericalFactors( result );
];


30 # xFactors(p_CanBeUni) <--  
[
    /* 
     * This may be a multi-variate polynomial, or it may be something else.
     * Original YT function Factors() did not attempt to factor such.
     *    If it is a multivariate polynomial, we will try certain
     * Special cases which we can relatively easily factor.
     *    If it is "something else", we will have to check, on a
     * case-by-case basis.
     */
    Local(vl,nvars,coeffs,result);
    If(InVerboseMode(),Tell("xFactors__maybeMulti",p));
    /*  --12/14/09 --  
    // First, remove any common monomial Factors
    comMonFacs := V(CommonMonomialFactors(p));
    //comMonFacs := xContents(p);
    If(InVerboseMode(),Tell("  com mon facs",comMonFacs));
    monFacList := {};
    If( comMonFacs != {},
      [
          p := Simplify( p / comMonFacs );
          If(InVerboseMode(),Tell("  2new_p",p));
          monFacList := comMonFacs;
          If(InVerboseMode(),Tell("   ",comMonFacs));
      ]
    );
*/

    vl     := VarList(p);
    nvars  := Length(vl);
    coeffs := Coef(p,x,0 .. 8);
    If(InVerboseMode(),Tell("CBU",{vl,nvars,coeffs}));
    If (nvars > 1, 
         [
            If( InVerboseMode(), Echo(" special ",p));
            result := xFactorsMultivariateSpecialCases(p);
         ], 
            //result := xFactorsSomethingElse(p) 
            result := xFactors(p) 
       );
       CombineNumericalFactors( result );
];


40 # xFactors(_p) <--
[
    /*
     * This may may be a polynomial with non-integer exponents.  Let's check.
     */
     If( InVerboseMode(), Echo("Possibly trying to factor polynomial with non-integral exponents") );
     Local( result);
     //Echo(40,p);
     //  NOT IMPLEMENTED YET
     result := {{p,1}};
     CombineNumericalFactors( result );
     
];

//------------------------------------------------------------------------
//                    S P E C I A L     C A S E S
//------------------------------------------------------------------------

10 # xFactorsMultivariateSpecialCases(-_expr) <-- {-1,1}:xFactorsMultivariateSpecialCases(expr);

10 # xFactorsMultivariateSpecialCases(x_IsAtom + y_IsAtom) <-- [If(InVerboseMode(),Tell(1));{{x+y,1}};];

10 # xFactorsMultivariateSpecialCases(x_IsAtom - y_IsAtom) <-- [If(InVerboseMode(),Tell(2));{{x-y,1}};];

10 # xFactorsMultivariateSpecialCases(_n*_x^p_IsInteger + _n*_y) <-- [If(InVerboseMode(),Tell(3));{n,1}:xFactorsMultivariateSpecialCases(x+y);];

10 # xFactorsMultivariateSpecialCases(_n*_x^p_IsInteger - _n*_y) <-- [If(InVerboseMode(),Tell(4));{n,1}:xFactorsMultivariateSpecialCases(x-y);];

10 # xFactorsMultivariateSpecialCases(n_IsInteger*_x + m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x+m*y)/Gcd(n,m))),1}};

10 # xFactorsMultivariateSpecialCases(n_IsInteger*_x - m_IsInteger*_y)_(Gcd(n,m)>1) <-- {{Gcd(n,m),1},{(Simplify((n*x-m*y)/Gcd(n,m))),1}};

10 # xFactorsMultivariateSpecialCases(_n*_x + _n*_y) <-- {n,1}:xFactorsMultivariateSpecialCases(x+y);

10 # xFactorsMultivariateSpecialCases(_n*_x - _n*_y) <-- {n,1}:xFactorsMultivariateSpecialCases(x-y);

10 # xFactorsMultivariateSpecialCases(_x^n_IsInteger - _y) <-- xFactorsBinomials(x^n - y); 

10 # xFactorsMultivariateSpecialCases(_x^n_IsInteger + _y) <-- xFactorsBinomials(x^n + y); 

10 # xFactorsMultivariateSpecialCases(_x^2+2*_x*_y+_y^2) <-- {{x+y,2}};

10 # xFactorsMultivariateSpecialCases(_x^2-2*_x*_y+_y^2) <-- {{x-y,2}};

20 # xFactorsSomethingElse(_p) <-- 
  [
      If( InVerboseMode(),
          [
              ECHO("   *** xFactorsSomethingElse: NOT IMPLEMENTED YET ***");
          ]
      );
      p;
  ];

//------------------------------------------------------------------------

/*
10 # CombineNumericalFactors( factrs_IsList ) <--
  [
      If( InVerboseMode(), Tell("Combine",factrs) );
      Local(q,a,b,t,f,err);
      err := False;
      t   := 1;
      f   := {};
      ForEach(q,factrs)
      [
          If( InVerboseMode(), Tell(1,q) );
          If( IsList(q) And Length(q)=2,
              [
                  {a,b} := q;
                  If( InVerboseMode(), Echo("     ",{a,b}) );
                  If( IsNumericList( {a,b} ),
                      t := t * a^b,
                      f := {a,b}:f
                  );
              ],
              err := True
          );
      ];
      If( InVerboseMode(),
        [
            Echo("      t = ",t);
            Echo("      f = ",f);
            Echo("    err = ",err);
        ]
      );
      If(Not err And t != 1, {t,1}:Reverse(f), factrs);
  ];
  */

//------------------------------------------------------------------------

/*
10 # CommonMonomialFactors( _expr )_(IsUniVar(expr)) <--
[
    If(InVerboseMode(),Tell("CommonMonomialFactors",expr));
    Local(coeffs,ii,cf,rr);
    coeffs := Remove( expr[3], 0 );
    If(InVerboseMode(),Tell("  ",coeffs));
    ForEach(ii,1 .. Length(coeffs))
    [
        c := coeffs[ii];
        If( Type(c)="-", coeffs[ii] := -c );
    ];
    cf:=MapSingle(Lambda({s},Flatten(s,"*")),coeffs);  
    If(InVerboseMode(),Tell("  ",cf));
    facs3 := {};
    If( AllSatisfy( "IsInteger", coeffs ),
      [
         Tell("      all remaining coefficients are numbers");
      ],
      [
         Tell("      some coefficients are compound");
         ForEach(c,cf)
         [
            facs := {};
            Tell("   ",Length(c));
            ForEach(t,c)
            [
                If(IsInteger(t),
                    DestructiveAppend(facs,FactorsSmallInteger(t)),
                    DestructiveAppend(facs,{t,1})
                 );
            ];
            Tell("     ",facs);
            ffacs := Flatten(facs,"List");
            Tell("     ",ffacs);        
            facs2 := {};
            For(ii:=1,ii<=Length(ffacs),ii:=ii+2)
            [
                Tell("          ",{ffacs[ii],ffacs[ii+1]});
                DestructiveAppend(facs2,FillList(ffacs[ii],ffacs[ii+1]));
            ];
            facs2 := Flatten(facs2,"List");
            Tell("      ",facs2);
            If(facs2!={},DestructiveAppend(facs3,facs2));
            rr := Intersection(facs3);
            If(InVerboseMode(),Tell("  ",rr));
            UnFlatten(rr,"*",1);
          ];
      ]
    );
];

11 # CommonMonomialFactors( expr_CanBeUni, _var) <--
[
    If(InVerboseMode(),Tell("CommonMonomialFactors_2",expr));
    Local(uniPoly,coeffs,vars,gcd);
    uniPoly := MakeUniPoly(expr,var);
    rr := CommonMonomialFactors(uniPoly);
];

12 # CommonMonomialFactors( expr_CanBeUni) <--
[
    If(InVerboseMode(),Tell("CommonMonomialFactors_3",expr));
    Local(uniPoly,coeffs,vars,gcd);
    uniPoly := HeuristicUniPoly(expr);
    rr := CommonMonomialFactors(uniPoly);
];
*/

/*
10 # MakeUniPoly( _expr, _var )_CanBeUni(expr,var) <-- 
[
    If(InVerboseMode(),Tell("MakeUniPoly_given_var",{expr,var}));
    Local(uniPolynomial);
    uniPolynomial := MakeUni(expr,var);
];
*/

/*
10 # HeuristicUniPoly( _expr ) <-- 
[
    If(InVerboseMode(),Tell("HeuristicUniPoly_infer_var",expr));
    Local(uniPolynomial,vars,var);
    vars := VarList(expr);
    If(Length(vars)>1,vars:=HeapSort(vars,"GreaterThan"));    
    var := vars[1];
    If(InVerboseMode(),Tell("  ",{vars,var}));
    uniPolynomial := MakeUniPoly(expr,var);
];
*/

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output






%mathpiper_docs,name="xFactors",categories="User Functions;Number Theory"
*CMD xFactors --- factorization
*STD
*CALL
	xFactors(x)

*PARMS

{x} -- integer or univariate polynomial

*DESC

This function decomposes the integer number {x} into a product of
numbers. 
Alternatively, if {x} is a univariate polynomial, it is
decomposed into irreducible polynomials.  If {x} is a polynomial
"over the integers", the irreducible polynomial Factors will also
be returned in the (unique) form with integer coefficients.

The factorization is returned as a list of pairs. The first member of
each pair is the factor, while the second member denotes the power to
which this factor should be raised. So the factorization
$x = p1^n1 * ... * p9^n9$
is returned as {{{p1,n1}, ..., {p9,n9}}}.

Programmer: Yacas Team + Sherm Ostrowsky

*E.G.
    In> xFactors(24)
    Result: {{2,3},{3,1}}
    
    In> xFactors(32*x^3+32*x^2-70*x-75)
    Result: {{4*x+5,2},{2*x-3,1}}

*SEE Factor, IsPrime, GaussianFactors
%/mathpiper_docs





