%mathpiper,def="CheckSolution"

Retract("CheckSolution",*);
Retract("CloseEnough",*);

10 # CloseEnough(_expr1,_expr2,_prec) <--
  [
      If(iDebug=True,Tell("CloseEnough",{expr1,expr2,prec}));
      Local(diff,ndiff,ncomp,result);
      diff := expr1 - expr2;
      If(diff != 0 And HasFunc(expr1,Sqrt), diff := RadSimp(expr1-expr2));
      If(diff != 0, diff := Simplify(expr1-expr2));      
      If(iDebug=True,Tell("  ce1",diff));
      If(diff=0,
          result:=True,
          [
              ndiff := Abs(N(diff,prec+1));
              ncomp := N(10^(-prec),prec);
              If(iDebug=True,Tell("  ce2",{ndiff,ncomp,ndiff/ncomp}));
              If(ndiff/ncomp<1,result:=True,result:=False);
          ]
      );
      result;
  ];
  

10 # CheckSolution( exprs_IsList, _var, solutions_IsList ) <--
  [
      If(iDebug=True,Tell("CheckSolutionL",{exprs,var,solutions}));
      Local(tests);
      
      tests := Subst(==,Atom("-")) (exprs Where solutions);
      If(iDebug,Tell("  1",tests));
      tests := AllSatisfy("IsZero",tests);
  ];

  
12 # CheckSolution( _expr, _var, solution_IsList ) <--
  [
      If(iDebug=True,Tell("CheckSolution1",{expr,var,solution}));
      Local(expr0,result,s,r);
      If( IsEquation(expr),
          Set(expr0,EquationLeft(expr)-EquationRight(expr)),
          Set(expr0,expr)
      );
      result := {};
      ForEach(s,solution) 
        [
            If(iDebug=True,Tell("  cs1",s));
            r := ( expr0 Where s );
            If(iDebug=True,Tell("    cs2",{expr0,r}));
            If(r=0,Push(result,s),If(CloseEnough(r,0,10),Push(result,s)));
        ];
        If(iDebug=True,Tell("  cs4",result)); 
        Reverse(result);
  ];
  
  
20 # CheckSolution( _expr, _var, _solution ) <-- False;

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output





%mathpiper_docs,name="CheckSolution",categories="User Functions;Solve"

*CMD CheckSolution --- Check the validity of solutions returned by the {Solve} function.
*STD
*CALL
	CheckSolution(expr,var,solution)

*PARMS

{expr}     -- a mathematical expression
{var}      -- a varible identifier
{solution} -- a List containing solutions to the equation.


*DESC

The function {Solve} will attempt to find solutions to the equation
{expr}, if {expr} is an actual equatio), or to the equivalent equation
represented by {expr==0} if {expr} is NOT an equation.

Solutions returned by {Solve} will be in the form of a List, such as
{{var==something,var==something_else}}.

For certain types of expressions or equation, {Solve} might return
invalid solutions as well as valid ones in the output List.  To check
the list of solutions, call the function CheckSolutions().  This function
will return a list containing only the valid solutions from among those
in the list (if any).  If none of the "solutions" is valid, this 
function will return the empty list.

*E.G.

In> ss1 := Solve(x^2==4,x)

Result: {x==2,x==(-2)}

In> CheckSolution(x^2==4,x,ss1)

Result: {x==2,x==(-2)}

In> CheckSolution(x^2==4,x,{x==2,x==3})   // Deliberately incorrect

Result: {x==2}

%/mathpiper_docs



