%mathpiper_docs,name="FromBase;ToBase"
*CMD FromBase --- conversion of a number from non-decimal base to decimal base
*CMD ToBase --- conversion of a number in decimal base to non-decimal base
*CORE
*CALL
	FromBase(base,"string")
	ToBase(base, number)

*PARMS

{base} -- integer, base to convert to/from

{number} -- integer, number to write out in a different base

{"string"} -- string representing a number in a different base

*DESC

In Yacas, all numbers are written in decimal notation (base 10).
The two functions {FromBase}, {ToBase} convert numbers between base 10 and a different base.
Numbers in non-decimal notation are represented by strings.

{FromBase} converts an integer, written as a string in base
{base}, to base 10. {ToBase} converts {number},
written in base 10, to base {base}.

*REM where is this p-adic capability? - sw
These functions use the p-adic expansion capabilities of the built-in
arbitrary precision math libraries.

Non-integer arguments are not supported.

*E.G.

Write the binary number {111111} as a decimal number:

	In> FromBase(2,"111111")
	Out> 63;

Write the (decimal) number {255} in hexadecimal notation:

	In> ToBase(16,255)
	Out> "ff";

*SEE PAdicExpand
%/mathpiper_docs



%mathpiper_docs,name="MaxEvalDepth"
*CMD MaxEvalDepth --- set the maximum evaluation depth
*CORE
*CALL
	MaxEvalDepth(n)

*PARMS

{n} -- new maximum evaluation depth

*DESC

Use this command to set the maximum evaluation depth to the integer
"n". The default value is 1000. The function {MaxEvalDepth} returns {True}.

The point of having a maximum evaluation depth is to catch any
infinite recursion. For example, after the definition {f(x) := f(x)}, evaluating the expression {f(x)} would call {f(x)}, which would
call {f(x)}, etc. The interpreter will halt if
the maximum evaluation depth is reached. Also indirect recursion, e.g.
the pair of definitions {f(x) := g(x)} and {g(x) := f(x)}, will be caught.

*E.G. notest

An example of an infinite recursion, caught because the maximum
evaluation depth is reached.

	In> f(x) := f(x)
	Out> True;
	In> f(x)
	Error on line 1 in file [CommandLine]
	Max evaluation stack depth reached.
	Please use MaxEvalDepth to increase the stack
	size as needed.

However, a long calculation may cause the maximum evaluation depth to
be reached without the presence of infinite recursion. The function {MaxEvalDepth} is meant for these cases.

	In> 10 # g(0) <-- 1;
	Out> True;
	In> 20 # g(n_IsPositiveInteger) <-- \
	  2 * g(n-1);
	Out> True;
	In> g(1001);
	Error on line 1 in file [CommandLine]
	Max evaluation stack depth reached.
	Please use MaxEvalDepth to increase the stack
	size as needed.
	
	In> MaxEvalDepth(10000);
	Out> True;
	In> g(1001);
	Out> 21430172143725346418968500981200036211228096234
	1106721488750077674070210224987224498639675763139171
	6255189345835106293650374290571384628087196915514939
	7149607869135549648461970842149210124742283755908364
	3060929499671638825347975351183310878921541258291423
	92955373084335320859663305248773674411336138752;
%/mathpiper_docs



%mathpiper_docs,name="Hold"
*CMD Hold --- keep expression unevaluated
*CORE
*CALL
	Hold(expr)

*PARMS

{expr} -- expression to keep unevaluated

*DESC

The expression "expr" is returned unevaluated. This is useful to
prevent the evaluation of a certain expression in a context in which
evaluation normally takes place.

The function {UnList()} also leaves its result unevaluated. Both functions stop the process of evaluation (no more rules will be applied).

*E.G. notest

	In> Echo({ Hold(1+1), "=", 1+1 });
	 1+1 = 2
	Out> True;

*SEE Eval, HoldArg, UnList
%/mathpiper_docs



%mathpiper_docs,name="Eval"
*CMD Eval --- force evaluation of expression
*CORE
*CALL
	Eval(expr)

*PARMS

{expr} -- expression to evaluate

*DESC

This function explicitly requests an evaluation of the expression
"expr", and returns the result of this evaluation.

*E.G.

	In> a := x;
	Out> x;
	In> x := 5;
	Out> 5;
	In> a;
	Out> x;
	In> Eval(a);
	Out> 5;

The variable {a} is bound to {x},
and {x} is bound to 5. Hence evaluating {a} will give {x}. Only when an extra
evaluation of {a} is requested, the value 5 is
returned.

Note that the behavior would be different if we had exchanged the
assignments. If the assignment {a := x} were given
while {x} had the value 5, the variable {a} would also get the value 5 because the assignment
operator {:=} evaluates the right-hand side.

*SEE Hold, HoldArg, :=
%/mathpiper_docs



%mathpiper_docs,name="While"
*CMD While --- loop while a condition is met
*CORE
*CALL
	While(pred) body

*PARMS

{pred} -- predicate deciding whether to keep on looping

{body} -- expression to loop over

*DESC

Keep on evaluating "body" while "pred" evaluates to {True}. More precisely, {While}
evaluates the predicate "pred", which should evaluate to either {True} or {False}. If the result is {True}, the expression "body" is evaluated and then
the predicate "pred" is again evaluated. If it is still {True}, the expressions "body" and "pred" are again
evaluated and so on until "pred" evaluates to {False}. At that point, the loop terminates and {While}
returns {True}.

In particular, if "pred" immediately evaluates to {False}, the body is never executed. {While} is the fundamental looping construct on which
all other loop commands are based. It is equivalent to the {while} command in the programming language C.

*E.G. notest

	In> x := 0;
	Out> 0;
	In> While (x! < 10^6) \
	  [ Echo({x, x!}); x++; ];
	 0  1
	 1  1
	 2  2
	 3  6
	 4  24
	 5  120
	 6  720
	 7  5040
	 8  40320
	 9  362880
	Out> True;

*SEE Until, For
%/mathpiper_docs



%mathpiper_docs,name="If"
*CMD If --- branch point
*CORE
*CALL
	If(pred, then)
	If(pred, then, else)

*PARMS

{pred} -- predicate to test

{then} -- expression to evaluate if "pred" is {True}

{else} -- expression to evaluate if "pred" is {False}

*DESC

This command implements a branch point. The predicate "pred" is
evaluated, which should result in either {True} or {False}. In the first case, the expression "then" is
evaluated and returned. If the predicate yields {False}, the expression "else" (if present) is evaluated and
returned. If there is no "else" branch (i.e. if the first calling
sequence is used), the {If} expression returns {False}.

*E.G.

The sign function is defined to be 1 if its argument is positive and
-1 if its argument is negative. A possible implementation is
	In> mysign(x) := If (IsPositiveReal(x), 1, -1);
	Out> True;
	In> mysign(Pi);
	Out> 1;
	In> mysign(-2.5);
	Out> -1;
Note that this will give incorrect results, if "x" cannot be
numerically approximated.
	In> mysign(a);
	Out> -1;
Hence a better implementation would be
	In> mysign(_x)_IsNumber(N(x)) <-- If \
	  (IsPositiveReal(x), 1, -1);
	Out> True;
%/mathpiper_docs



%mathpiper_docs,name=""
*CMD SystemCall --- pass a command to the shell
*CORE
*CALL
	SystemCall(str)

*PARMS

{str} -- string containing the command to call

*DESC

The command contained in the string "str" is executed by the
underlying operating system (OS).
The return value of {SystemCall} is {True} or {False} according to the exit code of the command.

The {SystemCall} function is not allowed in the body of the {Secure} command and will lead to an error.

*E.G. notest

In a UNIX environment, the command {SystemCall("ls")} would print the contents of the current directory.

	In> SystemCall("ls")
	AUTHORS
	COPYING
	ChangeLog
... (truncated to save space)
	Out> True;

The standard UNIX command {test} returns success or failure depending on conditions.
For example, the following command will check if a directory exists:

	In> SystemCall("test -d scripts/")
	Out> True;

Check that a file exists:
	In> SystemCall("test -f COPYING")
	Out> True;
	In> SystemCall("test -f nosuchfile.txt")
	Out> False;

*SEE Secure
%/mathpiper_docs



%mathpiper_docs,name="Use"
*CMD Use --- load a file, but not twice
*CORE
*CALL
	Use(name)

*PARMS

{name} -- name of the file to load

*DESC

If the file "name" has been loaded before, either by an earlier call
to {Use} or via the {DefLoad}
mechanism, nothing happens. Otherwise all expressions in the file are
read and evaluated. {Use} always returns {True}.

The purpose of this function is to make sure that the file will at
least have been loaded, but is not loaded twice.

*SEE Load, DefLoad, DefaultDirectory
%/mathpiper_docs



%mathpiper_docs,name="Subst"
*CMD Subst --- perform a substitution
*STD
*CALL
	Subst(from, to) expr

*PARMS

{from} -- expression to be substituted

{to} -- expression to substitute for "from"

{expr} -- expression in which the substitution takes place

*DESC

This function substitutes every occurrence of "from" in "expr" by
"to". This is a syntactical substitution: only places where "from"
occurs as a subexpression are affected.

*E.G.

	In> Subst(x, Sin(y)) x^2+x+1;
	Out> Sin(y)^2+Sin(y)+1;
	In> Subst(a+b, x) a+b+c;
	Out> x+c;
	In> Subst(b+c, x) a+b+c;
	Out> a+b+c;

The explanation for the last result is that the expression {a+b+c} is internally stored as {(a+b)+c}. Hence {a+b} is a subexpression, but {b+c} is not.

*SEE WithValue, /:
%/mathpiper_docs



%mathpiper_docs,name="TraceStack"
*CMD TraceStack --- show calling stack after an error occurs
*CORE
*CALL
	TraceStack(expression)

*PARMS

{expression} -- an expression to evaluate

*DESC

TraceStack shows the calling stack after an error occurred.
It shows the last few items on the stack, not to flood the screen.
These are usually the only items of interest on the stack.
This is probably by far the most useful debugging function in
Yacas. It shows the last few things it did just after an error
was generated somewhere.

For each stack frame, it shows if the function evaluated was a
built-in function or a user-defined function, and for the user-defined
function, the number of the rule it is trying whether it was evaluating
the pattern matcher of the rule, or the body code of the rule.

This functionality is not offered by default because it slows
down the evaluation code.

*E.G. notest

Here is an example of a function calling itself recursively,
causing Yacas to flood its stack:

	In> f(x):=f(Sin(x))
	Out> True;
	In> TraceStack(f(2))
	Debug> 982 :  f (Rule # 0 in body)
	Debug> 983 :  f (Rule # 0 in body)
	Debug> 984 :  f (Rule # 0 in body)
	Debug> 985 :  f (Rule # 0 in body)
	Debug> 986 :  f (Rule # 0 in body)
	Debug> 987 :  f (Rule # 0 in body)
	Debug> 988 :  f (Rule # 0 in body)
	Debug> 989 :  f (Rule # 0 in body)
	Debug> 990 :  f (Rule # 0 in body)
	Debug> 991 :  f (Rule # 0 in body)
	Debug> 992 :  f (Rule # 0 in body)
	Debug> 993 :  f (Rule # 0 in body)
	Debug> 994 :  f (Rule # 0 in body)
	Debug> 995 :  f (User function)
	Debug> 996 :  Sin (Rule # 0 in pattern)
	Debug> 997 :  IsList (Internal function)
	Error on line 1 in file [CommandLine]
	Max evaluation stack depth reached.
	Please use MaxEvalDepth to increase the stack
	size as needed.

*SEE TraceExp, TraceRule
%/mathpiper_docs






%mathpiper_docs,name="TraceRule"
*CMD TraceRule --- turn on tracing for a particular function
*CORE
*CALL
	TraceRule(template) expr

*PARMS

{template} -- template showing the operator to trace

{expr} -- expression to evaluate with tracing on

*DESC

The tracing facility is turned on for subexpressions of the form
"template", and the expression "expr" is evaluated. The template
"template" is an example of the function to trace on. Specifically, all
subexpressions with the same top-level operator and arity as "template"
are shown. The subexpressions are displayed before (indicated with {TrEnter}) and after ({TrLeave})
evaluation. In between, the arguments are shown before and after
evaluation ({TrArg}). Only functions defined in
scripts can be traced.

This is useful for tracing a function that is called from within
another function. This way you can see how your function behaves
in the environment it is used in.

*E.G. notest

	In> TraceRule(x+y) 2+3*5+4;
	    TrEnter(2+3*5+4);
	      TrEnter(2+3*5);
	          TrArg(2, 2);
	          TrArg(3*5, 15);
	      TrLeave(2+3*5, 17);
	        TrArg(2+3*5, 17);
	        TrArg(4, 4);
	    TrLeave(2+3*5+4, 21);
	Out> 21;

*SEE TraceStack, TraceExp
%/mathpiper_docs



%mathpiper_docs,name="quit;restart"
*CMD quit --- stop Yacas from running, from the command line
*CMD restart --- restart Yacas (to start with a clean slate)
*CORE
*CALL
	quit
	restart

*DESC

Type {quit} or {restart} at the Yacas prompt to exit or to restart the interpreter.

The directives {quit} and {restart} are <i>not</i> reserved words or variable names.
They take effect only when typed as first characters at a prompt.

Pressing {Ctrl-C} will stop the currently running calculation.
If there is no currently running calculation, {Ctrl-C} will quit the interpreter.

When the interpreter quits, it saves the command history
(so quitting by {Ctrl-C} does not mean a "crash").

This command is not a function but a special directive that only applies while running MathPiper interactively.  It should not be used in scripts.

*E.G.

To be effective, the directive must be typed immediately after the prompt:
	In> quit
	Quitting...
We can use variables named {quit}:
	In> 1+quit
	Out> quit+1;
There is no effect if we type some spaces first: 
	In>       restart
	Out> restart;

*SEE Exit
%/mathpiper_docs



%mathpiper_docs,name="DefaultDirectory"
*CMD DefaultDirectory --- add directory to path for Yacas scripts
*CORE
*CALL
	DefaultDirectory(path)

*PARMS

{path} -- a string containing a full path where yacas script files reside

*DESC

When loading files, yacas is also allowed to
look in the folder "path". {path} will be prepended
to the file name before trying to load the file.
This means that "path" should end with a forward slash (under Unix-like
operating systems).

Yacas first tries to load a file from the current
directory, and otherwise it tries to load from
directories defined with this function, in the
order they are defined. Note there will be at least one directory
specified at start-up time, defined during compilation. This
is the directory Yacas searches for the initialization scripts
and standard scripts.

MathPiper allows you to configure a few things at startup. The file
{~/.mathpiperrc} is written in the MathPiper language and
will be executed when MapthPiper is run. This function
can be useful in the {~/.MathPiperrc} file.

*E.G.

	In> DefaultDirectory("/home/user/myscripts/");
	Out> True;

*SEE Load, Use, DefLoad, FindFile
%/mathpiper_docs



%mathpiper_docs,name="PrettyPrinter'Set;PrettyPrinter'Get"
*CMD PrettyPrinter'Set --- set routine to use as pretty-printer
*CMD PrettyPrinter'Get --- get routine to use as pretty-printer

*STD

*CALL
	PrettyPrinter'Set(printer)
	PrettyPrinter'Set()
	PrettyPrinter'Get()

*PARMS

{printer} -- a string containing the name of a function that can "pretty-print" an expression.


*DESC

This function sets up the function printer to print out the results on
the command line. This can be reset to the internal printer with {PrettyPrinter'Set()} (when no argument is given, the system returns to the default).

Currently implemented prettyprinters are: {PrettyForm}, {TeXForm}, {Print}, {OMForm}, {CForm} and {DefaultPrint}.

{PrettyPrinter'Get()} returns the current pretty printer, or it returns
an empty string if the default pretty printer is used.

MathPiper allows you to configure a few things at startup. The file
{~/.mathpiperrc} is written in the MathPiper language and
will be executed when MapthPiper is run. This function
can be useful in the {~/.MathPiperrc} file.

*E.G.

	In> Taylor(x,0,5)Sin(x)
	Out> x-x^3/6+x^5/120;
	In> PrettyPrinter'Set("PrettyForm");
	
	True
	
	In> Taylor(x,0,5)Sin(x)
	
	     3    5
	    x    x
	x - -- + ---
	    6    120
	
	In> PrettyPrinter'Set();
	Out> True;
	In> Taylor(x,0,5)Sin(x)
	Out> x-x^3/6+x^5/120;

*SEE PrettyForm, Write, TeXForm, CForm, OMForm, PrettyReader'Set, PrettyReader'Get
%/mathpiper_docs



%mathpiper_docs,name="PrettyReader'Set;PrettyReader'Get"
*CMD PrettyReader'Set --- set routine to use as pretty-reader
*CMD PrettyReader'Get --- get routine that is currently used as pretty-reader

*STD

*CALL
	PrettyReader'Set(reader)
	PrettyReader'Set()
	PrettyReader'Get()

*PARMS

{reader} -- a string containing the name of a function that can read an expression from current input.


*DESC

This function sets up the function reader to read in the input on
the command line. This can be reset to the internal reader with {PrettyReader'Set()} (when no argument is given, the system returns to the default).

Currently implemented PrettyReaders are: {LispRead}, {OMRead}.

{PrettyReader'Get()} returns the current reader, or it returns
an empty string if the default pretty printer is used.

MathPiper allows you to configure a few things at startup. The file
{~/.mathpiperrc} is written in the MathPiper language and
will be executed when MapthPiper is run. This function
can be useful in the {~/.MathPiperrc} file.

*E.G.

	In> Taylor(x,0,5)Sin(x)
	Out> x-x^3/6+x^5/120
	In> PrettyReader'Set("LispRead")
	Out> True
	In> (Taylor x 0 5 (Sin x))
	Out> x-x^3/6+x^5/120

*SEE Read, LispRead, OMRead, PrettyPrinter'Set, PrettyPrinter'Get
%/mathpiper_docs



%mathpiper_docs,name="MaxEvalDepth"
*CMD MaxEvalDepth --- set depth of recursion stack
*CORE
*CALL
	MaxEvalDepth(n)
*PARMS
{n} -- integer
*DESC
Sets the maximum depth of recursive function call. An error message is printed when too many recursive calls are executed, and this function can be used to increase or decrease the limit as necessary.

%/mathpiper_docs



%mathpiper_docs,name="HistorySize"
*CMD HistorySize --- set size of history file
*CORE
*CALL
	HistorySize(n)

*PARMS

{n} -- number of lines to store in history file

*DESC

When exiting, yacas saves the command line history to a
file {~/.yacas_history}. By default it will
save the last 1024 lines. The default can be
overridden with this function. Passing -1 tells the system to save <i>all</i>
lines.

MathPiper allows you to configure a few things at startup. The file
{~/.mathpiperrc} is written in the MathPiper language and
will be executed when MapthPiper is run. This function
can be useful in the {~/.MathPiperrc} file.

*E.G.

	In> HistorySize(200)
	Out> True;
	In> quit

*SEE quit
%/mathpiper_docs



%mathpiper_docs,name="Version"
*CMD Version --- show version of Yacas
*CORE
*CALL
	Version()

*DESC

The function {Version()} returns a string representing the version of the currently running Yacas interpreter.

*E.G. notest

	In> Version()
	Out> "1.0.48rev3";
	In> LessThan(Version(), "1.0.47")
	Out> False;
	In> GreaterThan(Version(), "1.0.47")
	Out> True;

The last two calls show that the {LessThan} and {GreaterThan}
functions can be used for comparing version numbers. This 
method is only guaranteed, however, if the version is always expressed
in the form {d.d.dd} as above.

*REM
Note that on the Windows platforms the output may be different:
In> Version()
Out> "Windows-latest";

*SEE LessThan, GreaterThan
%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs



%mathpiper_docs,name=""

%/mathpiper_docs




