%mathpiper_docs,name=""

%/mathpiper_docs



*CMD Random, RandomSeed --- (pseudo-) random number generator
*STD
*CALL
	Random()
	RandomSeed(init)

*PARAMS
{init} -- positive integer, initial random seed

*DESC

The function {Random} returns a random number, uniformly distributed in the
interval between 0 and 1. The same sequence of random numbers is
generated in every Yacas session.

The random number generator can be initialized by calling {RandomSeed} with an integer value.
Each seed value will result in the same sequence of pseudo-random numbers.

*SEE RandomInteger, RandomPoly, Rng


*CMD RngCreate --- manipulate random number generators as objects
*CMD RngSeed --- manipulate random number generators as objects
*CMD Rng --- manipulate random number generators as objects
*STD
*CALL
	RngCreate()
	RngCreate(init)
	RngCreate(option==value,...)
	RngSeed(r, init)
	Rng(r)
	
*PARMS
{init} -- integer, initial seed value

{option} -- atom, option name

{value} -- atom, option value

{r} -- a list, RNG object

*DESC
These commands are an object-oriented interface to (pseudo-)random number generators (RNGs).

{RngCreate} returns a list which is a well-formed RNG object.
Its value should be saved in a variable and used to call {Rng} and {RngSeed}.

{Rng(r)} returns a floating-point random number between 0 and 1 and updates the RNG object {r}.
(Currently, the Gaussian option makes a RNG return a <i>complex</i> random number instead of a real random number.)

{RngSeed(r,init)} re-initializes the RNG object {r} with the seed value {init}.
The seed value should be a positive integer.

The {RngCreate} function accepts several options as arguments.
Currently the following options are available:

*	{seed} -- specify initial seed value, must be a positive integer
*	{dist} -- specify the distribution of the random number; currently {flat} and {gauss} are implemented, and the default is the flat (uniform) distribution
*	{engine} -- specify the RNG engine; currently {default} and {advanced} are available ("advanced" is slower but has much longer period)

If the initial seed is not specified, the value of 76544321 will be used.

The {gauss} option will create a RNG object that generates pairs of Gaussian distributed random numbers as a complex random number.
The real and the imaginary parts of this number are independent random numbers taken from a Gaussian (i.e. "normal") distribution with unit variance.

For the Gaussian distribution, the Box-Muller transform method is used.
A good description of this method, along with the proof that the method
generates normally distributed random numbers, can be found in Knuth, 
"The Art of Computer Programming", Volume 2 (Seminumerical algorithms, third 
edition), section 3.4.1 

Note that unlike the global {Random} function, the RNG objects created with {RngCreate} are independent RNGs and do not affect each other.
They generate independent streams of pseudo-random numbers.
However, the {Random} function is slightly faster.

*E.G.

	In> r1:=RngCreate(seed=1,dist=gauss)
	Out> {"GaussianRNGDist","RNGEngine'LCG'2",{1}}
	In> Rng(r1)
	Out> Complex(-1.6668466417,0.228904004);
	In> Rng(r1);
	Out> Complex(0.0279296109,-0.5382405341);
The second RNG gives a uniform distribution (default option) but uses a more complicated algorithm:
	In> [r2:=RngCreate(engine=advanced);Rng(r2);]
	Out> 0.3653615377;
The generator {r1} can be re-initialized with seed 1 again to obtain the same sequence:
	In> RngSeed(r1, 1)
	Out> True;
	In> Rng(r1)
	Out> Complex(-1.6668466417,0.228904004);
	

*SEE Random



*CMD RandomIntegerMatrix --- generate a matrix of random integers

*STD

*CALL
	RandomIntegerMatrix(rows,cols,from,to)

*PARMS

{rows} -- number of rows in matrix

{cols} -- number of cols in matrix

{from} -- lower bound

{to} -- upper bound

*DESC

This function generates a {rows x cols} matrix of random integers. All
entries lie between "from" and "to", including the boundaries, and
are uniformly distributed in this interval.

*E.G.
	In> PrettyForm( RandomIntegerMatrix(5,5,-2^10,2^10) )

	/                                               \
	| ( -506 ) ( 749 )  ( -574 ) ( -674 ) ( -106 )  |
	|                                               |
	| ( 301 )  ( 151 )  ( -326 ) ( -56 )  ( -277 )  |
	|                                               |
	| ( 777 )  ( -761 ) ( -161 ) ( -918 ) ( -417 )  |
	|                                               |
	| ( -518 ) ( 127 )  ( 136 )  ( 797 )  ( -406 )  |
	|                                               |
	| ( 679 )  ( 854 )  ( -78 )  ( 503 )  ( 772 )   |
	\                                               /

*SEE RandomIntegerVector, RandomPoly

*CMD RandomIntegerVector --- generate a vector of random integers

*STD

*CALL
	RandomIntegerVector(nr, from, to)

*PARMS

{nr} -- number of integers to generate

{from} -- lower bound

{to} -- upper bound

*DESC

This function generates a list with "nr" random integers. All
entries lie between "from" and "to", including the boundaries, and
are uniformly distributed in this interval.

*E.G.

	In> RandomIntegerVector(4,-3,3)
	Out> {0,3,2,-2};

*SEE Random, RandomPoly

*CMD RandomPoly --- construct a random polynomial
*STD
*CALL
	RandomPoly(var,deg,coefmin,coefmax)

*PARMS

{var} -- free variable for resulting univariate polynomial

{deg} -- degree of resulting univariate polynomial

{coefmin} -- minimum value for coefficients

{coefmax} -- maximum value for coefficients

*DESC

RandomPoly generates a random polynomial in variable "var", of
degree "deg", with integer coefficients ranging from "coefmin" to
"coefmax" (inclusive). The coefficients are uniformly distributed in
this interval, and are independent of each other.

*E.G.

	In> RandomPoly(x,3,-10,10)
	Out> 3*x^3+10*x^2-4*x-6;
	In> RandomPoly(x,3,-10,10)
	Out> -2*x^3-8*x^2+8;

*SEE Random, RandomIntegerVector



			Series

*CMD Add --- find sum of a list of values
*STD
*CALL
	Add(val1, val2, ...)
	Add({list})

*PARMS

{val1}, {val2} -- expressions

{{list}} -- list of expressions to add

*DESC

This function adds all its arguments and returns their sum. It accepts any
number of arguments. The arguments can be also passed as a list.

*E.G.

	In> Add(1,4,9);
	Out> 14;
	In> Add(1 .. 10);
	Out> 55;


*CMD Sum --- find sum of a sequence
*STD
*CALL
	Sum(var, from, to, body)

*PARMS

{var} -- variable to iterate over

{from} -- integer value to iterate from

{to} -- integer value to iterate up to

{body} -- expression to evaluate for each iteration

*DESC

The command finds the sum of the sequence generated by an iterative formula. 
The expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" up to "to", and the sum of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".

Warning: {Sum} does not evaluate its arguments {var} and {body} until the actual loop is run.

*E.G.

	In> Sum(i, 1, 3, i^2);
	Out> 14;

*SEE Factorize


*CMD Factorize --- product of a list of values
*STD
*CALL
	Factorize(list)
	Factorize(var, from, to, body)

*PARMS

{list} -- list of values to multiply

{var} -- variable to iterate over

{from} -- integer value to iterate from

{to} -- integer value to iterate up to

{body} -- expression to evaluate for each iteration

*DESC

The first form of the {Factorize} command simply
multiplies all the entries in "list" and returns their product.

If the second calling sequence is used, the expression "body" is
evaluated while the variable "var" ranges over all integers from
"from" up to "to", and the product of all the results is
returned. Obviously, "to" should be greater than or equal to
"from".

*E.G.

	In> Factorize({1,2,3,4});
	Out> 24;
	In> Factorize(i, 1, 4, i);
	Out> 24;

*SEE Sum, Apply


*CMD Taylor --- univariate Taylor series expansion
*STD
*CALL
	Taylor(var, at, order) expr

*PARMS

{var} -- variable

{at} -- point to get Taylor series around

{order} -- order of approximation

{expr} -- expression to get Taylor series for

*DESC

This function returns the Taylor series expansion of the expression
"expr" with respect to the variable "var" around "at" up to order
"order". This is a polynomial which agrees with "expr" at the
point "var = at", and furthermore the first "order" derivatives of
the polynomial at this point agree with "expr". Taylor expansions
around removable singularities are correctly handled by taking the
limit as "var" approaches "at".

*E.G.

	In> PrettyForm(Taylor(x,0,9) Sin(x))
	
	     3    5      7       9
	    x    x      x       x
	x - -- + --- - ---- + ------
	    6    120   5040   362880
	
	Out> True;

*SEE D, InverseTaylor, ReversePoly, BigOh

*CMD InverseTaylor --- Taylor expansion of inverse
*STD
*CALL
	InverseTaylor(var, at, order) expr

*PARMS

{var} -- variable

{at} -- point to get inverse Taylor series around

{order} -- order of approximation

{expr} -- expression to get inverse Taylor series for

*DESC

This function builds the Taylor series expansion of the inverse of the
expression "expr" with respect to the variable "var" around "at"
up to order "order". It uses the function {ReversePoly} to perform the task.

*E.G.

	In> PrettyPrinter'Set("PrettyForm")
	
	True
	
	In> exp1 := Taylor(x,0,7) Sin(x)
	
	     3    5      7
	    x    x      x
	x - -- + --- - ----
	    6    120   5040
	
	In> exp2 := InverseTaylor(x,0,7) ArcSin(x)
	
	 5      7     3
	x      x     x
	--- - ---- - -- + x
	120   5040   6
	
	In> Simplify(exp1-exp2)
	
	0


*SEE ReversePoly, Taylor, BigOh

*CMD ReversePoly --- solve $h(f(x)) = g(x) + O(x^n)$ for $h$
*STD
*CALL
	ReversePoly(f, g, var, newvar, degree)

*PARMS

{f}, {g} -- functions of "var"

{var} -- a variable

{newvar} -- a new variable to express the result in

{degree} -- the degree of the required solution

*DESC

This function returns a polynomial in "newvar", say "h(newvar)",
with the property that "h(f(var))" equals "g(var)" up to order
"degree". The degree of the result will be at most "degree-1". The
only requirement is that the first derivative of "f" should not be zero.

This function is used to determine the Taylor series expansion of the
inverse of a function "f": if we take "g(var)=var", then
"h(f(var))=var" (up to order "degree"), so "h" will be the
inverse of "f".

*E.G.

	In> f(x):=Eval(Expand((1+x)^4))
	Out> True;
	In> g(x) := x^2
	Out> True;
	In> h(y):=Eval(ReversePoly(f(x),g(x),x,y,8))
	Out> True;
	In> BigOh(h(f(x)),x,8)
	Out> x^2;
	In> h(x)
	Out> (-2695*(x-1)^7)/131072+(791*(x-1)^6)
	/32768 +(-119*(x-1)^5)/4096+(37*(x-1)^4)
	/1024+(-3*(x-1)^3)/64+(x-1)^2/16;

*SEE InverseTaylor, Taylor, BigOh

*CMD BigOh --- drop all terms of a certain order in a polynomial
*STD
*CALL
	BigOh(poly, var, degree)

*PARMS

{poly} -- a univariate polynomial

{var} -- a free variable

{degree} -- positive integer

*DESC

This function drops all terms of order "degree" or higher in
"poly", which is a polynomial in the variable "var".

*E.G.

	In> BigOh(1+x+x^2+x^3,x,2)
	Out> x+1;

*SEE Taylor, InverseTaylor


*CMD LagrangeInterpolant --- polynomial interpolation
*STD
*CALL
	LagrangeInterpolant(xlist, ylist, var)

*PARMS

{xlist} -- list of argument values

{ylist} -- list of function values

{var} -- free variable for resulting polynomial

*DESC

This function returns a polynomial in the variable "var" which
interpolates the points "(xlist, ylist)". Specifically, the value of
the resulting polynomial at "xlist[1]" is "ylist[1]", the value at
"xlist[2]" is "ylist[2]", etc. The degree of the polynomial is not
greater than the length of "xlist".

The lists "xlist" and "ylist" should be of equal
length. Furthermore, the entries of "xlist" should be all distinct
to ensure that there is one and only one solution.

This routine uses the Lagrange interpolant formula to build up the
polynomial.

*E.G.

	In> f := LagrangeInterpolant({0,1,2}, \
	  {0,1,1}, x);
	Out> (x*(x-1))/2-x*(x-2);
	In> Eval(Subst(x,0) f);
	Out> 0;
	In> Eval(Subst(x,1) f);
	Out> 1;
	In> Eval(Subst(x,2) f);
	Out> 1;
	
	In> PrettyPrinter'Set("PrettyForm");
	
	True
	
	In> LagrangeInterpolant({x1,x2,x3}, {y1,y2,y3}, x)
	
	y1 * ( x - x2 ) * ( x - x3 ) 
	---------------------------- 
	 ( x1 - x2 ) * ( x1 - x3 )   
	
	  y2 * ( x - x1 ) * ( x - x3 )
	+ ----------------------------
	   ( x2 - x1 ) * ( x2 - x3 )
	
	  y3 * ( x - x1 ) * ( x - x2 )
	+ ----------------------------
	   ( x3 - x1 ) * ( x3 - x2 )


*SEE Subst



			Combinatorics

*CMD !  --- factorial
*CMD !!  --- factorial and related functions
*CMD ***  --- factorial and related functions
*CMD Subfactorial  --- factorial and related functions
*STD
*CALL
	n!
	n!!
	a *** b
	Subfactorial(m)

*PARMS

{m} -- integer
{n} -- integer, half-integer, or list
{a}, {b} -- numbers

*DESC

The factorial function {n!} calculates the factorial of integer or half-integer numbers. For
nonnegative integers, $n! := n*(n-1)*(n-2)*...*1$. The factorial of
half-integers is defined via Euler's Gamma function, $z! := Gamma(z+1)$. If $n=0$ the function returns $1$.

The "double factorial" function {n!!} calculates $n*(n-2)*(n-4)*...$. This product terminates either with $1$ or with $2$ depending on whether $n$ is odd or even. If $n=0$ the function returns $1$.

The "partial factorial" function {a *** b} calculates the product $a*(a+1)*...$ which is terminated at the least integer not greater than $b$. The arguments $a$ and $b$ do not have to be integers; for integer arguments, {a *** b} = $b! / (a-1)!$. This function is sometimes a lot faster than evaluating the two factorials, especially if $a$ and $b$ are close together. If $a>b$ the function returns $1$.

The {Subfactorial} function can be interpreted as the  number of permutations of {m} objects in which no object 
appears in its natural place, also called "derangements." 

The factorial functions are threaded, meaning that if the argument {n} is a
list, the function will be applied to each element of the list.

Note: For reasons of Yacas syntax, the factorial sign {!} cannot precede other
non-letter symbols such as {+} or {*}. Therefore, you should enter a space
after {!} in expressions such as {x! +1}.

The factorial functions terminate and print an error message if the arguments are too large (currently the limit is $n < 65535$) because exact factorials of such large numbers are computationally expensive and most probably not useful. One can call {Internal'LnGammaNum()} to evaluate logarithms of such factorials to desired precision.

*E.G.

	In> 5!
	Out> 120;
	In> 1 * 2 * 3 * 4 * 5
	Out> 120;
	In> (1/2)!
	Out> Sqrt(Pi)/2;
	In> 7!!;
	Out> 105;
	In> 1/3 *** 10;
	Out> 17041024000/59049;
	In> Subfactorial(10)
	Out> 1334961;


*SEE Bin, Factorize, Gamma, !!, ***, Subfactorial

*CMD Bin --- binomial coefficients
*STD
*CALL
	Bin(n, m)

*PARMS

{n}, {m} -- integers

*DESC

This function calculates the binomial coefficient "n" above
"m", which equals $$n! / (m! * (n-m)!)$$

This is equal to the number of ways
to choose "m" objects out of a total of "n" objects if order is
not taken into account. The binomial coefficient is defined to be zero
if "m" is negative or greater than "n"; {Bin(0,0)}=1.

*E.G.

	In> Bin(10, 4)
	Out> 210;
	In> 10! / (4! * 6!)
	Out> 210;

*SEE !, Eulerian

*CMD Eulerian --- Eulerian numbers
*STD
*CALL
	Eulerian(n,m)

*PARMS

{n}, {m} --- integers

*DESC

The Eulerian numbers can be viewed as a generalization of the binomial coefficients,
and are given explicitly by $$ Sum(j,0,k+1,(-1)^j*Bin(n+1,j)*(k-j+1)^n) $$ .

*E.G.

	In> Eulerian(6,2)
	Out> 302;
	In> Eulerian(10,9)
	Out> 1;

*SEE Bin


*CMD LeviCivita --- totally anti-symmetric Levi-Civita symbol
*STD
*CALL
	LeviCivita(list)

*PARMS

{list} -- a list of integers 1 .. n in some order

*DESC

{LeviCivita} implements the Levi-Civita symbol. This is generally
useful for tensor calculus.  {list}  should be a list of integers,
and this function returns 1 if the integers are in successive order,
eg. {LeviCivita( {1,2,3,...} )}  would return 1. Swapping two elements of this
list would return -1. So, {LeviCivita( {2,1,3} )} would evaluate
to -1.

*E.G.

	In> LeviCivita({1,2,3})
	Out> 1;
	In> LeviCivita({2,1,3})
	Out> -1;
	In> LeviCivita({2,2,3})
	Out> 0;

*SEE Permutations

*CMD Permutations --- get all permutations of a list
*STD
*CALL
	Permutations(list)

*PARMS

{list} -- a list of elements

*DESC

Permutations returns a list with all the permutations of
the original list.

*E.G.

	In> Permutations({a,b,c})
	Out> {{a,b,c},{a,c,b},{c,a,b},{b,a,c},
	{b,c,a},{c,b,a}};

*SEE LeviCivita




			Special functions

*INTRO In this chapter, special and transcendental mathematical functions are described.

*CMD Gamma --- Euler's Gamma function
*STD
*CALL
	Gamma(x)

*PARMS

{x} -- expression

{number} -- expression that can be evaluated to a number

*DESC

{Gamma(x)} is an interface to Euler's Gamma function $Gamma(x)$. It returns exact values on integer and half-integer arguments. {N(Gamma(x)} takes a numeric parameter and always returns a floating-point number in the current precision.

Note that Euler's constant $gamma<=>0.57722$ is the lowercase {gamma} in Yacas.

*E.G.

	In> Gamma(1.3)
	Out> Gamma(1.3);
	In> N(Gamma(1.3),30)
	Out> 0.897470696306277188493754954771;
	In> Gamma(1.5)
	Out> Sqrt(Pi)/2;
	In> N(Gamma(1.5),30);
	Out> 0.88622692545275801364908374167;

*SEE !, N, gamma

*CMD Zeta --- Riemann's Zeta function

*STD
*CALL
	Zeta(x)

*PARMS

{x} -- expression

{number} -- expression that can be evaluated to a number

*DESC

{Zeta(x)} is an interface to Riemann's Zeta function $zeta(s)$. It returns exact values on integer and half-integer arguments. {N(Zeta(x)} takes a numeric parameter and always returns a floating-point number in the current precision.

*E.G.

	In> Precision(30)
	Out> True;
	In> Zeta(1)
	Out> Infinity;
	In> Zeta(1.3)
	Out> Zeta(1.3);
	In> N(Zeta(1.3))
	Out> 3.93194921180954422697490751058798;
	In> Zeta(2)
	Out> Pi^2/6;
	In> N(Zeta(2));
	Out> 1.64493406684822643647241516664602;

*SEE !, N


*CMD Bernoulli --- Bernoulli numbers and polynomials
*STD
*CALL
	Bernoulli(index)
	Bernoulli(index, x)

*PARMS

{x} -- expression that will be the variable in the polynomial

{index} -- expression that can be evaluated to an integer

*DESC

{Bernoulli(n)} evaluates the $n$-th Bernoulli number. {Bernoulli(n, x)} returns the $n$-th Bernoulli polynomial in the variable $x$. The polynomial is returned in the Horner form.

*EG

	In> Bernoulli(20);
	Out> -174611/330;
	In> Bernoulli(4, x);
	Out> ((x-2)*x+1)*x^2-1/30;

*SEE Gamma, Zeta

*CMD Euler --- Euler numbers and polynomials
*STD
*CALL
	Euler(index)
	Euler(index,x)

*PARMS

{x} -- expression that will be the variable in the polynomial

{index} -- expression that can be evaluated to an integer

*DESC

{Euler(n)} evaluates the $n$-th Euler number. {Euler(n,x)} returns the $n$-th Euler polynomial in the variable $x$.

*E.G.

	In> Euler(6)
	Out> -61;
	In> A:=Euler(5,x)
	Out> (x-1/2)^5+(-10*(x-1/2)^3)/4+(25*(x-1/2))/16;
	In> Simplify(A)
	Out> (2*x^5-5*x^4+5*x^2-1)/2;

*SEE Bin


*CMD LambertW --- Lambert's $W$ function

*STD
*CALL
	LambertW(x)
*PARMS

{x} -- expression, argument of the function

*DESC

Lambert's $W$ function is (a multiple-valued, complex function) defined for any (complex) $z$ by
$$ W(z) * Exp(W(z)) = z$$.
This function is sometimes useful to represent solutions of transcendental equations. For example, the equation $Ln(x)=3*x$ can be "solved" by writing $x= -3*W(-1/3)$. It is also possible to take a derivative or integrate this function "explicitly".

For real arguments $x$, $W(x)$ is real if $x>= -Exp(-1)$.

To compute the numeric value of the  principal branch of Lambert's $W$ function for real arguments $x>= -Exp(-1)$ to current precision, one can call {N(LambertW(x))} (where the function {N} tries to approximate its argument with a real value).

*E.G.
	In> LambertW(0)
	Out> 0;
	In> N(LambertW(-0.24/Sqrt(3*Pi)))
	Out> -0.0851224014;

*SEE Exp



*INCLUDE complex.chapt

*INCLUDE transforms.chapt

