%mathpiper_docs,name=""

%/mathpiper_docs







*CMD WithValue --- temporary assignment during an evaluation
*STD
*CALL
	WithValue(var, val, expr)
	WithValue({var,...}, {val,...}, expr)

*PARMS

{var} -- variable to assign to

{val} -- value to be assigned to "var"

{expr} -- expression to evaluate with "var" equal to "val"

*DESC

First, the expression "val" is assigned to the variable
"var". Then, the expression "expr" is evaluated and
returned. Finally, the assignment is reversed so that the variable
"var" has the same value as it had before {WithValue} was evaluated.

The second calling sequence assigns the first element in the list of
values to the first element in the list of variables, the second value
to the second variable, etc.

*E.G.

	In> WithValue(x, 3, x^2+y^2+1);
	Out> y^2+10;
	In> WithValue({x,y}, {3,2}, x^2+y^2+1);
	Out> 14;

*SEE Subst, /:

*CMD /: --- local simplification rules
*CMD /:: --- local simplification rules
*STD
*CALL
	expression /: patterns
	expressions /:: patterns
Precedence:
*EVAL OpPrecedence("/:")


*PARMS

{expression} -- an expression

{patterns} -- a list of patterns

*DESC

Sometimes you have an expression, and you want to use specific
simplification rules on it that are not done by default. This
can be done with the {/:} and the {/::} operators. Suppose we have the
expression containing things such as {Ln(a*b)}, and we want
to change these into {Ln(a)+Ln(b)}, the easiest way
to do this is using the {/:} operator, as follows:

	In> Sin(x)*Ln(a*b)
	Out> Sin(x)*Ln(a*b);
	In> % /: { Ln(_x*_y) <- Ln(x)+Ln(y) }
	Out> Sin(x)*(Ln(a)+Ln(b));

A whole list of simplification rules can be built up in the list,
and they will be applied to the expression on the left hand side
of {/:} .

The forms the patterns can have are one of:

	pattern <- replacement
	{pattern,replacement}
	{pattern,postpredicate,replacement}

Note that for these local rules, {<-} should be used instead of
{<--} which would be used in a global rule.

The {/:} operator traverses an expression much as {Subst} does, that is, top
down, trying to apply the rules from the beginning of the list of
rules to the end of the list of rules. If the rules cannot be applied
to an expression, it will try subexpressions of that
expression and so on.

It might be necessary sometimes to use the {/::} operator, which
repeatedly applies the {/:} operator until the result doesn't change
any more. Caution is required, since rules can contradict each other,
which could result in an infinite loop. To detect this situation,
just use /: repeatedly on the expression. The repetitive nature
should become apparent.

*E.G.

	In> Sin(u)*Ln(a*b) /: {Ln(_x*_y) <- Ln(x)+Ln(y)}
	Out> Sin(u)*(Ln(a)+Ln(b));
	In> Sin(u)*Ln(a*b) /:: { a <- 2, b <- 3 }
	Out> Sin(u)*Ln(6);

*SEE Subst


*CMD TraceStack --- show calling stack after an error occurs
*CORE
*CALL
	TraceStack(expression)

*PARMS

{expression} -- an expression to evaluate

*DESC

TraceStack shows the calling stack after an error occurred.
It shows the last few items on the stack, not to flood the screen.
These are usually the only items of interest on the stack.
This is probably by far the most useful debugging function in
Yacas. It shows the last few things it did just after an error
was generated somewhere.

For each stack frame, it shows if the function evaluated was a
built-in function or a user-defined function, and for the user-defined
function, the number of the rule it is trying whether it was evaluating
the pattern matcher of the rule, or the body code of the rule.

This functionality is not offered by default because it slows
down the evaluation code.

*E.G. notest

Here is an example of a function calling itself recursively,
causing Yacas to flood its stack:

	In> f(x):=f(Sin(x))
	Out> True;
	In> TraceStack(f(2))
	Debug> 982 :  f (Rule # 0 in body)
	Debug> 983 :  f (Rule # 0 in body)
	Debug> 984 :  f (Rule # 0 in body)
	Debug> 985 :  f (Rule # 0 in body)
	Debug> 986 :  f (Rule # 0 in body)
	Debug> 987 :  f (Rule # 0 in body)
	Debug> 988 :  f (Rule # 0 in body)
	Debug> 989 :  f (Rule # 0 in body)
	Debug> 990 :  f (Rule # 0 in body)
	Debug> 991 :  f (Rule # 0 in body)
	Debug> 992 :  f (Rule # 0 in body)
	Debug> 993 :  f (Rule # 0 in body)
	Debug> 994 :  f (Rule # 0 in body)
	Debug> 995 :  f (User function)
	Debug> 996 :  Sin (Rule # 0 in pattern)
	Debug> 997 :  IsList (Internal function)
	Error on line 1 in file [CommandLine]
	Max evaluation stack depth reached.
	Please use MaxEvalDepth to increase the stack
	size as needed.

*SEE TraceExp, TraceRule

*CMD TraceExp --- evaluate with tracing enabled
*CORE
*CALL
	TraceExp(expr)

*PARMS

{expr} -- expression to trace

*DESC

The expression "expr" is evaluated with the tracing facility turned
on. This means that every subexpression, which is evaluated, is shown
before and after evaluation. Before evaluation, it is shown in the
form {TrEnter(x)}, where {x}
denotes the subexpression being evaluated. After the evaluation the
line {TrLeave(x,y)} is printed, where {y} is the result of the evaluation. The indentation
shows the nesting level.

Note that this command usually generates huge amounts of output. A
more specific form of tracing (eg. {TraceRule}) is
probably more useful  for all but very simple expressions.

*E.G. notest

	In> TraceExp(2+3);
	  TrEnter(2+3);
	    TrEnter(2);
	    TrLeave(2, 2);
	    TrEnter(3);
	    TrLeave(3, 3);
	    TrEnter(IsNumber(x));
	      TrEnter(x);
	      TrLeave(x, 2);
	    TrLeave(IsNumber(x),True);
	    TrEnter(IsNumber(y));
	      TrEnter(y);
	      TrLeave(y, 3);
	    TrLeave(IsNumber(y),True);
	    TrEnter(True);
	    TrLeave(True, True);
	    TrEnter(MathAdd(x,y));
	      TrEnter(x);
	      TrLeave(x, 2);
	      TrEnter(y);
	      TrLeave(y, 3);
	    TrLeave(MathAdd(x,y),5);
	  TrLeave(2+3, 5);
	Out> 5;

*SEE TraceStack, TraceRule

*CMD TraceRule --- turn on tracing for a particular function
*CORE
*CALL
	TraceRule(template) expr

*PARMS

{template} -- template showing the operator to trace

{expr} -- expression to evaluate with tracing on

*DESC

The tracing facility is turned on for subexpressions of the form
"template", and the expression "expr" is evaluated. The template
"template" is an example of the function to trace on. Specifically, all
subexpressions with the same top-level operator and arity as "template"
are shown. The subexpressions are displayed before (indicated with {TrEnter}) and after ({TrLeave})
evaluation. In between, the arguments are shown before and after
evaluation ({TrArg}). Only functions defined in
scripts can be traced.

This is useful for tracing a function that is called from within
another function. This way you can see how your function behaves
in the environment it is used in.

*E.G. notest

	In> TraceRule(x+y) 2+3*5+4;
	    TrEnter(2+3*5+4);
	      TrEnter(2+3*5);
	          TrArg(2, 2);
	          TrArg(3*5, 15);
	      TrLeave(2+3*5, 17);
	        TrArg(2+3*5, 17);
	        TrArg(4, 4);
	    TrLeave(2+3*5+4, 21);
	Out> 21;

*SEE TraceStack, TraceExp

*CMD Time --- measure the time taken by a function
*STD
*CALL
	Time(expr)
*PARMS
{expr} -- any expression
*DESC

The function {Time(expr)} evaluates the expression {expr} and prints the time in seconds needed for the evaluation.
The time is printed to the current output stream.
The built-in function {GetTime} is used for timing.

The result is the "user time" as reported by the OS, not the real ("wall clock") time.
Therefore, any CPU-intensive processes running alongside Yacas will not significantly affect the result of {Time}.

*EG notest
	In> Time(N(MathLog(1000),40))
	0.34 seconds taken
	Out> 6.9077552789821370520539743640530926228033;

*SEE GetTime
