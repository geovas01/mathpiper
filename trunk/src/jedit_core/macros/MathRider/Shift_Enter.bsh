//Copyright (C) 2008 Ted Kosan (license information is at the end of this document.)

import org.mathrider.jyacasplugin.JYacasInterpreter;
import java.io.File;
import java.io.BufferedWriter;
import org.gjt.sp.jedit.textarea.Selection.Range;
import org.gjt.sp.jedit.textarea.Selection;
import errorlist.*;
import org.gjt.sp.jedit.bsh.EvalError;



stripWindowsDriveLetter(tempFilePath)
{
	//Remove Windows drive letter from the path.
	if(tempFilePath.indexOf(":") != -1)
	{
		tempFilePath = tempFilePath.split(":")[1];
			
		//Change window's backslashes to forward slashes.
		tempFilePath = tempFilePath.replace("\\","/");
	}//end if
	
	return tempFilePath;
}//end method.

//Note: This code needs to be moved to a Java object.
//errorSource = new DefaultErrorSource("MathRider");
//ErrorSource.registerErrorSource(errorSource);


buffer.save(view,null);

path = buffer.getPath();


if(path.endsWith(".ys")){
	
	//Remove Windows drive letter from the path.
	if(path.indexOf(":") != -1){
		path = path.split(":")[1];
		
		//Chance window's backslashes to forward slashes.
		path = path.replace("\\","/");
		//System.out.println(path);
	}
		
	runCommandInConsole(view,"JYacas","Load(\""+path+"\");");
	//interpreter=JYacasInterpreter.getInstance();
	

	//result = interpreter.evaluate("Load(\""+path+"\");");
	
	//System.out.println(result);
}else if (path.endsWith(".mws")){
	buffer.setMode("mathrider");
	currentCaretPosition = textArea.getCaretPosition();
	textArea.selectFold();
	fold  = textArea.getSelection()[0];
	foldStartIndex = fold.getStart();
	foldEndIndex = fold.getEnd();
	foldStartLine = fold.getStartLine();
	foldEndLine = fold.getEndLine();
	foldStartLineText = textArea.getLineText(foldStartLine);
	codeStartLine = foldStartLine+1;
	codeEndLine = foldEndLine-1;
	codeStartIndex = fold.getStart(textArea.getBuffer(),codeStartLine);
	codeEndIndex = fold.getEnd(textArea.getBuffer(),codeEndLine);
	codeSelection = new Range(codeStartIndex, codeEndIndex);
	textArea.setSelection(codeSelection);
	



	//Remove the whitespace at the end of the selected fold text.
	allFoldText = textArea.getSelectedText().replaceAll("\\s+$", "");
	//replaceAll("^\\s+", "");Remove whitespace at end of string.
	//replaceAll("\\s+$", "");Remove whitespace at beginning of string.
  //System.out.println("YYYY allFoldText: " + allFoldText); 
	
	textArea.setSelection(null);
	
	
		//{{{ Fold type.
	//	defaultFoldType = "%yacas";
		

			foldStartSelection = new Range(foldStartIndex, foldStartIndex + foldStartLineText.length());
			
			
			//Determine the indent character and how much the fold is indented by.  Then, create a string
			//that indents one more level for the output fold.
			indentCharType = foldStartLineText.charAt(0);
			indentAmount = new StringBuffer();
			if(indentCharType == 9 || indentCharType == 32)
			{
				
				for(indentCount = 0; foldStartLineText.charAt(indentCount) == indentCharType; indentCount++)
				{
					indentAmount.append(indentCharType);
				}//end for.
				
				
				if(indentCharType == 9)
				{indentAmount.append("\t");
				}
				else
				{
					indentAmount.append("    ");
				}//end if/else/
			}//end if.
			else
			{
				indentAmount.append("    ");
			}//end else.
				
				
			//Obtain fold type.
			typeText = foldStartLineText.substring(foldStartLineText.indexOf("%"));
			
			//Remove // commenf from line if present.
			if((commentIndex = typeText.indexOf("//")) != -1)
			{
				//System.out.println("XXXXXXX " + typeText);
				typeText = typeText.substring(0,commentIndex);
				
			}//end if.
			
			foldTypePropertyStrings = typeText.split(",");
			
			foldType = foldTypePropertyStrings[0];
			foldType = foldType.trim();
			
			foldProperties = new java.util.Hashtable();
			foldProperties.put("input","");
			foldProperties.put("output","output");
			foldProperties.put("collapse","false");
			foldProperties.put("clear","false");
			if(foldTypePropertyStrings.length != 1)
			{
				for(x = 1; x < foldTypePropertyStrings.length; x++)
				{
					property = foldTypePropertyStrings[x].split("=");
					key = property[0].trim();
					value = property[1].trim().replaceAll("\"","");
					foldProperties.put(key,value);
				}//end for.
			}//end if.
			//}}}

	
	
/*	endDollarSignIndex = -1;
	if(foldType.equalsIgnoreCase("%hoteqn"))
	{
		startDollarSignIndex = allFoldText.indexOf("$");
		if(startDollarSignIndex != -1)
		{
			endDollarSignIndex = allFoldText.indexOf("$", startDollarSignIndex+1);
		}//end if.

	}//end if.
	*/		
	foldSections = allFoldText.split("%yacas|%output|%geogebra|%beanshell|%hoteqn|%error|%html|%group");
	codeText = foldSections[0];
	codeText = codeText.replaceAll("\\s+$", "");
/*	
	//Do not include subfold as code.
	if(endDollarSignIndex != -1)
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b", endDollarSignIndex+1);
	}
	else
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b");
	}//end else.
	
	if(subFoldIndex != -1)
	{
		codeText = allFoldText.substring(0,subFoldIndex).replaceAll("\\s+$", "");
	}
	else
	{
		codeText = allFoldText;
	}
*/	
//   System.out.println("YYYY: codeText " + codeText);

//	noCrLf = text.replace("\n","").replace("\r","");
	isolatedCodeLength = codeText.length();
	isolatedCodeEndIndex = codeStartIndex + isolatedCodeLength;
	
	textArea.setCaretPosition(isolatedCodeEndIndex);

	
	try {
        // Create temp file.
        File tempFile = File.createTempFile("mathrider", ".mws_tmp");
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
        // Write to temp file
        BufferedWriter out = new BufferedWriter(new FileWriter(tempFile));
        out.write(codeText);
        out.close();
		                                                                                        


		

		result = "";
		status = "";
		collapseFold = foldProperties.get("collapse");
		
		///{{{ *** %yacas ***.
		if(foldType.equalsIgnoreCase("%yacas"))    
		{
			//JYacas section.
			
			interpreter = JYacasInterpreter.getInstance();
			

			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				
				tempFilePath = stripWindowsDriveLetter(tempFilePath);
			
				//System.out.println(tempFilePath);
        	
				result = interpreter.evaluate("Load(\""+tempFilePath+"\");");
				
				if(result != null )
				{
				
					if(result.startsWith("True:"))
					{
						result = result.substring(5,result.length());//Remove True: which is returned by Load.
					}
					else if (result.startsWith("True"))
					{
						result = result.substring(4,result.length());//Remove True which is returned by Load.
					}
				}//end if.}}}
				
				//Note: Since Load returns "True", it kills what was in %.
				//lastResult = interpreter.evaluate("%");
				//System.out.println(" XXXXX: " + lastResult);
				
				if(foldProperties.get("output").equalsIgnoreCase("latex") )
				{
					result = interpreter.evaluate("TeXForm(" + result + ");");
					result = result.replace("\"$","$");
					result = result.replace("$\"","$");
					status = "%hoteqn";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("openmath") )
				{	
					result = interpreter.evaluate("OMForm(" + result + ");");
					status = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("geogebra") )
				{
					status = "%geogebra";
				}
				else
				{
					status = "%output";
				}
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(net.sf.yacas.Yacasexception ye) 
			{
				result = ye.getMessage();
				status = "%error ";
			}
			
			

					
		}//end if }}}
		
	///{{{ *** %beanshell ***
		else if(foldType.equalsIgnoreCase("%beanshell"))
		{
			//buffer.setMode("beanshell");
			import bsh.Interpreter;
			interpreter = new Interpreter();
			interpreter.eval("import geogebra.GeoGebraApplet;");
			ggb = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			interpreter.set("ggb",ggb);
			interpreter.set("jEdit",jEdit);
			interpreter.set("returnError","none");
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();

				//System.out.println(tempFilePath);

				interpreter.source(tempFilePath);
				result = "";
	//System.out.println("tempFilePath: " + tempFilePath);
				status = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(EvalError e) 
			{
				System.out.println(" XXXX ERROR: " + interpreter.get("returnError"));
				System.out.println(" XXX Beanshell Exception: " + e.getMessage());
				
				message = e.getMessage();
				
				//Note: ugly hack to work around EvalError object sometimes throwing null pointer exceptions 
				// when either getErrorText() or getErrorLineNumber() is called. 
				if(message.indexOf("line") == -1)
				{
					errorText = e.getErrorText();
					errorLineNumber = e.getErrorLineNumber();
				}
				else
				{
					errorText = e.getMessage();
					errorLineNumber = Integer.parseInt( errorText.substring(errorText.indexOf("line") + 5, errorText.indexOf(",")));
				}
				
				


				

				status = "%error ";
							
							errorSource = JYacasInterpreter.getErrorSource(); //Note: obtaining error source from central location.

							adjustedErrorLineNumber = foldStartLine + (errorLineNumber + 1);
							result =  e.getMessage() + " " + errorText + " Line: " + adjustedErrorLineNumber;							
							
							filePath = textArea.getBuffer().getPath();
				    	
							errorSource.clear();
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, adjustedErrorLineNumber-1, 0, 0, result ) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );

			}
		}//end else
		// end %beanshell }}}
	
	///{{{ *** %geogebra ***
		else if(foldType.equalsIgnoreCase("%geogebra")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "geogebra" );
			
			errorSource = JYacasInterpreter.getErrorSource(); //Note: obtaining error source from central location.
			
			import geogebra.GeoGebraApplet;
			geogebra = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				//Clear geogebra.
				geogebra.setXML("<?xml version=\"1.0\" encoding=\"utf-8\"?> <geogebra format=\"2.5\"> </geogebra>");
				
			}//end if.
			
			
			
			
			result = "GeoGebra updated.";
			status = "%output";
			if(foldProperties.get("input").equalsIgnoreCase("xml") )
			{
				//buffer.setMode("xml");
				geogebra.setXML(codeText);
			}
			else
			{
				lines = codeText.split("\n");
				
				lineCount = lines.length;
				lineIndex = 0;
            	
				
				for(lineIndex = 0; lineIndex < lineCount; lineIndex++)
				{
					//System.out.println("YYYYY" + lines[lineIndex]);
					
					if(lines[lineIndex].trim().length() != 0 && ! lines[lineIndex].trim().startsWith("//"))
					{
					    endOfLineCommentIndex = lines[lineIndex].indexOf("//");
						if(endOfLineCommentIndex != -1)
						{
							currentLine = lines[lineIndex].split("//")[0];
						}
						else
						{
							currentLine = lines[lineIndex].trim();
						}//end if.
						
						returnFlag = geogebra.evalCommand(currentLine);
						
						if(returnFlag == false)
						{
							errorLine = foldStartLine + lineIndex+2;
							result = "Error on line " + errorLine + ".";
							status = "%error";
							
							filePath = textArea.getBuffer().getPath();
				    	
							errorSource.clear();
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, currentLine ) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
							
							break;      
						}//end if.
					}//end if.
				}//end for.

			}//end else
			
			
		}//end else
		//end %geogebra }}}

				                                                                                
	///{{{ *** %hoteqn ***
		else if(foldType.equalsIgnoreCase("%hoteqn")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "hoteqn" );
			
			errorSource = JYacasInterpreter.getErrorSource();
			
			//import geogebra.GeoGebraApplet;
			hotEqn = org.mathrider.hoteqnplugin.HotEqn.getHotEqn();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				hotEqn.setEquation("");
			}//end if.
			
			
			//lines = codeText.split("\n");
			

			
			//lineCount = lines.length;
			//lineIndex = 0;

			hotEqn.setEquation(codeText);
			result = "HotEqn updated.";
			status = "%output";
			
					/*
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						status = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
					*/

		}//end else
		//end %hoteqn }}}

	///{{{ *** %html ***
		else if(foldType.equalsIgnoreCase("%html")) 
		{
			//jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "yacasdocs" );
			
			result = "";
			status = "%output";
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				tempFilePath = stripWindowsDriveLetter(tempFilePath);
				tempFilePath = "file://" + tempFilePath;
				frame = new javax.swing.JFrame();
				contentPane = frame.getContentPane();
				JEditorPane editorPane = new JEditorPane();
				JScrollPane editorScrollPane = new JScrollPane(editorPane);
				editorScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				editorPane.setEditable(false);
				//editorPane.addHyperlinkListener(this);
				//java.net.URL url = new java.net.URL(tempFilePath);
				if (url != null) 
				{
					editorPane.setPage(tempFilePath);
					contentPane.add(editorScrollPane);//guiBox,BorderLayout.NORTH);
					frame.pack();
					frame.setAlwaysOnTop(true);
					frame.setTitle("MathRider");
					frame.setSize(new Dimension(400, 400));
					frame.setResizable(true);
					frame.setPreferredSize(new Dimension(400, 400));
					frame.setLocationRelativeTo(null);
					frame.show();
				}//end if.

			}catch(Exception e) 
			{
				result = e.getMessage();
				status = "%error ";
			}
			
					/*
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						status = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
					*/

		}//end else
		//end %html }}}

		
	///{{{ *** %uasm65 ***
		else if(foldType.equalsIgnoreCase("%uasm65")) 
		{
			//buffer.setMode("beanshell");
			import bsh.Interpreter;
			interpreter = new Interpreter();
			interpreter.set("jEdit",jEdit);
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();

				//System.out.println(tempFilePath);

				interpreter.source(tempFilePath);
				result = "";
	//System.out.println("tempFilePath: " + tempFilePath);
				status = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(Exception e) 
			{
				result = e.getMessage();
				status = "%error ";
			}
		}//end else
		
		
	///{{{ *** %uasm65 ***
		else if(foldType.equalsIgnoreCase("%output"))
		{
			return; //For now.
		}
		//end %uasm65 }}}
		else
		{
			return;
		}//end if/else

//===================================================================================
				//Determine how many lines are in the result.
				numberOfLines = 0;
				charIndex = 0;
				while(charIndex != result.length()){
					if(result.charAt(charIndex) == "\n"){
						numberOfLines++;
					}
					charIndex++;
				}//end while
				
				
				//Make room at the end of the current fold for output and place output there.
				//currentCaretPosition = textArea.getCaretPosition();
        	
        	
				rangeSelection = new Range(isolatedCodeEndIndex, codeEndIndex);
				
				textArea.setSelection(rangeSelection);
				
				result = result.trim();
				
			
				void displayResult()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						
						result = result.replaceAll("\n","\n" + indendAmount);//("\n","\n      ");
						textArea.setSelectedText("\n\n" + indentAmount + status + "\n" + indentAmount + "  " + result + "\n" + indentAmount + "%end\n",false);
						
						//("\n\n     " + status + "\n      "+ result + "\n     %end\n",false);
				 
						/*//If fold type was blank, set it to the default fold type.
						if(foldStartSelection != null)
						{
							textArea.setSelection(foldStartSelection);
							line = textArea.getSelectedText();
							line = line.replaceFirst("\\{\\{\\{", "\u007b\u007b\u007b" + defaultFoldType);
							textArea.setSelectedText(line);
							textArea.setSelection(null);
						}//end if
						  */
						
						textArea.setCaretPosition(currentCaretPosition);
						
						if(collapseFold.equalsIgnoreCase("true"))
						{
							textArea.collapseFold();
						}//end if.
						
						buffer.save(view,null);
					}
					VFSManager.runInAWTThread(this);
				
				}//end method.
				
				displayResult();
							
        	
			
				

    } 
	catch (IOException e) 
	{
		e.printStackTrace();
    }
	

	

}//end else if.




/* {{{ License.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */ //}}}

// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=0:
