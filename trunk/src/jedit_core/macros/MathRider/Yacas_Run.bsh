//Run the yacas script that is in the current buffer.

import org.mathrider.jyacasplugin.JYacasInterpreter;
import java.io.File;
import java.io.BufferedWriter;
import org.gjt.sp.jedit.textarea.Selection.Range;
import org.gjt.sp.jedit.textarea.Selection;
import errorlist.*;


//Note: This code needs to be moved to a Java object.
//errorSource = new DefaultErrorSource("MathRider");
//ErrorSource.registerErrorSource(errorSource);


buffer.save(view,null);

path = buffer.getPath();


if(path.endsWith(".ys")){
	
	//Remove Windows drive letter from the path.
	if(path.indexOf(":") != -1){
		path = path.split(":")[1];
		
		//Chance window's backslashes to forward slashes.
		path = path.replace("\\","/");
		//System.out.println(path);
	}
		
	runCommandInConsole(view,"JYacas","Load(\""+path+"\");");
	//interpreter=JYacasInterpreter.getInstance();
	

	//result = interpreter.evaluate("Load(\""+path+"\");");
	
	//System.out.println(result);
}else if (path.endsWith(".mrn")){
	textArea.selectFold();
	fold  = textArea.getSelection()[0];
	foldStartIndex = fold.getStart();
	foldEndIndex = fold.getEnd();
	foldStartLine = fold.getStartLine();
	foldEndLine = fold.getEndLine();
	foldStartLineText = textArea.getLineText(foldStartLine);
	codeStartLine = foldStartLine+1;
	codeEndLine = foldEndLine-1;
	codeStartIndex = fold.getStart(textArea.getBuffer(),codeStartLine);
	codeEndIndex = fold.getEnd(textArea.getBuffer(),codeEndLine);
	codeSelection = new Range(codeStartIndex, codeEndIndex);
	textArea.setSelection(codeSelection);
	



	
	allFoldText = textArea.getSelectedText().replaceAll("\\s+$", "");
	//replaceAll("^\\s+", "");Remove whitespace at end of string.
	//replaceAll("\\s+$", "");Remove whitespace at beginning of string.
	
	textArea.setSelection(null);  
	
	
	//Note: Add code to determine if <shift><enter> was executed outside of a fold.
	

//	
//	//text = text.substring(3,text.length()-3);
//	
	//Do not include subfold as code.
	subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b");
	if(subFoldIndex != -1)
	{
		codeText = allFoldText.substring(0,subFoldIndex).replaceAll("\\s+$", "");
	}
	else
	{
		codeText = allFoldText;
	}
	
	//System.out.println("YYYY: " + codeText);

//	noCrLf = text.replace("\n","").replace("\r","");
	isolatedCodeLength = codeText.length();
	isolatedCodeEndIndex = codeStartIndex + isolatedCodeLength;
	
	textArea.setCaretPosition(isolatedCodeEndIndex);

	
	try {
        // Create temp file.
        File tempFile = File.createTempFile("mathrider", ".mrn_tmp");
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
        // Write to temp file
        BufferedWriter out = new BufferedWriter(new FileWriter(tempFile));
        out.write(codeText);
        out.close();
		

    		
		
		defaultFoldType = "%yacas";
		
		
		
		//If there is no fold type, select start line so that the default fold type can be added.
		if(foldStartLineText.indexOf("%") == -1)
		{
			foldStartSelection = new Range(foldStartIndex, foldStartIndex + foldStartLineText.length());
		}
		else
		{
			foldStartSelection = null;
			
			//Obtain fold type.
			typeText = foldStartLineText.substring(foldStartLineText.indexOf("%"));
			foldTypePropertyStrings = typeText.split(",");
			
			foldType = foldTypePropertyStrings[0];
			
			foldProperties = null;
			if(foldTypePropertyStrings.length != 1)
			{
				foldProperties = new java.util.Hashtable();
				for(x = 1; x < foldTypePropertyStrings.length; x++)
				{
					property = foldTypePropertyStrings[x].split("=");
					key = property[0].trim();
					value = property[1].trim().replaceAll("\"","");
					foldProperties.put(key,value);
				}//end for.
			}//end if.
			
		}//end else.
		

		result = "";
		status = "";
		
		///{{{ *** %yacas ***.
		if(foldStartLineText.indexOf(defaultFoldType) != -1 || (defaultFoldType.equals("%yacas") && foldStartLineText.indexOf("%") == -1) )
		{
			//JYacas section.
			
			interpreter = JYacasInterpreter.getInstance();
			

			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				
				//Remove Windows drive letter from the path.
				if(tempFilePath.indexOf(":") != -1){
					tempFilePath = tempFilePath.split(":")[1];
			
					//Change window's backslashes to forward slashes.
					tempFilePath = tempFilePath.replace("\\","/");
				}//end if
			
				//System.out.println(tempFilePath);
        	
				result = interpreter.evaluate("Load(\""+tempFilePath+"\");");
				status = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(net.sf.yacas.Yacasexception ye) 
			{
				result = ye.getMessage();
				status = "%error ";
			}
			
			
			if(result != null )
			{
				
				if(result.startsWith("True:"))
				{
					result = result.substring(5,result.length());//Remove True: which is returned by Load.
				}
				else if (result.startsWith("True"))
				{
					result = result.substring(4,result.length());//Remove True which is returned by Load.
				}
			}//end if.}}}
					
		}//end if }}}
	///{{{ *** %beanshell ***
		else if(foldType.equalsIgnoreCase("%beanshell"))
		{
			import bsh.Interpreter;
			interpreter = new Interpreter();
			interpreter.eval("import geogebra.GeoGebraApplet;");
			interpreter.eval("ggb = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();");
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();

				//System.out.println(tempFilePath);

				interpreter.source(tempFilePath);
				result = "";
	//System.out.println("tempFilePath: " + tempFilePath);
				status = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(Exception e) 
			{
				result = e.getMessage();
				status = "%error ";
			}
		}//end else
		// end %beanshell }}}
	
	///{{{ *** %geogebra ***
		else if(foldType.equalsIgnoreCase("%geogebra")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "geogebra" );
			
			errorSource = JYacasInterpreter.getErrorSource();
			
			import geogebra.GeoGebraApplet;
			geogebra = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			
		
			if(foldProperties != null && foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				//Clear geogebra.
				geogebra.setXML("<?xml version=\"1.0\" encoding=\"utf-8\"?> <geogebra format=\"2.5\"> </geogebra>");
				
			}//end if.
			
			
			lines = codeText.split("\n");
			
			result = "GeoGebra updated.";
			status = "%output";
			
			lineCount = lines.length;
			lineIndex = 0;

			
			for(lineIndex = 0; lineIndex < lineCount; lineIndex++)
			{
				//System.out.println("YYYYY" + lines[lineIndex]);
				
				if(lines[lineIndex].trim().length() != 0 && ! lines[lineIndex].trim().startsWith("//"))
				{
				    endOfLineCommentIndex = lines[lineIndex].indexOf("//");
					if(endOfLineCommentIndex != -1)
					{
						currentLine = lines[lineIndex].split("//")[0];
					}
					else
					{
						currentLine = lines[lineIndex].trim();
					}//end if.
					
					returnFlag = geogebra.evalCommand(currentLine);
					
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						status = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
				}//end if.
			}//end for.
			
			
			
		}//end else
		//end %geogebra }}}

				

				
				//Determine how many lines are in the result.
				numberOfLines = 0;
				charIndex = 0;
				while(charIndex != result.length()){
					if(result.charAt(charIndex) == "\n"){
						numberOfLines++;
					}
					charIndex++;
				}//end while
				
				
				//Make room at the end of the current fold for output and place output there.
				currentCaretPosition = textArea.getCaretPosition();
        	
        	
				rangeSelection = new Range(isolatedCodeEndIndex, codeEndIndex);
				
				textArea.setSelection(rangeSelection);
				
				result = result.trim();
				
			
				void displayResult()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						
						result = result.replaceAll("\n","\n      ");
						textArea.setSelectedText("\n\n     {{{" + status + "\n      "+ result + "\n     }}}\n",false);
				 
						//If fold type was blank, set it to the default fold type.
						if(foldStartSelection != null)
						{
							textArea.setSelection(foldStartSelection);
							line = textArea.getSelectedText();
							line = line.replaceFirst("\\{\\{\\{", "\u007b\u007b\u007b" + defaultFoldType);
							textArea.setSelectedText(line);
							textArea.setSelection(null);
						}//end if
						
						
						textArea.setCaretPosition(currentCaretPosition);
						
						buffer.save(view,null);
					}
					VFSManager.runInAWTThread(this);
				
				}//end method.
				
				displayResult();
							
        	
			
				

    } 
	catch (IOException e) 
	{
		e.printStackTrace();
    }
	

	

}//end else if.
	


// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=1:
