;****************************************************************************
;  UMON65 Understandable Monitor for the 6500 series microprocessors.
;  Copyright 2007 by Ted Kosan.
;
;  Revision History:
;      -Modified to work with muvium robot.
;
;****************************************************************************


;****************************************************************************
;                                Equates Area.
;****************************************************************************   
;muvium

;For simple I/O board.
INPUTS		equ 4000h
OUTPUT1	equ 4001h
OUTPUT2	equ 4002h
LCD	    	equ 4003h

;For robot
;servo_left 	equ 4000h
;servo_right 	equ 4001h
;button_left 	equ 4002h
;button_right 	equ 4003h
;field_left 	equ 4004h
;field_right 	equ 4005h
;dist_left 	equ 4006h
;dist_right 	equ 4007h
;delay_secs 	equ 4008h
;delay_msecs 	equ 4009h
;
;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
;
;Transmitt Receive Register.
6551TRR	equ A000h ;400ah


;Status Register.  
;		    Status			          cleared by
;	b0	Parity error * (1: error)       self clearing **
;	b1	Framing error * (1: error)      self clearing **
;	b2	Overrun * (1: error)            self clearing **
;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
;                                                                                                            
;	note: * no interrupt generated for these conditions
;	      ** cleared automatically after a read of RDR and the next 
;		error free receipt of data
6551StR	equ A001h ;400bh  


;Comand Register  
;	b0	Data Terminal Ready
;			0 : disable receiver and all interrupts (DTR high)
;			1 : enable receiver and all interrupts (DTR low)
;	b1	Receiver Interrupt Enable
;			0 : IRQ interrupt enabled from bit 3 of status register
;			1 : IRQ interrupt disabled
;	b3,b2	Transmitter Control
;				Transmit Interrupt    RTS level    Transmitter
;			00	   disabled		high		off
;			01	   enabled		low		on
;			10	   disabled		low		on
;			11	   disabled		low	   Transmit BRK
;	b4	Normal/Echo Mode for Receiver
;			0 : normal
;			1 : echo (bits 2 and 3 must be 0)
;	b5	Parity Enable
;			0 : parity disabled, no parity bit generated or received
;			1 : parity enabled
;	b7,b6	Parity
;			00 : odd parity receiver and transmitter
;			01 : even parity receiver and transmitter
;			10 : mark parity bit transmitted, parity check disabled
;			11 : space parity bit transmitted, parity check disabled


;6551CmR	equ 0b202h  

;Control Register
;
;	b3-b0	baud rate generator:
;			0000 : 16x external clock
;			0001 : 50 baud
;			0010 : 75
;			0011 : 110
;			0100 : 134.5
;			0101 : 150
;			0110 : 300
;			0111 : 600
;			1000 : 1200
;			1001 : 1800
;			1010 : 2400
;			1011 : 3600
;			1100 : 4800
;			1101 : 7200
;			1110 : 9600
;			1111 : 19,200
;	b4	receiver clock source
;			0 : external receiver clock
;			1 : baud rate generator
;	b6,b5	word length                                                                  
;			00 : 8 bits
;			01 : 7
;			10 : 6
;			11 : 5
;	b7	stop bits
;			0 : 1 stop bit
;			1 : 2 stop bits
;			    (1 stop bit if parity and word length = 8)
;			    (1 1/2 stop bits if word length = 5 and no parity)
;6551CtR	equ 0b203h  




;InPort0 Equate.
InPort0	equ 0a000h

;OutPort0 Equate.
OutPort0	equ 0a100h

;****************************************************************************
;                       General Purpose Pointer Area.
;****************************************************************************
	org 0000h
	
GenPoint	dwd ?
IRQVect		dwd ?		;
BRKVect		dwd ?		;Break command indirect vector.
MessPtr		dwd ?		;
PointerA	dwd ?		;
PointerB	dwd ?		;
PointerC	dwd ?		;
NOpAdPtr	dwd ?		;
BOpAdPtr	dwd ?		;
BrkPt1Ad	dwd ?		;
BrkPt2Ad	dwd ?		;
BrkPt3Ad	dwd ?		;                                                                                       
BrkPt4Ad	dwd ?		;


	
;****************************************************************************
;                   General Purpose Variable Storage Area.
;****************************************************************************
	org 0200h 

		  
Obj1		dbt ?
Obj2		dbt ?
Obj3		dbt ?
Obj2Flg		dbt ?
Obj3Flg		dbt ?
AddMode		dbt ?
SrchTabl	dbt 10d(?)
SrchBtCt	dbt ?
TempAdd		dwd ?
TempAdd2	dwd ?
BrkPt1St	dbt ?
BrkPt2St	dbt ?
BrkPt3St	dbt ?
BrkPt4St	dbt ?
BP1OpHld	dbt ?
BP2OpHld	dbt ?
BP3OpHld	dbt ?
BP4OpHld	dbt ?
BPNumHld	dbt ?
BrValHld	dbt ?
TrBrkFlg	dbt ?
CurInsLn	dbt ?
NOpCdHld	dbt ?
BOpCdHld	dbt ?
BrnchFlg	dbt ?
TracCnt		dbt ?
AddHold		dwd ?
ObCdHld1	dbt ?
ObCdHld2	dbt ?
OpCdHold	dbt ?
TempA		dbt ?
UPgmCntr	dwd ?
UAccum		dbt ?
UXReg		dbt ?
UYReg		dbt ?
UStkPtr		dbt ?
UStatReg	dbt ?
ASCIIbuf	dbt 16d(?)
EndAdd		dwd ?
OpOffSet	dbt ?
OpFld1		dbt 20d(?)
OpFld2		dbt 20d(?)
OpFld3		dbt 20d(?)	
CodeCntr	dbt ?
Number		dbt ?
ChkSum		dbt ?
RecLen		dbt ?
CkSumAc		dwd ?
RecType 	dbt ?
wait0		dbt ?
wait1		dbt ?
		dbt ?
InptBufr	dbt 40d(?)
Command		dbt ?
RegTemp		dbt ?
DataTemp	dbt ?

;****************************************************************************
;                        Monitor Eprom Entry Point.
;****************************************************************************
	org 0e000h Note
	;org 1000h
	jmp Start

;****************************************************************************
;                  Monitor Utility Subroutine Jump Table.
;****************************************************************************
	jmp OutChar	;Output byte in A register to serial port.
	
	jmp GetChar	;Get a byte from the serial port.
	
	jmp GetCharW	;Wait and get a byte from the serial port.
	
	jmp PrntMess	;Print a message to the serial port.
	
	jmp OutSpace	;Output spaces to the serial port.
	
	jmp OutHex	;Output a HEX number to the serial port.
	
	jmp DgtToBin	;Convert an ASCII digit into binary.
	
	jmp GetLine	;Input a line from the serial port.
	

; Beginning of UMON65.
;****************************************************************************
;                       Start of UMON65 Main Routine.
;
;
;****************************************************************************
start *
	ldx #0ffh	;Initialize stack pointer and clear decimal
	txs		; mode.
;	cli		;
	cld		;
	
	jsr InitVars	;Initialize variables.
	
	jmp CkConfig	;Check switch register to determine what mode
			; to run the computer in.

;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
		
;****************************************************************************
;                     Check Computer's Configuration.
;****************************************************************************
CkConfig *
	;lda InPort0	;Get the switch settings and mask out the 
	;and #00001111b	; switch's high nibble.

;CkMon *
	
	;cmp #1d	;If the switch is set to a 1 then print the
	;bne CkEEPROM	; UMON65 monitor startup message and enter the
EnterMon *
	ldx #OpenMess<	; monitor through the maskable interrupt vector.
	ldy #OpenMess>	;
	jsr PrntMess	;
	brk		;

CkEEPROM *
	cmp #2d		;If the switch is set to a 2 then get the
	bne DoLgtSho	; switch's high nibble and jump to a program
	;lda InPort0	; present in the EEPROM which is indicated by
	and #11110000b	; the high nibble's value.  The program can be
	lsr a		; located at 1 of the following 16 locations:
	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
	clc
	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
	sta PointerA+1d	; 15-DE00.
	lda #0d		;
	sta PointerA	;
	jmp (PointerA)	;
			
DoLgtSho *
	jmp LghtShow
	
;****************************************************************************
;                            Light Show Subroutine.
;****************************************************************************
LghtShow *
	ldy #0h		;Make the Y register count from 0 to 255 and
	sty TempA	; output each number in the count to the
	;sty OutPort0	; light register.
LSOtLoop *		;
	ldx #100d	;
LSInLoop *		;
	iny		;
	bne LSInLoop	;
	dex		;
	bne LSInLoop	;
	inc TempA	;
	lda TempA	;
	;sta OutPort0	;
	jmp LSOtLoop	;

;****************************************************************************
;                            Monitor's Main Loop.
;****************************************************************************
MainLoop *	

	jsr GetLineP	;Get a typed line from the serial port.

	jsr ParsLine	;Break line into fields.
	
	jsr CkValCmd	;Check to see if a valid monitor command was
			; entered and if so execute that command's code.
	jmp MainLoop

	
;****************************************************************************
;                    Get Line From Serial Port Subroutine.
;****************************************************************************
GetLineP *
	ldx #Prompt<	;Print Prompt.
	ldy #Prompt>	;
	jsr PrntMess	;

GetLine *	
	ldy #0d		;Initialize Y index register.
	sty OpOffSet	;Initialize opcode holder offset pointer.
	sty command	;Initialize command holder.
	sty OpFld1	;Initialize operand field 1 buffer.
	sty OpFld2	;Initialize operand field 2 buffer.
	sty OpFld3	;Initialize operand field 3 buffer.
	
	ldy #0d		;Clear input buffer.
	lda #0d		;
ClrInpBf *		;
	sta InptBufr,y	;
	iny		;
	cpy #39d	;
	bne ClrInpBf	;
	
	ldy #0h		;Use Y register as buffer pointer.
	
GtAnChar *
	jsr GetCharW
;	jsr OutChar	;Echo character.  ;Note: remove for muvium.

	cmp #0h		;If no character is entered then try again.
	beq GtAnChar	;
	
	cmp #8d		;Check to see if the user entered a Delete or
	bne CkDel	; a Backspace.  If so then erase the character
	jmp DoDelete	; to the left of the cursor.
CkDel *			;
	cmp #127d	;
	bne GtCkChar	;
DoDelete *		;
	dey		;
	bmi AtStart	;
	lda #32d	;
	jsr OutChar	;
	lda #8d		;
	jsr OutChar	;
	jmp GtAnChar	;

AtStart *
	ldy #0d
	jmp GtAnChar
	
GtCkChar *
	cmp #10d	;If a LF was entered then accept line and exit,
	beq GtLnDone	; if not then accept the next character and
	sta InptBufr,y	; place it into the input buffer.
	iny		;
	
	cpy #39d	;Do not let buffer expand past 40 characters.
	bne GtAnChar
	ldy #39d	;Set buffer at 40 characters if over 40 characters.

	jmp GtAnChar	;
	
GtLnDone *
	;If a CR is in the input buffer then remove it.
	dey
	lda InptBufr,y
	cmp #13d
	beq PutNull
	iny
PutNull	 *
	lda #0h		;Put a NULL at end of the input buffer.
	sta InptBufr,y	;
		
	rts
	
;****************************************************************************
;                       Parse Input Buffer Subroutine.
;****************************************************************************
ParseOpr *	;Entry point if parsing for a UASM command is not
	ldy #0ffh	; desired.
	jmp GtAnoOpr	;
	
ParsLine *
	ldy #0d

	lda InptBufr,y
	beq ExtPrsLn	;If NULL or CR encountered then return.
	
	cmp #63d	;Check for upper case letter.
	bmi ParError	;
	cmp #90d	;	
	bpl CkSmCase	;
	
	sec
	bcs GetCmd	;
	
CkSmCase *
	cmp #97d	;Check for lower case letter.
	bmi ParError	;
	cmp #122d	;
	bpl ParError	;
	                
GetCmd *
	sta command	;Store command in command buffer.
                        
GtAnoOpr *       
	iny		;Point Y to the next operand field and check to
	cpy #20d	;make sure that the input line is not too long.
	beq ParError	;
	                
	lda InptBufr,y	;Check for the end of the input line.
	cmp #0d		;
	beq ExtPrsLn	;
	                
	cmp #32d	;Check for a space between operand fields.
	beq GtAnoOpr	;
	                
ScanOprn *              
	ldx OpOffSet	;Point X to the beginning of the current operand
	txa		; field holder and point OpOffSet to the beginning
	clc             
	adc #20d	; of the next operand field holder.
	sta OpOffSet	;
	
TranDgt *
	lda InptBufr,y	;
	                
	cmp #32d	;If a space is encountered then stop scanning.
	beq DoneScan	;
	                
	Cmp #0d		;If a CR is encountered then stop scanning.
	beq doneScan	;
	                
	sta OpFld1,x	;Transfer current operand from input buffer into
	inx		; current operand field holder.
	iny		;
	cpy #40d
	beq ParError
	
	jmp TranDgt	
	
DoneScan *
	lda #0h		;Put a NULL at the end of the current operand field
	sta OpFld1,x	; holder.
	
	jmp GtAnoOpr

ParError *
	rts
ExtPrsLn *
	rts

;****************************************************************************
;                     Check for Valid Command Subroutine.
;****************************************************************************
CkValCmd *
	sec
	
	lda command
	jsr ToLower

	cmp #108d	;Check for Load command.
	bne NxtCmd1	;
	jsr LdSRecs	;
	jmp ExitCmd	;
                        
NxtCmd1 *
	cmp #100d	;Check for Dump command.
	bne NxtCmd2	;
	jsr Dump	;
	jmp ExitCmd	;
                        
NxtCmd2 *
	cmp #114d	;Check for Register command.
	bne NxtCmd3	;
	jsr Register	;
	jmp ExitCmd	;
		
NxtCmd3 *
	cmp #103d	;Check for Go command.
	bne NxtCmd4	;
	jsr Go		;
	jmp ExitCmd	;
	
NxtCmd4 *
	cmp #101d	;Check for Enter command.
	bne NxtCmd5	;
	jsr Enter	;
	jmp ExitCmd	;
	
NxtCmd5 *
	cmp #102d	;Check for Fill command.
	bne NxtCmd6	;
	jsr Fill	;
	jmp ExitCmd	;

NxtCmd6 *
	cmp #117d	;Check for Unassemble command.
	bne NxtCmd7	;
	jsr UnAssem	;
	jmp ExitCmd	;

NxtCmd7 *
	cmp #116d	;Check for Trace command.
	bne NxtCmd8	;
	jsr Trace	;
	jmp ExitCmd	;

NxtCmd8 *
	cmp #98d	;Check for Breakpoint command.
	bne NxtCmd9	;
	jsr BreakPnt	;
	jmp ExitCmd	;
	
NxtCmd9 *
	cmp #115d	;Check for Search command.
	bne NxtCmd10	;
	jsr Search	;
	jmp ExitCmd	;

NxtCmd10 *
	cmp #109d	;Check for Move command.
	bne NxtCmd11	;
	jsr Move	;
	jmp ExitCmd	;
	
NxtCmd11 *
	cmp #'a'	;Check for Assemble command.
	bne NxtCmd12	;
	jsr Assemble	;
	jmp ExitCmd	;

NxtCmd12 *
	cmp #104d	;Check for Help command.
	bne NxtCmd13	;
	jsr Help	;
	jmp ExitCmd	;
NxtCmd13 *                 
	cmp #63d	;
	bne ExitCmd	;
	jsr Help	;
	jmp ExitCmd	;

ExitCmd *
	bcs CmdOk
	
CmdError *		;If there was an error with a command then
	ldx #CmdErMes<	; print a question mark.
	ldy #CmdErMes>	;
	jsr PrntMess	;
	clc		;
	rts		;
	
CmdOk *
	sec
	rts

;****************************************************************************
;                     Maskable Interrupt Service Subroutine.
;****************************************************************************
MaskInt *
	sei		;Disable interrupts.

	sta TempA	;Save accumulator.
			
	pla		;Check to see if BRK command was executed.
	pha		;
	and #10h	;
	bne DoBRK	;
	
	lda TempA	;Restore accumulator.

IRQ *	
	jmp (IRQVect)
	
DoBRK *
	jmp (BRKVect)

	
;****************************************************************************
;                          Break Service Subroutine.
;****************************************************************************
	
BRK *
	pla		;Save user's status register.
	sta UStatReg	;

	
	lda TempA	;Save user's accumulator.
	sta UAccum	;
	
	stx UXReg	;Save user's X register.
	
	sty UYReg	;Save user's Y register.
	
	tsx
	stx UStkPtr	;Save user's stack pointer.
	
	pla		;Save program counter of break instruction
	sec		; that caused execution of this code.
	sbc #1d		;
	sta UPgmCntr	;
	pla		; 
	sbc #0d		;
	sta UPgmCntr+1d	;
;	cli
	
	ldy #0d		;Print user's registers.
	sty OpFld1	;
	jsr Register	;

	lda TrBrkFlg	;If this break was placed by the trace command
	cmp #1d		; then go back to the trace subroutine.
	bne RepBPOp	;
	jmp Tr2ndEnt	;
	
RepBPOp *
	ldy #3d		;Replace the opcodes of all breakpointed
	ldx #6d		; addresses.
CkBPStBr *              ;
	lda BrkPt1St,y	;
	cmp #1d		;
	bne NxtBPStB	;
	lda BP1OpHld,y	;
	sta (BrkPt1Ad,x);
NxtBPStB *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPStBr	;
	
GoMain *
	jmp MainLoop	;Enter monitor.


;****************************************************************************
;                       Assemble Command Subroutine.
;****************************************************************************
Assemble *

	ldx #0d		;Get address to start assembling at and store
	jsr GetAdd	; in pointer A.
	bcs AAddOk	;
	jmp ErrAsem	;
AAddOk *		;
	stx PointerA	;
	sty PointerA+1d	;

AsemTop *		;On new line print current address being
	ldx #CRLF<	; assembled at and get next instruction to be
	ldy #CRLF>	; assembled from user.
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr GetLine	;
	jsr ParseOpr	;
	
	lda OpFld1	;Check for operator to be assembled. If no
	cmp #0d		; operator is found then exit Assemble 
	beq AsemDone	; subroutine.
	cmp #32d	;
	bne ACont	;
AsemDone *              ;
	jmp ExitAsem	;
	
ACont *			;Convert operator in input buffer to upper case,
	ldy #0d		; check to see if it is in the operator table and
ConvAno *		;
	lda OpFld1,y	; output a question mark if operator was not found.
	jsr ToUpper	;
	sta OpFld1,y	;
	iny		;
	cpy #3d		;
	bne ConvAno	;
	jsr OptrScan	;
	bcs AOptrOk	;
	
PrntQues *
	jsr PrntAdd	;If there was an error assembling the instruction
	lda #32d	; input from the user into object code then re-
	jsr OutChar	; output the line and print a question mark.
	ldx #OpFld1<	;
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;
	lda #32d	;
	jsr OutChar	;
	lda #63d	;
	jsr OutChar	;
	jmp AsemTop	;
	
AOptrOk *		;Check address mode of operand and print a quesion
	jsr AdMdScan	; mark if error occures while scanning operand.
	bcs AOpndOk	;
	jmp PrntQues
		
AOpndOk *		;Check to see if address mode of operand is a
	jsr AdMdTbSc	; valid address mode for instruction.
	bcs AOpTbFnd	;
	jmp PrntQues
		
AOpTbFnd *		;Extract object code from operand.
	jsr OpndScan	;
	bcs PrntAssm	;
	jmp PrntQues	;
	
PrntAssm *
	jsr PrntAdd	;Re-output current address.
	
	ldy #0d		;
	
	lda Obj1	;Output opcode, store it in memory, point to next
	sta (PointerA),y; byte, and print one space.
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj2Flg	;Output second object code byte if present, store it in
	beq NoObjCd	; it in memory, point to next byte, and print one
	lda Obj2	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj3Flg	;Output third object code byte if present, store
	beq NoObjCd3	; it in memory, point to next byte, and print one
	lda Obj3	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	jmp NoExSpcs

NoObjCd *		;If fewer then 3 bytes of object code are output
	lda #32d	; then output spaces instead.
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
NoObjCd3 *
	lda #32d	;
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
	
NoExSpcs *
	lda #32d	;
	jsr OutChar	;
	ldx #OpFld1<	;Re-output instruction that user had entered in.
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;

	jmp AsemTop
	
	
ErrAsem *
	clc
	rts
	
ExitAsem *
	sec
	rts
	

;****************************************************************************
;                       Operator Scan Subroutine.
;****************************************************************************
OptrScan *

	ldx #OpTable<	;Point pointer B to beginning of the operator
	stx PointerB	; table.
	ldx #Optable>	;
	stx PointerB+1d	;
	
OSCkAno *
	ldy #0d		;Compare a digit of the operator that the user
OSCkAnCM *		;
	lda (PointerB),y; entered with the analogous digit of the
	cmp OpFld1,y	; operator in the operator table.
	beq CharMtch	;
	
OptScan2 *
	lda PointerB	;Point pointer B to the beginning of the next
	clc		; operator in the operator table.
	adc #10d	;
	sta PointerB	;
	bcc OSNoCary	;
	inc PointerB+1d	;
	
OSNoCary *
	ldy #4d		;Check for the end of the operator table.
	lda (PointerB),y;
	cmp #'Z'	;
	beq OSNoMtch	;
	jmp OSCkAno	;
	
CharMtch *		;Check for an operator match in the operator
	iny		; table.
	cpy #3d		;
	beq OSMatch	;
	jmp OSCkAnCM	;
	
OSNoMtch *
	clc
	rts
	
OSMatch *
	sec
	rts


;****************************************************************************
;                     Address Mode Scan Subroutine.
;****************************************************************************
AdMdScan *

AMSCkIMP *
	ldy #0d		;Check for implied addressing mode.
	lda OpFld2,y	;
	cmp #0d		;
	bne AMSCkIMM	;
	lda #'P'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkIMM *		;Check for immediate addressing mode.
	cmp #'#'	;
	bne AMSCkACC	;
	lda #'M'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkACC *		;Check for accumulator addressing mode.
	cmp #'A'	;
	beq CkSpNull	;
	cmp #'a'	;
	beq CkSpNull	;
	jmp AMSCkREL	;
CkSpNull *		;
	iny		;
	lda OpFld2,y	;
	Cmp #0d		;
	beq IsAcc	;
	cmp #32d	;
	beq IsAcc	;
	jmp AMSCkREL	;
IsAcc *			;
	lda #'C'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkREL *		;Check for relative addressing mode.
	ldy #6d		;
	lda (PointerB),y;
	cmp #'L'	;
	bne AMSCkA_I	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkA_I *		;Dispatch to absolute or indexed check code.
	ldy #0d		;
	lda OpFld2,y	;
	cmp #'('	;
	bne AMSCkAB?	;
	jmp AMSCkId?	;
	
AMSCkAB? *		;Check to see if operand is absolute addressing
	ldy #0d		; mode or absolute indexed addressing mode.
AMSScnAB *		;
	lda OpFld2,y	;
	cmp #','	;
	beq CkXorY	;
	cmp #0d		;
	beq IsABS	;
	iny		;
	jmp AMSScnAB	;
	
CkXorY *		;Check for absolute X or absolute Y addressing
	iny		; mode.
	lda OpFld2,y	;                                                                        
	cmp #'X'	;
	beq IsABX	;
	cmp #'x'	;
	beq IsABX	;
	cmp #'Y'	;
	beq IsABY	;
	cmp #'y'	;
	beq IsABY	;
	jmp ErrAMS	;
	
IsABX *			;Save ABS, ABX or ABY mode in the variable to be
	lda #'X'	; returned.
	sta AddMode	;
	jmp ExitAMS	;
IsABY *			;
	lda #'Y'	;
	sta AddMode	;
	jmp ExitAMS	;
IsABS *			;
	lda #'S'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkId? *		;Dispatch to code that checks for IIR, IRI or
	iny		; IND addressing modes.
	lda OpFld2,y	;
	cmp #','	;
	beq CkIIR	;
	cmp #')'	;
	beq CkIRIIND	;
	cpy #11d	;
	bne AMSCkId?	;
	jmp ErrAMS	;

CkIIR *			;Check for IIR addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'X'	;
	beq IsIIR	;
	cmp #'x'	;
	beq IsIIR	;
	jmp ErrAMS	;
	
IsIIR *
	lda #'R'	;Save IIR addressing mode code in variable to be
	sta AddMode	; returned.
	jmp ExitAMS	;
	
CkIRIIND *		;Check for IND addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #0d		;
	beq IsIND	;
	cmp #','	;
	beq CkIRI	;
	jmp ErrAMS	;
	
CkIRI *			;Check for IRI addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'Y'	;
	beq IsIRI	;
	cmp #'y'	;
	beq IsIRI	;
	jmp ErrAMS	;
	
IsIND *			;Save IND or IRI addressing mode code in variable
	lda #'D'	; to be returned.
	sta AddMode	;
	jmp ExitAMS	;
IsIRI *			;
	lda #'I'	;
	sta AddMode	;
	jmp ExitAMS	;
	
ErrAMS *
	clc
	rts
	
ExitAMS *
	sec
	rts
	
	
;****************************************************************************
;                   Address Mode Table Search Subroutine.
;****************************************************************************
AdMdTbSc *		
	ldy #6d		;Check for address mode match between contents
	lda (PointerB),y; of variable AddMode & OpTable.
	cmp AddMode	;
	beq ExitAdMd	;
	
	lda PointerB	;Pointer Pointer B to next operator in
	clc		; operator table.
	adc #10d	;
	sta PointerB	;
	bcc AdMdNoCy	;
	inc PointerB+1d	;
	
AdMdNoCy *		;Check to see if next operator is the same type
	jsr OSCkANO	; that we are currently trying to assemble.
	bcs AdMdTbSc	;
	
ErrAdMd *
	clc
	rts
	
ExitAdMd *
	sec
	rts

;****************************************************************************
;                       Operand Scan Subroutine.
;****************************************************************************
OpndScan *

	lda #0d		;Initialize the flags that indicate whether or
	sta Obj2Flg	; not there are object bytes in addition to
	sta Obj3Flg	; the opcode object byte.
	
	ldy #7d		;Get the opcode of the instruction being 
	lda (PointerB),y; currently assembled from the opcode table
	sta Obj1	; and put it in Obj1.
	
	lda AddMode	;Check to see what address mode the instruction
	cmp #'P'	; currently being assembled is.
	beq OpndIMP	;
	cmp #'C'	;
	beq OpndACC	;
	cmp #'M'	;
	beq OpndIMM	;
	cmp #'S'	;
	beq OpndAB??	;
	cmp #'X'	;
	beq OpndAB??	;
	cmp #'Y'	;
	beq OpndAB??	;
	cmp #'I'	;
	beq OpndIN??	;
	cmp #'R'	;
	beq OpndIN??	;
	cmp #'D'	;
	beq OpndIN??	;
	cmp #'L'	;
	beq OpndAB??	;
	jmp ErrOpndS	;

OpndIMP *		;Process implied addressing mode.
	jmp ExtOpndS	;
	
OpndACC *		;Process accumulator addressing mode.
	jmp ExtOpndS	;
	
OpndIMM *		;Process immediate addressing mode.
	jsr ScnForHex	;
	bcs OpnMHFnd	;
	jmp ErrOpndS	;
OpnMHFnd *		;
	jsr AsToBin	;
	bcs OpndCvOk	;
	jmp ErrOpndS	;
OpndCvOk *		;
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;


OpndAB?? *		;Process absolute, absolute X, absolute Y.
	jsr ScnForHex	; Check for relative addressing mode and send
	bcs OpnAHFnd	; to appropriate code if found.
	jmp ErrOpndS	;
OpnAHFnd *		;
	jsr GetAdd	;
	bcs OpndAdOk	;
	jmp ErrOpndS	;
OpndAdOk *		;
	lda AddMode	;
	cmp #'L'	;
	beq OpndDoBr	;
DoAdd *			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;

OpndIN?? *		;Process indirect indexed, indexed indirect and
	jsr ScnForHex	; indirect addressing modes.
	bcs OpnINFnd	;
	jmp ErrOpndS	;
OpnINFnd *		;
	jsr GetAdd	;
	bcs OpINAdOk	;
	jmp ErrOpndS	;
OpINAdOk *		;
	lda AddMode	;
	cmp #'D'	;
	beq DoIND	;
	cpy #0d		;
	bne ErrOpndS	;
	stx Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
DoIND *			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;
	
OpndDoBr *		;Put address to be branched to in TempAdd and
	stx TempAdd	; the address of the first byte of the next
	sty TempAdd+1d	; instruction in TempAdd2.
	lda PointerA	;
	sta TempAdd2	;
	lda PointerA+1d	;
	sta TempAdd2+1d	;
	ldy #8d		;
	lda (PointerB),y;
	clc		;
	adc TempAdd2	;
	sta TempAdd2	;
	bcc OpBrNoOv	;
	inc TempAdd2+1d	;
OpBrNoOv *
	sec		;Subtract the address of the first byte of the
	lda TempAdd	; next instruction from the address to be branched
	sbc TempAdd2	; to in order to get the branch offset.
	sta TempAdd	;
	lda TempAdd+1d	;
	sbc TempAdd2+1d	;
	sta TempAdd+1d	;
	
	lda TempAdd+1d	;Check to make sure that MSB of the offset does
	cmp #0ffh	; not indicate a number greater than 127 or less
	beq OpCkNOff	; than 128.
	cmp #0d		;
	bne ErrOpndS	;
	
OpCkPOff *		;Check to make sure that LSB of the offset does
	lda TempAdd	; not contain a number greater than 127 or less
	cmp #128d	; than 128.
	bpl ErrOpndS	;
	jmp OffOk	;
OpCkNOff *		;
	lda TempAdd	;
	cmp #128d	;
	bmi ErrOpndS	;
	
OffOk *			;If offset is OK then put it in Obj2 and return.
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
	
ErrOpndS *
	clc
	rts
	
ExtOpndS *
	sec
	rts


;****************************************************************************
;                     Scan For Hex Digit Subroutine.
;****************************************************************************
ScnForHex *
	ldx #20d		
	
SFHNxtDg *
	ldy #0d		;Scan until either an upper case or a lower case
	lda OpFld1,x	; hex digit is encountered in the input buffer.
SFHCkDgt *		;
	cmp DgtTblUC,y	;
	beq ExitSFH	;
	cmp DgtTblLC,y	;
	beq ExitSFH	;
	iny		;
	cpy #16d	;
	beq IncBfPtr	;
	jmp SFHCkDgt	;

IncBfPtr *		;Point to the next digit in the input buffer.
	inx		;
	cpx #31d	;
	beq ErrSFH	;
	jmp SFHNxtDg	;

ErrSFH *
	clc
	rts
	
ExitSFH *
	sec
	rts
	
	
;****************************************************************************
;                       Breakpoint Command Subroutine.
;****************************************************************************
BreakPnt *
	lda OpFld1	;Check for a +, - or a ? in operand field #1.
	cmp #43d	;
	beq DoPlus	;
	cmp #45d	;
	beq DoMinus	;
	cmp #63d	;
	beq DmpBPAdd	;
	jmp ExitBP	;
DoPlus *		;
	jmp Plus	;
DoMinus *		;
	jmp Minus	;
	
DmpBPAdd *
	ldx #CRLF<	;If question mark was entered then dump current
	ldy #CRLF>	; breakpoints.
	jsr PrntMess	;
	ldy #0ffh	;
	ldx #0ffh	;
OtAdAgin *		;
	iny		;
	inx		;
	lda BrkPt1Ad,y	;
	sta PointerA	;
	iny		;
	lda BrkPt1Ad,y	;
	sta PointerA+1d	;
	lda BrkPt1St,x	;
	beq AdEmpty	;
	jsr PrntAdd	;
AdEmpty *		;
	cpy #7d		;
	bne OtAdAgin	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp ExitBP	;
	
Minus *
	lda OpFld2	;If minus was found in operand field #1 check for
	cmp #0d		; an address in operand field #2.  If no address
	beq ClrAllBP	; was found then clear all breakpoints, if an
	ldx #20d	; address was found then clear that one breakpoint.
	jsr GetAdd	;
	bcs Clr1BP	;
	jmp ExitBP	;
	
ClrAllBP *
	ldy #3d		;Clear all breakpoints.
ZeroBP *		;
	lda #0d		;
	sta BrkPt1St,y	;
	dey		;
	bpl ZeroBP	;
	jmp ExitBP	;
	
Clr1BP *
	stx TempAdd	;Search for a match between a breakpoint address
	sty TempAdd+1d	; in the breakpoint address table and the address
	ldy #3d		; that was entered.
	ldx #6d		;
CkBPAdd *		;
	jsr CmpBPAdd	;
	bcs FoundBP	;
	dey		;
	dex		;
	dex		;
	bpl CkBPAdd	;
	
BPNtFnd *		
	ldx #NoBPMess<	;If no match was found then print an error message
	ldy #NoBPMess>	; and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
FoundBP *
	lda #0d		;If match was found then zero out that breakpoint's
	sta BrkPt1St,y	; status indicator and exit.
	jmp ExitBP	;

Plus *
	lda OpFld2	;If a plus was entered then check operand field
	cmp #0d		; #2 for the address of the new breakpoint.
	beq OutBP2	;
	ldx #20d	;
	jsr GetAdd	;
	bcs BPAdOk	;
OutBP2 *		;
	jmp ExitBP	;


BPAdOk *
	stx TempAdd	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddP *		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmp	;
	jsr CmpBPAdd	;
	bcs OutBP2	;
NoCmp *			;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddP	;
	

	ldy #0d		;If a plus was entered then search breakpoint
CkNxtBP *		;
	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
	cmp #0d		;
	beq EmptyBP	;
	iny		;
	cpy #4d		;
	bne CkNxtBP	;
	
AllBPFull *
	ldx #BPFulMes<	;If all breakpoints are full then print an error
	ldy #BPFulMes>	; message and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
EmptyBP *
	sty BPNumHld	;
	lda #1d		;
	sta BrkPt1St,y	;
	
	
NxtBPSlt0 *
	cpy #0d		;Store new address in first position of
	bne NxtBPSlt1	; breakpoint table.
	lda TempAdd	;
	sta BrkPt1Ad	;
	lda TempAdd+1d	;
	sta BrkPt1Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt1 *		;
	cpy #1d		;Store new address in second position of
	bne NxtBPSlt2	; breakpoint table.
	lda TempAdd	;
	sta BrkPt2Ad	;
	lda TempAdd+1d	;
	sta BrkPt2Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt2 *		;
	cpy #2d		;Store new address in third position of
	bne NxtBPSlt3	; breakpoint table.
	lda TempAdd	;
	sta BrkPt3Ad	;
	lda TempAdd+1d	;
	sta BrkPt3Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt3 *		;
	lda TempAdd	;Store new address in forth position of
	sta BrkPt4Ad	; breakpoint table.
	lda TempAdd+1d	;
	sta BrkPt4Ad+1d	;
	jmp ExitBP	;

ExitBP *
	rts


;****************************************************************************
;                   Compare Breakpoint Address Subroutine.
;****************************************************************************
CmpBPAdd *
	cpy #0d		;Compare LSB of first breakpoint address.
	bne CmpNxt1	;
	lda TempAdd+1d	;
	cmp BrkPt1Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt1 *		;
	cpy #1d		;Compare MSB of second breakpoint address.
	bne CmpNxt2	;
	lda TempAdd+1d	;
	cmp BrkPt2Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt2 *		;
	cpy #2d		;Compare MSB of third breakpoint address.
	bne CmpNxt3	;
	lda TempAdd+1d	;
	cmp BrkPt3Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt3 *		;
	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
	cmp BrkPt4Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CChkFLSB *
	lda TempAdd	;Compare LSB of breakpoint address.
	cmp BrkPt1Ad,x	;
	beq BPMatch	;
	jmp NoMatch	;
	
BPMatch *		;Return with carry set if addresses match.
	sec		;
	rts		;
	
NoMatch *		;Return with carry cleared if addresses
	clc		; do not match.
	rts		;


;****************************************************************************
;                     Dump command Subroutine
;****************************************************************************
Dump *
	
	ldx #0h
	
	lda OpFld1,x	;If no operands then do a standard dump.
	cmp #0h		;
	beq DoStdDmp	;

	jsr AsToBin	;Get start address from operand field #1 and place
	bcs DgtOk1	; in zero page pointer.
	jmp ErrDump	;
DgtOk1 *		;
	sta PointerA+1d	;
	inx		;
	jsr AsToBin	;
	bcs DgtOk2	;
	jmp ErrDump	;
DgtOk2 *		;
	sta PointerA	;
	
	ldx #20d	;If no end address was entered then perform a
	lda OpFld1,x	; standard dump.
	cmp #0h		;
	beq DoStdDmp	;
	
	Jsr AsToBin	;Get end address from operand field #2 and place
	bcs OpFldOk1	; in the variable EndAdd.
	jmp ErrDump	;
OpFldOk1 *		;
	sta EndAdd+1d	;
	inx 		;
	jsr AsToBin	;
	bcs OpFldOk2	;
	jmp ErrDump	;
OpFldOk2 *		;
	sta EndAdd	;
	
	jmp DoDump	
	
DoStdDmp *
	lda PointerA+1d	;Adjust end address so that it will only dump the
	sta EndAdd+1d	; contents of 16 memory locations.
	lda PointerA	;
	sta EndAdd	;
	clc   		;Note: check to make sure this is correct.
	adc #15d	;
	sta EndAdd	;
	bcc DoDump	;
	inc EndAdd+1d	;
	
DoDump *
	lda #13d	;Output a CRLF.
	jsr OutChar	;
	lda #10d	;
	jsr OutChar	;

	ldx #0d		;
	ldy #0d		;

	jsr PrntAdd	;Output address of first dump memory location.
	
DumpAgin *
	lda (PointerA),y;Get byte from memory location.

	jsr PutASCBf	;Put character in ASCII buffer.
	
	jsr OutHex	;Convert to ASCII/Hex and print.
	
	inx
	cpx #16d	;
	bne Chk8	;
	jsr DumpASC	;Output ASCII interpretion of dumped line.
	
Chk8 *			;
	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
	bne OutSpc	; the dump screen.
	lda #32d	;
	jsr OutChar	;
	lda #45d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	jmp ChkEndAd	;
	
OutSpc *
	lda #32d	;Print a space between hex characters on dump screen.
	jsr OutChar	;
	
ChkEndAd *
	lda PointerA	;Check pointer against end address holder.  Exit
	cmp EndAdd	; subroutine if the end address has been reached,
	bne PointNxt	; increment pointer and dump the contents of 
	lda PointerA+1d	; another memory location if not.
	cmp EndAdd+1d	;
	beq ExitDump	;
PointNxt *
	inc PointerA	;
	bne NoCary2	;
	inc PointerA+1d	;
NoCary2 *		;

ChkCR *			;Perform end of dump line functions.
	cpx #16d	;
	bne NotEnd	;
	
	lda #10d	;Print a CRLF and reset X register to point to
	jsr OutChar	; beginning of new dump line.
	lda #13d	;
	jsr Outchar	;
	jsr PrntAdd	;
	ldx #0d		;
NotEnd *
	
	jmp DumpAgin	;

ErrDump *
	clc
	rts

ExitDump *
	inc PointerA	;Point to next location in memory to be dumped
	bne NoCary3	;
	inc PointerA+1d	;
NoCary3 *		;
	sec
	rts

;****************************************************************************
;                 Output the ASCII interpretation of the dumped line.
;****************************************************************************
DumpASC *
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	ldx #0d		;
OutAsc *
	lda ASCIIbuf,x	;
	jsr OutChar	;
	inx		;
	cpx #16d	;
	bne OutAsc	;
	rts


;****************************************************************************
;         Put byte from memory into ASCII buffer from Dump command.
;****************************************************************************
PutASCBf *
	pha
	cmp #32d
	bmi Period
	cmp #127d
	bpl Period
	sta ASCIIbuf,x
	jmp ExitPut
Period *
	lda #46d
	sta ASCIIbuf,x
ExitPut *
	pla
	rts
	
;****************************************************************************
;                        Enter Command Subroutine.
;****************************************************************************
Enter *
	lda OpFld1	;Check for operand in operand field #1.
	cmp #0d		;
	bne ChkOp2	;
	jmp ErrEntr	;
	
ChkOp2 *
	lda OpFld2	;Check for operand in operand field #2.
	cmp #0d		;
	bne ProcEntr	;
	jmp ErrEntr	;
	
ProcEntr *
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs EnAddOk	;
	jmp ErrEntr	;

EnAddOk *
	stx PointerA	;Put address from operand field #1 into
	sty PointerA+1d	; zero page variable Pointer.
	
	ldx #20d	;Get list of bytes to be entered into memory
	jsr GetList	; from operand field #2 and put them in memory
	bcc ErrEntr	; starting at Pointer.
	jmp ExitEntr	;
	
ErrEntr *
	clc
	rts	

ExitEntr *
	sec
	rts


;****************************************************************************
;                        Get List Subroutine
;
;	Zero page variable Pointer points to location in memory where
;	 list members will be placed.
;****************************************************************************
GetList *
	ldy #0d
	
	sty DataTemp	;Use this variable to count bytes in list.	
	
GLNxtByt *
	lda OpFld1,x	;Check for NULL that terminates current
	beq ListErr	; operand field.
	
	jsr AsToBin	;Convert byte in list to binary form and place
	bcs StInMem	; in memory.
	jmp ListErr	;
StInMem *		;
	sta (PointerA),y;
	inc PointerA	;
	bne LstNoOv	;
	inc PointerA+1d	;
LstNoOv *		;
	inc DataTemp	;
	lda DataTemp	;
	cmp #10d	;
	beq ExtGtLst	;
	
	inx		;Point to comma between bytes.

	lda OpFld1,x	;Check for NULL that terminates current
	beq ExtGtLst	; operand field.
	
	inx		;Point to next byte in list.
	
	jmp GLNxtByt	;
	
ExtGtLst *
	sec
	rts

ListErr *
	clc
	rts

;****************************************************************************
;                        Fill Command Subroutine.
;****************************************************************************
Fill *

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs FAdd1ok	;
	jmp ErrFill	;
FAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs FAdd2ok	;
	jmp ErrFill	;
FAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
FillAgin *
	ldx #40d	;Get list and place in memory.
	jsr GetList	;
	bcc ErrFill	;

	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq ChkFLSB	;
;	bmi ExitFill 	;
	jmp FillAgin 	;
ChkFLSB *
	lda EndAdd	; 
	cmp PointerA	;
	beq ExitFill	;
	
	jmp  FillAgin	;
	

ErrFill *
	clc
	rts

ExitFill *
	sec
	rts

;****************************************************************************
;                        Go Command Subroutine
;****************************************************************************
Go *

	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq CurentPC	;
			
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs GAddOk	;
	jmp ErrGo	;
	
GAddOk *		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;

CurentPC *
	ldx UPgmCntr	;
	stx TempAdd	;
	ldy UPgmCntr+1d	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddG *		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmpG	;
	jsr CmpBPAdd	;
	bcs MaError	;
NoCmpG *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddG	;
	jmp NoMatchG	;

MaError *
	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
	ldy #GoBPErrM>	; error message and exit.
	jsr PrntMess	;
	jmp ExitGo	;

NoMatchG *
	ldy #3d		;Check all active breakpoints in table, save
	ldx #6d		; the opcodes of the breakpointed addresses, 
CkBPSt *		;
	lda BrkPt1St,y	; and replace them with BRKs.
	cmp #1d		;
	bne NxtBPSt	;
	lda (BrkPt1Ad,x);
	sta BP1OpHld,y	;
	lda #0d		;
	sta (BrkPt1Ad,x);
NxtBPSt *		;
	dey		;
	dex		;
	dex		;
	bpl CkBPSt	;

	pla		;Remove Go command's return address and the check
	pla		; command's return address from the stack.
	pla		;
	pla		;
	
	jmp (UPgmCntr)	;Start executing at address being pointed to by
			; UPGmCntr.	

ErrGo *
	clc
	rts
	
ExitGo *
	sec
	rts

;****************************************************************************
;                       Help Command Subroutine.
;****************************************************************************
Help *
	ldx #HelpMess<
	ldy #HelpMess>
	jsr PrntMess
	rts

;****************************************************************************
;                     Load Command Subroutine
;****************************************************************************
LdSRecs *
	ldx #SRecStMs<
	ldy #SRecStMs>	
	jsr PrntMess
	
GtAnCh *		;
	jsr GetCharW	;Check for an S.
	cmp #83d	;
	bne GtAnCh	;
	
	;jsr OutChar	;Print an S to the user.
	
	jsr GetCharW	;Get record type ECHO it and store it.
	;jsr OutChar	;
	sta RecType	;
	
	cmp #48d	;Check for header record and process.
	bne NtHdr	;
	jsr ProcHdr	;
	bcc SError	;
	jmp NextLine	;
	
NtHdr *			;
	cmp #49d	;Check for code record and process.
	bne NtCd	;
	jsr ProcCode	;
	bcc SError	;
	jmp NextLine	;
	
NtCd *			;
	cmp #57d	;Check for termination record process, and print
	bne SError	; records loaded message.
	jsr ProcTerm	;
	bcc SError	;
	ldx #SRecEnMs<	;
	ldy #SRecEnMs>	;
	jsr PrntMess	;
	jmp ExitSRec	;
	
NextLine *
	jmp GtAnCh

SError *
	ldx #SRecErMe<
	ldy #SRecErMe>	
	jsr PrntMess
	sec
	rts
	
ExitSRec *
	jsr GetCharW
	sec
	rts
	
;****************************************************************************
;                Process Record Length and Address Subroutine
;****************************************************************************
PrRLeAdd *	
	
	lda #0h		;Zero out Checksum accumulator.
	sta CkSumAc	;
	sta CkSumAc+1h	;
	
	jsr Getnum	;Fetch record length and update checksum
	sta RecLen	; accumulator.
	jsr AccCkSum	;
	
	tax		;Adjust code byte counter and store it.
	dex		;
	dex		;
	dex		;
	txa		;
	sta CodeCntr	;
	
	jsr GetNum	;Get most significant byte of address and
	sta PointerA+1h	; store it.
	jsr AccCkSum	;
	
	jsr GetNum	;Get least significant byte of address and
	sta PointerA	; store it.
	jsr AccCkSum	;
	
	rts
	
;****************************************************************************
;        Get Code Byte Without Loading into Memory Subroutine.
;****************************************************************************
GtCodNld *
	
	lda CodeCntr
	beq ExitNld
	
GetOneNl *
	jsr GetNum
	jsr AccCkSum
	dec CodeCntr
	Bne GetOneNl
	
ExitNld *
	rts

;****************************************************************************
;        Get Code Byte and Load it into Memory Subroutine.
;****************************************************************************
GtCodLd *

	lda CodeCntr
	beq ExitLd
	
	ldy #0h
GtOneLd *
	jsr GetNum
	jsr AccCkSum
	sta (PointerA),y	
	inc PointerA
	bne NxtCode
	inc PointerA+1h
NxtCode *
	dec CodeCntr
	bne GtOneld
	
ExitLd *
	rts

;****************************************************************************
;                      Check Checksum Subroutine.
;****************************************************************************
ChkChkSm *

	lda CkSumAc	;Invert lowest byte of the checksum accumulator
	eor #0ffh	; and store it in CkhSum.
	sta ChkSum	;
	
	jsr GetNum	;Compare calculated checksum against S record	
	cmp ChkSum	; checksum.
	beq CkSumOK	;
	clc
	jmp Chkexit
CkSumOK *
	sec
Chkexit *
	rts

;****************************************************************************
;                       Get Number Subroutine.
;****************************************************************************
GetNum *
	tya
	pha

	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in most significat nibble
	bcc ExtGtNum	;
	asl a		; of number.
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in least significant
	bcc ExtGtNum	;
	ora number	; nibble of number.
	sta number	;
	
	pla
	tay
	lda number
ExtGtNum *
	rts

;****************************************************************************
;                    Accumulate Checksum Subroutine.
;****************************************************************************
AccCkSum *
	pha
	clc
	adc CkSumAc
	sta CkSumAc
	bcc NoOvrFlo
	inc CkSumAc+1h
NoOvrFlo *
	pla
	rts

;****************************************************************************
;                ASCII Digit to Binary Number Subroutine.
;
;        Enter with register 'A' containing the number to convert.
;        If the number was valid return its binary conversion in the
;        A register.  If the number is not convertable then clear the
;        carry flag and return.
;****************************************************************************
DgtToBin *
	
	stx RegTemp	;Save the character to convert.
	
	ldx #0h		
	
AnothDgt *
	cmp DgtTblUC,x	;Search through character table and try to find
	beq Match	; a match for the character present in the X
	cmp DgtTblLC,x	; register.
	beq Match	;
	
	inx		;If a match was not found then increment the
	cpx #16d	; table index register and check the next
	beq DgtError	; character.  If all the characters have been 
	jmp AnothDgt	; checked then return with an error.
	
DgtError *
	lda #0h
	clc
	jmp DgtExit

Match *
	txa
	sec
	
	ldx RegTemp
DgtExit	rts
	
;****************************************************************************
;                    Process Header Record Subroutine.
;****************************************************************************

ProcHdr *

	jsr PrRLeAdd
	jsr GtCodNld		
	jsr ChkChkSm
	
	rts

;****************************************************************************
;                     Process Code Record Subroutine
;****************************************************************************
ProcCode *

	jsr PrRLeAdd
	jsr GtCodLd
	jsr ChkChksm
	
	rts

;****************************************************************************
;                     Process Termination Record Subroutine
;****************************************************************************
ProcTerm *

	jsr PrRLeAdd
	jsr GtCodNld	
	jsr ChkChkSm

	rts

;****************************************************************************
;                       Move Command Subroutine.
;****************************************************************************
Move *
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq MOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs MAdd1ok	;
MOut *			;
	jmp ExitMove	;
MAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs MAdd2ok	;
	jmp ExitMove	;
MAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne MNOvFlo	;
	inc EndAdd+1d	;
	
MNOvFlo *		;
	ldx #40d	;Get destination address.
	jsr GetAdd	;
	bcs MAdd3ok	;
	jmp ExitMove	;
MAdd3ok *		;
	stx PointerB	;
	sty PointerB+1d	;

	ldy #0d		;Move bytes between start address and end address
MCont *			;to memory starting at destination address.
	lda (PointerA),y; 
	sta (PointerB),y;
	inc PointerB	;
	bne MNoOvf1	;
	inc PointerB+1d	;
MNoOvf1 *		;
	inc PointerA	;
	bne MNoOvf2	;
	inc PointerA+1d	;
MNoOvf2 *		;
	lda PointerA	;
	cmp EndAdd	;
	beq MCkMSB	;
	jmp MCont	;
MCkMSB *		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitMove	;
	jmp MCont	;
	
ExitMove *
	rts


;****************************************************************************
;                     Register Command Subroutine
;****************************************************************************
Register *
	pha
	txa
	pha
	tya
	pha
	php
	
	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq GenReg	;
	jmp SpecReg	;
	
GenReg *		;
	ldx #RegMess<	;Output register headings.
	ldy #RegMess>	;
	jsr PrntMess	;
	
	ldy #3d		;Output contents of user's program counter.
	jsr OutSpace	;
	lda UPgmCntr+1d	;
	jsr OutHex	;
	lda UPgmCntr	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's accumulator.
	jsr OutSpace	;
	lda UAccum	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's X register.
	jsr OutSpace	;
	lda UXreg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Y register.
	jsr OutSpace	;
	lda UYReg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Stack Pointer.
	jsr OutSpace	;
	lda UStkPtr	;
	jsr OutHex	;
	
	ldy #7d		;Output contents of user's Status register.
	jsr OutSpace	;
	lda UStatReg	;
	ldx #8d		;
NextFlag *		;
	rol a		;
	bcs OutOne	;
OutZero *		;
	pha		;
	lda #30h	;
	jsr OutChar	;
	pla		;
	jmp CkBtPos	;
OutOne *		;
	pha		;
	lda #31h	;
	jsr OutChar	;
	pla		;
CkBtPos *		;
	dex		;
	bne NextFlag	;
	jmp ExitReg	;
	
	
SpecReg *
	lda #13d
	jsr OutChar
	lda #10d
	jsr OutChar
	lda OpFld1
	jsr ToLower

CkPCReg *		;
	cmp #112d	;Get value for Program Counter from user.
	bne CkAReg	;
	lda UpgmCntr+1d	;
	jsr OutHex	;
	lda UpgmCntr	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetPC	;
	jmp ExitReg	;
GetPC	ldx #0d		;
	jsr AsToBin	;
	bcs PCMSBOK	;
	jmp ExitReg	;
PCMSBOK	tay		;
	inx		;
	jsr AsToBin	;
	bcs PCLSBOK	;
	jmp ExitReg	;
PCLSBOK	sta UPgmCntr	;
	sty UPgmCntr+1d	;
	jmp ExitReg	;
	
CkAReg *		;Get value for Accumulator from user.
	cmp #97d	;
	bne CkXReg	;
	lda UAccum	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetA	;
	jmp ExitReg	;
GetA *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs AOK		;
	jmp ExitReg	;
AOK *			;
	sta UAccum	;
	jmp ExitReg	;
	
CkXReg *		;Get value for X register from user.
	cmp #120d	;
	bne CkYReg	;
	lda UXreg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetX	;
	jmp ExitReg	;
GetX *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs XOK		;
	jmp ExitReg	;
XOK *			;
	sta UXReg	;
	jmp ExitReg	;
	
CkYReg *		;Get value for Y register from user.
	cmp #121d	;
	bne CkForS	;
	lda UYReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetY	;
	jmp ExitReg	;
GetY *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs YOK		;
	jmp ExitReg	;
YOK *			;
	sta UYReg	;
	jmp ExitReg	;
	
CkForS *		;Check if user is accessing the Stack Pointer or
	cmp #115d	; the Status Register.
	beq CkPorR	;
	jmp RegInErr	;
CkPorR *		;
	lda OpFld1+1d	;
	jsr ToLower	;
	cmp #112d	;
	beq CkSpReg	;
	cmp #114d	;
	beq CkSRReg	;
	jmp RegInErr	;

CkSpReg *		;
	lda UStkPtr	;Get value for Stack Pointer from user.
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSP	;
	jmp ExitReg	;
GetSP *			;
	ldx #0d		;
	jsr AsToBin	;
	bcs SPOK	;
	jmp ExitReg	;
SPOK *			;
	sta UStkPtr	;
	jmp ExitReg	;
	
CkSRReg *		;Get value for Status Register from user.
	lda UStatReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSR	;
	jmp ExitReg	;
GetSR	ldx #0d		;
	jsr AsToBin	;
	bcs SROK	;
	jmp ExitReg	;
SROK	sta UStatReg	;
	jmp ExitReg	;

RegInErr *
	clc
	jmp ErrRegOt
	
ExitReg *
	sec
ErrRegOt *
	plp
	pla
	tay
	pla
	tax
	pla
	rts

;****************************************************************************
;                       Search Command Subroutine.
;****************************************************************************
Search *
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq SOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs SAdd1ok	;
SOut *			;
	jmp ExitSrch	;
SAdd1ok	*		;
	stx PointerB	;
	sty PointerB+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs SAdd2ok	;
	jmp ExitSrch	;
SAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne SNOvFlo	;
	inc EndAdd+1d	;
	
SNOvFlo	*		;
	ldx #40d	;Get search list from operand field #3 and store
	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
	sta PointerA	; SrchBtCt.
	lda #SrchTabl>	;
	sta PointerA+1d	;
	jsr GetList	;
	bcc ExitSrch	;
	lda DataTemp	;
	sta SrchBtCt	;
	
	lda PointerB	;Transfer start address from pointer A to 
	sta PointerA	; pointer B.  Output a CRLF.
	lda PointerB+1d	;
	sta PointerA+1d	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	
SCkByte1 *		;Compare list with memory.
	ldx #0d		;
	ldy #0d		;
SCkByte2 *		;
	lda (PointerA),y;
	cmp SrchTabl,x	;
	beq SMatch	;
	
IncScPtr *
	jsr IncPntrA	;Increment memory pointer and check to see if
	lda PointerA	; the end address has been reached.
	cmp EndAdd	;
	beq SckMSB	;
	jmp SCkByte1	;
SCkMSB *		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitSrch	;
	jmp SCkByte1	;
	
SMatch *		;
	iny		;Check to see if all bytes in search list match
	inx		; bytes in memory.
	cpx SrchBtCt	;
	beq SFulMtch	;
	jmp SCkByte2	;

SFulMtch *		;
	jsr PrntAdd	;Output address where match was found.
	jsr IncPntrA	;
	jmp SCkByte1	;

ExitSrch *
	rts



;****************************************************************************
;                       Trace Command Subroutine.
;****************************************************************************
Trace *

	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq TNoOper	;
	
	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs TAdd1ok	;
	jmp ErrTrce	;
TAdd1ok *		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;
	
	lda OpFld2	;Check to see if a trace count has been 
	cmp #0d		; specified.
	bne GtTrcCnt	;

TNoOper *
	ldy #1d		;Set trace count to 1.
	sty TracCnt	;
	jmp StartTrc	;

GtTrcCnt *	
	ldx #20d	;Get trace count from user.
	jsr AsToBin	;
	bcs TrValOK	;
	jmp ErrTrce	;
TrValOK *		;
	sta TracCnt	;
	
StartTrc *
	pla		;Remove trace command's return address and
	pla		; the check command routine's return address from
	pla		; the stack.
	pla		;

ContTrc *	
	ldy UPgmCntr	;Transfer user's program counter to pointer A.
	sty PointerA	;
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;

	ldy #0d		;Get opcode of current instruction.
	lda (PointerA),y;
	sta OpCdHold	;
	
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs TOpCdFnd	; an opcode.
	jmp ErrTrce

TOpCdFnd *
	ldy #8d		;Get number of bytes in the current instruction
	lda (PointerB),y; information from opcode table.
	sta CurInsLn	;
	
	ldy #1d		;Get opcode of current instruction.
	lda OpCdHold	;

TrRTS *			;If the opcode is an RTS then copy the return
	cmp #60h	; address from the stack, save the opcode to
	bne TNxtOp0	; be returned to, and place a BRK at the return
	lda #2d		; address.
	sta BrnchFlg	;
	pla		;
	sta BOpAdPtr	;
	pla		;
	sta BOpAdPtr+1d	;
	pha		;
	lda BOpAdPtr	;
	pha		;
	inc BOpAdPtr	;
	bne NNOvflo	;
	inc BOpAdPtr+1d	;
NNOvflo *		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp0 *		;
	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
	bne TNxtOp1	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp1 *
	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
	bne TNxtOp2	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta PointerC	;
	iny		;
	lda (PointerA),y;
	sta PointerC+1d	;
	ldy #0d		;
	lda (PointerC),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerC),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
		
	
TNxtOp2 *
	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
	bne TNxtOp3	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp3 *
	ldy #0d		;Check to see if the current instruction is an
	lda (PointerB),y; actual branch.
	cmp #'B'	;
	bne NoBrnch2	;
	ldy #1d		;
	lda (PointerB),y;
	cmp #'I'	;
	bne Branch	;
NoBrnch2 *		;
	jmp NoBranch	;
	
Branch *		;If the opcode is a branch, Bxx aaaa,
	lda #1d		; then save the opcode of the instruction that
	sta BrnchFlg	; will be branched to and replace it with a BRK.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta BOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
			;
	ldy #1d		;
	lda (PointerA),y;
	sta BrValHld	;
	bpl AddAdd	;
SubAdd *		;
	dec BrValHld	;
	lda BrValHld	;
	eor #0ffh	;
	sta BrValHld	;
	sec		;
	lda BOpAdPtr	;
	sbc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	sbc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
AddAdd *		;
	clc		;
	lda BOpAdPtr	;
	adc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
GtBrOpCd *		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp Both	;
	
NoBranch *
	lda #0d		;Set branch flag to 0 to indicate the current
	sta BrnchFlg	; instruction is not a branch instruction.

Both *
	ldy CurInsLn	;
	lda (PointerA),y;Save the opcode of the next instruction to be
	sta NOpCdHld	; executed if no branch is taken and replace it
			; with a BRK command.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta NOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta NOpAdPtr+1d	;
	lda #0d		;
	sta (PointerA),y;
	
ChBkVect *
	lda #1d		;Make BRK jump here instead of main.
	sta TrBrkFlg	;
	
	lda UStatReg	;Execute instruction pointed to by UPgmCntr.
	pha		;
	lda UAccum	;
	ldx UXreg	;
	ldy UYReg	;
	plp		;
	jmp (UPgmCntr)	;
	
Tr2ndEnt *
	lda #0d		;Reset trace break flag.
	sta TrBrkFlg	;
	
CkBrnch *		;
	ldy #0d		;Check to see which opcodes need to be restored.
	lda BrnchFlg	;
	cmp #0d		;
	beq NoBrnch	;
	cmp #1d		;
	beq Brnch	;
	
DoJmp *
	lda BOpCdHld	;Restore opcode to be jumped to.
	sta (BOpAdPtr),y;
	jmp UpDtPtrA	;

Brnch *
	lda BOpCdHld	;Restore opcode to be branched to.
	sta (BOpAdPtr),y;
	
NoBrnch *
	lda NOpCdHld	;Restore opcode that will be executed next in
	sta (NOpAdPtr),y; the instruction stream.

UpDtPtrA *
	ldy UPgmCntr	;Set pointer A to point to the next instruction
	sty PointerA	; to be executed for unassemble.
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;
	
	ldx #CRLF<	;Unassemble next instruction in memory.
	ldy #CRLF>	;
	jsr PrntMess	;
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	jsr StartUnA	;
	
NxtIn *
	dec TracCnt	;Decrement trace count and trace again if it
	beq OutTrce	; is not zero.
	jmp ContTrc	;

OutTrce *
	jmp MainLoop	;Enter the main monitor loop using a jump
			; because the trace command's return address
			; and the check command routine's return address
			; were removed when a trace was initiated.
ErrTrce *
	clc
	rts	

ExitTrce *
	sec
	rts	

;****************************************************************************
;                       Scan for Valid Opcode Subroutine.
;****************************************************************************
ScanOpCd *
	
	ldx #OpTable<	;Point pointer B to beginning of opcode table.
	stx PointerB	;
	ldx #OpTable>	;
	stx PointerB+1d	;
	
CkTblEnd *
	ldy #4d		;Check for end of opcode table.
	lda (PointerB),y;
	cmp #90d	;
	beq OpCdNtFd	;
	
CkNxtOp *		;
	ldy #7d		;Check for an opcode match in the opcode table.
	lda (PointerB),y;
	cmp OpCdHold	;
	beq OpCdFndS	;
	
	lda PointerB	;Point pointer B to next entry in opcode table.
	clc		;
	adc #10d	;
	sta PointerB	;
	bcc ScNoCary	;
	inc PointerB+1d	;
		
ScNoCary *
	jmp CkTblEnd
	
	
OpCdFndS *
	sec
	rts
	
OpCdNtFd *
	clc
	rts
	
;****************************************************************************
;                       Unassemble Command Subroutine.
;****************************************************************************
UnAssem *
 nop
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq UNoOper	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs UAdd1ok	;
	jmp ErrUnAs	;
UAdd1ok *		;
	stx PointerA	;
	sty PointerA+1d	;
	
	lda OpFld2	;Check to see if an end address has been 
	cmp #0d		; specified.
	bne GtUEndAd	;
	
UNoOper *
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	clc		;If no end address has been specified by the
	lda PointerA	; user then set the end address to start address
	adc #20d	; + 20d.
	sta EndAdd	;
	bcc UNoCary	;
	ldx EndAdd+1d	;
	inx		;
	stx EndAdd+1d	;
UNoCary *		;
	jmp StartUnA	;
	
GtUEndAd *
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs UAdd2ok	;
	jmp ErrUnAs	;
UAdd2ok *		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
StartUnA *
	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq UChkFLSB	;
	bcc UOut	;
	jmp UNotFin 	;
UChkFLSB *
	lda EndAdd	; 
	cmp PointerA	;
	bcc UOut	;
	jmp UNotFin	;
UOut *			;
	jmp ExitUnAs	;

UNotFin *		;
	ldy #0d		;Get opcode byte from memory and save.
	lda (PointerA),y;
	sta OpCdHold	;
	
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs OpCdFnd	; an opcode.

NtOpCode *
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;

	lda OpCdHold	;Print the bad opcode.
	jsr OutHex	;
	
	ldx #BadOpMes<	;If byte was not an opcode then print question
	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
	jsr PrntMess	;
	jsr IncPntrA	;
	jmp StartUnA	;

OpCdFnd *
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr IncPntrA	;

CkAdMode *
	ldy #6d		;Get addressing mode indicator from table.
	lda (PointerB),y;
	
NxAdMo1 *		;
	cmp #'P'	;Check for implied addressing mode.
	bne NxAdMo2	;
	jmp ImpAdMo	;
	
NxAdMo2 *		;
	cmp #'M'	;Check for immediate addressing mode.
	bne NxAdMo3	;
	jmp ImmAdMo	;	

NxAdMo3 *		;
	cmp #'S'	;Check for absolute addressing mode.
	bne NxAdMo4	;
	jmp AbsxyAdM	;	

NxAdMo4 *		;
	cmp #'X'	;Check for absolute x addressing mode.
	bne NxAdMo5	;
	jmp AbsxyAdM	;

NxAdMo5 *		;
	cmp #'Y'	;Check for absolute y addressing mode.
	bne NxAdMo6	;
	jmp AbsxyAdM	;

NxAdMo6 *		;
	cmp #'R'	;Check for indexed indirect addressing mode.
	bne NxAdMo7	;
	jmp IIRAdMo	;

NxAdMo7 *		;
	cmp #'L'	;Check for relative addressing mode.
	bne NxAdMo8 	;
	jmp RelAdMo	;

NxAdMo8 *		;
	cmp #'C'	;Check for accumulator addressing mode.
	bne NxAdMo9 	;
	jmp AccAdMo	;

NxAdMo9 *		;
	cmp #'D'	;Check for indirect addressing mode.
	bne NxAdMo10 	;
	jmp IndAdMo	;

NxAdMo10 *
	cmp #'I'	;Check for indirect indexed addressing mode.
	bne BdOpCd	;
	jmp IRIAdMo	;

BdOpCd *		;
	jmp NtOpCode	;


ImpAdMo *
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	jmp StartUnA

AccAdMo *
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	lda #65d	;Print a capital A for accumulator addressing.
	jsr OutChar	;
	
	jmp StartUnA


ImmAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #35d	;Print a pound sign.
	jsr OutChar	;
	
	lda ObCdHld1	;Print immediate operand value.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	jmp StartUnA


AbsxyAdM *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	ldy #6d		;Check to see if address mode is abs, abx or
	lda (PointerB),y; aby.
	cmp #'X'	;
	beq AbxAdMo	;
	cmp #'Y'	;
	beq AbyAdMo	;
	
AbsAM *
	jmp StartUnA

AbxAdMo *
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	jmp StartUna
	
AbyAdMo *
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;

	jmp StartUnA


RelAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda PointerA	;Store a copy of the next instruction's start
	sta AddHold	; address.
	lda PointerA+1d	;
	sta AddHold+1d	;
	
	lda ObCdHld1	;Check to see if branch is positive or negative.
	bmi NegBrnch	;
	
PosBrnch *		;If branch is positive then find address being
	lda AddHold	; branched to by adding offset to start address
	clc		; of next instruction in memory.
	adc ObCdHld1	;
	sta AddHold	;
	bcc OutBrAdd	;
	inc AddHold+1d	;
	jmp OutBrAdd	;
		
NegBrnch *
	dec ObCdHld1	;If branch is negative then find address being
	lda ObCdHld1	; branched to by subtracting offset from start
	eor #0ffh	; address of next instruction in memory.
	sta ObCdHld1	;
	lda AddHold	;
	sec		;
	sbc ObCdHld1	;
	sta AddHold	;
	bcs OutBrAdd	;
	dec AddHold+1d	;
	
OutBrAdd *
	lda AddHold+1d	;Print address being branched to.
	jsr OutHex	;
	lda AddHold	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	jmp StartUnA


IRIAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;
	
	jmp StartUnA
	
IIRAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA

IndAdMo *
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA
	
ErrUnAs *
	clc
	rts

ExitUnAs *
	sec
	rts


;****************************************************************************
;                       Print Mnemonic Subroutine.
;****************************************************************************
PrntMnem *

	ldy #0d		;Use loop to print all three characters of
PrntMore *
	lda (PointerB),y; mnemonic.
	jsr OutChar	;
	iny		;
	cpy #3d		;
	bne PrntMore	;
	
	lda #32d	;Print a space after the mnemonic.
	jsr OutChar	;
	
	rts

;****************************************************************************
;                       Increment Pointer A Subroutine.
;****************************************************************************
IncPntrA *
	inc PointerA
	bne NoOvFl1
	inc PointerA+1d
NoOvFl1 *
	rts



;****************************************************************************
;                        Get Address Subroutine
;
;	X returns LSB of address.  Y returns MSB of address.
;****************************************************************************
GetAdd *		;Convert address found in operand field #x
	jsr AsToBin	; into binary.
	bcs AdMSBOK	;
	jmp ErrGtAd	;
AdMSBOK *		;
	tay		;
	inx		;
	jsr AsToBin	;
	bcs AdLSBOK	;
	jmp ErrGtAd	;
AdLSBOK *		;
	tax

	sec		;If conversion OK then set carry flag and
	rts		; return.
	
ErrGtAd *		;
	clc		;If error then clear carry and return.
	rts		;


;****************************************************************************
;                     Output a Colon Prompt Subroutine.
;****************************************************************************
OutColn *
	ldx #ColnPrmt<
	ldy #ColnPrmt>
	jsr PrntMess
	rts

;****************************************************************************
;                     Out Spaces Subroutine
;
;       Enter with the Y register indicating the number of spaces to output.
;****************************************************************************
OutSpace *		;Output the number of spaces indicated by
	pha		; the Y register.
OtAnoSpc *
	lda #32d
	jsr OutChar
	dey
	bne OtAnoSpc
	pla
	rts


;****************************************************************************
;              Covert ASCII character to lower case Subroutine.
;****************************************************************************
ToLower *
	cmp #65d
	bmi ExitToLo
	cmp #91d
	bpl ExitToLo
	clc
	adc #32d
ExitTolo *
	rts


;****************************************************************************
;              Covert ASCII character to upper case Subroutine.
;****************************************************************************
ToUpper *
	cmp #'a'
	bmi ExitToUp
	cmp #123d
	bpl ExitToUp
	sec
	sbc #32d
ExitToUp *
	rts



;****************************************************************************
;                         Print address.
;****************************************************************************
PrntAdd *
	lda PointerA+1d	;
	jsr OutHex	;
	lda PointerA	;
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	
	rts

;****************************************************************************
;                         Ascii to Binary Subroutine.
;****************************************************************************
AsToBin *		;X points to digits to be converted using
			; OpFld1 as a base.

	lda OpFld1,x	;Convert most significant digit to binary.
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	asl a		;
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	inx		;Convert least significant digit to binary.
	lda OpFld1,x	;
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	ora number	;
	
	sta number	;Store full binary number in number.
	sec
ExtAs2Bn *
	rts
	
;****************************************************************************
;                     Output a Hex byte to the serial port.
;
;            Enter with the number to be output in the A register.
;****************************************************************************
OutHex *
	sta number
	
	lsr a		;Output most significant digit of hex byte to
	lsr a		; serial port.
	lsr a		;
	lsr a		;
	and #0fh	;
	cmp #0ah	;
	bpl Letter1	;
	ora #30h	;
	jmp Print1st	;
Letter1 *		;
	sec
	sbc #9d		;
	ora #40h
Print1st *
	jsr OutChar	;
	
	lda number	;Output least significant digit of hex byte to
	and #0fh	; serial port.
	cmp #0ah	;
	bpl Letter2	;
	ora #30h	;
	jmp Print2nd	;
Letter2 *		;
	sec
	sbc #9d		;
	ora #40h	;
Print2nd *		;
	jsr OutChar	;
	
	lda number
	rts
	
;****************************************************************************
;                     Initialize Variables Subroutine
;****************************************************************************
InitVars *

	;lda #1ah	;Initialize ACIA control register, 2400
	;sta 6551CtR	; Baud.
	
	;lda #0bh	;Initialize ACIA command register.
	;sta 6551CmR	;
		
	lda #BRK<	;Initialize BRK vector.
	sta BRKVect	;
	lda #BRK>	;
	sta BRKVect+1d	;
	
	lda #0d		;Initialize trace break flag.
	sta TrBrkFlg	;
	
	lda #0d		;Initialize break point status variables.
	sta BrkPt1St	;
	sta BrkPt2St	;
	sta BrkPt3St	;
	sta BrkPt4St	;
	
	lda #0d		;Set the output port to all zeros (turn
	;sta OutPort0	; off all of the LEDs).
	
	rts

;****************************************************************************
;                          Print Message Subroutine.
;
; X holds the message pointer's low byte (< means less than) and Y holds its 
; high byte (> means greater than).  The message must have a NULL (0) after 
; the last character in the  Message so the PrntMess subroutine knows when to 
; stop printing.
;****************************************************************************
PrntMess *
	stx MessPtr	;Initialize pointer that will point to each
	sty MessPtr+1h	; character of message.
	
	ldy #0h
	
OutMess *		;
	lda (MessPtr),y	;Get a character from the message and if it is
	beq ExitMess	; a NULL (0) then exit this subroutine.
	
	jsr OutChar	;Output the character to the serial port.
	
	inc MessPtr	;Increment the message pointer to point to the
	bne PrNoOvf	; next character in the message.
	inc MessPtr+1d	;
	
PrNoOvf *
	jmp OutMess
		
ExitMess *
	rts

;****************************************************************************
;           Get Character (Don't Wait) From Serial Channel Subroutine
;****************************************************************************
GetChar *
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
	lda 6551StR	;Check ACIA to see if a character has been
	and #00001000b	; received and return with a NULL if no
	beq NoChar	; character was present.
	
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	jmp ExitGtCh	;
	
NoChar *
	lda #0d
	sta RegTemp
	
ExitGtCh *
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;             Get Character (Wait) From Serial Channel Subroutine
;****************************************************************************
GetCharW *
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
GtCkAgn *
	lda 6551StR	;Check the ACIA's receiver buffer full register
	and #00001000b	; and wait until a character is received.
	beq GtCkAgn	;
	
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;                 Output Chacacter to Serial Channel Subroutine 
;                   Character to print is in register 'A'
;****************************************************************************
OutChar *
	
	sta RegTemp	;Save registers.
	php		;
	tya		;
	pha		;
	txa		;
	pha		;
	
OtCkAgn *
	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
	and #00010000b	; register and wait until the buffer is empty.
	beq OtCkAgn	;
	
	lda RegTemp	;Output a character to the ACIA's Transmitt
	sta 6551TRR	; register.
	
	pla		;Restore registers.
	tax		;
	pla		;
	tay		;
	plp		;
	lda RegTemp	;
		
	rts


;****************************************************************************
;                          Delay Subroutine
;****************************************************************************
delay *
	pha
	txa
	pha
	tya
	pha
	
	lda #0h
	sta wait0
	lda #10h
	sta wait1
	
	
dw0 *
	dec wait0
	bne dw0
	dec wait1
	bne dw0
	
	pla
	tay
	pla                                                                        
	tax
	pla
	rts


;****************************************************************************
;                Constants
;****************************************************************************

UARTval		dbt 16h,0bh
DgtTblUC	dbt "0123456789ABCDEF"
		dbt 0h
DgtTblLC	dbt "0123456789abcdef"
		dbt 0h
OpenMess	dbt 10d,13d,10d
		dbt "UMON65 V1.11a - Understandable Monitor for the 6500 series microprocessors."
		dbt 10d,13d
		dbt 0h
prompt		dbt 10d,13d
		dbt "-"
		dbt 0h
CRLF		dbt 10d,13d,0d
SRecStMs	dbt 10d,13d
		dbt "Send S records when you are ready..."
		dbt 10d,13d,0d
SRecErMe	dbt 10d,13d,7d
		dbt "Error Loading S Records..."
		dbt 10d,13d,0d
SRecEnMs	dbt 10d,13d,7d
		dbt "S records successfully loaded."
		dbt 0d
RegMess		dbt 10d,13d,10d
		dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
		dbt 10d,13d,0d
ColnPrmt	dbt 10d,13d
		dbt " :"
		dbt 0d
BadOpMes	dbt "        ???"
		dbt 0d
BPFulMes	dbt 10d,13d
		dbt "All breakpoints are currently in use."
		dbt 0d
NoBPMess	dbt 10d,13d
		dbt "No breakpoint exists at this address."
		dbt 0d
GoBPErrM	dbt 10d,13d
		dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
		dbt 0d
CmdErMes	dbt 10d,13d
		dbt "?"
		dbt 0d
HelpMess	dbt 10d,13d,10d
		dbt "Assemble       A start_address"
		dbt 10d,13d
		dbt "Breakpoint     B (+,-,?) address"
		dbt 10d,13d
		dbt "Dump           D [start_address [end_address]]"
		dbt 10d,13d
		dbt "Enter          E address list"
		dbt 10d,13d
		dbt "Fill           F start_address end_address list"
		dbt 10d,13d
		dbt "Go             G [start_address]"
		dbt 10d,13d
		dbt "Help           H or ?"
		dbt 10d,13d
		dbt "Load           L"
		dbt 10d,13d
		dbt "Move           M start_address end_address destination_address"
		dbt 10d,13d
		dbt "Register       R [PC,AC,XR,YR,SP,SR]"
		dbt 10d,13d
		dbt "Search         S start_address end_address list"
		dbt 10d,13d
		dbt "Trace          T [start_address [value]]"
		dbt 10d,13d
		dbt "Unassemble     U [start_address [end_address]]"
		dbt 10d,13d,0d
	

OpTable		dbt "ADC IMM"
		dbt 069h,2h,2h
		dbt "ADC ABS"
		dbt 06Dh,3h,4h
		dbt "ADC ABX"
		dbt 07Dh,3h,4h
		dbt "ADC ABY"
		dbt 079h,3h,4h
		dbt "ADC IIR"
		dbt 061h,2h,6h
		dbt "ADC IRI"
		dbt 071h,2h,5h
		dbt "AND IMM"
		dbt 029h,2h,2h
		dbt "AND ABS"
		dbt 02Dh,3h,4h
		dbt "AND ABX"
		dbt 03Dh,3h,4h
		dbt "AND ABY"
		dbt 039h,3h,4h
		dbt "AND IIR"
		dbt 021h,2h,6h
		dbt "AND IRI"
		dbt 031h,2h,5h
		dbt "ASL ACC"
		dbt 00Ah,1h,2h
		dbt "ASL ABS"
		dbt 00Eh,3h,6h
		dbt "ASL ABX"
		dbt 01Eh,3h,7h
		dbt "BCC REL"
		dbt 090h,2h,2h
		dbt "BCS REL"
		dbt 0B0h,2h,2h
		dbt "BEQ REL"
		dbt 0F0h,2h,2h
		dbt "BIT ABS"
		dbt 02Ch,3h,4h
		dbt "BMI REL"
		dbt 030h,2h,2h
		dbt "BNE REL"
		dbt 0D0h,2h,2h
		dbt "BPL REL"
		dbt 010h,2h,2h
		dbt "BRK IMP"
		dbt 000h,1h,7h
		dbt "BVC REL"
		dbt 050h,2h,2h
		dbt "BVS REL"
		dbt 070h,2h,2h
		dbt "CLC IMP"
		dbt 018h,1h,2h
		dbt "CLD IMP"
		dbt 0D8h,1h,2h
		dbt "CLI IMP"
		dbt 058h,1h,2h
		dbt "CLV IMP"
		dbt 0B8h,1h,2h
		dbt "CMP IMM"
		dbt 0C9h,2h,2h
		dbt "CMP ABS"
		dbt 0CDh,3h,4h
		dbt "CMP ABX"
		dbt 0DDh,3h,4h
		dbt "CMP ABY"
		dbt 0D9h,3h,4h
		dbt "CMP IIR"
		dbt 0C1h,2h,6h
		dbt "CMP IRI"
		dbt 0D1h,2h,5h
		dbt "CPX IMM"
		dbt 0E0h,2h,2h
		dbt "CPX ABS"
		dbt 0ECh,3h,4h
		dbt "CPY IMM"
		dbt 0C0h,2h,2h
		dbt "CPY ABS"
		dbt 0CCh,3h,4h
		dbt "DEC ABS"
		dbt 0CEh,3h,6h
		dbt "DEC ABX"
		dbt 0DEh,3h,7h
		dbt "DEX IMP"
		dbt 0CAh,1h,2h
		dbt "DEY IMP"
		dbt 088h,1h,2h
		dbt "EOR IMM"
		dbt 049h,2h,2h
		dbt "EOR ABS"
		dbt 04Dh,3h,4h
		dbt "EOR ABX"
		dbt 05Dh,3h,4h
		dbt "EOR ABY"
		dbt 059h,3h,4h
		dbt "EOR IIR"
		dbt 041h,2h,6h
		dbt "EOR IRI"
		dbt 051h,2h,5h
		dbt "INC ABS"
		dbt 0EEh,3h,6h
		dbt "INC ABX"
		dbt 0FEh,3h,7h
		dbt "INX IMP"
		dbt 0E8h,1h,2h
		dbt "INY IMP"
		dbt 0C8h,1h,2h
		dbt "JMP ABS"
		dbt 04Ch,3h,3h
		dbt "JMP IND"
		dbt 06Ch,3h,5h
		dbt "JSR ABS"
		dbt 020h,3h,6h
		dbt "LDA IMM"
		dbt 0A9h,2h,2h
		dbt "LDA ABS"
		dbt 0ADh,3h,4h
		dbt "LDA ABX"
		dbt 0BDh,3h,4h
		dbt "LDA ABY"
		dbt 0B9h,3h,4h
		dbt "LDA IIR"
		dbt 0A1h,2h,6h
		dbt "LDA IRI"
		dbt 0B1h,2h,5h
		dbt "LDX IMM"
		dbt 0A2h,2h,2h
		dbt "LDX ABS"
		dbt 0AEh,3h,4h
		dbt "LDX ABY"
		dbt 0BEh,3h,4h
		dbt "LDY IMM"
		dbt 0A0h,2h,2h
		dbt "LDY ABS"
		dbt 0ACh,3h,4h
		dbt "LDY ABX"
		dbt 0BCh,3h,4h
		dbt "LSR ACC"
		dbt 04Ah,1h,2h
		dbt "LSR ABS"
		dbt 04Eh,3h,6h
		dbt "LSR ABX"
		dbt 05Eh,3h,7h
		dbt "NOP IMP"
		dbt 0EAh,1h,2h
		dbt "ORA IMM"
		dbt 009h,2h,2h
		dbt "ORA ABS"
		dbt 00Dh,3h,4h
		dbt "ORA ABX"
		dbt 01Dh,3h,4h
		dbt "ORA ABY"
		dbt 019h,3h,4h
		dbt "ORA IIR"
		dbt 001h,2h,6h
		dbt "ORA IRI"
		dbt 011h,2h,5h
		dbt "PHA IMP"
		dbt 048h,1h,3h
		dbt "PHP IMP"
		dbt 008h,1h,3h
		dbt "PLA IMP"
		dbt 068h,1h,4h
		dbt "PLP IMP"
		dbt 028h,1h,4h
		dbt "ROL ACC"
		dbt 02Ah,1h,2h
		dbt "ROL ABS"
		dbt 02Eh,3h,6h
		dbt "ROL ABX"
		dbt 03Eh,3h,7h
		dbt "ROR ACC"
		dbt 06Ah,1h,2h
		dbt "ROR ABS"
		dbt 06Eh,3h,6h
		dbt "ROR ABX"
		dbt 07Eh,3h,7h
		dbt "RTI IMP"
		dbt 040h,1h,6h
		dbt "RTS IMP"
		dbt 060h,1h,6h
		dbt "SBC IMM"
		dbt 0E9h,2h,2h
		dbt "SBC ABS"
		dbt 0EDh,3h,4h
		dbt "SBC ABX"
		dbt 0FDh,3h,4h
		dbt "SBC ABY"
		dbt 0F9h,3h,4h
		dbt "SBC IIR"
		dbt 0E1h,2h,6h
		dbt "SBC IRI"
		dbt 0F1h,2h,5h
		dbt "SEC IMP"
		dbt 038h,1h,2h
		dbt "SED IMP"
		dbt 0F8h,1h,2h
		dbt "SEI IMP"
		dbt 078h,1h,2h
		dbt "STA ABS"
		dbt 08Dh,3h,4h
		dbt "STA ABX"
		dbt 09Dh,3h,5h
		dbt "STA ABY"
		dbt 099h,3h,5h
		dbt "STA IIR"
		dbt 081h,2h,6h
		dbt "STA IRI"
		dbt 091h,2h,6h
		dbt "STX ABS"
		dbt 08Eh,3h,4h
		dbt "STY ABS"
		dbt 08Ch,3h,4h
		dbt "TAX IMP"
		dbt 0AAh,1h,2h
		dbt "TAY IMP"
		dbt 0A8h,1h,2h
		dbt "TSX IMP"
		dbt 0BAh,1h,2h
		dbt "TXA IMP"
		dbt 08Ah,1h,2h
		dbt "TXS IMP"
		dbt 09Ah,1h,2h
		dbt "TYA IMP"
		dbt 098h,1h,2h
		dbt "ZZZ ZZZ"
		dbt 000h,0h,0h
		
;****************************************************************************
;       Initialize 6502 reset vector and maskable interrupt vector.
;****************************************************************************
	org 0fffch	;Initialize reset vector.
	dbt 00h,0e0h	;                                                                                         
;	
	org 0fffeh	;Initialize maskable interrupt vector.
	dbt #MaskInt<	;
	dbt #MaskInt>	;
		end
		
