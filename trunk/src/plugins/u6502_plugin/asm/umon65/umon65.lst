
                000001 |;****************************************************************************
                000002 |;  UMON65 Understandable Monitor for the 6500 series microprocessors.
                000003 |;  Copyright 2008 by Ted Kosan.
                000004 |;
                000005 |;
                000006 |;****************************************************************************
                000007 |
                000008 |
                000009 |;****************************************************************************
                000010 |;                                Equates Area.
                000011 |;****************************************************************************   
                000012 |;muvium
                000013 |
                000014 |;For simple I/O board.
0000            000015 |INPUTS		equ 4000h
0000            000016 |OUTPUT1	equ 4001h
0000            000017 |OUTPUT2	equ 4002h
0000            000018 |LCD	    	equ 4003h
                000019 |
                000020 |;For robot
                000021 |;servo_left 	equ 4000h
                000022 |;servo_right 	equ 4001h
                000023 |;button_left 	equ 4002h
                000024 |;button_right 	equ 4003h
                000025 |;field_left 	equ 4004h
                000026 |;field_right 	equ 4005h
                000027 |;dist_left 	equ 4006h
                000028 |;dist_right 	equ 4007h
                000029 |;delay_secs 	equ 4008h
                000030 |;delay_msecs 	equ 4009h
                000031 |;
                000032 |;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
                000033 |;
                000034 |;Transmitt Receive Register.
0000            000035 |6551TRR	equ A000h ;400ah
                000036 |
                000037 |
                000038 |;Status Register.  
                000039 |;		    Status			          cleared by
                000040 |;	b0	Parity error * (1: error)       self clearing **
                000041 |;	b1	Framing error * (1: error)      self clearing **
                000042 |;	b2	Overrun * (1: error)            self clearing **
                000043 |;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
                000044 |;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
                000045 |;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
                000046 |;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
                000047 |;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
                000048 |;                                                                                                            
                000049 |;	note: * no interrupt generated for these conditions
                000050 |;	      ** cleared automatically after a read of RDR and the next 
                000051 |;		error free receipt of data
0000            000052 |6551StR	equ A001h ;400bh 
                000053 |
0000            000054 |6551Sleep equ A002h	; When an lda to this address is performed the emulator
                000055 |			;can be put to sleep.
                000056 |
                000057 |
                000058 |;Comand Register  
                000059 |;	b0	Data Terminal Ready
                000060 |;			0 : disable receiver and all interrupts (DTR high)
                000061 |;			1 : enable receiver and all interrupts (DTR low)
                000062 |;	b1	Receiver Interrupt Enable
                000063 |;			0 : IRQ interrupt enabled from bit 3 of status register
                000064 |;			1 : IRQ interrupt disabled
                000065 |;	b3,b2	Transmitter Control
                000066 |;				Transmit Interrupt    RTS level    Transmitter
                000067 |;			00	   disabled		high		off
                000068 |;			01	   enabled		low		on
                000069 |;			10	   disabled		low		on
                000070 |;			11	   disabled		low	   Transmit BRK
                000071 |;	b4	Normal/Echo Mode for Receiver
                000072 |;			0 : normal
                000073 |;			1 : echo (bits 2 and 3 must be 0)
                000074 |;	b5	Parity Enable
                000075 |;			0 : parity disabled, no parity bit generated or received
                000076 |;			1 : parity enabled
                000077 |;	b7,b6	Parity
                000078 |;			00 : odd parity receiver and transmitter
                000079 |;			01 : even parity receiver and transmitter
                000080 |;			10 : mark parity bit transmitted, parity check disabled
                000081 |;			11 : space parity bit transmitted, parity check disabled
                000082 |
                000083 |
                000084 |;6551CmR	equ 0b202h  
                000085 |
                000086 |;Control Register
                000087 |;
                000088 |;	b3-b0	baud rate generator:
                000089 |;			0000 : 16x external clock
                000090 |;			0001 : 50 baud
                000091 |;			0010 : 75
                000092 |;			0011 : 110
                000093 |;			0100 : 134.5
                000094 |;			0101 : 150
                000095 |;			0110 : 300
                000096 |;			0111 : 600
                000097 |;			1000 : 1200
                000098 |;			1001 : 1800
                000099 |;			1010 : 2400
                000100 |;			1011 : 3600
                000101 |;			1100 : 4800
                000102 |;			1101 : 7200
                000103 |;			1110 : 9600
                000104 |;			1111 : 19,200
                000105 |;	b4	receiver clock source
                000106 |;			0 : external receiver clock
                000107 |;			1 : baud rate generator
                000108 |;	b6,b5	word length                                                                  
                000109 |;			00 : 8 bits
                000110 |;			01 : 7
                000111 |;			10 : 6
                000112 |;			11 : 5
                000113 |;	b7	stop bits
                000114 |;			0 : 1 stop bit
                000115 |;			1 : 2 stop bits
                000116 |;			    (1 stop bit if parity and word length = 8)
                000117 |;			    (1 1/2 stop bits if word length = 5 and no parity)
                000118 |;6551CtR	equ 0b203h  
                000119 |
                000120 |
                000121 |
                000122 |
                000123 |;InPort0 Equate.
0000            000124 |InPort0	equ 0a000h
                000125 |
                000126 |;OutPort0 Equate.
0000            000127 |OutPort0	equ 0a100h
                000128 |
                000129 |;****************************************************************************
                000130 |;                       General Purpose Pointer Area.
                000131 |;****************************************************************************
0000            000132 |	org 0000h
                000133 |	
0000 00 00      000134 |GenPoint	dwd ?
0002 00 00      000135 |IRQVect		dwd ?		;
0004 00 00      000136 |BRKVect		dwd ?		;Break command indirect vector.
0006 00 00      000137 |MessPtr		dwd ?		;
0008 00 00      000138 |PointerA	dwd ?		;
000A 00 00      000139 |PointerB	dwd ?		;
000C 00 00      000140 |PointerC	dwd ?		;
000E 00 00      000141 |NOpAdPtr	dwd ?		;
0010 00 00      000142 |BOpAdPtr	dwd ?		;
0012 00 00      000143 |BrkPt1Ad	dwd ?		;
0014 00 00      000144 |BrkPt2Ad	dwd ?		;
0016 00 00      000145 |BrkPt3Ad	dwd ?		;                                                                                       
0018 00 00      000146 |BrkPt4Ad	dwd ?		;
                000147 |
                000148 |
                000149 |	
                000150 |;****************************************************************************
                000151 |;                   General Purpose Variable Storage Area.
                000152 |;****************************************************************************
                000153 |;	org 0200h 
                000154 |
                000155 |		  
001A 00         000156 |Obj1		dbt ?
001B 00         000157 |Obj2		dbt ?
001C 00         000158 |Obj3		dbt ?
001D 00         000159 |Obj2Flg		dbt ?
001E 00         000160 |Obj3Flg		dbt ?
001F 00         000161 |AddMode		dbt ?
0020 00         000162 |SrchTabl	dbt 10d(?)
0021 00 00 00         
0024 00 00 00         
0027 00 00 00         
002A 00         000163 |SrchBtCt	dbt ?
002B 00 00      000164 |TempAdd		dwd ?
002D 00 00      000165 |TempAdd2	dwd ?
002F 00         000166 |BrkPt1St	dbt ?
0030 00         000167 |BrkPt2St	dbt ?
0031 00         000168 |BrkPt3St	dbt ?
0032 00         000169 |BrkPt4St	dbt ?
0033 00         000170 |BP1OpHld	dbt ?
0034 00         000171 |BP2OpHld	dbt ?
0035 00         000172 |BP3OpHld	dbt ?
0036 00         000173 |BP4OpHld	dbt ?
0037 00         000174 |BPNumHld	dbt ?
0038 00         000175 |BrValHld	dbt ?
0039 00         000176 |TrBrkFlg	dbt ?
003A 00         000177 |CurInsLn	dbt ?
003B 00         000178 |NOpCdHld	dbt ?
003C 00         000179 |BOpCdHld	dbt ?
003D 00         000180 |BrnchFlg	dbt ?
003E 00         000181 |TracCnt		dbt ?
003F 00 00      000182 |AddHold		dwd ?
0041 00         000183 |ObCdHld1	dbt ?
0042 00         000184 |ObCdHld2	dbt ?
0043 00         000185 |OpCdHold	dbt ?
0044 00         000186 |TempA		dbt ?
0045 00 00      000187 |UPgmCntr	dwd ?
0047 00         000188 |UAccum		dbt ?
0048 00         000189 |UXReg		dbt ?
0049 00         000190 |UYReg		dbt ?
004A 00         000191 |UStkPtr		dbt ?
004B 00         000192 |UStatReg	dbt ?
004C 00         000193 |ASCIIbuf	dbt 16d(?)
004D 00 00 00         
0050 00 00 00         
0053 00 00 00         
0056 00 00 00         
0059 00 00 00         
005C 00 00      000194 |EndAdd		dwd ?
005E 00         000195 |OpOffSet	dbt ?
005F 00         000196 |OpFld1		dbt 20d(?)
0060 00 00 00         
0063 00 00 00         
0066 00 00 00         
0069 00 00 00         
006C 00 00 00         
006F 00 00 00         
0072 00               
0073 00         000197 |OpFld2		dbt 20d(?)
0074 00 00 00         
0077 00 00 00         
007A 00 00 00         
007D 00 00 00         
0080 00 00 00         
0083 00 00 00         
0086 00               
0087 00         000198 |OpFld3		dbt 20d(?)	
0088 00 00 00         
008B 00 00 00         
008E 00 00 00         
0091 00 00 00         
0094 00 00 00         
0097 00 00 00         
009A 00               
009B 00         000199 |CodeCntr	dbt ?
009C 00         000200 |Number		dbt ?
009D 00         000201 |ChkSum		dbt ?
009E 00         000202 |RecLen		dbt ?
009F 00 00      000203 |CkSumAc		dwd ?
00A1 00         000204 |RecType 	dbt ?
00A2 00         000205 |wait0		dbt ?
00A3 00         000206 |wait1		dbt ?
00A4 00         000207 |		dbt ?
00A5 00         000208 |InptBufr	dbt 40d(?)
00A6 00 00 00         
00A9 00 00 00         
00AC 00 00 00         
00AF 00 00 00         
00B2 00 00 00         
00B5 00 00 00         
00B8 00 00 00         
00BB 00 00 00         
00BE 00 00 00         
00C1 00 00 00         
00C4 00 00 00         
00C7 00 00 00         
00CA 00 00 00         
00CD 00         000209 |Command		dbt ?
00CE 00         000210 |RegTemp		dbt ?
00CF 00         000211 |DataTemp	dbt ?
                000212 |
                000213 |;****************************************************************************
                000214 |;                        Monitor Eprom Entry Point.
                000215 |;****************************************************************************
E000            000216 |	org 0e000h Note
                000217 |	;org 1000h
E000 4C 1B E0   000218 |	jmp Start
                000219 |
                000220 |;****************************************************************************
                000221 |;                  Monitor Utility Subroutine Jump Table.
                000222 |;****************************************************************************
E003 4C F0 F3   000223 |	jmp OutChar	;Output byte in A register to serial port.
                000224 |	
E006 4C AF F3   000225 |	jmp GetChar	;Get a byte from the serial port.
                000226 |	
E009 4C D2 F3   000227 |	jmp GetCharW	;Wait and get a byte from the serial port.
                000228 |	
E00C 4C 92 F3   000229 |	jmp PrntMess	;Print a message to the serial port.
                000230 |	
E00F 4C E2 F2   000231 |	jmp OutSpace	;Output spaces to the serial port.
                000232 |	
E012 4C 3E F3   000233 |	jmp OutHex	;Output a HEX number to the serial port.
                000234 |	
E015 4C 72 EA   000235 |	jmp DgtToBin	;Convert an ASCII digit into binary.
                000236 |	
E018 4C 87 E0   000237 |	jmp GetLine	;Input a line from the serial port.
                000238 |	
                000239 |
                000240 |; Beginning of UMON65.
                000241 |;****************************************************************************
                000242 |;                       Start of UMON65 Main Routine.
                000243 |;
                000244 |;
                000245 |;****************************************************************************
E01B            000246 |start *
E01B A2 FF      000247 |	ldx #0ffh	;Initialize stack pointer and clear decimal
E01D 9A         000248 |	txs		; mode.
                000249 |;	cli		;
E01E D8         000250 |	cld		;
                000251 |	
E01F 20 72 F3   000252 |	jsr InitVars	;Initialize variables.
                000253 |	
E022 4C 25 E0   000254 |	jmp CkConfig	;Check switch register to determine what mode
                000255 |			; to run the computer in.
                000256 |
                000257 |;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
                000258 |		
                000259 |;****************************************************************************
                000260 |;                     Check Computer's Configuration.
                000261 |;****************************************************************************
E025            000262 |CkConfig *
                000263 |	;lda InPort0	;Get the switch settings and mask out the 
                000264 |	;and #00001111b	; switch's high nibble.
                000265 |
                000266 |;CkMon *
                000267 |	
                000268 |	;cmp #1d	;If the switch is set to a 1 then print the
                000269 |	;bne CkEEPROM	; UMON65 monitor startup message and enter the
E025            000270 |EnterMon *
E025 A2 51      000271 |	ldx #OpenMess<	; monitor through the maskable interrupt vector.
E027 A0 F4      000272 |	ldy #OpenMess>	;
E029 20 92 F3   000273 |	jsr PrntMess	;
                000274 |	;brk		    ;
E02C A9 00      000275 |    lda #00000000b	 ;Initialize user's status register.
E02E 8D 4B 00   000276 |	sta UStatReg	;
                000277 |
                000278 |	
E031 A9 00      000279 |	lda #0d	    ;Initialize user's accumulator.
E033 8D 47 00   000280 |	sta UAccum	;
                000281 |	
E036 8D 48 00   000282 |	sta UXReg	;Initialize user's X register.
                000283 |	
E039 8D 49 00   000284 |	sta UYReg	;Initialize user's Y register.
                000285 |	
E03C A9 FF      000286 |	lda #0ffh    ;Initialize user's stack pointer
E03E 8D 4A 00   000287 |	sta UStkPtr	 ;.
                000288 |    
E041 4C 20 E2   000289 |    jmp ResetEntryPoint
                000290 |
E044            000291 |CkEEPROM *
E044 C9 02      000292 |	cmp #2d		;If the switch is set to a 2 then get the
E046 D0 13      000293 |	bne DoLgtSho	; switch's high nibble and jump to a program
                000294 |	;lda InPort0	; present in the EEPROM which is indicated by
E048 29 F0      000295 |	and #11110000b	; the high nibble's value.  The program can be
E04A 4A         000296 |	lsr a		; located at 1 of the following 16 locations:
E04B 4A         000297 |	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
E04C 4A         000298 |	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
E04D 18         000299 |	clc
E04E 69 C0      000300 |	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
E050 8D 09 00   000301 |	sta PointerA+1d	; 15-DE00.
E053 A9 00      000302 |	lda #0d		;
E055 8D 08 00   000303 |	sta PointerA	;
E058 6C 08 00   000304 |	jmp (PointerA)	;
                000305 |			
E05B            000306 |DoLgtSho *
E05B 4C 5E E0   000307 |	jmp LghtShow
                000308 |	
                000309 |;****************************************************************************
                000310 |;                            Light Show Subroutine.
                000311 |;****************************************************************************
E05E            000312 |LghtShow *
E05E A0 00      000313 |	ldy #0h		;Make the Y register count from 0 to 255 and
E060 8C 44 00   000314 |	sty TempA	; output each number in the count to the
                000315 |	;sty OutPort0	; light register.
E063            000316 |LSOtLoop *		;
E063 A2 64      000317 |	ldx #100d	;
E065            000318 |LSInLoop *		;
E065 C8         000319 |	iny		;
E066 D0 FD      000320 |	bne LSInLoop	;
E068 CA         000321 |	dex		;
E069 D0 FA      000322 |	bne LSInLoop	;
E06B EE 44 00   000323 |	inc TempA	;
E06E AD 44 00   000324 |	lda TempA	;
                000325 |	;sta OutPort0	;
E071 4C 63 E0   000326 |	jmp LSOtLoop	;
                000327 |
                000328 |;****************************************************************************
                000329 |;                            Monitor's Main Loop.
                000330 |;****************************************************************************
E074            000331 |MainLoop *	
                000332 |
E074 20 80 E0   000333 |	jsr GetLineP	;Get a typed line from the serial port.
                000334 |
E077 20 F2 E0   000335 |	jsr ParsLine	;Break line into fields.
                000336 |	
E07A 20 4A E1   000337 |	jsr CkValCmd	;Check to see if a valid monitor command was
                000338 |			; entered and if so execute that command's code.
E07D 4C 74 E0   000339 |	jmp MainLoop
                000340 |
                000341 |	
                000342 |;****************************************************************************
                000343 |;                    Get Line From Serial Port Subroutine.
                000344 |;****************************************************************************
E080            000345 |GetLineP *
E080 A2 A1      000346 |	ldx #Prompt<	;Print Prompt.
E082 A0 F4      000347 |	ldy #Prompt>	;
E084 20 92 F3   000348 |	jsr PrntMess	;
                000349 |
E087            000350 |GetLine *	
E087 A0 00      000351 |	ldy #0d		;Initialize Y index register.
E089 8C 5E 00   000352 |	sty OpOffSet	;Initialize opcode holder offset pointer.
E08C 8C CD 00   000353 |	sty command	;Initialize command holder.
E08F 8C 5F 00   000354 |	sty OpFld1	;Initialize operand field 1 buffer.
E092 8C 73 00   000355 |	sty OpFld2	;Initialize operand field 2 buffer.
E095 8C 87 00   000356 |	sty OpFld3	;Initialize operand field 3 buffer.
                000357 |	
E098 A0 00      000358 |	ldy #0d		;Clear input buffer.
E09A A9 00      000359 |	lda #0d		;
E09C            000360 |ClrInpBf *		;
E09C 99 A5 00   000361 |	sta InptBufr,y	;
E09F C8         000362 |	iny		;
E0A0 C0 27      000363 |	cpy #39d	;
E0A2 D0 F8      000364 |	bne ClrInpBf	;
                000365 |	
E0A4 A0 00      000366 |	ldy #0h		;Use Y register as buffer pointer.
                000367 |	
E0A6            000368 |GtAnChar *
E0A6 20 D2 F3   000369 |	jsr GetCharW
                000370 |;	jsr OutChar	;Echo character.  ;Note: remove for muvium.
                000371 |
E0A9 C9 00      000372 |	cmp #0h		;If no character is entered then try again.
E0AB F0 F9      000373 |	beq GtAnChar	;
                000374 |	
E0AD C9 08      000375 |	cmp #8d		;Check to see if the user entered a Delete or
E0AF D0 03      000376 |	bne CkDel	; a Backspace.  If so then erase the character
E0B1 4C B8 E0   000377 |	jmp DoDelete	; to the left of the cursor.
E0B4            000378 |CkDel *			;
E0B4 C9 7F      000379 |	cmp #127d	;
E0B6 D0 15      000380 |	bne GtCkChar	;
E0B8            000381 |DoDelete *		;
E0B8 88         000382 |	dey		;
E0B9 30 0D      000383 |	bmi AtStart	;
E0BB A9 20      000384 |	lda #32d	;
E0BD 20 F0 F3   000385 |	jsr OutChar	;
E0C0 A9 08      000386 |	lda #8d		;
E0C2 20 F0 F3   000387 |	jsr OutChar	;
E0C5 4C A6 E0   000388 |	jmp GtAnChar	;
                000389 |
E0C8            000390 |AtStart *
E0C8 A0 00      000391 |	ldy #0d
E0CA 4C A6 E0   000392 |	jmp GtAnChar
                000393 |	
E0CD            000394 |GtCkChar *
E0CD C9 0A      000395 |	cmp #10d	;If a LF was entered then accept line and exit,
E0CF F0 0D      000396 |	beq GtLnDone	; if not then accept the next character and
E0D1 99 A5 00   000397 |	sta InptBufr,y	; place it into the input buffer.
E0D4 C8         000398 |	iny		;
                000399 |	
E0D5 C0 27      000400 |	cpy #39d	;Do not let buffer expand past 40 characters.
E0D7 D0 CD      000401 |	bne GtAnChar
E0D9 A0 27      000402 |	ldy #39d	;Set buffer at 40 characters if over 40 characters.
                000403 |
E0DB 4C A6 E0   000404 |	jmp GtAnChar	;
                000405 |	
E0DE            000406 |GtLnDone *
                000407 |	;If a CR is in the input buffer then remove it.
E0DE 88         000408 |	dey
E0DF B9 A5 00   000409 |	lda InptBufr,y
E0E2 C9 0D      000410 |	cmp #13d
E0E4 F0 01      000411 |	beq PutNull
E0E6 C8         000412 |	iny
E0E7            000413 |PutNull	 *
E0E7 A9 00      000414 |	lda #0h		;Put a NULL at end of the input buffer.
E0E9 99 A5 00   000415 |	sta InptBufr,y	;
                000416 |		
E0EC 60         000417 |	rts
                000418 |	
                000419 |;****************************************************************************
                000420 |;                       Parse Input Buffer Subroutine.
                000421 |;****************************************************************************
E0ED            000422 |ParseOpr *	;Entry point if parsing for a UASM command is not
E0ED A0 FF      000423 |	ldy #0ffh	; desired.
E0EF 4C 0F E1   000424 |	jmp GtAnoOpr	;
                000425 |	
E0F2            000426 |ParsLine *
E0F2 A0 00      000427 |	ldy #0d
                000428 |
E0F4 B9 A5 00   000429 |	lda InptBufr,y
E0F7 F0 50      000430 |	beq ExtPrsLn	;If NULL or CR encountered then return.
                000431 |	
E0F9 C9 3F      000432 |	cmp #63d	;Check for upper case letter.
E0FB 30 4B      000433 |	bmi ParError	;
E0FD C9 5A      000434 |	cmp #90d	;	
E0FF 10 03      000435 |	bpl CkSmCase	;
                000436 |	
E101 38         000437 |	sec
E102 B0 08      000438 |	bcs GetCmd	;
                000439 |	
E104            000440 |CkSmCase *
E104 C9 61      000441 |	cmp #97d	;Check for lower case letter.
E106 30 40      000442 |	bmi ParError	;
E108 C9 7A      000443 |	cmp #122d	;
E10A 10 3C      000444 |	bpl ParError	;
                000445 |	                
E10C            000446 |GetCmd *
E10C 8D CD 00   000447 |	sta command	;Store command in command buffer.
                000448 |                        
E10F            000449 |GtAnoOpr *       
E10F C8         000450 |	iny		;Point Y to the next operand field and check to
E110 C0 14      000451 |	cpy #20d	;make sure that the input line is not too long.
E112 F0 34      000452 |	beq ParError	;
                000453 |	                
E114 B9 A5 00   000454 |	lda InptBufr,y	;Check for the end of the input line.
E117 C9 00      000455 |	cmp #0d		;
E119 F0 2E      000456 |	beq ExtPrsLn	;
                000457 |	                
E11B C9 20      000458 |	cmp #32d	;Check for a space between operand fields.
E11D F0 F0      000459 |	beq GtAnoOpr	;
                000460 |	                
E11F            000461 |ScanOprn *              
E11F AE 5E 00   000462 |	ldx OpOffSet	;Point X to the beginning of the current operand
E122 8A         000463 |	txa		; field holder and point OpOffSet to the beginning
E123 18         000464 |	clc             
E124 69 14      000465 |	adc #20d	; of the next operand field holder.
E126 8D 5E 00   000466 |	sta OpOffSet	;
                000467 |	
E129            000468 |TranDgt *
E129 B9 A5 00   000469 |	lda InptBufr,y	;
                000470 |	                
E12C C9 20      000471 |	cmp #32d	;If a space is encountered then stop scanning.
E12E F0 10      000472 |	beq DoneScan	;
                000473 |	                
E130 C9 00      000474 |	Cmp #0d		;If a CR is encountered then stop scanning.
E132 F0 0C      000475 |	beq doneScan	;
                000476 |	                
E134 9D 5F 00   000477 |	sta OpFld1,x	;Transfer current operand from input buffer into
E137 E8         000478 |	inx		; current operand field holder.
E138 C8         000479 |	iny		;
E139 C0 28      000480 |	cpy #40d
E13B F0 0B      000481 |	beq ParError
                000482 |	
E13D 4C 29 E1   000483 |	jmp TranDgt	
                000484 |	
E140            000485 |DoneScan *
E140 A9 00      000486 |	lda #0h		;Put a NULL at the end of the current operand field
E142 9D 5F 00   000487 |	sta OpFld1,x	; holder.
                000488 |	
E145 4C 0F E1   000489 |	jmp GtAnoOpr
                000490 |
E148            000491 |ParError *
E148 60         000492 |	rts
E149            000493 |ExtPrsLn *
E149 60         000494 |	rts
                000495 |
                000496 |;****************************************************************************
                000497 |;                     Check for Valid Command Subroutine.
                000498 |;****************************************************************************
E14A            000499 |CkValCmd *
E14A 38         000500 |	sec
                000501 |	
E14B AD CD 00   000502 |	lda command
E14E 20 ED F2   000503 |	jsr ToLower
                000504 |
E151 C9 6C      000505 |	cmp #108d	;Check for Load command.
E153 D0 06      000506 |	bne NxtCmd1	;
E155 20 69 E9   000507 |	jsr LdSRecs	;
E158 4C DD E1   000508 |	jmp ExitCmd	;
                000509 |                        
E15B            000510 |NxtCmd1 *
E15B C9 64      000511 |	cmp #100d	;Check for Dump command.
E15D D0 06      000512 |	bne NxtCmd2	;
E15F 20 3B E7   000513 |	jsr Dump	;
E162 4C DD E1   000514 |	jmp ExitCmd	;
                000515 |                        
E165            000516 |NxtCmd2 *
E165 C9 72      000517 |	cmp #114d	;Check for Register command.
E167 D0 06      000518 |	bne NxtCmd3	;
E169 20 1F EB   000519 |	jsr Register	;
E16C 4C DD E1   000520 |	jmp ExitCmd	;
                000521 |		
E16F            000522 |NxtCmd3 *
E16F C9 67      000523 |	cmp #103d	;Check for Go command.
E171 D0 06      000524 |	bne NxtCmd4	;
E173 20 E0 E8   000525 |	jsr Go		;
E176 4C DD E1   000526 |	jmp ExitCmd	;
                000527 |	
E179            000528 |NxtCmd4 *
E179 C9 65      000529 |	cmp #101d	;Check for Enter command.
E17B D0 06      000530 |	bne NxtCmd5	;
E17D 20 39 E8   000531 |	jsr Enter	;
E180 4C DD E1   000532 |	jmp ExitCmd	;
                000533 |	
E183            000534 |NxtCmd5 *
E183 C9 66      000535 |	cmp #102d	;Check for Fill command.
E185 D0 06      000536 |	bne NxtCmd6	;
E187 20 9F E8   000537 |	jsr Fill	;
E18A 4C DD E1   000538 |	jmp ExitCmd	;
                000539 |
E18D            000540 |NxtCmd6 *
E18D C9 75      000541 |	cmp #117d	;Check for Unassemble command.
E18F D0 06      000542 |	bne NxtCmd7	;
E191 20 B0 EF   000543 |	jsr UnAssem	;
E194 4C DD E1   000544 |	jmp ExitCmd	;
                000545 |
E197            000546 |NxtCmd7 *
E197 C9 74      000547 |	cmp #116d	;Check for Trace command.
E199 D0 06      000548 |	bne NxtCmd8	;
E19B 20 75 ED   000549 |	jsr Trace	;
E19E 4C DD E1   000550 |	jmp ExitCmd	;
                000551 |
E1A1            000552 |NxtCmd8 *
E1A1 C9 62      000553 |	cmp #98d	;Check for Breakpoint command.
E1A3 D0 06      000554 |	bne NxtCmd9	;
E1A5 20 D3 E5   000555 |	jsr BreakPnt	;
E1A8 4C DD E1   000556 |	jmp ExitCmd	;
                000557 |	
E1AB            000558 |NxtCmd9 *
E1AB C9 73      000559 |	cmp #115d	;Check for Search command.
E1AD D0 06      000560 |	bne NxtCmd10	;
E1AF 20 E4 EC   000561 |	jsr Search	;
E1B2 4C DD E1   000562 |	jmp ExitCmd	;
                000563 |
E1B5            000564 |NxtCmd10 *
E1B5 C9 6D      000565 |	cmp #109d	;Check for Move command.
E1B7 D0 06      000566 |	bne NxtCmd11	;
E1B9 20 B3 EA   000567 |	jsr Move	;
E1BC 4C DD E1   000568 |	jmp ExitCmd	;
                000569 |	
E1BF            000570 |NxtCmd11 *
E1BF C9 61      000571 |	cmp #'a'	;Check for Assemble command.
E1C1 D0 06      000572 |	bne NxtCmd12	;
E1C3 20 4A E2   000573 |	jsr Assemble	;
E1C6 4C DD E1   000574 |	jmp ExitCmd	;
                000575 |
E1C9            000576 |NxtCmd12 *
E1C9 C9 68      000577 |	cmp #104d	;Check for Help command.
E1CB D0 06      000578 |	bne NxtCmd13	;
E1CD 20 61 E9   000579 |	jsr Help	;
E1D0 4C DD E1   000580 |	jmp ExitCmd	;
E1D3            000581 |NxtCmd13 *                 
E1D3 C9 3F      000582 |	cmp #63d	;
E1D5 D0 06      000583 |	bne ExitCmd	;
E1D7 20 61 E9   000584 |	jsr Help	;
E1DA 4C DD E1   000585 |	jmp ExitCmd	;
                000586 |
E1DD            000587 |ExitCmd *
E1DD B0 09      000588 |	bcs CmdOk
                000589 |	
E1DF            000590 |CmdError *		;If there was an error with a command then
E1DF A2 1C      000591 |	ldx #CmdErMes<	; print a question mark.
E1E1 A0 F6      000592 |	ldy #CmdErMes>	;
E1E3 20 92 F3   000593 |	jsr PrntMess	;
E1E6 18         000594 |	clc		;
E1E7 60         000595 |	rts		;
                000596 |	
E1E8            000597 |CmdOk *
E1E8 38         000598 |	sec
E1E9 60         000599 |	rts
                000600 |
                000601 |;****************************************************************************
                000602 |;                     Maskable Interrupt Service Subroutine.
                000603 |;****************************************************************************
E1EA            000604 |MaskInt *
E1EA 78         000605 |	sei		;Disable interrupts.
                000606 |
E1EB 8D 44 00   000607 |	sta TempA	;Save accumulator.
                000608 |			
E1EE 68         000609 |	pla		;Check to see if BRK command was executed.
E1EF 48         000610 |	pha		;
E1F0 29 10      000611 |	and #10h	;
E1F2 D0 06      000612 |	bne DoBRK	;
                000613 |	
E1F4 AD 44 00   000614 |	lda TempA	;Restore accumulator.
                000615 |
E1F7            000616 |IRQ *	
E1F7 6C 02 00   000617 |	jmp (IRQVect)
                000618 |	
E1FA            000619 |DoBRK *
E1FA 6C 04 00   000620 |	jmp (BRKVect)
                000621 |
                000622 |	
                000623 |;****************************************************************************
                000624 |;                          Break Service Subroutine.
                000625 |;****************************************************************************
                000626 |	
E1FD            000627 |BRK *
E1FD 68         000628 |	pla		;Save user's status register.
E1FE 8D 4B 00   000629 |	sta UStatReg	;
                000630 |
                000631 |	
E201 AD 44 00   000632 |	lda TempA	;Save user's accumulator.
E204 8D 47 00   000633 |	sta UAccum	;
                000634 |	
E207 8E 48 00   000635 |	stx UXReg	;Save user's X register.
                000636 |	
E20A 8C 49 00   000637 |	sty UYReg	;Save user's Y register.
                000638 |	
E20D BA         000639 |	tsx
                000640 |    
E20E E8         000641 |    inx ;Remove the remaining 2 bytes that were pushed on the
E20F E8         000642 |    inx ; stack by the brk command.
                000643 |    
E210 8E 4A 00   000644 |	stx UStkPtr	;Save user's stack pointer.
                000645 |	
E213 68         000646 |	pla		;Save program counter of break instruction
E214 38         000647 |	sec		; that caused execution of this code.
E215 E9 01      000648 |	sbc #1d		;
E217 8D 45 00   000649 |	sta UPgmCntr	;
E21A 68         000650 |	pla		; 
E21B E9 00      000651 |	sbc #0d		;
E21D 8D 46 00   000652 |	sta UPgmCntr+1d	;
                000653 |;	cli
                000654 |
E220            000655 |ResetEntryPoint *
E220 A0 00      000656 |	ldy #0d		;Print user's registers.
E222 8C 5F 00   000657 |	sty OpFld1	;
E225 20 1F EB   000658 |	jsr Register	;
                000659 |
E228 AD 39 00   000660 |	lda TrBrkFlg	;If this break was placed by the trace command
E22B C9 01      000661 |	cmp #1d		; then go back to the trace subroutine.
E22D D0 03      000662 |	bne RepBPOp	;
E22F 4C 2B EF   000663 |	jmp Tr2ndEnt	;
                000664 |	
E232            000665 |RepBPOp *
E232 A0 03      000666 |	ldy #3d		;Replace the opcodes of all breakpointed
E234 A2 06      000667 |	ldx #6d		; addresses.
E236            000668 |CkBPStBr *              ;
E236 B9 2F 00   000669 |	lda BrkPt1St,y	;
E239 C9 01      000670 |	cmp #1d		;
E23B D0 05      000671 |	bne NxtBPStB	;
E23D B9 33 00   000672 |	lda BP1OpHld,y	;
E240 81 12      000673 |	sta (BrkPt1Ad,x);
E242            000674 |NxtBPStB *		;
E242 88         000675 |	dey		;
E243 CA         000676 |	dex		;
E244 CA         000677 |	dex		;
E245 10 EF      000678 |	bpl CkBPStBr	;
                000679 |	
E247            000680 |GoMain *
E247 4C 74 E0   000681 |	jmp MainLoop	;Enter monitor.
                000682 |
                000683 |
                000684 |;****************************************************************************
                000685 |;                       Assemble Command Subroutine.
                000686 |;****************************************************************************
E24A            000687 |Assemble *
                000688 |
E24A A2 00      000689 |	ldx #0d		;Get address to start assembling at and store
E24C 20 C3 F2   000690 |	jsr GetAdd	; in pointer A.
E24F B0 03      000691 |	bcs AAddOk	;
E251 4C 40 E3   000692 |	jmp ErrAsem	;
E254            000693 |AAddOk *		;
E254 8E 08 00   000694 |	stx PointerA	;
E257 8C 09 00   000695 |	sty PointerA+1d	;
                000696 |
E25A            000697 |AsemTop *		;On new line print current address being
E25A A2 A5      000698 |	ldx #CRLF<	; assembled at and get next instruction to be
E25C A0 F4      000699 |	ldy #CRLF>	; assembled from user.
E25E 20 92 F3   000700 |	jsr PrntMess	;
E261 20 05 F3   000701 |	jsr PrntAdd	;
E264 20 87 E0   000702 |	jsr GetLine	;
E267 20 ED E0   000703 |	jsr ParseOpr	;
                000704 |	
E26A AD 5F 00   000705 |	lda OpFld1	;Check for operator to be assembled. If no
E26D C9 00      000706 |	cmp #0d		; operator is found then exit Assemble 
E26F F0 04      000707 |	beq AsemDone	; subroutine.
E271 C9 20      000708 |	cmp #32d	;
E273 D0 03      000709 |	bne ACont	;
E275            000710 |AsemDone *              ;
E275 4C 42 E3   000711 |	jmp ExitAsem	;
                000712 |	
E278            000713 |ACont *			;Convert operator in input buffer to upper case,
E278 A0 00      000714 |	ldy #0d		; check to see if it is in the operator table and
E27A            000715 |ConvAno *		;
E27A B9 5F 00   000716 |	lda OpFld1,y	; output a question mark if operator was not found.
E27D 20 F9 F2   000717 |	jsr ToUpper	;
E280 99 5F 00   000718 |	sta OpFld1,y	;
E283 C8         000719 |	iny		;
E284 C0 03      000720 |	cpy #3d		;
E286 D0 F2      000721 |	bne ConvAno	;
E288 20 44 E3   000722 |	jsr OptrScan	;
E28B B0 28      000723 |	bcs AOptrOk	;
                000724 |	
E28D            000725 |PrntQues *
E28D 20 05 F3   000726 |	jsr PrntAdd	;If there was an error assembling the instruction
E290 A9 20      000727 |	lda #32d	; input from the user into object code then re-
E292 20 F0 F3   000728 |	jsr OutChar	; output the line and print a question mark.
E295 A2 5F      000729 |	ldx #OpFld1<	;
E297 A0 00      000730 |	ldy #OpFld1>	;
E299 20 92 F3   000731 |	jsr PrntMess	;
E29C A9 20      000732 |	lda #32d  	;
E29E 20 F0 F3   000733 |	jsr OutChar	;
E2A1 A2 73      000734 |	ldx #OpFld2<	;
E2A3 A0 00      000735 |	ldy #OpFld2>	;
E2A5 20 92 F3   000736 |	jsr PrntMess	;
E2A8 A9 20      000737 |	lda #32d	;
E2AA 20 F0 F3   000738 |	jsr OutChar	;
E2AD A9 3F      000739 |	lda #63d	;
E2AF 20 F0 F3   000740 |	jsr OutChar	;
E2B2 4C 5A E2   000741 |	jmp AsemTop	;
                000742 |	
E2B5            000743 |AOptrOk *		;Check address mode of operand and print a quesion
E2B5 20 7C E3   000744 |	jsr AdMdScan	; mark if error occures while scanning operand.
E2B8 B0 03      000745 |	bcs AOpndOk	;
E2BA 4C 8D E2   000746 |	jmp PrntQues
                000747 |		
E2BD            000748 |AOpndOk *		;Check to see if address mode of operand is a
E2BD 20 71 E4   000749 |	jsr AdMdTbSc	; valid address mode for instruction.
E2C0 B0 03      000750 |	bcs AOpTbFnd	;
E2C2 4C 8D E2   000751 |	jmp PrntQues
                000752 |		
E2C5            000753 |AOpTbFnd *		;Extract object code from operand.
E2C5 20 91 E4   000754 |	jsr OpndScan	;
E2C8 B0 03      000755 |	bcs PrntAssm	;
E2CA 4C 8D E2   000756 |	jmp PrntQues	;
                000757 |	
E2CD            000758 |PrntAssm *
E2CD 20 05 F3   000759 |	jsr PrntAdd	;Re-output current address.
                000760 |	
E2D0 A0 00      000761 |	ldy #0d		;
                000762 |	
E2D2 AD 1A 00   000763 |	lda Obj1	;Output opcode, store it in memory, point to next
E2D5 91 08      000764 |	sta (PointerA),y; byte, and print one space.
E2D7 20 3E F3   000765 |	jsr OutHex	;
E2DA 20 BA F2   000766 |	jsr IncPntrA	;
E2DD A9 20      000767 |	lda #32d	;
E2DF 20 F0 F3   000768 |	jsr OutChar	;
                000769 |	
E2E2 AD 1D 00   000770 |	lda Obj2Flg	;Output second object code byte if present, store it in
E2E5 F0 28      000771 |	beq NoObjCd	; it in memory, point to next byte, and print one
E2E7 AD 1B 00   000772 |	lda Obj2	; space.
E2EA 91 08      000773 |	sta (PointerA),y;
E2EC 20 3E F3   000774 |	jsr OutHex	;
E2EF 20 BA F2   000775 |	jsr IncPntrA	;
E2F2 A9 20      000776 |	lda #32d	;
E2F4 20 F0 F3   000777 |	jsr OutChar	;
                000778 |	
E2F7 AD 1E 00   000779 |	lda Obj3Flg	;Output third object code byte if present, store
E2FA F0 1E      000780 |	beq NoObjCd3	; it in memory, point to next byte, and print one
E2FC AD 1C 00   000781 |	lda Obj3	; space.
E2FF 91 08      000782 |	sta (PointerA),y;
E301 20 3E F3   000783 |	jsr OutHex	;
E304 20 BA F2   000784 |	jsr IncPntrA	;
E307 A9 20      000785 |	lda #32d	;
E309 20 F0 F3   000786 |	jsr OutChar	;
E30C 4C 25 E3   000787 |	jmp NoExSpcs
                000788 |
E30F            000789 |NoObjCd *		;If fewer then 3 bytes of object code are output
E30F A9 20      000790 |	lda #32d	; then output spaces instead.
E311 20 F0 F3   000791 |	jsr OutChar	;
E314 20 F0 F3   000792 |	jsr OutChar	;
E317 20 F0 F3   000793 |	jsr OutChar
E31A            000794 |NoObjCd3 *
E31A A9 20      000795 |	lda #32d	;
E31C 20 F0 F3   000796 |	jsr OutChar	;
E31F 20 F0 F3   000797 |	jsr OutChar	;
E322 20 F0 F3   000798 |	jsr OutChar
                000799 |	
E325            000800 |NoExSpcs *
E325 A9 20      000801 |	lda #32d	;
E327 20 F0 F3   000802 |	jsr OutChar	;
E32A A2 5F      000803 |	ldx #OpFld1<	;Re-output instruction that user had entered in.
E32C A0 00      000804 |	ldy #OpFld1>	;
E32E 20 92 F3   000805 |	jsr PrntMess	;
E331 A9 20      000806 |	lda #32d  	;
E333 20 F0 F3   000807 |	jsr OutChar	;
E336 A2 73      000808 |	ldx #OpFld2<	;
E338 A0 00      000809 |	ldy #OpFld2>	;
E33A 20 92 F3   000810 |	jsr PrntMess	;
                000811 |
E33D 4C 5A E2   000812 |	jmp AsemTop
                000813 |	
                000814 |	
E340            000815 |ErrAsem *
E340 18         000816 |	clc
E341 60         000817 |	rts
                000818 |	
E342            000819 |ExitAsem *
E342 38         000820 |	sec
E343 60         000821 |	rts
                000822 |	
                000823 |
                000824 |;****************************************************************************
                000825 |;                       Operator Scan Subroutine.
                000826 |;****************************************************************************
E344            000827 |OptrScan *
                000828 |
E344 A2 22      000829 |	ldx #OpTable<	;Point pointer B to beginning of the operator
E346 8E 0A 00   000830 |	stx PointerB	; table.
E349 A2 F8      000831 |	ldx #Optable>	;
E34B 8E 0B 00   000832 |	stx PointerB+1d	;
                000833 |	
E34E            000834 |OSCkAno *
E34E A0 00      000835 |	ldy #0d		;Compare a digit of the operator that the user
E350            000836 |OSCkAnCM *		;
E350 B1 0A      000837 |	lda (PointerB),y; entered with the analogous digit of the
E352 D9 5F 00   000838 |	cmp OpFld1,y	; operator in the operator table.
E355 F0 19      000839 |	beq CharMtch	;
                000840 |	
E357            000841 |OptScan2 *
E357 AD 0A 00   000842 |	lda PointerB	;Point pointer B to the beginning of the next
E35A 18         000843 |	clc		; operator in the operator table.
E35B 69 0A      000844 |	adc #10d	;
E35D 8D 0A 00   000845 |	sta PointerB	;
E360 90 03      000846 |	bcc OSNoCary	;
E362 EE 0B 00   000847 |	inc PointerB+1d	;
                000848 |	
E365            000849 |OSNoCary *
E365 A0 04      000850 |	ldy #4d		;Check for the end of the operator table.
E367 B1 0A      000851 |	lda (PointerB),y;
E369 C9 5A      000852 |	cmp #'Z'	;
E36B F0 0B      000853 |	beq OSNoMtch	;
E36D 4C 4E E3   000854 |	jmp OSCkAno	;
                000855 |	
E370            000856 |CharMtch *		;Check for an operator match in the operator
E370 C8         000857 |	iny		; table.
E371 C0 03      000858 |	cpy #3d		;
E373 F0 05      000859 |	beq OSMatch	;
E375 4C 50 E3   000860 |	jmp OSCkAnCM	;
                000861 |	
E378            000862 |OSNoMtch *
E378 18         000863 |	clc
E379 60         000864 |	rts
                000865 |	
E37A            000866 |OSMatch *
E37A 38         000867 |	sec
E37B 60         000868 |	rts
                000869 |
                000870 |
                000871 |;****************************************************************************
                000872 |;                     Address Mode Scan Subroutine.
                000873 |;****************************************************************************
E37C            000874 |AdMdScan *
                000875 |
E37C            000876 |AMSCkIMP *
E37C A0 00      000877 |	ldy #0d		;Check for implied addressing mode.
E37E B9 73 00   000878 |	lda OpFld2,y	;
E381 C9 00      000879 |	cmp #0d		;
E383 D0 08      000880 |	bne AMSCkIMM	;
E385 A9 50      000881 |	lda #'P'	;
E387 8D 1F 00   000882 |	sta AddMode	;
E38A 4C 6F E4   000883 |	jmp ExitAMS	;
                000884 |	
E38D            000885 |AMSCkIMM *		;Check for immediate addressing mode.
E38D C9 23      000886 |	cmp #'#'	;
E38F D0 08      000887 |	bne AMSCkACC	;
E391 A9 4D      000888 |	lda #'M'	;
E393 8D 1F 00   000889 |	sta AddMode	;
E396 4C 6F E4   000890 |	jmp ExitAMS	;
                000891 |	
E399            000892 |AMSCkACC *		;Check for accumulator addressing mode.
E399 C9 41      000893 |	cmp #'A'	;
E39B F0 07      000894 |	beq CkSpNull	;
E39D C9 61      000895 |	cmp #'a'	;
E39F F0 03      000896 |	beq CkSpNull	;
E3A1 4C BB E3   000897 |	jmp AMSCkREL	;
E3A4            000898 |CkSpNull *		;
E3A4 C8         000899 |	iny		;
E3A5 B9 73 00   000900 |	lda OpFld2,y	;
E3A8 C9 00      000901 |	Cmp #0d		;
E3AA F0 07      000902 |	beq IsAcc	;
E3AC C9 20      000903 |	cmp #32d	;
E3AE F0 03      000904 |	beq IsAcc	;
E3B0 4C BB E3   000905 |	jmp AMSCkREL	;
E3B3            000906 |IsAcc *			;
E3B3 A9 43      000907 |	lda #'C'	;
E3B5 8D 1F 00   000908 |	sta AddMode	;
E3B8 4C 6F E4   000909 |	jmp ExitAMS	;
                000910 |	
E3BB            000911 |AMSCkREL *		;Check for relative addressing mode.
E3BB A0 06      000912 |	ldy #6d		;
E3BD B1 0A      000913 |	lda (PointerB),y;
E3BF C9 4C      000914 |	cmp #'L'	;
E3C1 D0 06      000915 |	bne AMSCkA_I	;
E3C3 8D 1F 00   000916 |	sta AddMode	;
E3C6 4C 6F E4   000917 |	jmp ExitAMS	;
                000918 |	
E3C9            000919 |AMSCkA_I *		;Dispatch to absolute or indexed check code.
E3C9 A0 00      000920 |	ldy #0d		;
E3CB B9 73 00   000921 |	lda OpFld2,y	;
E3CE C9 28      000922 |	cmp #'('	;
E3D0 D0 03      000923 |	bne AMSCkAB?	;
E3D2 4C 15 E4   000924 |	jmp AMSCkId?	;
                000925 |	
E3D5            000926 |AMSCkAB? *		;Check to see if operand is absolute addressing
E3D5 A0 00      000927 |	ldy #0d		; mode or absolute indexed addressing mode.
E3D7            000928 |AMSScnAB *		;
E3D7 B9 73 00   000929 |	lda OpFld2,y	;
E3DA C9 2C      000930 |	cmp #','	;
E3DC F0 08      000931 |	beq CkXorY	;
E3DE C9 00      000932 |	cmp #0d		;
E3E0 F0 2B      000933 |	beq IsABS	;
E3E2 C8         000934 |	iny		;
E3E3 4C D7 E3   000935 |	jmp AMSScnAB	;
                000936 |	
E3E6            000937 |CkXorY *		;Check for absolute X or absolute Y addressing
E3E6 C8         000938 |	iny		; mode.
E3E7 B9 73 00   000939 |	lda OpFld2,y	;                                                                        
E3EA C9 58      000940 |	cmp #'X'	;
E3EC F0 0F      000941 |	beq IsABX	;
E3EE C9 78      000942 |	cmp #'x'	;
E3F0 F0 0B      000943 |	beq IsABX	;
E3F2 C9 59      000944 |	cmp #'Y'	;
E3F4 F0 0F      000945 |	beq IsABY	;
E3F6 C9 79      000946 |	cmp #'y'	;
E3F8 F0 0B      000947 |	beq IsABY	;
E3FA 4C 6D E4   000948 |	jmp ErrAMS	;
                000949 |	
E3FD            000950 |IsABX *			;Save ABS, ABX or ABY mode in the variable to be
E3FD A9 58      000951 |	lda #'X'	; returned.
E3FF 8D 1F 00   000952 |	sta AddMode	;
E402 4C 6F E4   000953 |	jmp ExitAMS	;
E405            000954 |IsABY *			;
E405 A9 59      000955 |	lda #'Y'	;
E407 8D 1F 00   000956 |	sta AddMode	;
E40A 4C 6F E4   000957 |	jmp ExitAMS	;
E40D            000958 |IsABS *			;
E40D A9 53      000959 |	lda #'S'	;
E40F 8D 1F 00   000960 |	sta AddMode	;
E412 4C 6F E4   000961 |	jmp ExitAMS	;
                000962 |	
E415            000963 |AMSCkId? *		;Dispatch to code that checks for IIR, IRI or
E415 C8         000964 |	iny		; IND addressing modes.
E416 B9 73 00   000965 |	lda OpFld2,y	;
E419 C9 2C      000966 |	cmp #','	;
E41B F0 0B      000967 |	beq CkIIR	;
E41D C9 29      000968 |	cmp #')'	;
E41F F0 1E      000969 |	beq CkIRIIND	;
E421 C0 0B      000970 |	cpy #11d	;
E423 D0 F0      000971 |	bne AMSCkId?	;
E425 4C 6D E4   000972 |	jmp ErrAMS	;
                000973 |
E428            000974 |CkIIR *			;Check for IIR addressing mode.
E428 C8         000975 |	iny		;
E429 B9 73 00   000976 |	lda OpFld2,y	;
E42C C9 58      000977 |	cmp #'X'	;
E42E F0 07      000978 |	beq IsIIR	;
E430 C9 78      000979 |	cmp #'x'	;
E432 F0 03      000980 |	beq IsIIR	;
E434 4C 6D E4   000981 |	jmp ErrAMS	;
                000982 |	
E437            000983 |IsIIR *
E437 A9 52      000984 |	lda #'R'	;Save IIR addressing mode code in variable to be
E439 8D 1F 00   000985 |	sta AddMode	; returned.
E43C 4C 6F E4   000986 |	jmp ExitAMS	;
                000987 |	
E43F            000988 |CkIRIIND *		;Check for IND addressing mode.
E43F C8         000989 |	iny		;
E440 B9 73 00   000990 |	lda OpFld2,y	;
E443 C9 00      000991 |	cmp #0d		;
E445 F0 16      000992 |	beq IsIND	;
E447 C9 2C      000993 |	cmp #','	;
E449 F0 03      000994 |	beq CkIRI	;
E44B 4C 6D E4   000995 |	jmp ErrAMS	;
                000996 |	
E44E            000997 |CkIRI *			;Check for IRI addressing mode.
E44E C8         000998 |	iny		;
E44F B9 73 00   000999 |	lda OpFld2,y	;
E452 C9 59      001000 |	cmp #'Y'	;
E454 F0 0F      001001 |	beq IsIRI	;
E456 C9 79      001002 |	cmp #'y'	;
E458 F0 0B      001003 |	beq IsIRI	;
E45A 4C 6D E4   001004 |	jmp ErrAMS	;
                001005 |	
E45D            001006 |IsIND *			;Save IND or IRI addressing mode code in variable
E45D A9 44      001007 |	lda #'D'	; to be returned.
E45F 8D 1F 00   001008 |	sta AddMode	;
E462 4C 6F E4   001009 |	jmp ExitAMS	;
E465            001010 |IsIRI *			;
E465 A9 49      001011 |	lda #'I'	;
E467 8D 1F 00   001012 |	sta AddMode	;
E46A 4C 6F E4   001013 |	jmp ExitAMS	;
                001014 |	
E46D            001015 |ErrAMS *
E46D 18         001016 |	clc
E46E 60         001017 |	rts
                001018 |	
E46F            001019 |ExitAMS *
E46F 38         001020 |	sec
E470 60         001021 |	rts
                001022 |	
                001023 |	
                001024 |;****************************************************************************
                001025 |;                   Address Mode Table Search Subroutine.
                001026 |;****************************************************************************
E471            001027 |AdMdTbSc *		
E471 A0 06      001028 |	ldy #6d		;Check for address mode match between contents
E473 B1 0A      001029 |	lda (PointerB),y; of variable AddMode & OpTable.
E475 CD 1F 00   001030 |	cmp AddMode	;
E478 F0 15      001031 |	beq ExitAdMd	;
                001032 |	
E47A AD 0A 00   001033 |	lda PointerB	;Pointer Pointer B to next operator in
E47D 18         001034 |	clc		; operator table.
E47E 69 0A      001035 |	adc #10d	;
E480 8D 0A 00   001036 |	sta PointerB	;
E483 90 03      001037 |	bcc AdMdNoCy	;
E485 EE 0B 00   001038 |	inc PointerB+1d	;
                001039 |	
E488            001040 |AdMdNoCy *		;Check to see if next operator is the same type
E488 20 4E E3   001041 |	jsr OSCkANO	; that we are currently trying to assemble.
E48B B0 E4      001042 |	bcs AdMdTbSc	;
                001043 |	
E48D            001044 |ErrAdMd *
E48D 18         001045 |	clc
E48E 60         001046 |	rts
                001047 |	
E48F            001048 |ExitAdMd *
E48F 38         001049 |	sec
E490 60         001050 |	rts
                001051 |
                001052 |;****************************************************************************
                001053 |;                       Operand Scan Subroutine.
                001054 |;****************************************************************************
E491            001055 |OpndScan *
                001056 |
E491 A9 00      001057 |	lda #0d		;Initialize the flags that indicate whether or
E493 8D 1D 00   001058 |	sta Obj2Flg	; not there are object bytes in addition to
E496 8D 1E 00   001059 |	sta Obj3Flg	; the opcode object byte.
                001060 |	
E499 A0 07      001061 |	ldy #7d		;Get the opcode of the instruction being 
E49B B1 0A      001062 |	lda (PointerB),y; currently assembled from the opcode table
E49D 8D 1A 00   001063 |	sta Obj1	; and put it in Obj1.
                001064 |	
E4A0 AD 1F 00   001065 |	lda AddMode	;Check to see what address mode the instruction
E4A3 C9 50      001066 |	cmp #'P'	; currently being assembled is.
E4A5 F0 27      001067 |	beq OpndIMP	;
E4A7 C9 43      001068 |	cmp #'C'	;
E4A9 F0 26      001069 |	beq OpndACC	;
E4AB C9 4D      001070 |	cmp #'M'	;
E4AD F0 25      001071 |	beq OpndIMM	;
E4AF C9 53      001072 |	cmp #'S'	;
E4B1 F0 3C      001073 |	beq OpndAB??	;
E4B3 C9 58      001074 |	cmp #'X'	;
E4B5 F0 38      001075 |	beq OpndAB??	;
E4B7 C9 59      001076 |	cmp #'Y'	;
E4B9 F0 34      001077 |	beq OpndAB??	;
E4BB C9 49      001078 |	cmp #'I'	;
E4BD F0 58      001079 |	beq OpndIN??	;
E4BF C9 52      001080 |	cmp #'R'	;
E4C1 F0 54      001081 |	beq OpndIN??	;
E4C3 C9 44      001082 |	cmp #'D'	;
E4C5 F0 50      001083 |	beq OpndIN??	;
E4C7 C9 4C      001084 |	cmp #'L'	;
E4C9 F0 24      001085 |	beq OpndAB??	;
E4CB 4C AA E5   001086 |	jmp ErrOpndS	;
                001087 |
E4CE            001088 |OpndIMP *		;Process implied addressing mode.
E4CE 4C AC E5   001089 |	jmp ExtOpndS	;
                001090 |	
E4D1            001091 |OpndACC *		;Process accumulator addressing mode.
E4D1 4C AC E5   001092 |	jmp ExtOpndS	;
                001093 |	
E4D4            001094 |OpndIMM *		;Process immediate addressing mode.
E4D4 20 AE E5   001095 |	jsr ScnForHex	;
E4D7 B0 03      001096 |	bcs OpnMHFnd	;
E4D9 4C AA E5   001097 |	jmp ErrOpndS	;
E4DC            001098 |OpnMHFnd *		;
E4DC 20 1C F3   001099 |	jsr AsToBin	;
E4DF B0 03      001100 |	bcs OpndCvOk	;
E4E1 4C AA E5   001101 |	jmp ErrOpndS	;
E4E4            001102 |OpndCvOk *		;
E4E4 8D 1B 00   001103 |	sta Obj2	;
E4E7 A9 01      001104 |	lda #1d		;
E4E9 8D 1D 00   001105 |	sta Obj2Flg	;
E4EC 4C AC E5   001106 |	jmp ExtOpndS	;
                001107 |
                001108 |
E4EF            001109 |OpndAB?? *		;Process absolute, absolute X, absolute Y.
E4EF 20 AE E5   001110 |	jsr ScnForHex	; Check for relative addressing mode and send
E4F2 B0 03      001111 |	bcs OpnAHFnd	; to appropriate code if found.
E4F4 4C AA E5   001112 |	jmp ErrOpndS	;
E4F7            001113 |OpnAHFnd *		;
E4F7 20 C3 F2   001114 |	jsr GetAdd	;
E4FA B0 03      001115 |	bcs OpndAdOk	;
E4FC 4C AA E5   001116 |	jmp ErrOpndS	;
E4FF            001117 |OpndAdOk *		;
E4FF AD 1F 00   001118 |	lda AddMode	;
E502 C9 4C      001119 |	cmp #'L'	;
E504 F0 48      001120 |	beq OpndDoBr	;
E506            001121 |DoAdd *			;
E506 8E 1B 00   001122 |	stx Obj2	;
E509 8C 1C 00   001123 |	sty Obj3	;
E50C A9 01      001124 |	lda #1d		;
E50E 8D 1D 00   001125 |	sta Obj2Flg	;
E511 8D 1E 00   001126 |	sta Obj3Flg	;
E514 4C AC E5   001127 |	jmp ExtOpndS	;
                001128 |
E517            001129 |OpndIN?? *		;Process indirect indexed, indexed indirect and
E517 20 AE E5   001130 |	jsr ScnForHex	; indirect addressing modes.
E51A B0 03      001131 |	bcs OpnINFnd	;
E51C 4C AA E5   001132 |	jmp ErrOpndS	;
E51F            001133 |OpnINFnd *		;
E51F 20 C3 F2   001134 |	jsr GetAdd	;
E522 B0 03      001135 |	bcs OpINAdOk	;
E524 4C AA E5   001136 |	jmp ErrOpndS	;
E527            001137 |OpINAdOk *		;
E527 AD 1F 00   001138 |	lda AddMode	;
E52A C9 44      001139 |	cmp #'D'	;
E52C F0 0F      001140 |	beq DoIND	;
E52E C0 00      001141 |	cpy #0d		;
E530 D0 78      001142 |	bne ErrOpndS	;
E532 8E 1B 00   001143 |	stx Obj2	;
E535 A9 01      001144 |	lda #1d		;
E537 8D 1D 00   001145 |	sta Obj2Flg	;
E53A 4C AC E5   001146 |	jmp ExtOpndS	;
E53D            001147 |DoIND *			;
E53D 8E 1B 00   001148 |	stx Obj2	;
E540 8C 1C 00   001149 |	sty Obj3	;
E543 A9 01      001150 |	lda #1d		;
E545 8D 1D 00   001151 |	sta Obj2Flg	;
E548 8D 1E 00   001152 |	sta Obj3Flg	;
E54B 4C AC E5   001153 |	jmp ExtOpndS	;
                001154 |	
E54E            001155 |OpndDoBr *		;Put address to be branched to in TempAdd and
E54E 8E 2B 00   001156 |	stx TempAdd	; the address of the first byte of the next
E551 8C 2C 00   001157 |	sty TempAdd+1d	; instruction in TempAdd2.
E554 AD 08 00   001158 |	lda PointerA	;
E557 8D 2D 00   001159 |	sta TempAdd2	;
E55A AD 09 00   001160 |	lda PointerA+1d	;
E55D 8D 2E 00   001161 |	sta TempAdd2+1d	;
E560 A0 08      001162 |	ldy #8d		;
E562 B1 0A      001163 |	lda (PointerB),y;
E564 18         001164 |	clc		;
E565 6D 2D 00   001165 |	adc TempAdd2	;
E568 8D 2D 00   001166 |	sta TempAdd2	;
E56B 90 03      001167 |	bcc OpBrNoOv	;
E56D EE 2E 00   001168 |	inc TempAdd2+1d	;
E570            001169 |OpBrNoOv *
E570 38         001170 |	sec		;Subtract the address of the first byte of the
E571 AD 2B 00   001171 |	lda TempAdd	; next instruction from the address to be branched
E574 ED 2D 00   001172 |	sbc TempAdd2	; to in order to get the branch offset.
E577 8D 2B 00   001173 |	sta TempAdd	;
E57A AD 2C 00   001174 |	lda TempAdd+1d	;
E57D ED 2E 00   001175 |	sbc TempAdd2+1d	;
E580 8D 2C 00   001176 |	sta TempAdd+1d	;
                001177 |	
E583 AD 2C 00   001178 |	lda TempAdd+1d	;Check to make sure that MSB of the offset does
E586 C9 FF      001179 |	cmp #0ffh	; not indicate a number greater than 127 or less
E588 F0 0E      001180 |	beq OpCkNOff	; than 128.
E58A C9 00      001181 |	cmp #0d		;
E58C D0 1C      001182 |	bne ErrOpndS	;
                001183 |	
E58E            001184 |OpCkPOff *		;Check to make sure that LSB of the offset does
E58E AD 2B 00   001185 |	lda TempAdd	; not contain a number greater than 127 or less
E591 C9 80      001186 |	cmp #128d	; than 128.
E593 10 15      001187 |	bpl ErrOpndS	;
E595 4C 9F E5   001188 |	jmp OffOk	;
E598            001189 |OpCkNOff *		;
E598 AD 2B 00   001190 |	lda TempAdd	;
E59B C9 80      001191 |	cmp #128d	;
E59D 30 0B      001192 |	bmi ErrOpndS	;
                001193 |	
E59F            001194 |OffOk *			;If offset is OK then put it in Obj2 and return.
E59F 8D 1B 00   001195 |	sta Obj2	;
E5A2 A9 01      001196 |	lda #1d		;
E5A4 8D 1D 00   001197 |	sta Obj2Flg	;
E5A7 4C AC E5   001198 |	jmp ExtOpndS	;
                001199 |	
E5AA            001200 |ErrOpndS *
E5AA 18         001201 |	clc
E5AB 60         001202 |	rts
                001203 |	
E5AC            001204 |ExtOpndS *
E5AC 38         001205 |	sec
E5AD 60         001206 |	rts
                001207 |
                001208 |
                001209 |;****************************************************************************
                001210 |;                     Scan For Hex Digit Subroutine.
                001211 |;****************************************************************************
E5AE            001212 |ScnForHex *
E5AE A2 14      001213 |	ldx #20d		
                001214 |	
E5B0            001215 |SFHNxtDg *
E5B0 A0 00      001216 |	ldy #0d		;Scan until either an upper case or a lower case
E5B2 BD 5F 00   001217 |	lda OpFld1,x	; hex digit is encountered in the input buffer.
E5B5            001218 |SFHCkDgt *		;
E5B5 D9 2F F4   001219 |	cmp DgtTblUC,y	;
E5B8 F0 17      001220 |	beq ExitSFH	;
E5BA D9 40 F4   001221 |	cmp DgtTblLC,y	;
E5BD F0 12      001222 |	beq ExitSFH	;
E5BF C8         001223 |	iny		;
E5C0 C0 10      001224 |	cpy #16d	;
E5C2 F0 03      001225 |	beq IncBfPtr	;
E5C4 4C B5 E5   001226 |	jmp SFHCkDgt	;
                001227 |
E5C7            001228 |IncBfPtr *		;Point to the next digit in the input buffer.
E5C7 E8         001229 |	inx		;
E5C8 E0 1F      001230 |	cpx #31d	;
E5CA F0 03      001231 |	beq ErrSFH	;
E5CC 4C B0 E5   001232 |	jmp SFHNxtDg	;
                001233 |
E5CF            001234 |ErrSFH *
E5CF 18         001235 |	clc
E5D0 60         001236 |	rts
                001237 |	
E5D1            001238 |ExitSFH *
E5D1 38         001239 |	sec
E5D2 60         001240 |	rts
                001241 |	
                001242 |	
                001243 |;****************************************************************************
                001244 |;                       Breakpoint Command Subroutine.
                001245 |;****************************************************************************
E5D3            001246 |BreakPnt *
E5D3 AD 5F 00   001247 |	lda OpFld1	;Check for a +, - or a ? in operand field #1.
E5D6 C9 2B      001248 |	cmp #43d	;
E5D8 F0 0B      001249 |	beq DoPlus	;
E5DA C9 2D      001250 |	cmp #45d	;
E5DC F0 0A      001251 |	beq DoMinus	;
E5DE C9 3F      001252 |	cmp #63d	;
E5E0 F0 09      001253 |	beq DmpBPAdd	;
E5E2 4C F3 E6   001254 |	jmp ExitBP	;
E5E5            001255 |DoPlus *		;
E5E5 4C 5F E6   001256 |	jmp Plus	;
E5E8            001257 |DoMinus *		;
E5E8 4C 1B E6   001258 |	jmp Minus	;
                001259 |	
E5EB            001260 |DmpBPAdd *
E5EB A2 A5      001261 |	ldx #CRLF<	;If question mark was entered then dump current
E5ED A0 F4      001262 |	ldy #CRLF>	; breakpoints.
E5EF 20 92 F3   001263 |	jsr PrntMess	;
E5F2 A0 FF      001264 |	ldy #0ffh	;
E5F4 A2 FF      001265 |	ldx #0ffh	;
E5F6            001266 |OtAdAgin *		;
E5F6 C8         001267 |	iny		;
E5F7 E8         001268 |	inx		;
E5F8 B9 12 00   001269 |	lda BrkPt1Ad,y	;
E5FB 8D 08 00   001270 |	sta PointerA	;
E5FE C8         001271 |	iny		;
E5FF B9 12 00   001272 |	lda BrkPt1Ad,y	;
E602 8D 09 00   001273 |	sta PointerA+1d	;
E605 BD 2F 00   001274 |	lda BrkPt1St,x	;
E608 F0 03      001275 |	beq AdEmpty	;
E60A 20 05 F3   001276 |	jsr PrntAdd	;
E60D            001277 |AdEmpty *		;
E60D C0 07      001278 |	cpy #7d		;
E60F D0 E5      001279 |	bne OtAdAgin	;
E611 A2 A5      001280 |	ldx #CRLF<	;
E613 A0 F4      001281 |	ldy #CRLF>	;
E615 20 92 F3   001282 |	jsr PrntMess	;
E618 4C F3 E6   001283 |	jmp ExitBP	;
                001284 |	
E61B            001285 |Minus *
E61B AD 73 00   001286 |	lda OpFld2	;If minus was found in operand field #1 check for
E61E C9 00      001287 |	cmp #0d		; an address in operand field #2.  If no address
E620 F0 0A      001288 |	beq ClrAllBP	; was found then clear all breakpoints, if an
E622 A2 14      001289 |	ldx #20d	; address was found then clear that one breakpoint.
E624 20 C3 F2   001290 |	jsr GetAdd	;
E627 B0 10      001291 |	bcs Clr1BP	;
E629 4C F3 E6   001292 |	jmp ExitBP	;
                001293 |	
E62C            001294 |ClrAllBP *
E62C A0 03      001295 |	ldy #3d		;Clear all breakpoints.
E62E            001296 |ZeroBP *		;
E62E A9 00      001297 |	lda #0d		;
E630 99 2F 00   001298 |	sta BrkPt1St,y	;
E633 88         001299 |	dey		;
E634 10 F8      001300 |	bpl ZeroBP	;
E636 4C F3 E6   001301 |	jmp ExitBP	;
                001302 |	
E639            001303 |Clr1BP *
E639 8E 2B 00   001304 |	stx TempAdd	;Search for a match between a breakpoint address
E63C 8C 2C 00   001305 |	sty TempAdd+1d	; in the breakpoint address table and the address
E63F A0 03      001306 |	ldy #3d		; that was entered.
E641 A2 06      001307 |	ldx #6d		;
E643            001308 |CkBPAdd *		;
E643 20 F4 E6   001309 |	jsr CmpBPAdd	;
E646 B0 0F      001310 |	bcs FoundBP	;
E648 88         001311 |	dey		;
E649 CA         001312 |	dex		;
E64A CA         001313 |	dex		;
E64B 10 F6      001314 |	bpl CkBPAdd	;
                001315 |	
E64D            001316 |BPNtFnd *		
E64D A2 B2      001317 |	ldx #NoBPMess<	;If no match was found then print an error message
E64F A0 F5      001318 |	ldy #NoBPMess>	; and exit.
E651 20 92 F3   001319 |	jsr PrntMess	;
E654 4C F3 E6   001320 |	jmp ExitBP	;
                001321 |	
E657            001322 |FoundBP *
E657 A9 00      001323 |	lda #0d		;If match was found then zero out that breakpoint's
E659 99 2F 00   001324 |	sta BrkPt1St,y	; status indicator and exit.
E65C 4C F3 E6   001325 |	jmp ExitBP	;
                001326 |
E65F            001327 |Plus *
E65F AD 73 00   001328 |	lda OpFld2	;If a plus was entered then check operand field
E662 C9 00      001329 |	cmp #0d		; #2 for the address of the new breakpoint.
E664 F0 07      001330 |	beq OutBP2	;
E666 A2 14      001331 |	ldx #20d	;
E668 20 C3 F2   001332 |	jsr GetAdd	;
E66B B0 03      001333 |	bcs BPAdOk	;
E66D            001334 |OutBP2 *		;
E66D 4C F3 E6   001335 |	jmp ExitBP	;
                001336 |
                001337 |
E670            001338 |BPAdOk *
E670 8E 2B 00   001339 |	stx TempAdd	;
E673 8C 2C 00   001340 |	sty TempAdd+1d	;
E676 A0 03      001341 |	ldy #3d		;Check to make sure that breakpoint address has
E678 A2 06      001342 |	ldx #6d		; not already been entered into table.
E67A            001343 |CkBPAddP *		;
E67A B9 2F 00   001344 |	lda BrkPt1St,y	;
E67D C9 00      001345 |	cmp #0d		;
E67F F0 05      001346 |	beq NoCmp	;
E681 20 F4 E6   001347 |	jsr CmpBPAdd	;
E684 B0 E7      001348 |	bcs OutBP2	;
E686            001349 |NoCmp *			;
E686 88         001350 |	dey		;
E687 CA         001351 |	dex		;
E688 CA         001352 |	dex		;
E689 10 EF      001353 |	bpl CkBPAddP	;
                001354 |	
                001355 |
E68B A0 00      001356 |	ldy #0d		;If a plus was entered then search breakpoint
E68D            001357 |CkNxtBP *		;
E68D B9 2F 00   001358 |	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
E690 C9 00      001359 |	cmp #0d		;
E692 F0 0F      001360 |	beq EmptyBP	;
E694 C8         001361 |	iny		;
E695 C0 04      001362 |	cpy #4d		;
E697 D0 F4      001363 |	bne CkNxtBP	;
                001364 |	
E699            001365 |AllBPFull *
E699 A2 8A      001366 |	ldx #BPFulMes<	;If all breakpoints are full then print an error
E69B A0 F5      001367 |	ldy #BPFulMes>	; message and exit.
E69D 20 92 F3   001368 |	jsr PrntMess	;
E6A0 4C F3 E6   001369 |	jmp ExitBP	;
                001370 |	
E6A3            001371 |EmptyBP *
E6A3 8C 37 00   001372 |	sty BPNumHld	;
E6A6 A9 01      001373 |	lda #1d		;
E6A8 99 2F 00   001374 |	sta BrkPt1St,y	;
                001375 |	
                001376 |	
E6AB            001377 |NxtBPSlt0 *
E6AB C0 00      001378 |	cpy #0d		;Store new address in first position of
E6AD D0 0F      001379 |	bne NxtBPSlt1	; breakpoint table.
E6AF AD 2B 00   001380 |	lda TempAdd	;
E6B2 8D 12 00   001381 |	sta BrkPt1Ad	;
E6B5 AD 2C 00   001382 |	lda TempAdd+1d	;
E6B8 8D 13 00   001383 |	sta BrkPt1Ad+1d	;
E6BB 4C F3 E6   001384 |	jmp ExitBP	;
                001385 |	
E6BE            001386 |NxtBPSlt1 *		;
E6BE C0 01      001387 |	cpy #1d		;Store new address in second position of
E6C0 D0 0F      001388 |	bne NxtBPSlt2	; breakpoint table.
E6C2 AD 2B 00   001389 |	lda TempAdd	;
E6C5 8D 14 00   001390 |	sta BrkPt2Ad	;
E6C8 AD 2C 00   001391 |	lda TempAdd+1d	;
E6CB 8D 15 00   001392 |	sta BrkPt2Ad+1d	;
E6CE 4C F3 E6   001393 |	jmp ExitBP	;
                001394 |	
E6D1            001395 |NxtBPSlt2 *		;
E6D1 C0 02      001396 |	cpy #2d		;Store new address in third position of
E6D3 D0 0F      001397 |	bne NxtBPSlt3	; breakpoint table.
E6D5 AD 2B 00   001398 |	lda TempAdd	;
E6D8 8D 16 00   001399 |	sta BrkPt3Ad	;
E6DB AD 2C 00   001400 |	lda TempAdd+1d	;
E6DE 8D 17 00   001401 |	sta BrkPt3Ad+1d	;
E6E1 4C F3 E6   001402 |	jmp ExitBP	;
                001403 |	
E6E4            001404 |NxtBPSlt3 *		;
E6E4 AD 2B 00   001405 |	lda TempAdd	;Store new address in forth position of
E6E7 8D 18 00   001406 |	sta BrkPt4Ad	; breakpoint table.
E6EA AD 2C 00   001407 |	lda TempAdd+1d	;
E6ED 8D 19 00   001408 |	sta BrkPt4Ad+1d	;
E6F0 4C F3 E6   001409 |	jmp ExitBP	;
                001410 |
E6F3            001411 |ExitBP *
E6F3 60         001412 |	rts
                001413 |
                001414 |
                001415 |;****************************************************************************
                001416 |;                   Compare Breakpoint Address Subroutine.
                001417 |;****************************************************************************
E6F4            001418 |CmpBPAdd *
E6F4 C0 00      001419 |	cpy #0d		;Compare LSB of first breakpoint address.
E6F6 D0 0B      001420 |	bne CmpNxt1	;
E6F8 AD 2C 00   001421 |	lda TempAdd+1d	;
E6FB CD 13 00   001422 |	cmp BrkPt1Ad+1d	;
E6FE F0 2C      001423 |	beq CChkFLSB	;
E700 4C 39 E7   001424 |	jmp NoMatch 	;
                001425 |	
E703            001426 |CmpNxt1 *		;
E703 C0 01      001427 |	cpy #1d		;Compare MSB of second breakpoint address.
E705 D0 0B      001428 |	bne CmpNxt2	;
E707 AD 2C 00   001429 |	lda TempAdd+1d	;
E70A CD 15 00   001430 |	cmp BrkPt2Ad+1d	;
E70D F0 1D      001431 |	beq CChkFLSB	;
E70F 4C 39 E7   001432 |	jmp NoMatch 	;
                001433 |	
E712            001434 |CmpNxt2 *		;
E712 C0 02      001435 |	cpy #2d		;Compare MSB of third breakpoint address.
E714 D0 0B      001436 |	bne CmpNxt3	;
E716 AD 2C 00   001437 |	lda TempAdd+1d	;
E719 CD 17 00   001438 |	cmp BrkPt3Ad+1d	;
E71C F0 0E      001439 |	beq CChkFLSB	;
E71E 4C 39 E7   001440 |	jmp NoMatch 	;
                001441 |	
E721            001442 |CmpNxt3 *		;
E721 AD 2C 00   001443 |	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
E724 CD 19 00   001444 |	cmp BrkPt4Ad+1d	;
E727 F0 03      001445 |	beq CChkFLSB	;
E729 4C 39 E7   001446 |	jmp NoMatch 	;
                001447 |	
E72C            001448 |CChkFLSB *
E72C AD 2B 00   001449 |	lda TempAdd	;Compare LSB of breakpoint address.
E72F DD 12 00   001450 |	cmp BrkPt1Ad,x	;
E732 F0 03      001451 |	beq BPMatch	;
E734 4C 39 E7   001452 |	jmp NoMatch	;
                001453 |	
E737            001454 |BPMatch *		;Return with carry set if addresses match.
E737 38         001455 |	sec		;
E738 60         001456 |	rts		;
                001457 |	
E739            001458 |NoMatch *		;Return with carry cleared if addresses
E739 18         001459 |	clc		; do not match.
E73A 60         001460 |	rts		;
                001461 |
                001462 |
                001463 |;****************************************************************************
                001464 |;                     Dump command Subroutine
                001465 |;****************************************************************************
E73B            001466 |Dump *
                001467 |	
E73B A2 00      001468 |	ldx #0h
                001469 |	
E73D BD 5F 00   001470 |	lda OpFld1,x	;If no operands then do a standard dump.
E740 C9 00      001471 |	cmp #0h		;
E742 F0 3A      001472 |	beq DoStdDmp	;
                001473 |
E744 20 1C F3   001474 |	jsr AsToBin	;Get start address from operand field #1 and place
E747 B0 03      001475 |	bcs DgtOk1	; in zero page pointer.
E749 4C FF E7   001476 |	jmp ErrDump	;
E74C            001477 |DgtOk1 *		;
E74C 8D 09 00   001478 |	sta PointerA+1d	;
E74F E8         001479 |	inx		;
E750 20 1C F3   001480 |	jsr AsToBin	;
E753 B0 03      001481 |	bcs DgtOk2	;
E755 4C FF E7   001482 |	jmp ErrDump	;
E758            001483 |DgtOk2 *		;
E758 8D 08 00   001484 |	sta PointerA	;
                001485 |	
E75B A2 14      001486 |	ldx #20d	;If no end address was entered then perform a
E75D BD 5F 00   001487 |	lda OpFld1,x	; standard dump.
E760 C9 00      001488 |	cmp #0h		;
E762 F0 1A      001489 |	beq DoStdDmp	;
                001490 |	
E764 20 1C F3   001491 |	Jsr AsToBin	;Get end address from operand field #2 and place
E767 B0 03      001492 |	bcs OpFldOk1	; in the variable EndAdd.
E769 4C FF E7   001493 |	jmp ErrDump	;
E76C            001494 |OpFldOk1 *		;
E76C 8D 5D 00   001495 |	sta EndAdd+1d	;
E76F E8         001496 |	inx 		;
E770 20 1C F3   001497 |	jsr AsToBin	;
E773 B0 03      001498 |	bcs OpFldOk2	;
E775 4C FF E7   001499 |	jmp ErrDump	;
E778            001500 |OpFldOk2 *		;
E778 8D 5C 00   001501 |	sta EndAdd	;
                001502 |	
E77B 4C 95 E7   001503 |	jmp DoDump	
                001504 |	
E77E            001505 |DoStdDmp *
E77E AD 09 00   001506 |	lda PointerA+1d	;Adjust end address so that it will only dump the
E781 8D 5D 00   001507 |	sta EndAdd+1d	; contents of 16 memory locations.
E784 AD 08 00   001508 |	lda PointerA	;
E787 8D 5C 00   001509 |	sta EndAdd	;
E78A 18         001510 |	clc   		;Note: check to make sure this is correct.
E78B 69 0F      001511 |	adc #15d	;
E78D 8D 5C 00   001512 |	sta EndAdd	;
E790 90 03      001513 |	bcc DoDump	;
E792 EE 5D 00   001514 |	inc EndAdd+1d	;
                001515 |	
E795            001516 |DoDump *
E795 A9 0D      001517 |	lda #13d	;Output a CRLF.
E797 20 F0 F3   001518 |	jsr OutChar	;
E79A A9 0A      001519 |	lda #10d	;
E79C 20 F0 F3   001520 |	jsr OutChar	;
                001521 |
E79F A2 00      001522 |	ldx #0d		;
E7A1 A0 00      001523 |	ldy #0d		;
                001524 |
E7A3 20 05 F3   001525 |	jsr PrntAdd	;Output address of first dump memory location.
                001526 |	
E7A6            001527 |DumpAgin *
E7A6 B1 08      001528 |	lda (PointerA),y;Get byte from memory location.
                001529 |
E7A8 20 23 E8   001530 |	jsr PutASCBf	;Put character in ASCII buffer.
                001531 |	
E7AB 20 3E F3   001532 |	jsr OutHex	;Convert to ASCII/Hex and print.
                001533 |	
E7AE E8         001534 |	inx
E7AF E0 10      001535 |	cpx #16d	;
E7B1 D0 03      001536 |	bne Chk8	;
E7B3 20 0B E8   001537 |	jsr DumpASC	;Output ASCII interpretion of dumped line.
                001538 |	
E7B6            001539 |Chk8 *			;
E7B6 E0 08      001540 |	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
E7B8 D0 12      001541 |	bne OutSpc	; the dump screen.
E7BA A9 20      001542 |	lda #32d	;
E7BC 20 F0 F3   001543 |	jsr OutChar	;
E7BF A9 2D      001544 |	lda #45d	;
E7C1 20 F0 F3   001545 |	jsr OutChar	;
E7C4 A9 20      001546 |	lda #32d	;
E7C6 20 F0 F3   001547 |	jsr OutChar	;
E7C9 4C D1 E7   001548 |	jmp ChkEndAd	;
                001549 |	
E7CC            001550 |OutSpc *
E7CC A9 20      001551 |	lda #32d	;Print a space between hex characters on dump screen.
E7CE 20 F0 F3   001552 |	jsr OutChar	;
                001553 |	
E7D1            001554 |ChkEndAd *
E7D1 AD 08 00   001555 |	lda PointerA	;Check pointer against end address holder.  Exit
E7D4 CD 5C 00   001556 |	cmp EndAdd	; subroutine if the end address has been reached,
E7D7 D0 08      001557 |	bne PointNxt	; increment pointer and dump the contents of 
E7D9 AD 09 00   001558 |	lda PointerA+1d	; another memory location if not.
E7DC CD 5D 00   001559 |	cmp EndAdd+1d	;
E7DF F0 20      001560 |	beq ExitDump	;
E7E1            001561 |PointNxt *
E7E1 EE 08 00   001562 |	inc PointerA	;
E7E4 D0 03      001563 |	bne NoCary2	;
E7E6 EE 09 00   001564 |	inc PointerA+1d	;
E7E9            001565 |NoCary2 *		;
                001566 |
E7E9            001567 |ChkCR *			;Perform end of dump line functions.
E7E9 E0 10      001568 |	cpx #16d	;
E7EB D0 0F      001569 |	bne NotEnd	;
                001570 |	
E7ED A9 0A      001571 |	lda #10d	;Print a CRLF and reset X register to point to
E7EF 20 F0 F3   001572 |	jsr OutChar	; beginning of new dump line.
E7F2 A9 0D      001573 |	lda #13d	;
E7F4 20 F0 F3   001574 |	jsr Outchar	;
E7F7 20 05 F3   001575 |	jsr PrntAdd	;
E7FA A2 00      001576 |	ldx #0d		;
E7FC            001577 |NotEnd *
                001578 |	
E7FC 4C A6 E7   001579 |	jmp DumpAgin	;
                001580 |
E7FF            001581 |ErrDump *
E7FF 18         001582 |	clc
E800 60         001583 |	rts
                001584 |
E801            001585 |ExitDump *
E801 EE 08 00   001586 |	inc PointerA	;Point to next location in memory to be dumped
E804 D0 03      001587 |	bne NoCary3	;
E806 EE 09 00   001588 |	inc PointerA+1d	;
E809            001589 |NoCary3 *		;
E809 38         001590 |	sec
E80A 60         001591 |	rts
                001592 |
                001593 |;****************************************************************************
                001594 |;                 Output the ASCII interpretation of the dumped line.
                001595 |;****************************************************************************
E80B            001596 |DumpASC *
E80B A9 20      001597 |	lda #32d	;
E80D 20 F0 F3   001598 |	jsr OutChar	;
E810 A9 20      001599 |	lda #32d	;
E812 20 F0 F3   001600 |	jsr OutChar	;
E815 A2 00      001601 |	ldx #0d		;
E817            001602 |OutAsc *
E817 BD 4C 00   001603 |	lda ASCIIbuf,x	;
E81A 20 F0 F3   001604 |	jsr OutChar	;
E81D E8         001605 |	inx		;
E81E E0 10      001606 |	cpx #16d	;
E820 D0 F5      001607 |	bne OutAsc	;
E822 60         001608 |	rts
                001609 |
                001610 |
                001611 |;****************************************************************************
                001612 |;         Put byte from memory into ASCII buffer from Dump command.
                001613 |;****************************************************************************
E823            001614 |PutASCBf *
E823 48         001615 |	pha
E824 C9 20      001616 |	cmp #32d
E826 30 0A      001617 |	bmi Period
E828 C9 7F      001618 |	cmp #127d
E82A 10 06      001619 |	bpl Period
E82C 9D 4C 00   001620 |	sta ASCIIbuf,x
E82F 4C 37 E8   001621 |	jmp ExitPut
E832            001622 |Period *
E832 A9 2E      001623 |	lda #46d
E834 9D 4C 00   001624 |	sta ASCIIbuf,x
E837            001625 |ExitPut *
E837 68         001626 |	pla
E838 60         001627 |	rts
                001628 |	
                001629 |;****************************************************************************
                001630 |;                        Enter Command Subroutine.
                001631 |;****************************************************************************
E839            001632 |Enter *
E839 AD 5F 00   001633 |	lda OpFld1	;Check for operand in operand field #1.
E83C C9 00      001634 |	cmp #0d		;
E83E D0 03      001635 |	bne ChkOp2	;
E840 4C 67 E8   001636 |	jmp ErrEntr	;
                001637 |	
E843            001638 |ChkOp2 *
E843 AD 73 00   001639 |	lda OpFld2	;Check for operand in operand field #2.
E846 C9 00      001640 |	cmp #0d		;
E848 D0 03      001641 |	bne ProcEntr	;
E84A 4C 67 E8   001642 |	jmp ErrEntr	;
                001643 |	
E84D            001644 |ProcEntr *
E84D A2 00      001645 |	ldx #0d		;Get address from operand field #1.
E84F 20 C3 F2   001646 |	jsr GetAdd	;
E852 B0 03      001647 |	bcs EnAddOk	;
E854 4C 67 E8   001648 |	jmp ErrEntr	;
                001649 |
E857            001650 |EnAddOk *
E857 8E 08 00   001651 |	stx PointerA	;Put address from operand field #1 into
E85A 8C 09 00   001652 |	sty PointerA+1d	; zero page variable Pointer.
                001653 |	
E85D A2 14      001654 |	ldx #20d	;Get list of bytes to be entered into memory
E85F 20 6B E8   001655 |	jsr GetList	; from operand field #2 and put them in memory
E862 90 03      001656 |	bcc ErrEntr	; starting at Pointer.
E864 4C 69 E8   001657 |	jmp ExitEntr	;
                001658 |	
E867            001659 |ErrEntr *
E867 18         001660 |	clc
E868 60         001661 |	rts	
                001662 |
E869            001663 |ExitEntr *
E869 38         001664 |	sec
E86A 60         001665 |	rts
                001666 |
                001667 |
                001668 |;****************************************************************************
                001669 |;                        Get List Subroutine
                001670 |;
                001671 |;	Zero page variable Pointer points to location in memory where
                001672 |;	 list members will be placed.
                001673 |;****************************************************************************
E86B            001674 |GetList *
E86B A0 00      001675 |	ldy #0d
                001676 |	
E86D 8C CF 00   001677 |	sty DataTemp	;Use this variable to count bytes in list.	
                001678 |	
E870            001679 |GLNxtByt *
E870 BD 5F 00   001680 |	lda OpFld1,x	;Check for NULL that terminates current
E873 F0 28      001681 |	beq ListErr	; operand field.
                001682 |	
E875 20 1C F3   001683 |	jsr AsToBin	;Convert byte in list to binary form and place
E878 B0 03      001684 |	bcs StInMem	; in memory.
E87A 4C 9D E8   001685 |	jmp ListErr	;
E87D            001686 |StInMem *		;
E87D 91 08      001687 |	sta (PointerA),y;
E87F EE 08 00   001688 |	inc PointerA	;
E882 D0 03      001689 |	bne LstNoOv	;
E884 EE 09 00   001690 |	inc PointerA+1d	;
E887            001691 |LstNoOv *		;
E887 EE CF 00   001692 |	inc DataTemp	;
E88A AD CF 00   001693 |	lda DataTemp	;
E88D C9 0A      001694 |	cmp #10d	;
E88F F0 0A      001695 |	beq ExtGtLst	;
                001696 |	
E891 E8         001697 |	inx		;Point to comma between bytes.
                001698 |
E892 BD 5F 00   001699 |	lda OpFld1,x	;Check for NULL that terminates current
E895 F0 04      001700 |	beq ExtGtLst	; operand field.
                001701 |	
E897 E8         001702 |	inx		;Point to next byte in list.
                001703 |	
E898 4C 70 E8   001704 |	jmp GLNxtByt	;
                001705 |	
E89B            001706 |ExtGtLst *
E89B 38         001707 |	sec
E89C 60         001708 |	rts
                001709 |
E89D            001710 |ListErr *
E89D 18         001711 |	clc
E89E 60         001712 |	rts
                001713 |
                001714 |;****************************************************************************
                001715 |;                        Fill Command Subroutine.
                001716 |;****************************************************************************
E89F            001717 |Fill *
                001718 |
E89F A2 00      001719 |	ldx #0d		;Get start address.
E8A1 20 C3 F2   001720 |	jsr GetAdd	;
E8A4 B0 03      001721 |	bcs FAdd1ok	;
E8A6 4C DC E8   001722 |	jmp ErrFill	;
E8A9            001723 |FAdd1ok *		;
E8A9 8E 08 00   001724 |	stx PointerA	;
E8AC 8C 09 00   001725 |	sty PointerA+1d	;
                001726 |	
E8AF A2 14      001727 |	ldx #20d	;Get end address.
E8B1 20 C3 F2   001728 |	jsr GetAdd	;
E8B4 B0 03      001729 |	bcs FAdd2ok	;
E8B6 4C DC E8   001730 |	jmp ErrFill	;
E8B9            001731 |FAdd2ok *		;
E8B9 8E 5C 00   001732 |	stx EndAdd	;
E8BC 8C 5D 00   001733 |	sty EndAdd+1d	;
                001734 |	
E8BF            001735 |FillAgin *
E8BF A2 28      001736 |	ldx #40d	;Get list and place in memory.
E8C1 20 6B E8   001737 |	jsr GetList	;
E8C4 90 16      001738 |	bcc ErrFill	;
                001739 |
E8C6 AD 5D 00   001740 |	lda EndAdd+1d	;Check to see if end address has been reached.
E8C9 CD 09 00   001741 |	cmp PointerA+1d	;
E8CC F0 03      001742 |	beq ChkFLSB	;
                001743 |;	bmi ExitFill 	;
E8CE 4C BF E8   001744 |	jmp FillAgin 	;
E8D1            001745 |ChkFLSB *
E8D1 AD 5C 00   001746 |	lda EndAdd	; 
E8D4 CD 08 00   001747 |	cmp PointerA	;
E8D7 F0 05      001748 |	beq ExitFill	;
                001749 |	
E8D9 4C BF E8   001750 |	jmp  FillAgin	;
                001751 |	
                001752 |
E8DC            001753 |ErrFill *
E8DC 18         001754 |	clc
E8DD 60         001755 |	rts
                001756 |
E8DE            001757 |ExitFill *
E8DE 38         001758 |	sec
E8DF 60         001759 |	rts
                001760 |
                001761 |;****************************************************************************
                001762 |;                        Go Command Subroutine
                001763 |;****************************************************************************
E8E0            001764 |Go *
                001765 |
E8E0 AD 5F 00   001766 |	lda OpFld1	;Check for operand.
E8E3 C9 00      001767 |	cmp #0d		;
E8E5 F0 10      001768 |	beq CurentPC	;
                001769 |			
E8E7 A2 00      001770 |	ldx #0d		;Get address from operand field #1.
E8E9 20 C3 F2   001771 |	jsr GetAdd	;
E8EC B0 03      001772 |	bcs GAddOk	;
E8EE 4C 5D E9   001773 |	jmp ErrGo	;
                001774 |	
E8F1            001775 |GAddOk *		;
E8F1 8E 45 00   001776 |	stx UPgmCntr	;
E8F4 8C 46 00   001777 |	sty UPgmCntr+1d	;
                001778 |
E8F7            001779 |CurentPC *
E8F7 AE 45 00   001780 |	ldx UPgmCntr	;
E8FA 8E 2B 00   001781 |	stx TempAdd	;
E8FD AC 46 00   001782 |	ldy UPgmCntr+1d	;
E900 8C 2C 00   001783 |	sty TempAdd+1d	;
E903 A0 03      001784 |	ldy #3d		;Check to make sure that breakpoint address has
E905 A2 06      001785 |	ldx #6d		; not already been entered into table.
E907            001786 |CkBPAddG *		;
E907 B9 2F 00   001787 |	lda BrkPt1St,y	;
E90A C9 00      001788 |	cmp #0d		;
E90C F0 05      001789 |	beq NoCmpG	;
E90E 20 F4 E6   001790 |	jsr CmpBPAdd	;
E911 B0 08      001791 |	bcs MaError	;
E913            001792 |NoCmpG *		;
E913 88         001793 |	dey		;
E914 CA         001794 |	dex		;
E915 CA         001795 |	dex		;
E916 10 EF      001796 |	bpl CkBPAddG	;
E918 4C 25 E9   001797 |	jmp NoMatchG	;
                001798 |
E91B            001799 |MaError *
E91B A2 DA      001800 |	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
E91D A0 F5      001801 |	ldy #GoBPErrM>	; error message and exit.
E91F 20 92 F3   001802 |	jsr PrntMess	;
E922 4C 5F E9   001803 |	jmp ExitGo	;
                001804 |
E925            001805 |NoMatchG *
E925 A0 03      001806 |	ldy #3d		;Check all active breakpoints in table, save
E927 A2 06      001807 |	ldx #6d		; the opcodes of the breakpointed addresses, 
E929            001808 |CkBPSt *		;
E929 B9 2F 00   001809 |	lda BrkPt1St,y	; and replace them with BRKs.
E92C C9 01      001810 |	cmp #1d		;
E92E D0 09      001811 |	bne NxtBPSt	;
E930 A1 12      001812 |	lda (BrkPt1Ad,x);
E932 99 33 00   001813 |	sta BP1OpHld,y	;
E935 A9 00      001814 |	lda #0d		;
E937 81 12      001815 |	sta (BrkPt1Ad,x);
E939            001816 |NxtBPSt *		;
E939 88         001817 |	dey		;
E93A CA         001818 |	dex		;
E93B CA         001819 |	dex		;
E93C 10 EB      001820 |	bpl CkBPSt	;
                001821 |
E93E 68         001822 |	pla		;Remove Go command's return address and the check
E93F 68         001823 |	pla		; command's return address from the stack.
E940 68         001824 |	pla		;
E941 68         001825 |	pla		;
                001826 |    
E942 AD 5F 00   001827 |    lda OpFld1	;Check for operand.
E945 C9 00      001828 |	cmp #0d		;
E947 F0 11      001829 |	beq DoNotRestoreRegistersGo
                001830 | 
E949 A2 FF      001831 |    ldx #0ffh    ;Restore user's registers.
E94B 9A         001832 |    txs          ;
E94C AD 4B 00   001833 |    lda UStatReg ;
E94F 48         001834 |	pha          ;
E950 AD 47 00   001835 |	lda UAccum	 ;
E953 AE 48 00   001836 |	ldx UXReg	 ;
E956 AC 49 00   001837 |	ldy UYReg	 ;
E959 28         001838 |    plp          ;
                001839 |   
E95A            001840 |DoNotRestoreRegistersGo *
                001841 |	
E95A 6C 45 00   001842 |	jmp (UPgmCntr)	;Start executing at address being pointed to by
                001843 |			; UPGmCntr.	
                001844 |
E95D            001845 |ErrGo *
E95D 18         001846 |	clc
E95E 60         001847 |	rts
                001848 |	
E95F            001849 |ExitGo *
E95F 38         001850 |	sec
E960 60         001851 |	rts
                001852 |
                001853 |;****************************************************************************
                001854 |;                       Help Command Subroutine.
                001855 |;****************************************************************************
E961            001856 |Help *
E961 A2 20      001857 |	ldx #HelpMess<
E963 A0 F6      001858 |	ldy #HelpMess>
E965 20 92 F3   001859 |	jsr PrntMess
E968 60         001860 |	rts
                001861 |
                001862 |;****************************************************************************
                001863 |;                     Load Command Subroutine
                001864 |;****************************************************************************
E969            001865 |LdSRecs *
E969 A2 A8      001866 |	ldx #SRecStMs<
E96B A0 F4      001867 |	ldy #SRecStMs>	
E96D 20 92 F3   001868 |	jsr PrntMess
                001869 |	
E970 20 D2 F3   001870 |	jsr GetCharW	;Wait for first character of record.
E973 A2 A5      001871 |	ldx #CRLF<	;
E975 A0 F4      001872 |	ldy #CRLF>	;
E977 20 92 F3   001873 |	jsr PrntMess	;
E97A 4C 80 E9   001874 |	jmp CkS		;
                001875 |	
E97D            001876 |GtAnCh *		;
E97D 20 D2 F3   001877 |	jsr GetCharW	;Check for an S.
E980            001878 |CkS *			;
E980 C9 53      001879 |	cmp #83d	;
E982 D0 F9      001880 |	bne GtAnCh	;
                001881 |	
E984 20 F0 F3   001882 |	jsr OutChar	;Print an S to the user.
                001883 |	
E987 20 D2 F3   001884 |	jsr GetCharW	;Get record type ECHO it and store it.
E98A 20 F0 F3   001885 |	jsr OutChar	;
E98D 8D A1 00   001886 |	sta RecType	;
                001887 |	
E990 C9 30      001888 |	cmp #48d	;Check for header record and process.
E992 D0 08      001889 |	bne NtHdr	;
E994 20 95 EA   001890 |	jsr ProcHdr	;
E997 90 25      001891 |	bcc SError	;
E999 4C BB E9   001892 |	jmp NextLine	;
                001893 |	
E99C            001894 |NtHdr *			;
E99C C9 31      001895 |	cmp #49d	;Check for code record and process.
E99E D0 08      001896 |	bne NtCd	;
E9A0 20 9F EA   001897 |	jsr ProcCode	;
E9A3 90 19      001898 |	bcc SError	;
E9A5 4C BB E9   001899 |	jmp NextLine	;
                001900 |	
E9A8            001901 |NtCd *			;
E9A8 C9 39      001902 |	cmp #57d	;Check for termination record process, and print
E9AA D0 12      001903 |	bne SError	; records loaded message.
E9AC 20 A9 EA   001904 |	jsr ProcTerm	;
E9AF 90 0D      001905 |	bcc SError	;
E9B1 A2 F1      001906 |	ldx #SRecEnMs<	;
E9B3 A0 F4      001907 |	ldy #SRecEnMs>	;
E9B5 20 92 F3   001908 |	jsr PrntMess	;
E9B8 4C C7 E9   001909 |	jmp ExitSRec	;
                001910 |	
E9BB            001911 |NextLine *
E9BB 4C 7D E9   001912 |	jmp GtAnCh
                001913 |
E9BE            001914 |SError *
E9BE A2 D1      001915 |	ldx #SRecErMe<
E9C0 A0 F4      001916 |	ldy #SRecErMe>	
E9C2 20 92 F3   001917 |	jsr PrntMess
E9C5 38         001918 |	sec
E9C6 60         001919 |	rts
                001920 |	
E9C7            001921 |ExitSRec *
E9C7 20 D2 F3   001922 |	jsr GetCharW
E9CA 38         001923 |	sec
E9CB 60         001924 |	rts
                001925 |	
                001926 |;****************************************************************************
                001927 |;                Process Record Length and Address Subroutine
                001928 |;****************************************************************************
E9CC            001929 |PrRLeAdd *	
                001930 |	
E9CC A9 00      001931 |	lda #0h		;Zero out Checksum accumulator.
E9CE 8D 9F 00   001932 |	sta CkSumAc	;
E9D1 8D A0 00   001933 |	sta CkSumAc+1h	;
                001934 |	
E9D4 20 3C EA   001935 |	jsr Getnum	;Fetch record length and update checksum
E9D7 8D 9E 00   001936 |	sta RecLen	; accumulator.
E9DA 20 63 EA   001937 |	jsr AccCkSum	;
                001938 |	
E9DD AA         001939 |	tax		;Adjust code byte counter and store it.
E9DE CA         001940 |	dex		;
E9DF CA         001941 |	dex		;
E9E0 CA         001942 |	dex		;
E9E1 8A         001943 |	txa		;
E9E2 8D 9B 00   001944 |	sta CodeCntr	;
                001945 |	
E9E5 20 3C EA   001946 |	jsr GetNum	;Get most significant byte of address and
E9E8 8D 09 00   001947 |	sta PointerA+1h	; store it.
E9EB 20 63 EA   001948 |	jsr AccCkSum	;
                001949 |	
E9EE 20 3C EA   001950 |	jsr GetNum	;Get least significant byte of address and
E9F1 8D 08 00   001951 |	sta PointerA	; store it.
E9F4 20 63 EA   001952 |	jsr AccCkSum	;
                001953 |	
E9F7 60         001954 |	rts
                001955 |	
                001956 |;****************************************************************************
                001957 |;        Get Code Byte Without Loading into Memory Subroutine.
                001958 |;****************************************************************************
E9F8            001959 |GtCodNld *
                001960 |	
E9F8 AD 9B 00   001961 |	lda CodeCntr
E9FB F0 0B      001962 |	beq ExitNld
                001963 |	
E9FD            001964 |GetOneNl *
E9FD 20 3C EA   001965 |	jsr GetNum
EA00 20 63 EA   001966 |	jsr AccCkSum
EA03 CE 9B 00   001967 |	dec CodeCntr
EA06 D0 F5      001968 |	Bne GetOneNl
                001969 |	
EA08            001970 |ExitNld *
EA08 60         001971 |	rts
                001972 |
                001973 |;****************************************************************************
                001974 |;        Get Code Byte and Load it into Memory Subroutine.
                001975 |;****************************************************************************
EA09            001976 |GtCodLd *
                001977 |
EA09 AD 9B 00   001978 |	lda CodeCntr
EA0C F0 17      001979 |	beq ExitLd
                001980 |	
EA0E A0 00      001981 |	ldy #0h
EA10            001982 |GtOneLd *
EA10 20 3C EA   001983 |	jsr GetNum
EA13 20 63 EA   001984 |	jsr AccCkSum
EA16 91 08      001985 |	sta (PointerA),y	
EA18 EE 08 00   001986 |	inc PointerA
EA1B D0 03      001987 |	bne NxtCode
EA1D EE 09 00   001988 |	inc PointerA+1h
EA20            001989 |NxtCode *
EA20 CE 9B 00   001990 |	dec CodeCntr
EA23 D0 EB      001991 |	bne GtOneld
                001992 |	
EA25            001993 |ExitLd *
EA25 60         001994 |	rts
                001995 |
                001996 |;****************************************************************************
                001997 |;                      Check Checksum Subroutine.
                001998 |;****************************************************************************
EA26            001999 |ChkChkSm *
                002000 |
EA26 AD 9F 00   002001 |	lda CkSumAc	;Invert lowest byte of the checksum accumulator
EA29 49 FF      002002 |	eor #0ffh	; and store it in CkhSum.
EA2B 8D 9D 00   002003 |	sta ChkSum	;
                002004 |	
EA2E 20 3C EA   002005 |	jsr GetNum	;Compare calculated checksum against S record	
EA31 CD 9D 00   002006 |	cmp ChkSum	; checksum.
EA34 F0 04      002007 |	beq CkSumOK	;
EA36 18         002008 |	clc
EA37 4C 3B EA   002009 |	jmp Chkexit
EA3A            002010 |CkSumOK *
EA3A 38         002011 |	sec
EA3B            002012 |Chkexit *
EA3B 60         002013 |	rts
                002014 |
                002015 |;****************************************************************************
                002016 |;                       Get Number Subroutine.
                002017 |;****************************************************************************
EA3C            002018 |GetNum *
EA3C 98         002019 |	tya
EA3D 48         002020 |	pha
                002021 |
EA3E 20 D2 F3   002022 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
EA41 20 72 EA   002023 |	jsr DgtToBin	; and position hex digit in most significat nibble
EA44 90 1C      002024 |	bcc ExtGtNum	;
EA46 0A         002025 |	asl a		; of number.
EA47 0A         002026 |	asl a		;
EA48 0A         002027 |	asl a		;
EA49 0A         002028 |	asl a		;
EA4A 29 F0      002029 |	and #0f0h	;
EA4C 8D 9C 00   002030 |	sta number	;
                002031 |	
EA4F 20 D2 F3   002032 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
EA52 20 72 EA   002033 |	jsr DgtToBin	; and position hex digit in least significant
EA55 90 0B      002034 |	bcc ExtGtNum	;
EA57 0D 9C 00   002035 |	ora number	; nibble of number.
EA5A 8D 9C 00   002036 |	sta number	;
                002037 |	
EA5D 68         002038 |	pla
EA5E A8         002039 |	tay
EA5F AD 9C 00   002040 |	lda number
EA62            002041 |ExtGtNum *
EA62 60         002042 |	rts
                002043 |
                002044 |;****************************************************************************
                002045 |;                    Accumulate Checksum Subroutine.
                002046 |;****************************************************************************
EA63            002047 |AccCkSum *
EA63 48         002048 |	pha
EA64 18         002049 |	clc
EA65 6D 9F 00   002050 |	adc CkSumAc
EA68 8D 9F 00   002051 |	sta CkSumAc
EA6B 90 03      002052 |	bcc NoOvrFlo
EA6D EE A0 00   002053 |	inc CkSumAc+1h
EA70            002054 |NoOvrFlo *
EA70 68         002055 |	pla
EA71 60         002056 |	rts
                002057 |
                002058 |;****************************************************************************
                002059 |;                ASCII Digit to Binary Number Subroutine.
                002060 |;
                002061 |;        Enter with register 'A' containing the number to convert.
                002062 |;        If the number was valid return its binary conversion in the
                002063 |;        A register.  If the number is not convertable then clear the
                002064 |;        carry flag and return.
                002065 |;****************************************************************************
EA72            002066 |DgtToBin *
                002067 |	
EA72 8E CE 00   002068 |	stx RegTemp	;Save the character to convert.
                002069 |	
EA75 A2 00      002070 |	ldx #0h		
                002071 |	
EA77            002072 |AnothDgt *
EA77 DD 2F F4   002073 |	cmp DgtTblUC,x	;Search through character table and try to find
EA7A F0 13      002074 |	beq Match	; a match for the character present in the X
EA7C DD 40 F4   002075 |	cmp DgtTblLC,x	; register.
EA7F F0 0E      002076 |	beq Match	;
                002077 |	
EA81 E8         002078 |	inx		;If a match was not found then increment the
EA82 E0 10      002079 |	cpx #16d	; table index register and check the next
EA84 F0 03      002080 |	beq DgtError	; character.  If all the characters have been 
EA86 4C 77 EA   002081 |	jmp AnothDgt	; checked then return with an error.
                002082 |	
EA89            002083 |DgtError *
EA89 A9 00      002084 |	lda #0h
EA8B 18         002085 |	clc
EA8C 4C 94 EA   002086 |	jmp DgtExit
                002087 |
EA8F            002088 |Match *
EA8F 8A         002089 |	txa
EA90 38         002090 |	sec
                002091 |	
EA91 AE CE 00   002092 |	ldx RegTemp
EA94 60         002093 |DgtExit	rts
                002094 |	
                002095 |;****************************************************************************
                002096 |;                    Process Header Record Subroutine.
                002097 |;****************************************************************************
                002098 |
EA95            002099 |ProcHdr *
                002100 |
EA95 20 CC E9   002101 |	jsr PrRLeAdd
EA98 20 F8 E9   002102 |	jsr GtCodNld		
EA9B 20 26 EA   002103 |	jsr ChkChkSm
                002104 |	
EA9E 60         002105 |	rts
                002106 |
                002107 |;****************************************************************************
                002108 |;                     Process Code Record Subroutine
                002109 |;****************************************************************************
EA9F            002110 |ProcCode *
                002111 |
EA9F 20 CC E9   002112 |	jsr PrRLeAdd
EAA2 20 09 EA   002113 |	jsr GtCodLd
EAA5 20 26 EA   002114 |	jsr ChkChksm
                002115 |	
EAA8 60         002116 |	rts
                002117 |
                002118 |;****************************************************************************
                002119 |;                     Process Termination Record Subroutine
                002120 |;****************************************************************************
EAA9            002121 |ProcTerm *
                002122 |
EAA9 20 CC E9   002123 |	jsr PrRLeAdd
EAAC 20 F8 E9   002124 |	jsr GtCodNld	
EAAF 20 26 EA   002125 |	jsr ChkChkSm
                002126 |
EAB2 60         002127 |	rts
                002128 |
                002129 |;****************************************************************************
                002130 |;                       Move Command Subroutine.
                002131 |;****************************************************************************
EAB3            002132 |Move *
EAB3 AD 5F 00   002133 |	lda OpFld1	;Check for operands.
EAB6 C9 00      002134 |	cmp #0d		;
EAB8 F0 07      002135 |	beq MOut	;
                002136 |
EABA A2 00      002137 |	ldx #0d		;Get start address.
EABC 20 C3 F2   002138 |	jsr GetAdd	;
EABF B0 03      002139 |	bcs MAdd1ok	;
EAC1            002140 |MOut *			;
EAC1 4C 1E EB   002141 |	jmp ExitMove	;
EAC4            002142 |MAdd1ok *		;
EAC4 8E 08 00   002143 |	stx PointerA	;
EAC7 8C 09 00   002144 |	sty PointerA+1d	;
                002145 |	
EACA A2 14      002146 |	ldx #20d	;Get end address and increment by 1.
EACC 20 C3 F2   002147 |	jsr GetAdd	;
EACF B0 03      002148 |	bcs MAdd2ok	;
EAD1 4C 1E EB   002149 |	jmp ExitMove	;
EAD4            002150 |MAdd2ok *		;
EAD4 8E 5C 00   002151 |	stx EndAdd	;
EAD7 8C 5D 00   002152 |	sty EndAdd+1d	;
EADA EE 5C 00   002153 |	inc EndAdd	;
EADD D0 03      002154 |	bne MNOvFlo	;
EADF EE 5D 00   002155 |	inc EndAdd+1d	;
                002156 |	
EAE2            002157 |MNOvFlo *		;
EAE2 A2 28      002158 |	ldx #40d	;Get destination address.
EAE4 20 C3 F2   002159 |	jsr GetAdd	;
EAE7 B0 03      002160 |	bcs MAdd3ok	;
EAE9 4C 1E EB   002161 |	jmp ExitMove	;
EAEC            002162 |MAdd3ok *		;
EAEC 8E 0A 00   002163 |	stx PointerB	;
EAEF 8C 0B 00   002164 |	sty PointerB+1d	;
                002165 |
EAF2 A0 00      002166 |	ldy #0d		;Move bytes between start address and end address
EAF4            002167 |MCont *			;to memory starting at destination address.
EAF4 B1 08      002168 |	lda (PointerA),y; 
EAF6 91 0A      002169 |	sta (PointerB),y;
EAF8 EE 0A 00   002170 |	inc PointerB	;
EAFB D0 03      002171 |	bne MNoOvf1	;
EAFD EE 0B 00   002172 |	inc PointerB+1d	;
EB00            002173 |MNoOvf1 *		;
EB00 EE 08 00   002174 |	inc PointerA	;
EB03 D0 03      002175 |	bne MNoOvf2	;
EB05 EE 09 00   002176 |	inc PointerA+1d	;
EB08            002177 |MNoOvf2 *		;
EB08 AD 08 00   002178 |	lda PointerA	;
EB0B CD 5C 00   002179 |	cmp EndAdd	;
EB0E F0 03      002180 |	beq MCkMSB	;
EB10 4C F4 EA   002181 |	jmp MCont	;
EB13            002182 |MCkMSB *		;
EB13 AD 09 00   002183 |	lda PointerA+1d	;
EB16 CD 5D 00   002184 |	cmp EndAdd+1d	;
EB19 F0 03      002185 |	beq ExitMove	;
EB1B 4C F4 EA   002186 |	jmp MCont	;
                002187 |	
EB1E            002188 |ExitMove *
EB1E 60         002189 |	rts
                002190 |
                002191 |
                002192 |;****************************************************************************
                002193 |;                     Register Command Subroutine
                002194 |;****************************************************************************
EB1F            002195 |Register *
EB1F 48         002196 |	pha
EB20 8A         002197 |	txa
EB21 48         002198 |	pha
EB22 98         002199 |	tya
EB23 48         002200 |	pha
EB24 08         002201 |	php
                002202 |	
EB25 AD 5F 00   002203 |	lda OpFld1	;Check for operand.
EB28 C9 00      002204 |	cmp #0d		;
EB2A F0 03      002205 |	beq GenReg	;
EB2C 4C 97 EB   002206 |	jmp SpecReg	;
                002207 |	
EB2F            002208 |GenReg *		;
EB2F A2 2F      002209 |	ldx #RegMess<	;Output register headings.
EB31 A0 F5      002210 |	ldy #RegMess>	;
EB33 20 92 F3   002211 |	jsr PrntMess	;
                002212 |	
EB36 A0 03      002213 |	ldy #3d		;Output contents of user's program counter.
EB38 20 E2 F2   002214 |	jsr OutSpace	;
EB3B AD 46 00   002215 |	lda UPgmCntr+1d	;
EB3E 20 3E F3   002216 |	jsr OutHex	;
EB41 AD 45 00   002217 |	lda UPgmCntr	;
EB44 20 3E F3   002218 |	jsr OutHex	;
                002219 |	
EB47 A0 09      002220 |	ldy #9d		;Output contents of user's accumulator.
EB49 20 E2 F2   002221 |	jsr OutSpace	;
EB4C AD 47 00   002222 |	lda UAccum	;
EB4F 20 3E F3   002223 |	jsr OutHex	;
                002224 |	
EB52 A0 09      002225 |	ldy #9d		;Output contents of user's X register.
EB54 20 E2 F2   002226 |	jsr OutSpace	;
EB57 AD 48 00   002227 |	lda UXreg	;
EB5A 20 3E F3   002228 |	jsr OutHex	;
                002229 |	
EB5D A0 08      002230 |	ldy #8d		;Output contents of user's Y register.
EB5F 20 E2 F2   002231 |	jsr OutSpace	;
EB62 AD 49 00   002232 |	lda UYReg	;
EB65 20 3E F3   002233 |	jsr OutHex	;
                002234 |	
EB68 A0 08      002235 |	ldy #8d		;Output contents of user's Stack Pointer.
EB6A 20 E2 F2   002236 |	jsr OutSpace	;
EB6D AD 4A 00   002237 |	lda UStkPtr	;
EB70 20 3E F3   002238 |	jsr OutHex	;
                002239 |	
EB73 A0 07      002240 |	ldy #7d		;Output contents of user's Status register.
EB75 20 E2 F2   002241 |	jsr OutSpace	;
EB78 AD 4B 00   002242 |	lda UStatReg	;
EB7B A2 08      002243 |	ldx #8d		;
EB7D            002244 |NextFlag *		;
EB7D 2A         002245 |	rol a		;
EB7E B0 0A      002246 |	bcs OutOne	;
EB80            002247 |OutZero *		;
EB80 48         002248 |	pha		;
EB81 A9 30      002249 |	lda #30h	;
EB83 20 F0 F3   002250 |	jsr OutChar	;
EB86 68         002251 |	pla		;
EB87 4C 91 EB   002252 |	jmp CkBtPos	;
EB8A            002253 |OutOne *		;
EB8A 48         002254 |	pha		;
EB8B A9 31      002255 |	lda #31h	;
EB8D 20 F0 F3   002256 |	jsr OutChar	;
EB90 68         002257 |	pla		;
EB91            002258 |CkBtPos *		;
EB91 CA         002259 |	dex		;
EB92 D0 E9      002260 |	bne NextFlag	;
EB94 4C DC EC   002261 |	jmp ExitReg	;
                002262 |	
                002263 |	
EB97            002264 |SpecReg *
EB97 A9 0D      002265 |	lda #13d
EB99 20 F0 F3   002266 |	jsr OutChar
EB9C A9 0A      002267 |	lda #10d
EB9E 20 F0 F3   002268 |	jsr OutChar
EBA1 AD 5F 00   002269 |	lda OpFld1
EBA4 20 ED F2   002270 |	jsr ToLower
                002271 |
EBA7            002272 |CkPCReg *		;
EBA7 C9 70      002273 |	cmp #112d	;Get value for Program Counter from user.
EBA9 D0 3C      002274 |	bne CkAReg	;
EBAB AD 46 00   002275 |	lda UpgmCntr+1d	;
EBAE 20 3E F3   002276 |	jsr OutHex	;
EBB1 AD 45 00   002277 |	lda UpgmCntr	;
EBB4 20 3E F3   002278 |	jsr OutHex	;
EBB7 20 DA F2   002279 |	jsr OutColn	;
EBBA 20 87 E0   002280 |	jsr GetLine	;
EBBD 20 ED E0   002281 |	jsr ParseOpr	;
EBC0 AD 5F 00   002282 |	lda OpFld1	;
EBC3 C9 00      002283 |	cmp #0d		;
EBC5 D0 03      002284 |	bne GetPC	;
EBC7 4C DC EC   002285 |	jmp ExitReg	;
EBCA A2 00      002286 |GetPC	ldx #0d		;
EBCC 20 1C F3   002287 |	jsr AsToBin	;
EBCF B0 03      002288 |	bcs PCMSBOK	;
EBD1 4C DC EC   002289 |	jmp ExitReg	;
EBD4 A8         002290 |PCMSBOK	tay		;
EBD5 E8         002291 |	inx		;
EBD6 20 1C F3   002292 |	jsr AsToBin	;
EBD9 B0 03      002293 |	bcs PCLSBOK	;
EBDB 4C DC EC   002294 |	jmp ExitReg	;
EBDE 8D 45 00   002295 |PCLSBOK	sta UPgmCntr	;
EBE1 8C 46 00   002296 |	sty UPgmCntr+1d	;
EBE4 4C DC EC   002297 |	jmp ExitReg	;
                002298 |	
EBE7            002299 |CkAReg *		;Get value for Accumulator from user.
EBE7 C9 61      002300 |	cmp #97d	;
EBE9 D0 29      002301 |	bne CkXReg	;
EBEB AD 47 00   002302 |	lda UAccum	;
EBEE 20 3E F3   002303 |	jsr OutHex	;
EBF1 20 DA F2   002304 |	jsr OutColn	;
EBF4 20 87 E0   002305 |	jsr GetLine	;
EBF7 20 ED E0   002306 |	jsr ParseOpr	;
EBFA AD 5F 00   002307 |	lda OpFld1	;
EBFD C9 00      002308 |	cmp #0d		;
EBFF D0 03      002309 |	bne GetA	;
EC01 4C DC EC   002310 |	jmp ExitReg	;
EC04            002311 |GetA *			;
EC04 A2 00      002312 |	ldx #0d		;
EC06 20 1C F3   002313 |	jsr AsToBin	;
EC09 B0 03      002314 |	bcs AOK		;
EC0B 4C DC EC   002315 |	jmp ExitReg	;
EC0E            002316 |AOK *			;
EC0E 8D 47 00   002317 |	sta UAccum	;
EC11 4C DC EC   002318 |	jmp ExitReg	;
                002319 |	
EC14            002320 |CkXReg *		;Get value for X register from user.
EC14 C9 78      002321 |	cmp #120d	;
EC16 D0 29      002322 |	bne CkYReg	;
EC18 AD 48 00   002323 |	lda UXreg	;
EC1B 20 3E F3   002324 |	jsr OutHex	;
EC1E 20 DA F2   002325 |	jsr OutColn	;
EC21 20 87 E0   002326 |	jsr GetLine	;
EC24 20 ED E0   002327 |	jsr ParseOpr	;
EC27 AD 5F 00   002328 |	lda OpFld1	;
EC2A C9 00      002329 |	cmp #0d		;
EC2C D0 03      002330 |	bne GetX	;
EC2E 4C DC EC   002331 |	jmp ExitReg	;
EC31            002332 |GetX *			;
EC31 A2 00      002333 |	ldx #0d		;
EC33 20 1C F3   002334 |	jsr AsToBin	;
EC36 B0 03      002335 |	bcs XOK		;
EC38 4C DC EC   002336 |	jmp ExitReg	;
EC3B            002337 |XOK *			;
EC3B 8D 48 00   002338 |	sta UXReg	;
EC3E 4C DC EC   002339 |	jmp ExitReg	;
                002340 |	
EC41            002341 |CkYReg *		;Get value for Y register from user.
EC41 C9 79      002342 |	cmp #121d	;
EC43 D0 29      002343 |	bne CkForS	;
EC45 AD 49 00   002344 |	lda UYReg	;
EC48 20 3E F3   002345 |	jsr OutHex	;
EC4B 20 DA F2   002346 |	jsr OutColn	;
EC4E 20 87 E0   002347 |	jsr GetLine	;
EC51 20 ED E0   002348 |	jsr ParseOpr	;
EC54 AD 5F 00   002349 |	lda OpFld1	;
EC57 C9 00      002350 |	cmp #0d		;
EC59 D0 03      002351 |	bne GetY	;
EC5B 4C DC EC   002352 |	jmp ExitReg	;
EC5E            002353 |GetY *			;
EC5E A2 00      002354 |	ldx #0d		;
EC60 20 1C F3   002355 |	jsr AsToBin	;
EC63 B0 03      002356 |	bcs YOK		;
EC65 4C DC EC   002357 |	jmp ExitReg	;
EC68            002358 |YOK *			;
EC68 8D 49 00   002359 |	sta UYReg	;
EC6B 4C DC EC   002360 |	jmp ExitReg	;
                002361 |	
EC6E            002362 |CkForS *		;Check if user is accessing the Stack Pointer or
EC6E C9 73      002363 |	cmp #115d	; the Status Register.
EC70 F0 03      002364 |	beq CkPorR	;
EC72 4C D8 EC   002365 |	jmp RegInErr	;
EC75            002366 |CkPorR *		;
EC75 AD 60 00   002367 |	lda OpFld1+1d	;
EC78 20 ED F2   002368 |	jsr ToLower	;
EC7B C9 70      002369 |	cmp #112d	;
EC7D F0 07      002370 |	beq CkSpReg	;
EC7F C9 72      002371 |	cmp #114d	;
EC81 F0 2C      002372 |	beq CkSRReg	;
EC83 4C D8 EC   002373 |	jmp RegInErr	;
                002374 |
EC86            002375 |CkSpReg *		;
EC86 AD 4A 00   002376 |	lda UStkPtr	;Get value for Stack Pointer from user.
EC89 20 3E F3   002377 |	jsr OutHex	;
EC8C 20 DA F2   002378 |	jsr OutColn	;
EC8F 20 87 E0   002379 |	jsr GetLine	;
EC92 20 ED E0   002380 |	jsr ParseOpr	;
EC95 AD 5F 00   002381 |	lda OpFld1	;
EC98 C9 00      002382 |	cmp #0d		;
EC9A D0 03      002383 |	bne GetSP	;
EC9C 4C DC EC   002384 |	jmp ExitReg	;
EC9F            002385 |GetSP *			;
EC9F A2 00      002386 |	ldx #0d		;
ECA1 20 1C F3   002387 |	jsr AsToBin	;
ECA4 B0 03      002388 |	bcs SPOK	;
ECA6 4C DC EC   002389 |	jmp ExitReg	;
ECA9            002390 |SPOK *			;
ECA9 8D 4A 00   002391 |	sta UStkPtr	;
ECAC 4C DC EC   002392 |	jmp ExitReg	;
                002393 |	
ECAF            002394 |CkSRReg *		;Get value for Status Register from user.
ECAF AD 4B 00   002395 |	lda UStatReg	;
ECB2 20 3E F3   002396 |	jsr OutHex	;
ECB5 20 DA F2   002397 |	jsr OutColn	;
ECB8 20 87 E0   002398 |	jsr GetLine	;
ECBB 20 ED E0   002399 |	jsr ParseOpr	;
ECBE AD 5F 00   002400 |	lda OpFld1	;
ECC1 C9 00      002401 |	cmp #0d		;
ECC3 D0 03      002402 |	bne GetSR	;
ECC5 4C DC EC   002403 |	jmp ExitReg	;
ECC8 A2 00      002404 |GetSR	ldx #0d		;
ECCA 20 1C F3   002405 |	jsr AsToBin	;
ECCD B0 03      002406 |	bcs SROK	;
ECCF 4C DC EC   002407 |	jmp ExitReg	;
ECD2 8D 4B 00   002408 |SROK	sta UStatReg	;
ECD5 4C DC EC   002409 |	jmp ExitReg	;
                002410 |
ECD8            002411 |RegInErr *
ECD8 18         002412 |	clc
ECD9 4C DD EC   002413 |	jmp ErrRegOt
                002414 |	
ECDC            002415 |ExitReg *
ECDC 38         002416 |	sec
ECDD            002417 |ErrRegOt *
ECDD 28         002418 |	plp
ECDE 68         002419 |	pla
ECDF A8         002420 |	tay
ECE0 68         002421 |	pla
ECE1 AA         002422 |	tax
ECE2 68         002423 |	pla
ECE3 60         002424 |	rts
                002425 |
                002426 |;****************************************************************************
                002427 |;                       Search Command Subroutine.
                002428 |;****************************************************************************
ECE4            002429 |Search *
ECE4 AD 5F 00   002430 |	lda OpFld1	;Check for operands.
ECE7 C9 00      002431 |	cmp #0d		;
ECE9 F0 07      002432 |	beq SOut	;
                002433 |
ECEB A2 00      002434 |	ldx #0d		;Get start address.
ECED 20 C3 F2   002435 |	jsr GetAdd	;
ECF0 B0 03      002436 |	bcs SAdd1ok	;
ECF2            002437 |SOut *			;
ECF2 4C 74 ED   002438 |	jmp ExitSrch	;
ECF5            002439 |SAdd1ok	*		;
ECF5 8E 0A 00   002440 |	stx PointerB	;
ECF8 8C 0B 00   002441 |	sty PointerB+1d	;
                002442 |	
ECFB A2 14      002443 |	ldx #20d	;Get end address and increment by 1.
ECFD 20 C3 F2   002444 |	jsr GetAdd	;
ED00 B0 03      002445 |	bcs SAdd2ok	;
ED02 4C 74 ED   002446 |	jmp ExitSrch	;
ED05            002447 |SAdd2ok *		;
ED05 8E 5C 00   002448 |	stx EndAdd	;
ED08 8C 5D 00   002449 |	sty EndAdd+1d	;
ED0B EE 5C 00   002450 |	inc EndAdd	;
ED0E D0 03      002451 |	bne SNOvFlo	;
ED10 EE 5D 00   002452 |	inc EndAdd+1d	;
                002453 |	
ED13            002454 |SNOvFlo	*		;
ED13 A2 28      002455 |	ldx #40d	;Get search list from operand field #3 and store
ED15 A9 20      002456 |	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
ED17 8D 08 00   002457 |	sta PointerA	; SrchBtCt.
ED1A A9 00      002458 |	lda #SrchTabl>	;
ED1C 8D 09 00   002459 |	sta PointerA+1d	;
ED1F 20 6B E8   002460 |	jsr GetList	;
ED22 90 50      002461 |	bcc ExitSrch	;
ED24 AD CF 00   002462 |	lda DataTemp	;
ED27 8D 2A 00   002463 |	sta SrchBtCt	;
                002464 |	
ED2A AD 0A 00   002465 |	lda PointerB	;Transfer start address from pointer A to 
ED2D 8D 08 00   002466 |	sta PointerA	; pointer B.  Output a CRLF.
ED30 AD 0B 00   002467 |	lda PointerB+1d	;
ED33 8D 09 00   002468 |	sta PointerA+1d	;
ED36 A2 A5      002469 |	ldx #CRLF<	;
ED38 A0 F4      002470 |	ldy #CRLF>	;
ED3A 20 92 F3   002471 |	jsr PrntMess	;
                002472 |	
ED3D            002473 |SCkByte1 *		;Compare list with memory.
ED3D A2 00      002474 |	ldx #0d		;
ED3F A0 00      002475 |	ldy #0d		;
ED41            002476 |SCkByte2 *		;
ED41 B1 08      002477 |	lda (PointerA),y;
ED43 DD 20 00   002478 |	cmp SrchTabl,x	;
ED46 F0 19      002479 |	beq SMatch	;
                002480 |	
ED48            002481 |IncScPtr *
ED48 20 BA F2   002482 |	jsr IncPntrA	;Increment memory pointer and check to see if
ED4B AD 08 00   002483 |	lda PointerA	; the end address has been reached.
ED4E CD 5C 00   002484 |	cmp EndAdd	;
ED51 F0 03      002485 |	beq SckMSB	;
ED53 4C 3D ED   002486 |	jmp SCkByte1	;
ED56            002487 |SCkMSB *		;
ED56 AD 09 00   002488 |	lda PointerA+1d	;
ED59 CD 5D 00   002489 |	cmp EndAdd+1d	;
ED5C F0 16      002490 |	beq ExitSrch	;
ED5E 4C 3D ED   002491 |	jmp SCkByte1	;
                002492 |	
ED61            002493 |SMatch *		;
ED61 C8         002494 |	iny		;Check to see if all bytes in search list match
ED62 E8         002495 |	inx		; bytes in memory.
ED63 EC 2A 00   002496 |	cpx SrchBtCt	;
ED66 F0 03      002497 |	beq SFulMtch	;
ED68 4C 41 ED   002498 |	jmp SCkByte2	;
                002499 |
ED6B            002500 |SFulMtch *		;
ED6B 20 05 F3   002501 |	jsr PrntAdd	;Output address where match was found.
ED6E 20 BA F2   002502 |	jsr IncPntrA	;
ED71 4C 3D ED   002503 |	jmp SCkByte1	;
                002504 |
ED74            002505 |ExitSrch *
ED74 60         002506 |	rts
                002507 |
                002508 |
                002509 |
                002510 |;****************************************************************************
                002511 |;                       Trace Command Subroutine.
                002512 |;****************************************************************************
ED75            002513 |Trace *
                002514 |
ED75 AD 5F 00   002515 |	lda OpFld1	;Check for operands.
ED78 C9 00      002516 |	cmp #0d		;
ED7A F0 17      002517 |	beq TNoOper	;
                002518 |	
ED7C A2 00      002519 |	ldx #0d		;Get start address.
ED7E 20 C3 F2   002520 |	jsr GetAdd	;
ED81 B0 03      002521 |	bcs TAdd1ok	;
ED83 4C 7C EF   002522 |	jmp ErrTrce	;
ED86            002523 |TAdd1ok *		;
ED86 8E 45 00   002524 |	stx UPgmCntr	;
ED89 8C 46 00   002525 |	sty UPgmCntr+1d	;
                002526 |	
ED8C AD 73 00   002527 |	lda OpFld2	;Check to see if a trace count has been 
ED8F C9 00      002528 |	cmp #0d		; specified.
ED91 D0 08      002529 |	bne GtTrcCnt	;
                002530 |
ED93            002531 |TNoOper *
ED93 A0 01      002532 |	ldy #1d		;Set trace count to 1.
ED95 8C 3E 00   002533 |	sty TracCnt	;
ED98 4C A8 ED   002534 |	jmp StartTrc	;
                002535 |
ED9B            002536 |GtTrcCnt *	
ED9B A2 14      002537 |	ldx #20d	;Get trace count from user.
ED9D 20 1C F3   002538 |	jsr AsToBin	;
EDA0 B0 03      002539 |	bcs TrValOK	;
EDA2 4C 7C EF   002540 |	jmp ErrTrce	;
EDA5            002541 |TrValOK *		;
EDA5 8D 3E 00   002542 |	sta TracCnt	;
                002543 |	
EDA8            002544 |StartTrc *
EDA8 68         002545 |	pla		;Remove trace command's return address and
EDA9 68         002546 |	pla		; the check command routine's return address from
EDAA 68         002547 |	pla		; the stack.
EDAB 68         002548 |	pla		;
                002549 |
EDAC            002550 |ContTrc *	
EDAC AC 45 00   002551 |	ldy UPgmCntr	;Transfer user's program counter to pointer A.
EDAF 8C 08 00   002552 |	sty PointerA	;
EDB2 AC 46 00   002553 |	ldy UPgmCntr+1d	;
EDB5 8C 09 00   002554 |	sty PointerA+1d	;
                002555 |
EDB8 A0 00      002556 |	ldy #0d		;Get opcode of current instruction.
EDBA B1 08      002557 |	lda (PointerA),y;
EDBC 8D 43 00   002558 |	sta OpCdHold	;
                002559 |	
EDBF 20 80 EF   002560 |	jsr ScanOpCd	;Check to see if byte from memory location was
EDC2 B0 03      002561 |	bcs TOpCdFnd	; an opcode.
EDC4 4C 7C EF   002562 |	jmp ErrTrce
                002563 |
EDC7            002564 |TOpCdFnd *
EDC7 A0 08      002565 |	ldy #8d		;Get number of bytes in the current instruction
EDC9 B1 0A      002566 |	lda (PointerB),y; information from opcode table.
EDCB 8D 3A 00   002567 |	sta CurInsLn	;
                002568 |	
EDCE A0 01      002569 |	ldy #1d		;Get opcode of current instruction.
EDD0 AD 43 00   002570 |	lda OpCdHold	;
                002571 |
EDD3            002572 |TrRTS *			;If the opcode is an RTS then copy the return
EDD3 C9 60      002573 |	cmp #60h	; address from the stack, save the opcode to
EDD5 D0 28      002574 |	bne TNxtOp0	; be returned to, and place a BRK at the return
EDD7 A9 02      002575 |	lda #2d		; address.
EDD9 8D 3D 00   002576 |	sta BrnchFlg	;
EDDC 68         002577 |	pla		;
EDDD 8D 10 00   002578 |	sta BOpAdPtr	;
EDE0 68         002579 |	pla		;
EDE1 8D 11 00   002580 |	sta BOpAdPtr+1d	;
EDE4 48         002581 |	pha		;
EDE5 AD 10 00   002582 |	lda BOpAdPtr	;
EDE8 48         002583 |	pha		;
EDE9 EE 10 00   002584 |	inc BOpAdPtr	;
EDEC D0 03      002585 |	bne NNOvflo	;
EDEE EE 11 00   002586 |	inc BOpAdPtr+1d	;
EDF1            002587 |NNOvflo *		;
EDF1 A0 00      002588 |	ldy #0d		;
EDF3 B1 10      002589 |	lda (BOpAdPtr),y;
EDF5 8D 3C 00   002590 |	sta BOpCdHld	;
EDF8 A9 00      002591 |	lda #0d		;
EDFA 91 10      002592 |	sta (BOpAdPtr),y;
EDFC 4C 0B EF   002593 |	jmp ChBkVect	;
                002594 |	
EDFF            002595 |TNxtOp0 *		;
EDFF C9 4C      002596 |	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
EE01 D0 1E      002597 |	bne TNxtOp1	; then save the opcode of the instruction that
EE03 A9 02      002598 |	lda #2d		; will be jumped to and replace it with a BRK.
EE05 8D 3D 00   002599 |	sta BrnchFlg	;
EE08 B1 08      002600 |	lda (PointerA),y;
EE0A 8D 10 00   002601 |	sta BOpAdPtr	;
EE0D C8         002602 |	iny		;
EE0E B1 08      002603 |	lda (PointerA),y;
EE10 8D 11 00   002604 |	sta BOpAdPtr+1d	;
EE13 A0 00      002605 |	ldy #0d		;
EE15 B1 10      002606 |	lda (BOpAdPtr),y;
EE17 8D 3C 00   002607 |	sta BOpCdHld	;
EE1A A9 00      002608 |	lda #0d		;
EE1C 91 10      002609 |	sta (BOpAdPtr),y;
EE1E 4C 0B EF   002610 |	jmp ChBkVect	;
                002611 |	
EE21            002612 |TNxtOp1 *
EE21 C9 6C      002613 |	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
EE23 D0 2B      002614 |	bne TNxtOp2	; then save the opcode of the instruction that
EE25 A9 02      002615 |	lda #2d		; will be jumped to and replace it with a BRK.
EE27 8D 3D 00   002616 |	sta BrnchFlg	;
EE2A B1 08      002617 |	lda (PointerA),y;
EE2C 8D 0C 00   002618 |	sta PointerC	;
EE2F C8         002619 |	iny		;
EE30 B1 08      002620 |	lda (PointerA),y;
EE32 8D 0D 00   002621 |	sta PointerC+1d	;
EE35 A0 00      002622 |	ldy #0d		;
EE37 B1 0C      002623 |	lda (PointerC),y;
EE39 8D 10 00   002624 |	sta BOpAdPtr	;
EE3C C8         002625 |	iny		;
EE3D B1 0C      002626 |	lda (PointerC),y;
EE3F 8D 11 00   002627 |	sta BOpAdPtr+1d	;
EE42 A0 00      002628 |	ldy #0d		;
EE44 B1 10      002629 |	lda (BOpAdPtr),y;
EE46 8D 3C 00   002630 |	sta BOpCdHld	;
EE49 A9 00      002631 |	lda #0d		;
EE4B 91 10      002632 |	sta (BOpAdPtr),y;
EE4D 4C 0B EF   002633 |	jmp ChBkVect	;
                002634 |		
                002635 |	
EE50            002636 |TNxtOp2 *
EE50 C9 20      002637 |	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
EE52 D0 1E      002638 |	bne TNxtOp3	; then save the opcode of the instruction that
EE54 A9 02      002639 |	lda #2d		; will be jumped to and replace it with a BRK.
EE56 8D 3D 00   002640 |	sta BrnchFlg	;
EE59 B1 08      002641 |	lda (PointerA),y;
EE5B 8D 10 00   002642 |	sta BOpAdPtr	;
EE5E C8         002643 |	iny		;
EE5F B1 08      002644 |	lda (PointerA),y;
EE61 8D 11 00   002645 |	sta BOpAdPtr+1d	;
EE64 A0 00      002646 |	ldy #0d		;
EE66 B1 10      002647 |	lda (BOpAdPtr),y;
EE68 8D 3C 00   002648 |	sta BOpCdHld	;
EE6B A9 00      002649 |	lda #0d		;
EE6D 91 10      002650 |	sta (BOpAdPtr),y;
EE6F 4C 0B EF   002651 |	jmp ChBkVect	;
                002652 |	
EE72            002653 |TNxtOp3 *
EE72 A0 00      002654 |	ldy #0d		;Check to see if the current instruction is an
EE74 B1 0A      002655 |	lda (PointerB),y; actual branch.
EE76 C9 42      002656 |	cmp #'B'	;
EE78 D0 08      002657 |	bne NoBrnch2	;
EE7A A0 01      002658 |	ldy #1d		;
EE7C B1 0A      002659 |	lda (PointerB),y;
EE7E C9 49      002660 |	cmp #'I'	;
EE80 D0 03      002661 |	bne Branch	;
EE82            002662 |NoBrnch2 *		;
EE82 4C E8 EE   002663 |	jmp NoBranch	;
                002664 |	
EE85            002665 |Branch *		;If the opcode is a branch, Bxx aaaa,
EE85 A9 01      002666 |	lda #1d		; then save the opcode of the instruction that
EE87 8D 3D 00   002667 |	sta BrnchFlg	; will be branched to and replace it with a BRK.
EE8A 18         002668 |	clc		;
EE8B AD 08 00   002669 |	lda PointerA	;
EE8E 6D 3A 00   002670 |	adc CurInsLn	;
EE91 8D 10 00   002671 |	sta BOpAdPtr	;
EE94 AD 09 00   002672 |	lda PointerA+1d	;
EE97 69 00      002673 |	adc #0d		;
EE99 8D 11 00   002674 |	sta BOpAdPtr+1d	;
                002675 |			;
EE9C A0 01      002676 |	ldy #1d		;
EE9E B1 08      002677 |	lda (PointerA),y;
EEA0 8D 38 00   002678 |	sta BrValHld	;
EEA3 10 20      002679 |	bpl AddAdd	;
EEA5            002680 |SubAdd *		;
EEA5 CE 38 00   002681 |	dec BrValHld	;
EEA8 AD 38 00   002682 |	lda BrValHld	;
EEAB 49 FF      002683 |	eor #0ffh	;
EEAD 8D 38 00   002684 |	sta BrValHld	;
EEB0 38         002685 |	sec		;
EEB1 AD 10 00   002686 |	lda BOpAdPtr	;
EEB4 ED 38 00   002687 |	sbc BrValHld	;
EEB7 8D 10 00   002688 |	sta BOpAdPtr	;
EEBA AD 11 00   002689 |	lda BOpAdPtr+1d	;
EEBD E9 00      002690 |	sbc #0d		;
EEBF 8D 11 00   002691 |	sta BOpAdPtr+1d	;
EEC2 4C DA EE   002692 |	jmp GtBrOpCd	;
EEC5            002693 |AddAdd *		;
EEC5 18         002694 |	clc		;
EEC6 AD 10 00   002695 |	lda BOpAdPtr	;
EEC9 6D 38 00   002696 |	adc BrValHld	;
EECC 8D 10 00   002697 |	sta BOpAdPtr	;
EECF AD 11 00   002698 |	lda BOpAdPtr+1d	;
EED2 69 00      002699 |	adc #0d		;
EED4 8D 11 00   002700 |	sta BOpAdPtr+1d	;
EED7 4C DA EE   002701 |	jmp GtBrOpCd	;
EEDA            002702 |GtBrOpCd *		;
EEDA A0 00      002703 |	ldy #0d		;
EEDC B1 10      002704 |	lda (BOpAdPtr),y;
EEDE 8D 3C 00   002705 |	sta BOpCdHld	;
EEE1 A9 00      002706 |	lda #0d		;
EEE3 91 10      002707 |	sta (BOpAdPtr),y;
EEE5 4C ED EE   002708 |	jmp Both	;
                002709 |	
EEE8            002710 |NoBranch *
EEE8 A9 00      002711 |	lda #0d		;Set branch flag to 0 to indicate the current
EEEA 8D 3D 00   002712 |	sta BrnchFlg	; instruction is not a branch instruction.
                002713 |
EEED            002714 |Both *
EEED AC 3A 00   002715 |	ldy CurInsLn	;
EEF0 B1 08      002716 |	lda (PointerA),y;Save the opcode of the next instruction to be
EEF2 8D 3B 00   002717 |	sta NOpCdHld	; executed if no branch is taken and replace it
                002718 |			; with a BRK command.
EEF5 18         002719 |	clc		;
EEF6 AD 08 00   002720 |	lda PointerA	;
EEF9 6D 3A 00   002721 |	adc CurInsLn	;
EEFC 8D 0E 00   002722 |	sta NOpAdPtr	;
EEFF AD 09 00   002723 |	lda PointerA+1d	;
EF02 69 00      002724 |	adc #0d		;
EF04 8D 0F 00   002725 |	sta NOpAdPtr+1d	;
EF07 A9 00      002726 |	lda #0d		;
EF09 91 08      002727 |	sta (PointerA),y;
                002728 |	
EF0B            002729 |ChBkVect *
EF0B A9 01      002730 |	lda #1d		    ;Make BRK jump here instead of main.
EF0D 8D 39 00   002731 |	sta TrBrkFlg	;
                002732 |	
EF10 AD 5F 00   002733 |    lda OpFld1	;Check to see if user entered address.
EF13 C9 00      002734 |	cmp #0d		;
EF15 F0 03      002735 |	beq DoNotRestoreStackPointer
EF17 A2 FF      002736 |    ldx #0ffh    
EF19 9A         002737 |    txs          ;
EF1A            002738 |DoNotRestoreStackPointer *
                002739 |
EF1A AD 4B 00   002740 |	lda UStatReg	;Restore user's registers.
EF1D 48         002741 |	pha		        ;
EF1E AD 47 00   002742 |	lda UAccum	    ;
EF21 AE 48 00   002743 |	ldx UXreg	    ;
EF24 AC 49 00   002744 |	ldy UYReg	    ;
EF27 28         002745 |	plp		        ;
                002746 |    
EF28 6C 45 00   002747 |	jmp (UPgmCntr)	;Jump to user's code.
                002748 |	
EF2B            002749 |Tr2ndEnt *
EF2B A9 00      002750 |	lda #0d		;Reset trace break flag.
EF2D 8D 39 00   002751 |	sta TrBrkFlg	;
                002752 |	
EF30            002753 |CkBrnch *		;
EF30 A0 00      002754 |	ldy #0d		;Check to see which opcodes need to be restored.
EF32 AD 3D 00   002755 |	lda BrnchFlg	;
EF35 C9 00      002756 |	cmp #0d		;
EF37 F0 11      002757 |	beq NoBrnch	;
EF39 C9 01      002758 |	cmp #1d		;
EF3B F0 08      002759 |	beq Brnch	;
                002760 |	
EF3D            002761 |DoJmp *
EF3D AD 3C 00   002762 |	lda BOpCdHld	;Restore opcode to be jumped to.
EF40 91 10      002763 |	sta (BOpAdPtr),y;
EF42 4C 4F EF   002764 |	jmp UpDtPtrA	;
                002765 |
EF45            002766 |Brnch *
EF45 AD 3C 00   002767 |	lda BOpCdHld	;Restore opcode to be branched to.
EF48 91 10      002768 |	sta (BOpAdPtr),y;
                002769 |	
EF4A            002770 |NoBrnch *
EF4A AD 3B 00   002771 |	lda NOpCdHld	;Restore opcode that will be executed next in
EF4D 91 0E      002772 |	sta (NOpAdPtr),y; the instruction stream.
                002773 |
EF4F            002774 |UpDtPtrA *
EF4F AC 45 00   002775 |	ldy UPgmCntr	;Set pointer A to point to the next instruction
EF52 8C 08 00   002776 |	sty PointerA	; to be executed for unassemble.
EF55 AC 46 00   002777 |	ldy UPgmCntr+1d	;
EF58 8C 09 00   002778 |	sty PointerA+1d	;
                002779 |	
EF5B A2 A5      002780 |	ldx #CRLF<	;Unassemble next instruction in memory.
EF5D A0 F4      002781 |	ldy #CRLF>	;
EF5F 20 92 F3   002782 |	jsr PrntMess	;
EF62 AD 08 00   002783 |	lda PointerA	;
EF65 8D 5C 00   002784 |	sta EndAdd	;
EF68 AD 09 00   002785 |	lda PointerA+1d	;
EF6B 8D 5D 00   002786 |	sta EndAdd+1d	;
EF6E 20 FF EF   002787 |	jsr StartUnA	;
                002788 |	
EF71            002789 |NxtIn *
EF71 CE 3E 00   002790 |	dec TracCnt	;Decrement trace count and trace again if it
EF74 F0 03      002791 |	beq OutTrce	; is not zero.
EF76 4C AC ED   002792 |	jmp ContTrc	;
                002793 |
EF79            002794 |OutTrce *
EF79 4C 74 E0   002795 |	jmp MainLoop	;Enter the main monitor loop using a jump
                002796 |			; because the trace command's return address
                002797 |			; and the check command routine's return address
                002798 |			; were removed when a trace was initiated.
EF7C            002799 |ErrTrce *
EF7C 18         002800 |	clc
EF7D 60         002801 |	rts	
                002802 |
EF7E            002803 |ExitTrce *
EF7E 38         002804 |	sec
EF7F 60         002805 |	rts	
                002806 |
                002807 |;****************************************************************************
                002808 |;                       Scan for Valid Opcode Subroutine.
                002809 |;****************************************************************************
EF80            002810 |ScanOpCd *
                002811 |	
EF80 A2 22      002812 |	ldx #OpTable<	;Point pointer B to beginning of opcode table.
EF82 8E 0A 00   002813 |	stx PointerB	;
EF85 A2 F8      002814 |	ldx #OpTable>	;
EF87 8E 0B 00   002815 |	stx PointerB+1d	;
                002816 |	
EF8A            002817 |CkTblEnd *
EF8A A0 04      002818 |	ldy #4d		;Check for end of opcode table.
EF8C B1 0A      002819 |	lda (PointerB),y;
EF8E C9 5A      002820 |	cmp #90d	;
EF90 F0 1C      002821 |	beq OpCdNtFd	;
                002822 |	
EF92            002823 |CkNxtOp *		;
EF92 A0 07      002824 |	ldy #7d		;Check for an opcode match in the opcode table.
EF94 B1 0A      002825 |	lda (PointerB),y;
EF96 CD 43 00   002826 |	cmp OpCdHold	;
EF99 F0 11      002827 |	beq OpCdFndS	;
                002828 |	
EF9B AD 0A 00   002829 |	lda PointerB	;Point pointer B to next entry in opcode table.
EF9E 18         002830 |	clc		;
EF9F 69 0A      002831 |	adc #10d	;
EFA1 8D 0A 00   002832 |	sta PointerB	;
EFA4 90 03      002833 |	bcc ScNoCary	;
EFA6 EE 0B 00   002834 |	inc PointerB+1d	;
                002835 |		
EFA9            002836 |ScNoCary *
EFA9 4C 8A EF   002837 |	jmp CkTblEnd
                002838 |	
                002839 |	
EFAC            002840 |OpCdFndS *
EFAC 38         002841 |	sec
EFAD 60         002842 |	rts
                002843 |	
EFAE            002844 |OpCdNtFd *
EFAE 18         002845 |	clc
EFAF 60         002846 |	rts
                002847 |	
                002848 |;****************************************************************************
                002849 |;                       Unassemble Command Subroutine.
                002850 |;****************************************************************************
EFB0            002851 |UnAssem *
EFB0 AD 5F 00   002852 |	lda OpFld1	;Check for operands.
EFB3 C9 00      002853 |	cmp #0d		;
EFB5 F0 17      002854 |	beq UNoOper	;
                002855 |
EFB7 A2 00      002856 |	ldx #0d		;Get start address.
EFB9 20 C3 F2   002857 |	jsr GetAdd	;
EFBC B0 03      002858 |	bcs UAdd1ok	;
EFBE 4C A4 F2   002859 |	jmp ErrUnAs	;
EFC1            002860 |UAdd1ok *		;
EFC1 8E 08 00   002861 |	stx PointerA	;
EFC4 8C 09 00   002862 |	sty PointerA+1d	;
                002863 |	
EFC7 AD 73 00   002864 |	lda OpFld2	;Check to see if an end address has been 
EFCA C9 00      002865 |	cmp #0d		; specified.
EFCC D0 21      002866 |	bne GtUEndAd	;
                002867 |	
EFCE            002868 |UNoOper *
EFCE AD 08 00   002869 |	lda PointerA	;
EFD1 8D 5C 00   002870 |	sta EndAdd	;
EFD4 AD 09 00   002871 |	lda PointerA+1d	;
EFD7 8D 5D 00   002872 |	sta EndAdd+1d	;
EFDA 18         002873 |	clc		;If no end address has been specified by the
EFDB AD 08 00   002874 |	lda PointerA	; user then set the end address to start address
EFDE 69 14      002875 |	adc #20d	; + 20d.
EFE0 8D 5C 00   002876 |	sta EndAdd	;
EFE3 90 07      002877 |	bcc UNoCary	;
EFE5 AE 5D 00   002878 |	ldx EndAdd+1d	;
EFE8 E8         002879 |	inx		;
EFE9 8E 5D 00   002880 |	stx EndAdd+1d	;
EFEC            002881 |UNoCary *		;
EFEC 4C FF EF   002882 |	jmp StartUnA	;
                002883 |	
EFEF            002884 |GtUEndAd *
EFEF A2 14      002885 |	ldx #20d	;Get end address.
EFF1 20 C3 F2   002886 |	jsr GetAdd	;
EFF4 B0 03      002887 |	bcs UAdd2ok	;
EFF6 4C A4 F2   002888 |	jmp ErrUnAs	;
EFF9            002889 |UAdd2ok *		;
EFF9 8E 5C 00   002890 |	stx EndAdd	;
EFFC 8C 5D 00   002891 |	sty EndAdd+1d	;
                002892 |	
EFFF            002893 |StartUnA *
EFFF AD 5D 00   002894 |	lda EndAdd+1d	;Check to see if end address has been reached.
F002 CD 09 00   002895 |	cmp PointerA+1d	;
F005 F0 05      002896 |	beq UChkFLSB	;
F007 90 0E      002897 |	bcc UOut	;
F009 4C 1A F0   002898 |	jmp UNotFin 	;
F00C            002899 |UChkFLSB *
F00C AD 5C 00   002900 |	lda EndAdd	; 
F00F CD 08 00   002901 |	cmp PointerA	;
F012 90 03      002902 |	bcc UOut	;
F014 4C 1A F0   002903 |	jmp UNotFin	;
F017            002904 |UOut *			;
F017 4C A6 F2   002905 |	jmp ExitUnAs	;
                002906 |
F01A            002907 |UNotFin *		;
F01A A0 00      002908 |	ldy #0d		;Get opcode byte from memory and save.
F01C B1 08      002909 |	lda (PointerA),y;
F01E 8D 43 00   002910 |	sta OpCdHold	;
F021 20 80 EF   002911 |	jsr ScanOpCd	;Check to see if byte from memory location was
F024 B0 1D      002912 |	bcs OpCdFnd	; an opcode.
                002913 |
F026            002914 |NtOpCode *
F026 A2 A5      002915 |	ldx #CRLF<	;Print start address of current instruction.
F028 A0 F4      002916 |	ldy #CRLF>	;
F02A 20 92 F3   002917 |	jsr PrntMess	;
F02D 20 05 F3   002918 |	jsr PrntAdd	;
                002919 |
F030 AD 43 00   002920 |	lda OpCdHold	;Print the bad opcode.
F033 20 3E F3   002921 |	jsr OutHex	;
                002922 |	
F036 A2 7E      002923 |	ldx #BadOpMes<	;If byte was not an opcode then print question
F038 A0 F5      002924 |	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
F03A 20 92 F3   002925 |	jsr PrntMess	;
F03D 20 BA F2   002926 |	jsr IncPntrA	;
F040 4C FF EF   002927 |	jmp StartUnA	;
                002928 |
F043            002929 |OpCdFnd *
F043 A2 A5      002930 |	ldx #CRLF<	;Print start address of current instruction.
F045 A0 F4      002931 |	ldy #CRLF>	;
F047 20 92 F3   002932 |	jsr PrntMess	;
F04A 20 05 F3   002933 |	jsr PrntAdd	;
F04D 20 BA F2   002934 |	jsr IncPntrA	;
                002935 |
F050            002936 |CkAdMode *
F050 A0 06      002937 |	ldy #6d		;Get addressing mode indicator from table.
F052 B1 0A      002938 |	lda (PointerB),y;
                002939 |	
F054            002940 |NxAdMo1 *		;
F054 C9 50      002941 |	cmp #'P'	;Check for implied addressing mode.
F056 D0 03      002942 |	bne NxAdMo2	;
F058 4C 9D F0   002943 |	jmp ImpAdMo	;
                002944 |	
F05B            002945 |NxAdMo2 *		;
F05B C9 4D      002946 |	cmp #'M'	;Check for immediate addressing mode.
F05D D0 03      002947 |	bne NxAdMo3	;
F05F 4C C4 F0   002948 |	jmp ImmAdMo	;	
                002949 |
F062            002950 |NxAdMo3 *		;
F062 C9 53      002951 |	cmp #'S'	;Check for absolute addressing mode.
F064 D0 03      002952 |	bne NxAdMo4	;
F066 4C F7 F0   002953 |	jmp AbsxyAdM	;	
                002954 |
F069            002955 |NxAdMo4 *		;
F069 C9 58      002956 |	cmp #'X'	;Check for absolute x addressing mode.
F06B D0 03      002957 |	bne NxAdMo5	;
F06D 4C F7 F0   002958 |	jmp AbsxyAdM	;
                002959 |
F070            002960 |NxAdMo5 *		;
F070 C9 59      002961 |	cmp #'Y'	;Check for absolute y addressing mode.
F072 D0 03      002962 |	bne NxAdMo6	;
F074 4C F7 F0   002963 |	jmp AbsxyAdM	;
                002964 |
F077            002965 |NxAdMo6 *		;
F077 C9 52      002966 |	cmp #'R'	;Check for indexed indirect addressing mode.
F079 D0 03      002967 |	bne NxAdMo7	;
F07B 4C 14 F2   002968 |	jmp IIRAdMo	;
                002969 |
F07E            002970 |NxAdMo7 *		;
F07E C9 4C      002971 |	cmp #'L'	;Check for relative addressing mode.
F080 D0 03      002972 |	bne NxAdMo8 	;
F082 4C 61 F1   002973 |	jmp RelAdMo	;
                002974 |
F085            002975 |NxAdMo8 *		;
F085 C9 43      002976 |	cmp #'C'	;Check for accumulator addressing mode.
F087 D0 03      002977 |	bne NxAdMo9 	;
F089 4C AE F0   002978 |	jmp AccAdMo	;
                002979 |
F08C            002980 |NxAdMo9 *		;
F08C C9 44      002981 |	cmp #'D'	;Check for indirect addressing mode.
F08E D0 03      002982 |	bne NxAdMo10 	;
F090 4C 56 F2   002983 |	jmp IndAdMo	;
                002984 |
F093            002985 |NxAdMo10 *
F093 C9 49      002986 |	cmp #'I'	;Check for indirect indexed addressing mode.
F095 D0 03      002987 |	bne BdOpCd	;
F097 4C D2 F1   002988 |	jmp IRIAdMo	;
                002989 |
F09A            002990 |BdOpCd *		;
F09A 4C 26 F0   002991 |	jmp NtOpCode	;
                002992 |
                002993 |
F09D            002994 |ImpAdMo *
F09D AD 43 00   002995 |	lda OpCdHold	;Print the opcode.
F0A0 20 3E F3   002996 |	jsr OutHex	;
                002997 |	
F0A3 A0 08      002998 |	ldy #8d		;Print spaces between object code field and
F0A5 20 E2 F2   002999 |	jsr OutSpace	; operator field.
                003000 |		
F0A8 20 A8 F2   003001 |	jsr PrntMnem	;Print the operator.
                003002 |	
F0AB 4C FF EF   003003 |	jmp StartUnA
                003004 |
F0AE            003005 |AccAdMo *
F0AE AD 43 00   003006 |	lda OpCdHold	;Print the opcode.
F0B1 20 3E F3   003007 |	jsr OutHex	;
                003008 |	
F0B4 A0 08      003009 |	ldy #8d		;Print spaces between object code field and
F0B6 20 E2 F2   003010 |	jsr OutSpace	; operator field.
                003011 |		
F0B9 20 A8 F2   003012 |	jsr PrntMnem	;Print the operator.
                003013 |	
F0BC A9 41      003014 |	lda #65d	;Print a capital A for accumulator addressing.
F0BE 20 F0 F3   003015 |	jsr OutChar	;
                003016 |	
F0C1 4C FF EF   003017 |	jmp StartUnA
                003018 |
                003019 |
F0C4            003020 |ImmAdMo *
F0C4 A0 00      003021 |	ldy #0d
                003022 |
F0C6 AD 43 00   003023 |	lda OpCdHold	;Print the opcode and a space.
F0C9 20 3E F3   003024 |	jsr OutHex	;
F0CC A9 20      003025 |	lda #32d	;
F0CE 20 F0 F3   003026 |	jsr OutChar	;
                003027 |	
F0D1 B1 08      003028 |	lda (PointerA),y;Print the second byte of the instruction and
F0D3 8D 41 00   003029 |	sta ObCdHld1	; increment the memory pointer.
F0D6 20 3E F3   003030 |	jsr OutHex	;
F0D9 20 BA F2   003031 |	jsr IncPntrA	;
                003032 |	
F0DC A0 05      003033 |	ldy #5d		;Print spaces between object code field and
F0DE 20 E2 F2   003034 |	jsr OutSpace	; operator field.
                003035 |	
F0E1 20 A8 F2   003036 |	jsr PrntMnem	;Print the operator.
                003037 |	
F0E4 A9 23      003038 |	lda #35d	;Print a pound sign.
F0E6 20 F0 F3   003039 |	jsr OutChar	;
                003040 |	
F0E9 AD 41 00   003041 |	lda ObCdHld1	;Print immediate operand value.
F0EC 20 3E F3   003042 |	jsr OutHex	;
                003043 |	
F0EF A9 68      003044 |	lda #104d	;Print lower case h to indicate hex number.
F0F1 20 F0 F3   003045 |	jsr OutChar	;
                003046 |	
F0F4 4C FF EF   003047 |	jmp StartUnA
                003048 |
                003049 |
F0F7            003050 |AbsxyAdM *
F0F7 A0 00      003051 |	ldy #0d
                003052 |
F0F9 AD 43 00   003053 |	lda OpCdHold	;Print the opcode and a space.
F0FC 20 3E F3   003054 |	jsr OutHex	;
F0FF A9 20      003055 |	lda #32d	;
F101 20 F0 F3   003056 |	jsr OutChar	;
                003057 |	
F104 B1 08      003058 |	lda (PointerA),y;Print the second byte of the instruction and
F106 8D 41 00   003059 |	sta ObCdHld1	; increment the memory pointer
F109 20 3E F3   003060 |	jsr OutHex	;
F10C 20 BA F2   003061 |	jsr IncPntrA	;
                003062 |	
F10F A9 20      003063 |	lda #32d	;Print a space between obj codes.
F111 20 F0 F3   003064 |	jsr OutChar	;
                003065 |	
F114 B1 08      003066 |	lda (PointerA),y;Print the third byte of the instruction and
F116 8D 42 00   003067 |	sta ObCdHld2	; increment the memory pointer
F119 20 3E F3   003068 |	jsr OutHex	;
F11C 20 BA F2   003069 |	jsr IncPntrA	;
                003070 |	
F11F A0 02      003071 |	ldy #2d		;Print spaces between object code field and
F121 20 E2 F2   003072 |	jsr OutSpace	; operator field.
                003073 |	
F124 20 A8 F2   003074 |	jsr PrntMnem	;Print the operator.
                003075 |
F127 AD 42 00   003076 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
F12A 20 3E F3   003077 |	jsr OutHex	;
F12D AD 41 00   003078 |	lda ObCdHld1	;
F130 20 3E F3   003079 |	jsr OutHex	;
                003080 |	
F133 A9 68      003081 |	lda #104d	;Print lower case h to indicate hex number.
F135 20 F0 F3   003082 |	jsr OutChar	;
                003083 |
F138 A0 06      003084 |	ldy #6d		;Check to see if address mode is abs, abx or
F13A B1 0A      003085 |	lda (PointerB),y; aby.
F13C C9 58      003086 |	cmp #'X'	;
F13E F0 07      003087 |	beq AbxAdMo	;
F140 C9 59      003088 |	cmp #'Y'	;
F142 F0 10      003089 |	beq AbyAdMo	;
                003090 |	
F144            003091 |AbsAM *
F144 4C FF EF   003092 |	jmp StartUnA
                003093 |
F147            003094 |AbxAdMo *
F147 A9 2C      003095 |	lda #44d	;Print comma and x.
F149 20 F0 F3   003096 |	jsr OutChar	;
F14C A9 58      003097 |	lda #88d	;
F14E 20 F0 F3   003098 |	jsr OutChar	;
                003099 |	
F151 4C FF EF   003100 |	jmp StartUna
                003101 |	
F154            003102 |AbyAdMo *
F154 A9 2C      003103 |	lda #44d	;Print comma and y.
F156 20 F0 F3   003104 |	jsr OutChar	;
F159 A9 59      003105 |	lda #89d	;
F15B 20 F0 F3   003106 |	jsr OutChar	;
                003107 |
F15E 4C FF EF   003108 |	jmp StartUnA
                003109 |
                003110 |
F161            003111 |RelAdMo *
F161 A0 00      003112 |	ldy #0d
                003113 |
F163 AD 43 00   003114 |	lda OpCdHold	;Print the opcode and a space.
F166 20 3E F3   003115 |	jsr OutHex	;
F169 A9 20      003116 |	lda #32d	;
F16B 20 F0 F3   003117 |	jsr OutChar	;
                003118 |	
F16E B1 08      003119 |	lda (PointerA),y;Print the second byte of the instruction and
F170 8D 41 00   003120 |	sta ObCdHld1	; increment the memory pointer.
F173 20 3E F3   003121 |	jsr OutHex	;
F176 20 BA F2   003122 |	jsr IncPntrA	;
                003123 |	
F179 A0 05      003124 |	ldy #5d		;Print spaces between object code field and
F17B 20 E2 F2   003125 |	jsr OutSpace	; operator field.
                003126 |	
F17E 20 A8 F2   003127 |	jsr PrntMnem	;Print the operator.
                003128 |
F181 AD 08 00   003129 |	lda PointerA	;Store a copy of the next instruction's start
F184 8D 3F 00   003130 |	sta AddHold	; address.
F187 AD 09 00   003131 |	lda PointerA+1d	;
F18A 8D 40 00   003132 |	sta AddHold+1d	;
                003133 |	
F18D AD 41 00   003134 |	lda ObCdHld1	;Check to see if branch is positive or negative.
F190 30 12      003135 |	bmi NegBrnch	;
                003136 |	
F192            003137 |PosBrnch *		;If branch is positive then find address being
F192 AD 3F 00   003138 |	lda AddHold	; branched to by adding offset to start address
F195 18         003139 |	clc		; of next instruction in memory.
F196 6D 41 00   003140 |	adc ObCdHld1	;
F199 8D 3F 00   003141 |	sta AddHold	;
F19C 90 20      003142 |	bcc OutBrAdd	;
F19E EE 40 00   003143 |	inc AddHold+1d	;
F1A1 4C BE F1   003144 |	jmp OutBrAdd	;
                003145 |		
F1A4            003146 |NegBrnch *
F1A4 CE 41 00   003147 |	dec ObCdHld1	;If branch is negative then find address being
F1A7 AD 41 00   003148 |	lda ObCdHld1	; branched to by subtracting offset from start
F1AA 49 FF      003149 |	eor #0ffh	; address of next instruction in memory.
F1AC 8D 41 00   003150 |	sta ObCdHld1	;
F1AF AD 3F 00   003151 |	lda AddHold	;
F1B2 38         003152 |	sec		;
F1B3 ED 41 00   003153 |	sbc ObCdHld1	;
F1B6 8D 3F 00   003154 |	sta AddHold	;
F1B9 B0 03      003155 |	bcs OutBrAdd	;
F1BB CE 40 00   003156 |	dec AddHold+1d	;
                003157 |	
F1BE            003158 |OutBrAdd *
F1BE AD 40 00   003159 |	lda AddHold+1d	;Print address being branched to.
F1C1 20 3E F3   003160 |	jsr OutHex	;
F1C4 AD 3F 00   003161 |	lda AddHold	;
F1C7 20 3E F3   003162 |	jsr OutHex	;
                003163 |	
F1CA A9 68      003164 |	lda #104d	;Print lower case h to indicate hex number.
F1CC 20 F0 F3   003165 |	jsr OutChar	;
                003166 |
F1CF 4C FF EF   003167 |	jmp StartUnA
                003168 |
                003169 |
F1D2            003170 |IRIAdMo *
F1D2 A0 00      003171 |	ldy #0d
                003172 |
F1D4 AD 43 00   003173 |	lda OpCdHold	;Print the opcode and a space.
F1D7 20 3E F3   003174 |	jsr OutHex	;
F1DA A9 20      003175 |	lda #32d	;
F1DC 20 F0 F3   003176 |	jsr OutChar	;
                003177 |	
F1DF B1 08      003178 |	lda (PointerA),y;Print the second byte of the instruction and
F1E1 8D 41 00   003179 |	sta ObCdHld1	; increment the memory pointer.
F1E4 20 3E F3   003180 |	jsr OutHex	;
F1E7 20 BA F2   003181 |	jsr IncPntrA	;
                003182 |	
F1EA A0 05      003183 |	ldy #5d		;Print spaces between object code field and
F1EC 20 E2 F2   003184 |	jsr OutSpace	; operator field.
                003185 |	
F1EF 20 A8 F2   003186 |	jsr PrntMnem	;Print the operator.
                003187 |	
F1F2 A9 28      003188 |	lda #40d	;Print (.
F1F4 20 F0 F3   003189 |	jsr OutChar	;
                003190 |	
F1F7 AD 41 00   003191 |	lda ObCdHld1	;Print offset into zero page.
F1FA 20 3E F3   003192 |	jsr OutHex	;
                003193 |	
F1FD A9 68      003194 |	lda #104d	;Print lower case h to indicate hex.
F1FF 20 F0 F3   003195 |	jsr OutChar	;
                003196 |	
F202 A9 29      003197 |	lda #41d	;Print ).
F204 20 F0 F3   003198 |	jsr OutChar	;
                003199 |	
F207 A9 2C      003200 |	lda #44d	;Print comma and y.
F209 20 F0 F3   003201 |	jsr OutChar	;
F20C A9 59      003202 |	lda #89d	;
F20E 20 F0 F3   003203 |	jsr OutChar	;
                003204 |	
F211 4C FF EF   003205 |	jmp StartUnA
                003206 |	
F214            003207 |IIRAdMo *
F214 A0 00      003208 |	ldy #0d
                003209 |
F216 AD 43 00   003210 |	lda OpCdHold	;Print the opcode and a space.
F219 20 3E F3   003211 |	jsr OutHex	;
F21C A9 20      003212 |	lda #32d	;
F21E 20 F0 F3   003213 |	jsr OutChar	;
                003214 |	
F221 B1 08      003215 |	lda (PointerA),y;Print the second byte of the instruction and
F223 8D 41 00   003216 |	sta ObCdHld1	; increment the memory pointer.
F226 20 3E F3   003217 |	jsr OutHex	;
F229 20 BA F2   003218 |	jsr IncPntrA	;
                003219 |	
F22C A0 05      003220 |	ldy #5d		;Print spaces between object code field and
F22E 20 E2 F2   003221 |	jsr OutSpace	; operator field.
                003222 |	
F231 20 A8 F2   003223 |	jsr PrntMnem	;Print the operator.
                003224 |	
F234 A9 28      003225 |	lda #40d	;Print (.
F236 20 F0 F3   003226 |	jsr OutChar	;
                003227 |	
F239 AD 41 00   003228 |	lda ObCdHld1	;Print offset into zero page.
F23C 20 3E F3   003229 |	jsr OutHex	;
                003230 |	
F23F A9 68      003231 |	lda #104d	;Print lower case h to indicate hex.
F241 20 F0 F3   003232 |	jsr OutChar	;
                003233 |	
F244 A9 2C      003234 |	lda #44d	;Print comma and x.
F246 20 F0 F3   003235 |	jsr OutChar	;
F249 A9 58      003236 |	lda #88d	;
F24B 20 F0 F3   003237 |	jsr OutChar	;
                003238 |	
F24E A9 29      003239 |	lda #41d	;Print ).
F250 20 F0 F3   003240 |	jsr OutChar	;
                003241 |	
F253 4C FF EF   003242 |	jmp StartUnA
                003243 |
F256            003244 |IndAdMo *
F256 A0 00      003245 |	ldy #0d
                003246 |
F258 AD 43 00   003247 |	lda OpCdHold	;Print the opcode and a space.
F25B 20 3E F3   003248 |	jsr OutHex	;
F25E A9 20      003249 |	lda #32d	;
F260 20 F0 F3   003250 |	jsr OutChar	;
                003251 |	
F263 B1 08      003252 |	lda (PointerA),y;Print the second byte of the instruction and
F265 8D 41 00   003253 |	sta ObCdHld1	; increment the memory pointer
F268 20 3E F3   003254 |	jsr OutHex	;
F26B 20 BA F2   003255 |	jsr IncPntrA	;
                003256 |	
F26E A9 20      003257 |	lda #32d	;Print a space between obj codes.
F270 20 F0 F3   003258 |	jsr OutChar	;
                003259 |	
F273 B1 08      003260 |	lda (PointerA),y;Print the third byte of the instruction and
F275 8D 42 00   003261 |	sta ObCdHld2	; increment the memory pointer
F278 20 3E F3   003262 |	jsr OutHex	;
F27B 20 BA F2   003263 |	jsr IncPntrA	;
                003264 |	
F27E A0 02      003265 |	ldy #2d		;Print spaces between object code field and
F280 20 E2 F2   003266 |	jsr OutSpace	; operator field.
                003267 |	
F283 20 A8 F2   003268 |	jsr PrntMnem	;Print the operator.
                003269 |
F286 A9 28      003270 |	lda #40d	;Print (.
F288 20 F0 F3   003271 |	jsr OutChar	;
                003272 |	
F28B AD 42 00   003273 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
F28E 20 3E F3   003274 |	jsr OutHex	;
F291 AD 41 00   003275 |	lda ObCdHld1	;
F294 20 3E F3   003276 |	jsr OutHex	;
                003277 |	
F297 A9 68      003278 |	lda #104d	;Print lower case h to indicate hex number.
F299 20 F0 F3   003279 |	jsr OutChar	;
                003280 |	
F29C A9 29      003281 |	lda #41d	;Print ).
F29E 20 F0 F3   003282 |	jsr OutChar	;
                003283 |	
F2A1 4C FF EF   003284 |	jmp StartUnA
                003285 |	
F2A4            003286 |ErrUnAs *
F2A4 18         003287 |	clc
F2A5 60         003288 |	rts
                003289 |
F2A6            003290 |ExitUnAs *
F2A6 38         003291 |	sec
F2A7 60         003292 |	rts
                003293 |
                003294 |
                003295 |;****************************************************************************
                003296 |;                       Print Mnemonic Subroutine.
                003297 |;****************************************************************************
F2A8            003298 |PrntMnem *
                003299 |
F2A8 A0 00      003300 |	ldy #0d		;Use loop to print all three characters of
F2AA            003301 |PrntMore *
F2AA B1 0A      003302 |	lda (PointerB),y; mnemonic.
F2AC 20 F0 F3   003303 |	jsr OutChar	;
F2AF C8         003304 |	iny		;
F2B0 C0 03      003305 |	cpy #3d		;
F2B2 D0 F6      003306 |	bne PrntMore	;
                003307 |	
F2B4 A9 20      003308 |	lda #32d	;Print a space after the mnemonic.
F2B6 20 F0 F3   003309 |	jsr OutChar	;
                003310 |	
F2B9 60         003311 |	rts
                003312 |
                003313 |;****************************************************************************
                003314 |;                       Increment Pointer A Subroutine.
                003315 |;****************************************************************************
F2BA            003316 |IncPntrA *
F2BA EE 08 00   003317 |	inc PointerA
F2BD D0 03      003318 |	bne NoOvFl1
F2BF EE 09 00   003319 |	inc PointerA+1d
F2C2            003320 |NoOvFl1 *
F2C2 60         003321 |	rts
                003322 |
                003323 |
                003324 |
                003325 |;****************************************************************************
                003326 |;                        Get Address Subroutine
                003327 |;
                003328 |;	X returns LSB of address.  Y returns MSB of address.
                003329 |;****************************************************************************
F2C3            003330 |GetAdd *		;Convert address found in operand field #x
F2C3 20 1C F3   003331 |	jsr AsToBin	; into binary.
F2C6 B0 03      003332 |	bcs AdMSBOK	;
F2C8 4C D8 F2   003333 |	jmp ErrGtAd	;
F2CB            003334 |AdMSBOK *		;
F2CB A8         003335 |	tay		;
F2CC E8         003336 |	inx		;
F2CD 20 1C F3   003337 |	jsr AsToBin	;
F2D0 B0 03      003338 |	bcs AdLSBOK	;
F2D2 4C D8 F2   003339 |	jmp ErrGtAd	;
F2D5            003340 |AdLSBOK *		;
F2D5 AA         003341 |	tax
                003342 |
F2D6 38         003343 |	sec		;If conversion OK then set carry flag and
F2D7 60         003344 |	rts		; return.
                003345 |	
F2D8            003346 |ErrGtAd *		;
F2D8 18         003347 |	clc		;If error then clear carry and return.
F2D9 60         003348 |	rts		;
                003349 |
                003350 |
                003351 |;****************************************************************************
                003352 |;                     Output a Colon Prompt Subroutine.
                003353 |;****************************************************************************
F2DA            003354 |OutColn *
F2DA A2 79      003355 |	ldx #ColnPrmt<
F2DC A0 F5      003356 |	ldy #ColnPrmt>
F2DE 20 92 F3   003357 |	jsr PrntMess
F2E1 60         003358 |	rts
                003359 |
                003360 |;****************************************************************************
                003361 |;                     Out Spaces Subroutine
                003362 |;
                003363 |;       Enter with the Y register indicating the number of spaces to output.
                003364 |;****************************************************************************
F2E2            003365 |OutSpace *		;Output the number of spaces indicated by
F2E2 48         003366 |	pha		; the Y register.
F2E3            003367 |OtAnoSpc *
F2E3 A9 20      003368 |	lda #32d
F2E5 20 F0 F3   003369 |	jsr OutChar
F2E8 88         003370 |	dey
F2E9 D0 F8      003371 |	bne OtAnoSpc
F2EB 68         003372 |	pla
F2EC 60         003373 |	rts
                003374 |
                003375 |
                003376 |;****************************************************************************
                003377 |;              Covert ASCII character to lower case Subroutine.
                003378 |;****************************************************************************
F2ED            003379 |ToLower *
F2ED C9 41      003380 |	cmp #65d
F2EF 30 07      003381 |	bmi ExitToLo
F2F1 C9 5B      003382 |	cmp #91d
F2F3 10 03      003383 |	bpl ExitToLo
F2F5 18         003384 |	clc
F2F6 69 20      003385 |	adc #32d
F2F8            003386 |ExitTolo *
F2F8 60         003387 |	rts
                003388 |
                003389 |
                003390 |;****************************************************************************
                003391 |;              Covert ASCII character to upper case Subroutine.
                003392 |;****************************************************************************
F2F9            003393 |ToUpper *
F2F9 C9 61      003394 |	cmp #'a'
F2FB 30 07      003395 |	bmi ExitToUp
F2FD C9 7B      003396 |	cmp #123d
F2FF 10 03      003397 |	bpl ExitToUp
F301 38         003398 |	sec
F302 E9 20      003399 |	sbc #32d
F304            003400 |ExitToUp *
F304 60         003401 |	rts
                003402 |
                003403 |
                003404 |
                003405 |;****************************************************************************
                003406 |;                         Print address.
                003407 |;****************************************************************************
F305            003408 |PrntAdd *
F305 AD 09 00   003409 |	lda PointerA+1d	;
F308 20 3E F3   003410 |	jsr OutHex	;
F30B AD 08 00   003411 |	lda PointerA	;
F30E 20 3E F3   003412 |	jsr OutHex	;
F311 A9 20      003413 |	lda #32d	;
F313 20 F0 F3   003414 |	jsr OutChar	;
F316 A9 20      003415 |	lda #32d	;
F318 20 F0 F3   003416 |	jsr OutChar	;
                003417 |	
F31B 60         003418 |	rts
                003419 |
                003420 |;****************************************************************************
                003421 |;                         Ascii to Binary Subroutine.
                003422 |;****************************************************************************
F31C            003423 |AsToBin *		;X points to digits to be converted using
                003424 |			; OpFld1 as a base.
                003425 |
F31C BD 5F 00   003426 |	lda OpFld1,x	;Convert most significant digit to binary.
F31F 20 72 EA   003427 |	jsr DgtToBin	;
F322 90 19      003428 |	bcc ExtAs2Bn	;
F324 0A         003429 |	asl a		;
F325 0A         003430 |	asl a		;
F326 0A         003431 |	asl a		;
F327 0A         003432 |	asl a		;
F328 29 F0      003433 |	and #0f0h	;
F32A 8D 9C 00   003434 |	sta number	;
                003435 |	
F32D E8         003436 |	inx		;Convert least significant digit to binary.
F32E BD 5F 00   003437 |	lda OpFld1,x	;
F331 20 72 EA   003438 |	jsr DgtToBin	;
F334 90 07      003439 |	bcc ExtAs2Bn	;
F336 0D 9C 00   003440 |	ora number	;
                003441 |	
F339 8D 9C 00   003442 |	sta number	;Store full binary number in number.
F33C 38         003443 |	sec
F33D            003444 |ExtAs2Bn *
F33D 60         003445 |	rts
                003446 |	
                003447 |;****************************************************************************
                003448 |;                     Output a Hex byte to the serial port.
                003449 |;
                003450 |;            Enter with the number to be output in the A register.
                003451 |;****************************************************************************
F33E            003452 |OutHex *
F33E 8D 9C 00   003453 |	sta number
                003454 |	
F341 4A         003455 |	lsr a		;Output most significant digit of hex byte to
F342 4A         003456 |	lsr a		; serial port.
F343 4A         003457 |	lsr a		;
F344 4A         003458 |	lsr a		;
F345 29 0F      003459 |	and #0fh	;
F347 C9 0A      003460 |	cmp #0ah	;
F349 10 05      003461 |	bpl Letter1	;
F34B 09 30      003462 |	ora #30h	;
F34D 4C 55 F3   003463 |	jmp Print1st	;
F350            003464 |Letter1 *		;
F350 38         003465 |	sec
F351 E9 09      003466 |	sbc #9d		;
F353 09 40      003467 |	ora #40h
F355            003468 |Print1st *
F355 20 F0 F3   003469 |	jsr OutChar	;
                003470 |	
F358 AD 9C 00   003471 |	lda number	;Output least significant digit of hex byte to
F35B 29 0F      003472 |	and #0fh	; serial port.
F35D C9 0A      003473 |	cmp #0ah	;
F35F 10 05      003474 |	bpl Letter2	;
F361 09 30      003475 |	ora #30h	;
F363 4C 6B F3   003476 |	jmp Print2nd	;
F366            003477 |Letter2 *		;
F366 38         003478 |	sec
F367 E9 09      003479 |	sbc #9d		;
F369 09 40      003480 |	ora #40h	;
F36B            003481 |Print2nd *		;
F36B 20 F0 F3   003482 |	jsr OutChar	;
                003483 |	
F36E AD 9C 00   003484 |	lda number
F371 60         003485 |	rts
                003486 |	
                003487 |;****************************************************************************
                003488 |;                     Initialize Variables Subroutine
                003489 |;****************************************************************************
F372            003490 |InitVars *
                003491 |
                003492 |	;lda #1ah	;Initialize ACIA control register, 2400
                003493 |	;sta 6551CtR	; Baud.
                003494 |	
                003495 |	;lda #0bh	;Initialize ACIA command register.
                003496 |	;sta 6551CmR	;
                003497 |		
F372 A9 FD      003498 |	lda #BRK<	;Initialize BRK vector.
F374 8D 04 00   003499 |	sta BRKVect	;
F377 A9 E1      003500 |	lda #BRK>	;
F379 8D 05 00   003501 |	sta BRKVect+1d	;
                003502 |	
F37C A9 00      003503 |	lda #0d		;Initialize trace break flag.
F37E 8D 39 00   003504 |	sta TrBrkFlg	;
                003505 |	
F381 A9 00      003506 |	lda #0d		;Initialize break point status variables.
F383 8D 2F 00   003507 |	sta BrkPt1St	;
F386 8D 30 00   003508 |	sta BrkPt2St	;
F389 8D 31 00   003509 |	sta BrkPt3St	;
F38C 8D 32 00   003510 |	sta BrkPt4St	;
                003511 |	
F38F A9 00      003512 |	lda #0d		;Set the output port to all zeros (turn
                003513 |	;sta OutPort0	; off all of the LEDs).
                003514 |	
F391 60         003515 |	rts
                003516 |
                003517 |;****************************************************************************
                003518 |;                          Print Message Subroutine.
                003519 |;
                003520 |; X holds the message pointer's low byte (< means less than) and Y holds its 
                003521 |; high byte (> means greater than).  The message must have a NULL (0) after 
                003522 |; the last character in the  Message so the PrntMess subroutine knows when to 
                003523 |; stop printing.
                003524 |;****************************************************************************
F392            003525 |PrntMess *
F392 48         003526 |	pha
                003527 |	
F393 8E 06 00   003528 |	stx MessPtr	;Initialize pointer that will point to each
F396 8C 07 00   003529 |	sty MessPtr+1h	; character of message.
                003530 |	
F399 A0 00      003531 |	ldy #0h
                003532 |	
F39B            003533 |OutMess *		;
F39B B1 06      003534 |	lda (MessPtr),y	;Get a character from the message and if it is
F39D F0 0E      003535 |	beq ExitMess	; a NULL (0) then exit this subroutine.
                003536 |	
F39F 20 F0 F3   003537 |	jsr OutChar	;Output the character to the serial port.
                003538 |	
F3A2 EE 06 00   003539 |	inc MessPtr	;Increment the message pointer to point to the
F3A5 D0 03      003540 |	bne PrNoOvf	; next character in the message.
F3A7 EE 07 00   003541 |	inc MessPtr+1d	;
                003542 |	
F3AA            003543 |PrNoOvf *
F3AA 4C 9B F3   003544 |	jmp OutMess
                003545 |		
F3AD            003546 |ExitMess *
F3AD 68         003547 |	pla
                003548 |	
F3AE 60         003549 |	rts
                003550 |
                003551 |;****************************************************************************
                003552 |;           Get Character (Don't Wait) From Serial Channel Subroutine
                003553 |;****************************************************************************
F3AF            003554 |GetChar *
F3AF 08         003555 |	php		;Save the registers on the stack.
F3B0 8A         003556 |	txa		;
F3B1 48         003557 |	pha		;
F3B2 98         003558 |	tya		;
F3B3 48         003559 |	pha		;
                003560 |	
F3B4 AD 01 A0   003561 |	lda 6551StR	;Check ACIA to see if a character has been
F3B7 29 08      003562 |	and #00001000b	; received and return with a NULL if no
F3B9 F0 09      003563 |	beq NoChar	; character was present.
                003564 |	
F3BB AD 00 A0   003565 |	lda 6551TRR	;Get the received character from the ACIA's 
F3BE 8D CE 00   003566 |	sta RegTemp	; receive register.
F3C1 4C C9 F3   003567 |	jmp ExitGtCh	;
                003568 |	
F3C4            003569 |NoChar *
F3C4 A9 00      003570 |	lda #0d
F3C6 8D CE 00   003571 |	sta RegTemp
                003572 |	
F3C9            003573 |ExitGtCh *
F3C9 68         003574 |	pla		;Restore the registers.
F3CA A8         003575 |	tay		;
F3CB 68         003576 |	pla		;
F3CC AA         003577 |	tax		;
F3CD 28         003578 |	plp		;
F3CE AD CE 00   003579 |	lda RegTemp	;
                003580 |	
F3D1 60         003581 |	rts
                003582 |	
                003583 |;****************************************************************************
                003584 |;             Get Character (Wait) From Serial Channel Subroutine
                003585 |;****************************************************************************
F3D2            003586 |GetCharW *
F3D2 08         003587 |	php		;Save the registers on the stack.
F3D3 8A         003588 |	txa		;
F3D4 48         003589 |	pha		;
F3D5 98         003590 |	tya		;
F3D6 48         003591 |	pha		;
                003592 |	
F3D7            003593 |GtCkAgn *
F3D7 AD 02 A0   003594 |	lda 6551Sleep ;Allow the emulator to be put to sleep.
                003595 |	
F3DA AD 01 A0   003596 |	lda 6551StR	;Check the ACIA's receiver buffer full register
F3DD 29 08      003597 |	and #00001000b	; and wait until a character is received.
F3DF F0 F6      003598 |	beq GtCkAgn	;
                003599 |	
F3E1 AD 00 A0   003600 |	lda 6551TRR	;Get the received character from the ACIA's 
F3E4 8D CE 00   003601 |	sta RegTemp	; receive register.
                003602 |	
F3E7 68         003603 |	pla		;Restore the registers.
F3E8 A8         003604 |	tay		;
F3E9 68         003605 |	pla		;
F3EA AA         003606 |	tax		;
F3EB 28         003607 |	plp		;
F3EC AD CE 00   003608 |	lda RegTemp	;
                003609 |	
F3EF 60         003610 |	rts
                003611 |	
                003612 |;****************************************************************************
                003613 |;                 Output Chacacter to Serial Channel Subroutine 
                003614 |;                   Character to print is in register 'A'
                003615 |;****************************************************************************
F3F0            003616 |OutChar *
                003617 |	
F3F0 8D CE 00   003618 |	sta RegTemp	;Save registers.
F3F3 08         003619 |	php		;
F3F4 98         003620 |	tya		;
F3F5 48         003621 |	pha		;
F3F6 8A         003622 |	txa		;
F3F7 48         003623 |	pha		;
                003624 |	
F3F8            003625 |OtCkAgn *
F3F8 AD 01 A0   003626 |	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
F3FB 29 10      003627 |	and #00010000b	; register and wait until the buffer is empty.
F3FD F0 F9      003628 |	beq OtCkAgn	;
                003629 |	
F3FF AD CE 00   003630 |	lda RegTemp	;Output a character to the ACIA's Transmitt
F402 8D 00 A0   003631 |	sta 6551TRR	; register.
                003632 |	
F405 68         003633 |	pla		;Restore registers.
F406 AA         003634 |	tax		;
F407 68         003635 |	pla		;
F408 A8         003636 |	tay		;
F409 28         003637 |	plp		;
F40A AD CE 00   003638 |	lda RegTemp	;
                003639 |		
F40D 60         003640 |	rts
                003641 |
                003642 |
                003643 |;****************************************************************************
                003644 |;                          Delay Subroutine
                003645 |;****************************************************************************
F40E            003646 |delay *
F40E 48         003647 |	pha
F40F 8A         003648 |	txa
F410 48         003649 |	pha
F411 98         003650 |	tya
F412 48         003651 |	pha
                003652 |	
F413 A9 00      003653 |	lda #0h
F415 8D A2 00   003654 |	sta wait0
F418 A9 10      003655 |	lda #10h
F41A 8D A3 00   003656 |	sta wait1
                003657 |	
                003658 |	
F41D            003659 |dw0 *
F41D CE A2 00   003660 |	dec wait0
F420 D0 FB      003661 |	bne dw0
F422 CE A3 00   003662 |	dec wait1
F425 D0 F6      003663 |	bne dw0
                003664 |	
F427 68         003665 |	pla
F428 A8         003666 |	tay
F429 68         003667 |	pla                                                                        
F42A AA         003668 |	tax
F42B 68         003669 |	pla
F42C 60         003670 |	rts
                003671 |
                003672 |
                003673 |;****************************************************************************
                003674 |;                Constants
                003675 |;****************************************************************************
                003676 |
F42D 16         003677 |UARTval		dbt 16h,0bh
F42E 0B               
F42F 30         003678 |DgtTblUC	dbt "0123456789ABCDEF"
F430 31 32 33         
F433 34 35 36         
F436 37 38 39         
F439 41 42 43         
F43C 44 45 46         
F43F 00         003679 |		dbt 0h
F440 30         003680 |DgtTblLC	dbt "0123456789abcdef"
F441 31 32 33         
F444 34 35 36         
F447 37 38 39         
F44A 61 62 63         
F44D 64 65 66         
F450 00         003681 |		dbt 0h
F451 0A         003682 |OpenMess	dbt 10d,13d,10d
F452 0D               
F453 0A               
F454 55         003683 |		dbt "UMON65 V1.16 - Understandable Monitor for the 6500 series microprocessors."
F455 4D 4F 4E         
F458 36 35 20         
F45B 56 31 2E         
F45E 31 36 20         
F461 2D 20 55         
F464 6E 64 65         
F467 72 73 74         
F46A 61 6E 64         
F46D 61 62 6C         
F470 65 20 4D         
F473 6F 6E 69         
F476 74 6F 72         
F479 20 66 6F         
F47C 72 20 74         
F47F 68 65 20         
F482 36 35 30         
F485 30 20 73         
F488 65 72 69         
F48B 65 73 20         
F48E 6D 69 63         
F491 72 6F 70         
F494 72 6F 63         
F497 65 73 73         
F49A 6F 72 73         
F49D 2E               
F49E 0A         003684 |		dbt 10d,13d
F49F 0D               
F4A0 00         003685 |		dbt 0h
F4A1 0A         003686 |prompt		dbt 10d,13d
F4A2 0D               
F4A3 2D         003687 |		dbt "-"
F4A4 00         003688 |		dbt 0h
F4A5 0A         003689 |CRLF		dbt 10d,13d,0d
F4A6 0D               
F4A7 00               
F4A8 0A         003690 |SRecStMs	dbt 10d,13d
F4A9 0D               
F4AA 53         003691 |		dbt "Send S records when you are ready..."
F4AB 65 6E 64         
F4AE 20 53 20         
F4B1 72 65 63         
F4B4 6F 72 64         
F4B7 73 20 77         
F4BA 68 65 6E         
F4BD 20 79 6F         
F4C0 75 20 61         
F4C3 72 65 20         
F4C6 72 65 61         
F4C9 64 79 2E         
F4CC 2E 2E            
F4CE 0A         003692 |		dbt 10d,13d,0d
F4CF 0D               
F4D0 00               
F4D1 0A         003693 |SRecErMe	dbt 10d,13d,7d
F4D2 0D               
F4D3 07               
F4D4 45         003694 |		dbt "Error Loading S Records..."
F4D5 72 72 6F         
F4D8 72 20 4C         
F4DB 6F 61 64         
F4DE 69 6E 67         
F4E1 20 53 20         
F4E4 52 65 63         
F4E7 6F 72 64         
F4EA 73 2E 2E         
F4ED 2E               
F4EE 0A         003695 |		dbt 10d,13d,0d
F4EF 0D               
F4F0 00               
F4F1 0A         003696 |SRecEnMs	dbt 10d,13d,7d
F4F2 0D               
F4F3 07               
F4F4 53         003697 |		dbt "S records successfully loaded (press <enter> to continue)."
F4F5 20 72 65         
F4F8 63 6F 72         
F4FB 64 73 20         
F4FE 73 75 63         
F501 63 65 73         
F504 73 66 75         
F507 6C 6C 79         
F50A 20 6C 6F         
F50D 61 64 65         
F510 64 20 28         
F513 70 72 65         
F516 73 73 20         
F519 3C 65 6E         
F51C 74 65 72         
F51F 3E 20 74         
F522 6F 20 63         
F525 6F 6E 74         
F528 69 6E 75         
F52B 65 29 2E         
F52E 00         003698 |		dbt 0d
F52F 0A         003699 |RegMess		dbt 10d,13d,10d
F530 0D               
F531 0A               
F532 50         003700 |		dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
F533 67 6D 43         
F536 6E 74 72         
F539 28 50 43         
F53C 29 20 20         
F53F 41 63 63         
F542 75 6D 28         
F545 41 43 29         
F548 20 20 58         
F54B 52 65 67         
F54E 28 58 52         
F551 29 20 20         
F554 59 52 65         
F557 67 28 59         
F55A 52 29 20         
F55D 20 53 74         
F560 6B 50 74         
F563 72 28 53         
F566 50 29 20         
F569 20 4E 56         
F56C 2D 42 44         
F56F 49 5A 43         
F572 28 53 52         
F575 29               
F576 0A         003701 |		dbt 10d,13d,0d
F577 0D               
F578 00               
F579 0A         003702 |ColnPrmt	dbt 10d,13d
F57A 0D               
F57B 20         003703 |		dbt " :"
F57C 3A               
F57D 00         003704 |		dbt 0d
F57E 20         003705 |BadOpMes	dbt "        ???"
F57F 20 20 20         
F582 20 20 20         
F585 20 3F 3F         
F588 3F               
F589 00         003706 |		dbt 0d
F58A 0A         003707 |BPFulMes	dbt 10d,13d
F58B 0D               
F58C 41         003708 |		dbt "All breakpoints are currently in use."
F58D 6C 6C 20         
F590 62 72 65         
F593 61 6B 70         
F596 6F 69 6E         
F599 74 73 20         
F59C 61 72 65         
F59F 20 63 75         
F5A2 72 72 65         
F5A5 6E 74 6C         
F5A8 79 20 69         
F5AB 6E 20 75         
F5AE 73 65 2E         
F5B1 00         003709 |		dbt 0d
F5B2 0A         003710 |NoBPMess	dbt 10d,13d
F5B3 0D               
F5B4 4E         003711 |		dbt "No breakpoint exists at this address."
F5B5 6F 20 62         
F5B8 72 65 61         
F5BB 6B 70 6F         
F5BE 69 6E 74         
F5C1 20 65 78         
F5C4 69 73 74         
F5C7 73 20 61         
F5CA 74 20 74         
F5CD 68 69 73         
F5D0 20 61 64         
F5D3 64 72 65         
F5D6 73 73 2E         
F5D9 00         003712 |		dbt 0d
F5DA 0A         003713 |GoBPErrM	dbt 10d,13d
F5DB 0D               
F5DC 59         003714 |		dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
F5DD 6F 75 20         
F5E0 63 61 6E         
F5E3 6E 6F 74         
F5E6 20 47 4F         
F5E9 20 61 74         
F5EC 20 61 20         
F5EF 62 72 65         
F5F2 61 6B 70         
F5F5 6F 69 6E         
F5F8 74 65 64         
F5FB 20 61 64         
F5FE 64 72 65         
F601 73 73 2C         
F604 20 54 52         
F607 41 43 45         
F60A 20 70 61         
F60D 73 74 20         
F610 69 74 20         
F613 74 68 65         
F616 6E 20 47         
F619 4F 2E            
F61B 00         003715 |		dbt 0d
F61C 0A         003716 |CmdErMes	dbt 10d,13d
F61D 0D               
F61E 3F         003717 |		dbt "?"
F61F 00         003718 |		dbt 0d
F620 0A         003719 |HelpMess	dbt 10d,13d,10d
F621 0D               
F622 0A               
F623 41         003720 |		dbt "Assemble       A start_address"
F624 73 73 65         
F627 6D 62 6C         
F62A 65 20 20         
F62D 20 20 20         
F630 20 20 41         
F633 20 73 74         
F636 61 72 74         
F639 5F 61 64         
F63C 64 72 65         
F63F 73 73            
F641 0A         003721 |		dbt 10d,13d
F642 0D               
F643 42         003722 |		dbt "Breakpoint     B (+,-,?) address"
F644 72 65 61         
F647 6B 70 6F         
F64A 69 6E 74         
F64D 20 20 20         
F650 20 20 42         
F653 20 28 2B         
F656 2C 2D 2C         
F659 3F 29 20         
F65C 61 64 64         
F65F 72 65 73         
F662 73               
F663 0A         003723 |		dbt 10d,13d
F664 0D               
F665 44         003724 |		dbt "Dump           D [start_address [end_address]]"
F666 75 6D 70         
F669 20 20 20         
F66C 20 20 20         
F66F 20 20 20         
F672 20 20 44         
F675 20 5B 73         
F678 74 61 72         
F67B 74 5F 61         
F67E 64 64 72         
F681 65 73 73         
F684 20 5B 65         
F687 6E 64 5F         
F68A 61 64 64         
F68D 72 65 73         
F690 73 5D 5D         
F693 0A         003725 |		dbt 10d,13d
F694 0D               
F695 45         003726 |		dbt "Enter          E address list"
F696 6E 74 65         
F699 72 20 20         
F69C 20 20 20         
F69F 20 20 20         
F6A2 20 20 45         
F6A5 20 61 64         
F6A8 64 72 65         
F6AB 73 73 20         
F6AE 6C 69 73         
F6B1 74               
F6B2 0A         003727 |		dbt 10d,13d
F6B3 0D               
F6B4 46         003728 |		dbt "Fill           F start_address end_address list"
F6B5 69 6C 6C         
F6B8 20 20 20         
F6BB 20 20 20         
F6BE 20 20 20         
F6C1 20 20 46         
F6C4 20 73 74         
F6C7 61 72 74         
F6CA 5F 61 64         
F6CD 64 72 65         
F6D0 73 73 20         
F6D3 65 6E 64         
F6D6 5F 61 64         
F6D9 64 72 65         
F6DC 73 73 20         
F6DF 6C 69 73         
F6E2 74               
F6E3 0A         003729 |		dbt 10d,13d
F6E4 0D               
F6E5 47         003730 |		dbt "Go             G [start_address]"
F6E6 6F 20 20         
F6E9 20 20 20         
F6EC 20 20 20         
F6EF 20 20 20         
F6F2 20 20 47         
F6F5 20 5B 73         
F6F8 74 61 72         
F6FB 74 5F 61         
F6FE 64 64 72         
F701 65 73 73         
F704 5D               
F705 0A         003731 |		dbt 10d,13d
F706 0D               
F707 48         003732 |		dbt "Help           H or ?"
F708 65 6C 70         
F70B 20 20 20         
F70E 20 20 20         
F711 20 20 20         
F714 20 20 48         
F717 20 6F 72         
F71A 20 3F            
F71C 0A         003733 |		dbt 10d,13d
F71D 0D               
F71E 4C         003734 |		dbt "Load           L"
F71F 6F 61 64         
F722 20 20 20         
F725 20 20 20         
F728 20 20 20         
F72B 20 20 4C         
F72E 0A         003735 |		dbt 10d,13d
F72F 0D               
F730 4D         003736 |		dbt "Move           M start_address end_address destination_address"
F731 6F 76 65         
F734 20 20 20         
F737 20 20 20         
F73A 20 20 20         
F73D 20 20 4D         
F740 20 73 74         
F743 61 72 74         
F746 5F 61 64         
F749 64 72 65         
F74C 73 73 20         
F74F 65 6E 64         
F752 5F 61 64         
F755 64 72 65         
F758 73 73 20         
F75B 64 65 73         
F75E 74 69 6E         
F761 61 74 69         
F764 6F 6E 5F         
F767 61 64 64         
F76A 72 65 73         
F76D 73               
F76E 0A         003737 |		dbt 10d,13d
F76F 0D               
F770 52         003738 |		dbt "Register       R [PC,AC,XR,YR,SP,SR]"
F771 65 67 69         
F774 73 74 65         
F777 72 20 20         
F77A 20 20 20         
F77D 20 20 52         
F780 20 5B 50         
F783 43 2C 41         
F786 43 2C 58         
F789 52 2C 59         
F78C 52 2C 53         
F78F 50 2C 53         
F792 52 5D            
F794 0A         003739 |		dbt 10d,13d
F795 0D               
F796 53         003740 |		dbt "Search         S start_address end_address list"
F797 65 61 72         
F79A 63 68 20         
F79D 20 20 20         
F7A0 20 20 20         
F7A3 20 20 53         
F7A6 20 73 74         
F7A9 61 72 74         
F7AC 5F 61 64         
F7AF 64 72 65         
F7B2 73 73 20         
F7B5 65 6E 64         
F7B8 5F 61 64         
F7BB 64 72 65         
F7BE 73 73 20         
F7C1 6C 69 73         
F7C4 74               
F7C5 0A         003741 |		dbt 10d,13d
F7C6 0D               
F7C7 54         003742 |		dbt "Trace          T [start_address [value]]"
F7C8 72 61 63         
F7CB 65 20 20         
F7CE 20 20 20         
F7D1 20 20 20         
F7D4 20 20 54         
F7D7 20 5B 73         
F7DA 74 61 72         
F7DD 74 5F 61         
F7E0 64 64 72         
F7E3 65 73 73         
F7E6 20 5B 76         
F7E9 61 6C 75         
F7EC 65 5D 5D         
F7EF 0A         003743 |		dbt 10d,13d
F7F0 0D               
F7F1 55         003744 |		dbt "Unassemble     U [start_address [end_address]]"
F7F2 6E 61 73         
F7F5 73 65 6D         
F7F8 62 6C 65         
F7FB 20 20 20         
F7FE 20 20 55         
F801 20 5B 73         
F804 74 61 72         
F807 74 5F 61         
F80A 64 64 72         
F80D 65 73 73         
F810 20 5B 65         
F813 6E 64 5F         
F816 61 64 64         
F819 72 65 73         
F81C 73 5D 5D         
F81F 0A         003745 |		dbt 10d,13d,0d
F820 0D               
F821 00               
                003746 |	
                003747 |
F822 41         003748 |OpTable		dbt "ADC IMM"
F823 44 43 20         
F826 49 4D 4D         
F829 69         003749 |		dbt 069h,2h,2h
F82A 02               
F82B 02               
F82C 41         003750 |		dbt "ADC ABS"
F82D 44 43 20         
F830 41 42 53         
F833 6D         003751 |		dbt 06Dh,3h,4h
F834 03               
F835 04               
F836 41         003752 |		dbt "ADC ABX"
F837 44 43 20         
F83A 41 42 58         
F83D 7D         003753 |		dbt 07Dh,3h,4h
F83E 03               
F83F 04               
F840 41         003754 |		dbt "ADC ABY"
F841 44 43 20         
F844 41 42 59         
F847 79         003755 |		dbt 079h,3h,4h
F848 03               
F849 04               
F84A 41         003756 |		dbt "ADC IIR"
F84B 44 43 20         
F84E 49 49 52         
F851 61         003757 |		dbt 061h,2h,6h
F852 02               
F853 06               
F854 41         003758 |		dbt "ADC IRI"
F855 44 43 20         
F858 49 52 49         
F85B 71         003759 |		dbt 071h,2h,5h
F85C 02               
F85D 05               
F85E 41         003760 |		dbt "AND IMM"
F85F 4E 44 20         
F862 49 4D 4D         
F865 29         003761 |		dbt 029h,2h,2h
F866 02               
F867 02               
F868 41         003762 |		dbt "AND ABS"
F869 4E 44 20         
F86C 41 42 53         
F86F 2D         003763 |		dbt 02Dh,3h,4h
F870 03               
F871 04               
F872 41         003764 |		dbt "AND ABX"
F873 4E 44 20         
F876 41 42 58         
F879 3D         003765 |		dbt 03Dh,3h,4h
F87A 03               
F87B 04               
F87C 41         003766 |		dbt "AND ABY"
F87D 4E 44 20         
F880 41 42 59         
F883 39         003767 |		dbt 039h,3h,4h
F884 03               
F885 04               
F886 41         003768 |		dbt "AND IIR"
F887 4E 44 20         
F88A 49 49 52         
F88D 21         003769 |		dbt 021h,2h,6h
F88E 02               
F88F 06               
F890 41         003770 |		dbt "AND IRI"
F891 4E 44 20         
F894 49 52 49         
F897 31         003771 |		dbt 031h,2h,5h
F898 02               
F899 05               
F89A 41         003772 |		dbt "ASL ACC"
F89B 53 4C 20         
F89E 41 43 43         
F8A1 0A         003773 |		dbt 00Ah,1h,2h
F8A2 01               
F8A3 02               
F8A4 41         003774 |		dbt "ASL ABS"
F8A5 53 4C 20         
F8A8 41 42 53         
F8AB 0E         003775 |		dbt 00Eh,3h,6h
F8AC 03               
F8AD 06               
F8AE 41         003776 |		dbt "ASL ABX"
F8AF 53 4C 20         
F8B2 41 42 58         
F8B5 1E         003777 |		dbt 01Eh,3h,7h
F8B6 03               
F8B7 07               
F8B8 42         003778 |		dbt "BCC REL"
F8B9 43 43 20         
F8BC 52 45 4C         
F8BF 90         003779 |		dbt 090h,2h,2h
F8C0 02               
F8C1 02               
F8C2 42         003780 |		dbt "BCS REL"
F8C3 43 53 20         
F8C6 52 45 4C         
F8C9 B0         003781 |		dbt 0B0h,2h,2h
F8CA 02               
F8CB 02               
F8CC 42         003782 |		dbt "BEQ REL"
F8CD 45 51 20         
F8D0 52 45 4C         
F8D3 F0         003783 |		dbt 0F0h,2h,2h
F8D4 02               
F8D5 02               
F8D6 42         003784 |		dbt "BIT ABS"
F8D7 49 54 20         
F8DA 41 42 53         
F8DD 2C         003785 |		dbt 02Ch,3h,4h
F8DE 03               
F8DF 04               
F8E0 42         003786 |		dbt "BMI REL"
F8E1 4D 49 20         
F8E4 52 45 4C         
F8E7 30         003787 |		dbt 030h,2h,2h
F8E8 02               
F8E9 02               
F8EA 42         003788 |		dbt "BNE REL"
F8EB 4E 45 20         
F8EE 52 45 4C         
F8F1 D0         003789 |		dbt 0D0h,2h,2h
F8F2 02               
F8F3 02               
F8F4 42         003790 |		dbt "BPL REL"
F8F5 50 4C 20         
F8F8 52 45 4C         
F8FB 10         003791 |		dbt 010h,2h,2h
F8FC 02               
F8FD 02               
F8FE 42         003792 |		dbt "BRK IMP"
F8FF 52 4B 20         
F902 49 4D 50         
F905 00         003793 |		dbt 000h,1h,7h
F906 01               
F907 07               
F908 42         003794 |		dbt "BVC REL"
F909 56 43 20         
F90C 52 45 4C         
F90F 50         003795 |		dbt 050h,2h,2h
F910 02               
F911 02               
F912 42         003796 |		dbt "BVS REL"
F913 56 53 20         
F916 52 45 4C         
F919 70         003797 |		dbt 070h,2h,2h
F91A 02               
F91B 02               
F91C 43         003798 |		dbt "CLC IMP"
F91D 4C 43 20         
F920 49 4D 50         
F923 18         003799 |		dbt 018h,1h,2h
F924 01               
F925 02               
F926 43         003800 |		dbt "CLD IMP"
F927 4C 44 20         
F92A 49 4D 50         
F92D D8         003801 |		dbt 0D8h,1h,2h
F92E 01               
F92F 02               
F930 43         003802 |		dbt "CLI IMP"
F931 4C 49 20         
F934 49 4D 50         
F937 58         003803 |		dbt 058h,1h,2h
F938 01               
F939 02               
F93A 43         003804 |		dbt "CLV IMP"
F93B 4C 56 20         
F93E 49 4D 50         
F941 B8         003805 |		dbt 0B8h,1h,2h
F942 01               
F943 02               
F944 43         003806 |		dbt "CMP IMM"
F945 4D 50 20         
F948 49 4D 4D         
F94B C9         003807 |		dbt 0C9h,2h,2h
F94C 02               
F94D 02               
F94E 43         003808 |		dbt "CMP ABS"
F94F 4D 50 20         
F952 41 42 53         
F955 CD         003809 |		dbt 0CDh,3h,4h
F956 03               
F957 04               
F958 43         003810 |		dbt "CMP ABX"
F959 4D 50 20         
F95C 41 42 58         
F95F DD         003811 |		dbt 0DDh,3h,4h
F960 03               
F961 04               
F962 43         003812 |		dbt "CMP ABY"
F963 4D 50 20         
F966 41 42 59         
F969 D9         003813 |		dbt 0D9h,3h,4h
F96A 03               
F96B 04               
F96C 43         003814 |		dbt "CMP IIR"
F96D 4D 50 20         
F970 49 49 52         
F973 C1         003815 |		dbt 0C1h,2h,6h
F974 02               
F975 06               
F976 43         003816 |		dbt "CMP IRI"
F977 4D 50 20         
F97A 49 52 49         
F97D D1         003817 |		dbt 0D1h,2h,5h
F97E 02               
F97F 05               
F980 43         003818 |		dbt "CPX IMM"
F981 50 58 20         
F984 49 4D 4D         
F987 E0         003819 |		dbt 0E0h,2h,2h
F988 02               
F989 02               
F98A 43         003820 |		dbt "CPX ABS"
F98B 50 58 20         
F98E 41 42 53         
F991 EC         003821 |		dbt 0ECh,3h,4h
F992 03               
F993 04               
F994 43         003822 |		dbt "CPY IMM"
F995 50 59 20         
F998 49 4D 4D         
F99B C0         003823 |		dbt 0C0h,2h,2h
F99C 02               
F99D 02               
F99E 43         003824 |		dbt "CPY ABS"
F99F 50 59 20         
F9A2 41 42 53         
F9A5 CC         003825 |		dbt 0CCh,3h,4h
F9A6 03               
F9A7 04               
F9A8 44         003826 |		dbt "DEC ABS"
F9A9 45 43 20         
F9AC 41 42 53         
F9AF CE         003827 |		dbt 0CEh,3h,6h
F9B0 03               
F9B1 06               
F9B2 44         003828 |		dbt "DEC ABX"
F9B3 45 43 20         
F9B6 41 42 58         
F9B9 DE         003829 |		dbt 0DEh,3h,7h
F9BA 03               
F9BB 07               
F9BC 44         003830 |		dbt "DEX IMP"
F9BD 45 58 20         
F9C0 49 4D 50         
F9C3 CA         003831 |		dbt 0CAh,1h,2h
F9C4 01               
F9C5 02               
F9C6 44         003832 |		dbt "DEY IMP"
F9C7 45 59 20         
F9CA 49 4D 50         
F9CD 88         003833 |		dbt 088h,1h,2h
F9CE 01               
F9CF 02               
F9D0 45         003834 |		dbt "EOR IMM"
F9D1 4F 52 20         
F9D4 49 4D 4D         
F9D7 49         003835 |		dbt 049h,2h,2h
F9D8 02               
F9D9 02               
F9DA 45         003836 |		dbt "EOR ABS"
F9DB 4F 52 20         
F9DE 41 42 53         
F9E1 4D         003837 |		dbt 04Dh,3h,4h
F9E2 03               
F9E3 04               
F9E4 45         003838 |		dbt "EOR ABX"
F9E5 4F 52 20         
F9E8 41 42 58         
F9EB 5D         003839 |		dbt 05Dh,3h,4h
F9EC 03               
F9ED 04               
F9EE 45         003840 |		dbt "EOR ABY"
F9EF 4F 52 20         
F9F2 41 42 59         
F9F5 59         003841 |		dbt 059h,3h,4h
F9F6 03               
F9F7 04               
F9F8 45         003842 |		dbt "EOR IIR"
F9F9 4F 52 20         
F9FC 49 49 52         
F9FF 41         003843 |		dbt 041h,2h,6h
FA00 02               
FA01 06               
FA02 45         003844 |		dbt "EOR IRI"
FA03 4F 52 20         
FA06 49 52 49         
FA09 51         003845 |		dbt 051h,2h,5h
FA0A 02               
FA0B 05               
FA0C 49         003846 |		dbt "INC ABS"
FA0D 4E 43 20         
FA10 41 42 53         
FA13 EE         003847 |		dbt 0EEh,3h,6h
FA14 03               
FA15 06               
FA16 49         003848 |		dbt "INC ABX"
FA17 4E 43 20         
FA1A 41 42 58         
FA1D FE         003849 |		dbt 0FEh,3h,7h
FA1E 03               
FA1F 07               
FA20 49         003850 |		dbt "INX IMP"
FA21 4E 58 20         
FA24 49 4D 50         
FA27 E8         003851 |		dbt 0E8h,1h,2h
FA28 01               
FA29 02               
FA2A 49         003852 |		dbt "INY IMP"
FA2B 4E 59 20         
FA2E 49 4D 50         
FA31 C8         003853 |		dbt 0C8h,1h,2h
FA32 01               
FA33 02               
FA34 4A         003854 |		dbt "JMP ABS"
FA35 4D 50 20         
FA38 41 42 53         
FA3B 4C         003855 |		dbt 04Ch,3h,3h
FA3C 03               
FA3D 03               
FA3E 4A         003856 |		dbt "JMP IND"
FA3F 4D 50 20         
FA42 49 4E 44         
FA45 6C         003857 |		dbt 06Ch,3h,5h
FA46 03               
FA47 05               
FA48 4A         003858 |		dbt "JSR ABS"
FA49 53 52 20         
FA4C 41 42 53         
FA4F 20         003859 |		dbt 020h,3h,6h
FA50 03               
FA51 06               
FA52 4C         003860 |		dbt "LDA IMM"
FA53 44 41 20         
FA56 49 4D 4D         
FA59 A9         003861 |		dbt 0A9h,2h,2h
FA5A 02               
FA5B 02               
FA5C 4C         003862 |		dbt "LDA ABS"
FA5D 44 41 20         
FA60 41 42 53         
FA63 AD         003863 |		dbt 0ADh,3h,4h
FA64 03               
FA65 04               
FA66 4C         003864 |		dbt "LDA ABX"
FA67 44 41 20         
FA6A 41 42 58         
FA6D BD         003865 |		dbt 0BDh,3h,4h
FA6E 03               
FA6F 04               
FA70 4C         003866 |		dbt "LDA ABY"
FA71 44 41 20         
FA74 41 42 59         
FA77 B9         003867 |		dbt 0B9h,3h,4h
FA78 03               
FA79 04               
FA7A 4C         003868 |		dbt "LDA IIR"
FA7B 44 41 20         
FA7E 49 49 52         
FA81 A1         003869 |		dbt 0A1h,2h,6h
FA82 02               
FA83 06               
FA84 4C         003870 |		dbt "LDA IRI"
FA85 44 41 20         
FA88 49 52 49         
FA8B B1         003871 |		dbt 0B1h,2h,5h
FA8C 02               
FA8D 05               
FA8E 4C         003872 |		dbt "LDX IMM"
FA8F 44 58 20         
FA92 49 4D 4D         
FA95 A2         003873 |		dbt 0A2h,2h,2h
FA96 02               
FA97 02               
FA98 4C         003874 |		dbt "LDX ABS"
FA99 44 58 20         
FA9C 41 42 53         
FA9F AE         003875 |		dbt 0AEh,3h,4h
FAA0 03               
FAA1 04               
FAA2 4C         003876 |		dbt "LDX ABY"
FAA3 44 58 20         
FAA6 41 42 59         
FAA9 BE         003877 |		dbt 0BEh,3h,4h
FAAA 03               
FAAB 04               
FAAC 4C         003878 |		dbt "LDY IMM"
FAAD 44 59 20         
FAB0 49 4D 4D         
FAB3 A0         003879 |		dbt 0A0h,2h,2h
FAB4 02               
FAB5 02               
FAB6 4C         003880 |		dbt "LDY ABS"
FAB7 44 59 20         
FABA 41 42 53         
FABD AC         003881 |		dbt 0ACh,3h,4h
FABE 03               
FABF 04               
FAC0 4C         003882 |		dbt "LDY ABX"
FAC1 44 59 20         
FAC4 41 42 58         
FAC7 BC         003883 |		dbt 0BCh,3h,4h
FAC8 03               
FAC9 04               
FACA 4C         003884 |		dbt "LSR ACC"
FACB 53 52 20         
FACE 41 43 43         
FAD1 4A         003885 |		dbt 04Ah,1h,2h
FAD2 01               
FAD3 02               
FAD4 4C         003886 |		dbt "LSR ABS"
FAD5 53 52 20         
FAD8 41 42 53         
FADB 4E         003887 |		dbt 04Eh,3h,6h
FADC 03               
FADD 06               
FADE 4C         003888 |		dbt "LSR ABX"
FADF 53 52 20         
FAE2 41 42 58         
FAE5 5E         003889 |		dbt 05Eh,3h,7h
FAE6 03               
FAE7 07               
FAE8 4E         003890 |		dbt "NOP IMP"
FAE9 4F 50 20         
FAEC 49 4D 50         
FAEF EA         003891 |		dbt 0EAh,1h,2h
FAF0 01               
FAF1 02               
FAF2 4F         003892 |		dbt "ORA IMM"
FAF3 52 41 20         
FAF6 49 4D 4D         
FAF9 09         003893 |		dbt 009h,2h,2h
FAFA 02               
FAFB 02               
FAFC 4F         003894 |		dbt "ORA ABS"
FAFD 52 41 20         
FB00 41 42 53         
FB03 0D         003895 |		dbt 00Dh,3h,4h
FB04 03               
FB05 04               
FB06 4F         003896 |		dbt "ORA ABX"
FB07 52 41 20         
FB0A 41 42 58         
FB0D 1D         003897 |		dbt 01Dh,3h,4h
FB0E 03               
FB0F 04               
FB10 4F         003898 |		dbt "ORA ABY"
FB11 52 41 20         
FB14 41 42 59         
FB17 19         003899 |		dbt 019h,3h,4h
FB18 03               
FB19 04               
FB1A 4F         003900 |		dbt "ORA IIR"
FB1B 52 41 20         
FB1E 49 49 52         
FB21 01         003901 |		dbt 001h,2h,6h
FB22 02               
FB23 06               
FB24 4F         003902 |		dbt "ORA IRI"
FB25 52 41 20         
FB28 49 52 49         
FB2B 11         003903 |		dbt 011h,2h,5h
FB2C 02               
FB2D 05               
FB2E 50         003904 |		dbt "PHA IMP"
FB2F 48 41 20         
FB32 49 4D 50         
FB35 48         003905 |		dbt 048h,1h,3h
FB36 01               
FB37 03               
FB38 50         003906 |		dbt "PHP IMP"
FB39 48 50 20         
FB3C 49 4D 50         
FB3F 08         003907 |		dbt 008h,1h,3h
FB40 01               
FB41 03               
FB42 50         003908 |		dbt "PLA IMP"
FB43 4C 41 20         
FB46 49 4D 50         
FB49 68         003909 |		dbt 068h,1h,4h
FB4A 01               
FB4B 04               
FB4C 50         003910 |		dbt "PLP IMP"
FB4D 4C 50 20         
FB50 49 4D 50         
FB53 28         003911 |		dbt 028h,1h,4h
FB54 01               
FB55 04               
FB56 52         003912 |		dbt "ROL ACC"
FB57 4F 4C 20         
FB5A 41 43 43         
FB5D 2A         003913 |		dbt 02Ah,1h,2h
FB5E 01               
FB5F 02               
FB60 52         003914 |		dbt "ROL ABS"
FB61 4F 4C 20         
FB64 41 42 53         
FB67 2E         003915 |		dbt 02Eh,3h,6h
FB68 03               
FB69 06               
FB6A 52         003916 |		dbt "ROL ABX"
FB6B 4F 4C 20         
FB6E 41 42 58         
FB71 3E         003917 |		dbt 03Eh,3h,7h
FB72 03               
FB73 07               
FB74 52         003918 |		dbt "ROR ACC"
FB75 4F 52 20         
FB78 41 43 43         
FB7B 6A         003919 |		dbt 06Ah,1h,2h
FB7C 01               
FB7D 02               
FB7E 52         003920 |		dbt "ROR ABS"
FB7F 4F 52 20         
FB82 41 42 53         
FB85 6E         003921 |		dbt 06Eh,3h,6h
FB86 03               
FB87 06               
FB88 52         003922 |		dbt "ROR ABX"
FB89 4F 52 20         
FB8C 41 42 58         
FB8F 7E         003923 |		dbt 07Eh,3h,7h
FB90 03               
FB91 07               
FB92 52         003924 |		dbt "RTI IMP"
FB93 54 49 20         
FB96 49 4D 50         
FB99 40         003925 |		dbt 040h,1h,6h
FB9A 01               
FB9B 06               
FB9C 52         003926 |		dbt "RTS IMP"
FB9D 54 53 20         
FBA0 49 4D 50         
FBA3 60         003927 |		dbt 060h,1h,6h
FBA4 01               
FBA5 06               
FBA6 53         003928 |		dbt "SBC IMM"
FBA7 42 43 20         
FBAA 49 4D 4D         
FBAD E9         003929 |		dbt 0E9h,2h,2h
FBAE 02               
FBAF 02               
FBB0 53         003930 |		dbt "SBC ABS"
FBB1 42 43 20         
FBB4 41 42 53         
FBB7 ED         003931 |		dbt 0EDh,3h,4h
FBB8 03               
FBB9 04               
FBBA 53         003932 |		dbt "SBC ABX"
FBBB 42 43 20         
FBBE 41 42 58         
FBC1 FD         003933 |		dbt 0FDh,3h,4h
FBC2 03               
FBC3 04               
FBC4 53         003934 |		dbt "SBC ABY"
FBC5 42 43 20         
FBC8 41 42 59         
FBCB F9         003935 |		dbt 0F9h,3h,4h
FBCC 03               
FBCD 04               
FBCE 53         003936 |		dbt "SBC IIR"
FBCF 42 43 20         
FBD2 49 49 52         
FBD5 E1         003937 |		dbt 0E1h,2h,6h
FBD6 02               
FBD7 06               
FBD8 53         003938 |		dbt "SBC IRI"
FBD9 42 43 20         
FBDC 49 52 49         
FBDF F1         003939 |		dbt 0F1h,2h,5h
FBE0 02               
FBE1 05               
FBE2 53         003940 |		dbt "SEC IMP"
FBE3 45 43 20         
FBE6 49 4D 50         
FBE9 38         003941 |		dbt 038h,1h,2h
FBEA 01               
FBEB 02               
FBEC 53         003942 |		dbt "SED IMP"
FBED 45 44 20         
FBF0 49 4D 50         
FBF3 F8         003943 |		dbt 0F8h,1h,2h
FBF4 01               
FBF5 02               
FBF6 53         003944 |		dbt "SEI IMP"
FBF7 45 49 20         
FBFA 49 4D 50         
FBFD 78         003945 |		dbt 078h,1h,2h
FBFE 01               
FBFF 02               
FC00 53         003946 |		dbt "STA ABS"
FC01 54 41 20         
FC04 41 42 53         
FC07 8D         003947 |		dbt 08Dh,3h,4h
FC08 03               
FC09 04               
FC0A 53         003948 |		dbt "STA ABX"
FC0B 54 41 20         
FC0E 41 42 58         
FC11 9D         003949 |		dbt 09Dh,3h,5h
FC12 03               
FC13 05               
FC14 53         003950 |		dbt "STA ABY"
FC15 54 41 20         
FC18 41 42 59         
FC1B 99         003951 |		dbt 099h,3h,5h
FC1C 03               
FC1D 05               
FC1E 53         003952 |		dbt "STA IIR"
FC1F 54 41 20         
FC22 49 49 52         
FC25 81         003953 |		dbt 081h,2h,6h
FC26 02               
FC27 06               
FC28 53         003954 |		dbt "STA IRI"
FC29 54 41 20         
FC2C 49 52 49         
FC2F 91         003955 |		dbt 091h,2h,6h
FC30 02               
FC31 06               
FC32 53         003956 |		dbt "STX ABS"
FC33 54 58 20         
FC36 41 42 53         
FC39 8E         003957 |		dbt 08Eh,3h,4h
FC3A 03               
FC3B 04               
FC3C 53         003958 |		dbt "STY ABS"
FC3D 54 59 20         
FC40 41 42 53         
FC43 8C         003959 |		dbt 08Ch,3h,4h
FC44 03               
FC45 04               
FC46 54         003960 |		dbt "TAX IMP"
FC47 41 58 20         
FC4A 49 4D 50         
FC4D AA         003961 |		dbt 0AAh,1h,2h
FC4E 01               
FC4F 02               
FC50 54         003962 |		dbt "TAY IMP"
FC51 41 59 20         
FC54 49 4D 50         
FC57 A8         003963 |		dbt 0A8h,1h,2h
FC58 01               
FC59 02               
FC5A 54         003964 |		dbt "TSX IMP"
FC5B 53 58 20         
FC5E 49 4D 50         
FC61 BA         003965 |		dbt 0BAh,1h,2h
FC62 01               
FC63 02               
FC64 54         003966 |		dbt "TXA IMP"
FC65 58 41 20         
FC68 49 4D 50         
FC6B 8A         003967 |		dbt 08Ah,1h,2h
FC6C 01               
FC6D 02               
FC6E 54         003968 |		dbt "TXS IMP"
FC6F 58 53 20         
FC72 49 4D 50         
FC75 9A         003969 |		dbt 09Ah,1h,2h
FC76 01               
FC77 02               
FC78 54         003970 |		dbt "TYA IMP"
FC79 59 41 20         
FC7C 49 4D 50         
FC7F 98         003971 |		dbt 098h,1h,2h
FC80 01               
FC81 02               
FC82 5A         003972 |		dbt "ZZZ ZZZ"
FC83 5A 5A 20         
FC86 5A 5A 5A         
FC89 00         003973 |		dbt 000h,0h,0h
FC8A 00               
FC8B 00               
                003974 |		
                003975 |;****************************************************************************
                003976 |;       Initialize 6502 reset vector and maskable interrupt vector.
                003977 |;****************************************************************************
FFFC            003978 |	org 0fffch	;Initialize reset vector.
FFFC 00         003979 |	dbt 00h,0e0h	;                                                                                         
FFFD E0               
                003980 |;	
FFFE            003981 |	org 0fffeh	;Initialize maskable interrupt vector.
FFFE EA         003982 |	dbt #MaskInt<	;
FFFF E1         003983 |	dbt #MaskInt>	;
                003984 |		end
                003985 |		