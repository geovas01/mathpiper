
%_fricas,title=""
1+1 
%/_fricas

    %output,preserve="false"
            1+1
             
            
               (3)  2
                                                                    Type: PositiveInteger
            
.   %/output


        	


%_fricas,title=""
1-1
%/_fricas

    %output,preserve="false"
      1-1
       
      
         (4)  0
                                                           Type: NonNegativeInteger
      
.   %/output

 
        	




%_fricas,title=""
-1 
%/_fricas

    %output,preserve="false"
      -1
       
      
         (5)  - 1
                                                                      Type: Integer
      
.   %/output

        	


The FriCAS interpreter guesses the most appropriate type. For simple things types do not matter much.

Apart from the above integer domains, there are rational numbers and floting point numbers, complex integers, complex floats, etc.

%_fricas,title=""
2/3 
%/_fricas

    %output,preserve="false"
      2/3
       
      
              2
         (6)  -
              3
                                                            Type: Fraction(Integer)
      
.   %/output

        	



%_fricas,title=""
3/6 
%/_fricas

    %output,preserve="false"
            3/6
             
            
                    1
               (7)  -
                    2
                                                                  Type: Fraction(Integer)
            
.   %/output


        	



%_fricas,title=""
2/3 + 1/5 * (- 2/11)
%/_fricas

    %output,preserve="false"
      2/3 + 1/5 * (- 2/11)
       
      
              104
         (8)  ---
              165
                                                            Type: Fraction(Integer)
      
.   %/output

 
        	



%_fricas,title=""
2^10 
%/_fricas


        	


%_fricas,title=""
factorial(100) 
%/_fricas

    %output,preserve="false"
      factorial(100)
       
      
         (9)
        9332621544394415268169923885626670049071596826438162146859296389521759999322_
         991560894146397615651828625369792082722375825118521091686400000000000000000_
         0000000
                                                              Type: PositiveInteger
      
.   %/output


        	


By default 20 digits are used for floting point computation.

%_fricas,title=""
2/3 + 1.0 
%/_fricas

    %output,preserve="false"
      2/3 + 1.0
       
      
         (10)  1.6666666666 666666667
                                                                        Type: Float
      
.   %/output


        	


By using the digits function, one can query and set the number of digits that are used during the computation.

By default, a fraction is expressed in the most appropriate domain, which would be Fraction(Integer). Coercion into the appropriate type is done via the :: operator.

%_fricas,title=""
digits 40 
22/7 :: Float 
digits(20) 
22/7 :: Float 
%/_fricas

    %output,preserve="false"
      digits 40 
       
      
         (11)  20
                                                              Type: PositiveInteger
      22/7 :: Float 
       
      
         (12)  3.1428571428 5714285714 2857142857 142857143
                                                                        Type: Float
      digits(20) 
       
      
         (13)  40
                                                              Type: PositiveInteger
      22/7 :: Float
       
      
         (14)  3.1428571428 571428571
                                                                        Type: Float
      
.   %/output


        	


A number that contains a dot, is automatically a member of the floating point domain. So the following fraction is computed within the respective domain, namely, Float.

%_fricas,title=""
22/7.0 
%/_fricas

    %output,preserve="false"
      22/7.0
       
      
         (15)  3.1428571428 571428571
                                                                        Type: Float
      
.   %/output




%_fricas,title=""
sqrt(2.0)
%/_fricas

    %output,preserve="false"
      sqrt(2.0)
       
      
         (16)  1.4142135623 730950488
                                                                        Type: Float
      
.   %/output

 
        	


For integer arguments, it is not clear what the user actually wants. So the expression remains unevaluated.

Note that we get AlgebraicNumber as yet another number type.

%_fricas,title=""
sqrt(3)
%/_fricas

    %output,preserve="false"
      sqrt(3)
       
      
                +-+
         (17)  \|3
                                                              Type: AlgebraicNumber
      
.   %/output

 
        	

AlgebraicNumber

In fact, AlgebraicNumber is a step into the direction of computing with symbols rather than just numbers.

%_fricas,title=""
sqrt(2)+sqrt(3)
%/_fricas

    %output,preserve="false"
      sqrt(2)+sqrt(3)
       
      
                +-+    +-+
         (18)  \|3  + \|2
                                                              Type: AlgebraicNumber
      
.   %/output

 
        	



FriCAS can also deal with complex numbers. The symbol %i denotes the imaginary unit. Here we have Gaussian integers.

%_fricas,title=""
2+3*%i 
%/_fricas

    %output,preserve="false"
      2+3*%i
       
      
         (19)  2 + 3%i
                                                             Type: Complex(Integer)
      
.   %/output


        	



As with integers, the resulting type is appropriately chosen, i.e. "complex rational numbers".

%_fricas,title=""
(2 + 3*%i) / (3 + 5*%i)
%/_fricas

    %output,preserve="false"
      (2 + 3*%i) / (3 + 5*%i)
       
      
               21    1
         (20)  -- - -- %i
               34   34
                                                   Type: Complex(Fraction(Integer))
      
.   %/output

 


As with real numbers where Float is the corresponding domain in FriCAS, complex numbers can only be modelled approximately on a computer.

%_fricas,title=""
sqrt(2.0) * (1 + 2.0*%i)
%/_fricas

    %output,preserve="false"
            sqrt(2.0) * (1 + 2.0*%i)
             
            
               (21)  1.4142135623 730950488 + 2.8284271247 461900976 %i
                                                                     Type: Complex(Float)
            
.   %/output

 
        	



Not everything can be done with floating point numbers. FriCAS does not automatically extend the number domain from real numbers to complex numbers. 
It rather considers Float as a domain with partial operations, i.e. operations that might fail on certain input.

%_fricas,title=""
sqrt(5.0) 
sqrt(-5.0)
%/_fricas

    %output,preserve="false"
      sqrt(5.0) 
       
      
         (22)  2.2360679774 997896964
                                                                        Type: Float
      sqrt(-5.0)
       
       
         >> Error detected within library code:
         negative sqrt
      
      
.   %/output

 
        	



But we can convert an algebraic number into a complex floating point number.

%_fricas,title=""
sqrt(-5) 
sqrt(-5) :: Complex(Float) 
%/_fricas

    %output,preserve="false"
      sqrt(-5) 
       
      
                +---+
         (23)  \|- 5
                                                              Type: AlgebraicNumber
      sqrt(-5) :: Complex(Float)
       
      
         (24)  2.2360679774 997896964 %i
                                                               Type: Complex(Float)
      
.   %/output


        	



There are a lot of functions that can be used with floating point numbers.

Note that % is an abbreviation of "this domain", i.e. Float in our case. The question mark is just used as a placeholder for an argument.

%_fricas,title=""
)show Float 
%/_fricas

    %output,preserve="false"
      )show Float
       
       Float  is a domain constructor
       Abbreviation for Float is FLOAT 
       This constructor is exposed in this frame.
      ------------------------------- Operations --------------------------------
       ?*? : (Fraction(Integer),%) -> %      ?*? : (%,Fraction(Integer)) -> %
       ?*? : (%,%) -> %                      ?*? : (Integer,%) -> %
       ?*? : (PositiveInteger,%) -> %        ?+? : (%,%) -> %
       ?-? : (%,%) -> %                      -? : % -> %
       ?/? : (%,Integer) -> %                ?/? : (%,%) -> %
       ?<? : (%,%) -> Boolean                ?<=? : (%,%) -> Boolean
       ?=? : (%,%) -> Boolean                ?>? : (%,%) -> Boolean
       ?>=? : (%,%) -> Boolean               D : % -> %
       D : (%,NonNegativeInteger) -> %       OMwrite : (%,Boolean) -> String
       OMwrite : % -> String                 1 : () -> %
       0 : () -> %                           ?^? : (%,%) -> %
       ?^? : (%,Fraction(Integer)) -> %      ?^? : (%,Integer) -> %
       ?^? : (%,PositiveInteger) -> %        abs : % -> %
       acos : % -> %                         acosh : % -> %
       acot : % -> %                         acoth : % -> %
       acsc : % -> %                         acsch : % -> %
       asec : % -> %                         asech : % -> %
       asin : % -> %                         asinh : % -> %
       associates? : (%,%) -> Boolean        atan : (%,%) -> %
       atan : % -> %                         atanh : % -> %
       base : () -> PositiveInteger          bits : () -> PositiveInteger
       ceiling : % -> %                      coerce : % -> DoubleFloat
       coerce : Fraction(Integer) -> %       coerce : Integer -> %
       coerce : Fraction(Integer) -> %       coerce : % -> %
       coerce : Integer -> %                 coerce : % -> OutputForm
       convert : DoubleFloat -> %            convert : % -> InputForm
       convert : % -> String                 convert : % -> Pattern(Float)
       convert : % -> DoubleFloat            convert : % -> Float
       cos : % -> %                          cosh : % -> %
       cot : % -> %                          coth : % -> %
       csc : % -> %                          csch : % -> %
       differentiate : % -> %                digits : () -> PositiveInteger
       exp : % -> %                          exp1 : () -> %
       exponent : % -> Integer               factor : % -> Factored(%)
       float : (Integer,Integer) -> %        floor : % -> %
       fractionPart : % -> %                 gcd : List(%) -> %
       gcd : (%,%) -> %                      hash : % -> SingleInteger
       inv : % -> %                          latex : % -> String
       lcm : List(%) -> %                    lcm : (%,%) -> %
       log : % -> %                          log10 : % -> %
       log10 : () -> %                       log2 : % -> %
       log2 : () -> %                        mantissa : % -> Integer
       max : (%,%) -> %                      min : (%,%) -> %
       negative? : % -> Boolean              norm : % -> %
       normalize : % -> %                    nthRoot : (%,Integer) -> %
       one? : % -> Boolean                   order : % -> Integer
       outputFixed : () -> Void              outputFloating : () -> Void
       outputGeneral : () -> Void            pi : () -> %
       positive? : % -> Boolean              precision : () -> PositiveInteger
       prime? : % -> Boolean                 ?quo? : (%,%) -> %
       recip : % -> Union(%,"failed")        relerror : (%,%) -> Integer
       ?rem? : (%,%) -> %                    retract : % -> Fraction(Integer)
       retract : % -> Integer                round : % -> %
       sample : () -> %                      sec : % -> %
       sech : % -> %                         shift : (%,Integer) -> %
       sign : % -> Integer                   sin : % -> %
       sinh : % -> %                         sizeLess? : (%,%) -> Boolean
       smaller? : (%,%) -> Boolean           sqrt : % -> %
       squareFree : % -> Factored(%)         squareFreePart : % -> %
       tan : % -> %                          tanh : % -> %
       truncate : % -> %                     unit? : % -> Boolean
       unitCanonical : % -> %                wholePart : % -> Integer
       zero? : % -> Boolean                  ?~=? : (%,%) -> Boolean
       ?*? : (NonNegativeInteger,%) -> %
       OMwrite : (OpenMathDevice,%,Boolean) -> Void
       OMwrite : (OpenMathDevice,%) -> Void
       ?^? : (%,NonNegativeInteger) -> %
       bits : PositiveInteger -> PositiveInteger if $ has ATARBPR
       characteristic : () -> NonNegativeInteger
       decreasePrecision : Integer -> PositiveInteger if $ has ATARBPR
       differentiate : (%,NonNegativeInteger) -> %
       digits : PositiveInteger -> PositiveInteger if $ has ATARBPR
       divide : (%,%) -> Record(quotient: %,remainder: %)
       euclideanSize : % -> NonNegativeInteger
       expressIdealMember : (List(%),%) -> Union(List(%),"failed")
       exquo : (%,%) -> Union(%,"failed")
       extendedEuclidean : (%,%,%) -> Union(Record(coef1: %,coef2: %),"failed")
       extendedEuclidean : (%,%) -> Record(coef1: %,coef2: %,generator: %)
       float : (Integer,Integer,PositiveInteger) -> %
       gcdPolynomial : (SparseUnivariatePolynomial(%),SparseUnivariatePolynomial(%)) -> SparseUnivariatePolynomial(%)
       increasePrecision : Integer -> PositiveInteger if $ has ATARBPR
       max : () -> % if not(has($,arbitraryExponent)) and not(has($,arbitraryPrecision))
       min : () -> % if not(has($,arbitraryExponent)) and not(has($,arbitraryPrecision))
       multiEuclidean : (List(%),%) -> Union(List(%),"failed")
       outputFixed : NonNegativeInteger -> Void
       outputFloating : NonNegativeInteger -> Void
       outputGeneral : NonNegativeInteger -> Void
       outputSpacing : NonNegativeInteger -> Void
       patternMatch : (%,Pattern(Float),PatternMatchResult(Float,%)) -> PatternMatchResult(Float,%)
       precision : PositiveInteger -> PositiveInteger if $ has ATARBPR
       principalIdeal : List(%) -> Record(coef: List(%),generator: %)
       rationalApproximation : (%,NonNegativeInteger,NonNegativeInteger) -> Fraction(Integer)
       rationalApproximation : (%,NonNegativeInteger) -> Fraction(Integer)
       retractIfCan : % -> Union(Fraction(Integer),"failed")
       retractIfCan : % -> Union(Integer,"failed")
       subtractIfCan : (%,%) -> Union(%,"failed")
       unitNormal : % -> Record(unit: %,canonical: %,associate: %)
      
      
.   %/output


        	



FriCAS can be used as a numerical engine.

%_fricas,title=""
tan(sin(1.0)*exp(3.5)) 
%/_fricas

    %output,preserve="false"
      tan(sin(1.0)*exp(3.5))
       
      
         (25)  - 0.4330175174 1640407036
                                                                        Type: Float
      
.   %/output


        	



%_fricas,title=""
log(abs(-3.0*sin(2*3.1415))) 
%/_fricas

    %output,preserve="false"
      log(abs(-3.0*sin(2*3.1415)))
       
      
         (26)  - 7.4948833967 339587459
                                                                        Type: Float
      
.   %/output


        	


Referring to previous results

FriCAS uses % to refer to the previous result. Using %%(n) with a positive integer n, refers to the n-th computed output, 
while the expression %%(-n) counts from the current line number backwards and refers to this output.

%_fricas,title=""
11 
%/_fricas

    %output,preserve="false"
      11
       
      
         (27)  11
                                                              Type: PositiveInteger
      
.   %/output


        	



%_fricas,title=""
22 
%/_fricas

    %output,preserve="false"
      22
       
      
         (28)  22
                                                              Type: PositiveInteger
      
.   %/output


        	


%_fricas,title=""
% 
%/_fricas

    %output,preserve="false"
            %
             
            
               (29)  22
                                                                    Type: PositiveInteger
            
.   %/output


        	



%_fricas,title=""
%%(-3)
%/_fricas

    %output,preserve="false"
      %%(-3)
       
      
         (30)  11
                                                              Type: PositiveInteger
      
.   %/output

 
        	


%_fricas,title=""
%%(3)
%/_fricas

    %output,preserve="false"
      %%(3)
       
      
         (31)  20
                                                              Type: PositiveInteger
      
.   %/output

 
        	



Computation with symbols

Entering variables is as easy as in most other CAS.

%_fricas,title=""
4*x^2+4*x+1
%/_fricas

    %output,preserve="false"
      4*x^2+4*x+1
       
      
                 2
         (32)  4x  + 4x + 1
                                                          Type: Polynomial(Integer)
      
.   %/output

 
        	


Note that the resulting domain is not Polynomial(Integer).

%_fricas,title=""
factor(%) 
%/_fricas

    %output,preserve="false"
      factor(%)
       
      
                       2
         (33)  (2x + 1)
                                                Type: Factored(Polynomial(Integer))
      
.   %/output


        	



The domain Factored(X) keeps its elements in a factored form as long as possible.

%_fricas,title=""
factor((x^2-1))
%/_fricas

    %output,preserve="false"
      factor((x^2-1))
       
      
         (34)  (x - 1)(x + 1)
                                                Type: Factored(Polynomial(Integer))
      
.   %/output

 
        	



%_fricas,title=""
%*(x-1)
%/_fricas

    %output,preserve="false"
        %*(x-1)
         
        
                        2
           (35)  (x - 1) (x + 1)
                                                  Type: Factored(Polynomial(Integer))
            
.   %/output

 
        	



%_fricas,title=""
%+1
%/_fricas

    %output,preserve="false"
      %+1
       
      
                3    2
         (36)  x  - x  - x + 2
                                                Type: Factored(Polynomial(Integer))
      
.   %/output

 
        	



But since factorization is costly, elements are not automatically factored.

Delaying computation to the time when an actual result is needed is usually a good idea, since working symbolically with the operations can save computational effort.

%_fricas,title=""
%-1
%/_fricas

    %output,preserve="false"
            %-1
             
            
                      3    2
               (37)  x  - x  - x + 1
                                                      Type: Factored(Polynomial(Integer))
            
.   %/output

 
        	



%_fricas,title=""
factor % 
%/_fricas

    %output,preserve="false"
      factor %
       
      
                      2
         (38)  (x - 1) (x + 1)
                                                Type: Factored(Polynomial(Integer))
      
.   %/output


        	



FriCAS knows about the standard mathematical functions. And can do computations with them.

%_fricas,title=""
sin(x)*exp(x) 
%/_fricas

    %output,preserve="false"
      sin(x)*exp(x)
       
      
                 x
         (39)  %e sin(x)
                                                          Type: Expression(Integer)
      
.   %/output


        	



Some mathematical constants and their properties are built-in.

%_fricas,title=""
%e 
%/_fricas

    %output,preserve="false"
      %e
       
      
         (40)  %e
                                                          Type: Expression(Integer)
      
.   %/output


        	



%_fricas,title=""
%pi
%/_fricas

    %output,preserve="false"
      %pi
       
      
         (41)  %pi
                                                                           Type: Pi
      
.   %/output

 
        	



%_fricas,title=""
%e^(%pi * %i) 
%/_fricas

    %output,preserve="false"
      %e^(%pi * %i)
       
      
         (42)  - 1
                                                 Type: Expression(Complex(Integer))
      
.   %/output


        	



Expressions vs. specific types

Eagerness of evaluation of an expression depends on its type. In fact, each type defines a certain normal form and the expression is simply stored in this form.

%_fricas,title=""
(x^100 + 1)*(x^100-1)
%/_fricas

    %output,preserve="false"
      (x^100 + 1)*(x^100-1)
       
      
                200
         (43)  x    - 1
                                                          Type: Polynomial(Integer)
      
.   %/output

 
        	



%_fricas,title=""
(x^50-1)/(x-1) 
%/_fricas

    %output,preserve="false"
      (x^50-1)/(x-1)
       
      
         (44)
            49    48    47    46    45    44    43    42    41    40    39    38    37
           x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x
         + 
            36    35    34    33    32    31    30    29    28    27    26    25    24
           x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x
         + 
            23    22    21    20    19    18    17    16    15    14    13    12    11
           x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x   + x
         + 
            10    9    8    7    6    5    4    3    2
           x   + x  + x  + x  + x  + x  + x  + x  + x  + x + 1
                                                Type: Fraction(Polynomial(Integer))
      
.   %/output


        	



The domain Expression(Integer) is similar to the way expressions are stored in other computer algebra systems.

If FriCAS does not find a more appropriate interpretation for an expresssion, the expression often ends up in being of type Expression(Integer).

%_fricas,title=""
sin(%pi/3)
%/_fricas

    %output,preserve="false"
      sin(%pi/3)
       
      
                +-+
               \|3
         (45)  ----
                 2
                                                          Type: Expression(Integer)
      
.   %/output

 
        	



%_fricas,title=""
sin(x)^2 + cos(x)^2 
%/_fricas

    %output,preserve="false"
      sin(x)^2 + cos(x)^2
       
      
                     2         2
         (46)  sin(x)  + cos(x)
                                                          Type: Expression(Integer)
      
.   %/output


        	


Some expressions are not automatically simplified.

%_fricas,title=""
simplify(%)
%/_fricas

    %output,preserve="false"
      simplify(%)
       
      
         (47)  1
                                                          Type: Expression(Integer)
      
.   %/output

 
        	



In some cases, it is simply not clear what a "simpler expression" actually means.

%_fricas,title=""
simplify(sin(2*x)) 
%/_fricas

    %output,preserve="false"
      simplify(sin(2*x))
       
      
         (48)  sin(2x)
                                                          Type: Expression(Integer)
      
.   %/output


        	



%_fricas,title=""
simplify(2*sin(x)*cos(x))
%/_fricas

    %output,preserve="false"
      simplify(2*sin(x)*cos(x))
       
      
         (49)  2cos(x)sin(x)
                                                          Type: Expression(Integer)
      
.   %/output

 
        	



Variables, Assignments, Equations, Declarations

In addition to accessing previoiusly computed values via the %%(n) mechanism, intermediate results can also be stored in variables.

%_fricas,title=""
a := 1/3 + 22/7
%/_fricas

    %output,preserve="false"
      a := 1/3 + 22/7
       
      
               73
         (50)  --
               21
                                                            Type: Fraction(Integer)
      
.   %/output

 
        	



%_fricas,title=""
a
%/_fricas

    %output,preserve="false"
      a
       
      
               73
         (51)  --
               21
                                                            Type: Fraction(Integer)
      
.   %/output


        	



Assignment is done via :=. A simple = sign just creates an equation.

%_fricas,title=""
A = 1/3 + 22/7 
%/_fricas

    %output,preserve="false"
      A = 1/3 + 22/7
       
      
                  73
         (52)  A= --
                  21
                                      Type: Equation(Polynomial(Fraction(Integer)))
      
.   %/output


        	



FriCAS is case-sensitive.

%_fricas,title=""
A 
%/_fricas

    %output,preserve="false"
      A
       
      
         (53)  A
                                                                  Type: Variable(A)
      
.   %/output


        	



%_fricas,title=""
A = lhs(%%(-2))
%/_fricas

    %output,preserve="false"
      A = lhs(%%(-2))
       
      
         (54)  A= A
                                      Type: Equation(Polynomial(Fraction(Integer)))
      
.   %/output

 
        	



In order to see whether an equation is true or false, we must turn it into a boolean.

%_fricas,title=""
%::Boolean
%/_fricas

    %output,preserve="false"
      %::Boolean
       
      
         (55)  true
                                                                      Type: Boolean
      
.   %/output

 
        	



%_fricas,title=""
(A=10)::Boolean
%/_fricas

    %output,preserve="false"
      (A=10)::Boolean
       
      
         (56)  false
                                                                      Type: Boolean
      
.   %/output

 
        	



The type of a variable can be declared in advance. Its type is then fixed for the whole session.

%_fricas,title=""
v: PositiveInteger
%/_fricas

    %output,preserve="false"
      v: PositiveInteger
       
                                                                         Type: Void
      
.   %/output

 
        	



%_fricas,title=""
v := 1/2 
%/_fricas

    %output,preserve="false"
      v := 1/2
       
       
         Cannot convert right-hand side of assignment
         0.5
      
            to an object of the type PositiveInteger of the left-hand side.
      
.   %/output


        	




If a variable has been declared, it is no longer automatically converted to an indeterminate that can be used in an expression.

%_fricas,title=""
5*v
%/_fricas

    %output,preserve="false"
      5*v
       
       
         v is declared as being in PositiveInteger but has not been given a 
            value.
      
.   %/output

 
        	

 


One would have to prepend an apostroph to refer to a symbol of that name.

%_fricas,title=""
5 * 'v
%/_fricas

    %output,preserve="false"
      5 * 'v
       
      
         (58)  5v
                                                          Type: Polynomial(Integer)
      
.   %/output

 
        	



Only values that belong to the respective type can be assigned to the variable.

%_fricas,title=""
v := -1
%/_fricas

    %output,preserve="false"
      v := -1
       
         Compiling function G849 with type Integer -> Boolean 
       
         Cannot convert right-hand side of assignment
         - 1
      
            to an object of the type PositiveInteger of the left-hand side.
      
.   %/output

 
        	



%_fricas,title=""
v := 1
%/_fricas

    %output,preserve="false"
      v := 1
       
      
         (59)  1
                                                              Type: PositiveInteger
      
.   %/output

 
        	



Functions

Functions, are first class objects, they can be assigned to variables and can be used as arguments of functions.

The operator +-> is used to created anonymous functions, i.e. lambda expressions.

%_fricas,title=""
f := x +-> sin(x)*exp(x)
%/_fricas

    %output,preserve="false"
      f := x +-> sin(x)*exp(x)
       
      
         (60)  x +-> sin(x)exp(x)
                                                            Type: AnonymousFunction
      
.   %/output

 
        	



%_fricas,title=""
f(%pi/3) 
%/_fricas

    %output,preserve="false"
      f(%pi/3)
       
      
                     %pi
                     ---
                +-+   3
               \|3 %e
         (61)  ---------
                   2
                                                          Type: Expression(Integer)
      
.   %/output


        	



Simply using an expression in a functional way makes no sense.

%_fricas,title=""
g := sin(x)*exp(x)
%/_fricas

    %output,preserve="false"
      g := sin(x)*exp(x)
       
      
                 x
         (62)  %e sin(x)
                                                          Type: Expression(Integer)
      
.   %/output

 
        	



%_fricas,title=""
g(%pi/2)
%/_fricas

    %output,preserve="false"
      g(%pi/2)
       
         There are no library operations named g 
            Use HyperDoc Browse or issue
                                       )what op g
            to learn if there is any operation containing " g " in its name.
       
         Cannot find a definition or applicable library operation named g 
            with argument type(s) 
                                           Pi
            
            Perhaps you should use "@" to indicate the required return type, 
            or "$" to specify which version of the function you need.
      
.   %/output

 
        	




%_fricas,title=""
eval(g, x=%pi/2) 
%/_fricas

    %output,preserve="false"
      eval(g, x=%pi/2)
       
      
                 %pi
                 ---
                  2
         (63)  %e
                                                          Type: Expression(Integer)
      
.   %/output


        	



Declaring the type of a function explicitly, restricts the way the function can be used.

%_fricas,title=""
f1: Integer -> Integer 
%/_fricas

    %output,preserve="false"
      f1: Integer -> Integer
       
                                                                         Type: Void
      
.   %/output


        	


%_fricas,title=""
f1 := x +-> gcd(x,x+6) 
%/_fricas

    %output,preserve="false"
      f1 := x +-> gcd(x,x+6)
       
      
         (65)  theMap(*1;anonymousFunction;1;frame1;internal)
                                                         Type: (Integer -> Integer)
      
.   %/output


        	



%_fricas,title=""
f1(18)
%/_fricas

    %output,preserve="false"
      f1(18)
       
      
         (66)  6
                                                              Type: PositiveInteger
      
.   %/output

 
        	



%_fricas,title=""
f1(2.3) 
%/_fricas

    %output,preserve="false"
      f1(2.3)
       
         There are no library operations named f1 
            Use HyperDoc Browse or issue
                                       )what op f1
            to learn if there is any operation containing " f1 " in its name.
       
         Cannot find a definition or applicable library operation named f1 
            with argument type(s) 
                                          Float
            
            Perhaps you should use "@" to indicate the required return type, 
            or "$" to specify which version of the function you need.
      
.   %/output


        	



Functions can also be defined via the "delayed assignment" using ==.

%_fricas,title=""
f2(x: Integer): String == reverse(string(x))
%/_fricas

    %output,preserve="false"
      f2(x: Integer): String == reverse(string(x))
       
         Function declaration f2 : Integer -> String has been added to 
            workspace.
                                                                         Type: Void
      
.   %/output

 
        	



Functions will automatically be compiled to machine code, the first time they are used.

%_fricas,title=""
f2(123453) 
%/_fricas

    %output,preserve="false"
      f2(123453)
       
         Compiling function f2 with type Integer -> String 
      
         (68)  "354321"
                                                                       Type: String
      
.   %/output


        	



The function cannot be applied to strings, because that would require the string to be converted into an integer.

%_fricas,title=""
f2("FriCAS") 
%/_fricas

    %output,preserve="false"
      f2("FriCAS")
       
         Conversion failed in the compiled user function f2 .
       
         Cannot convert from type String to Integer for value
         "FriCAS"
      
      
.   %/output


        	



Multivariate function definitions are no problem.

%_fricas,title=""
f3(x,y,z) == (x+2*y)*z 
%/_fricas

    %output,preserve="false"
      f3(x,y,z) == (x+2*y)*z
       
                                                                         Type: Void
      
.   %/output


        	



%_fricas,title=""
f3(3,4,2)
%/_fricas

    %output,preserve="false"
      f3(3,4,2)
       
         Compiling function f3 with type (PositiveInteger,PositiveInteger,
            PositiveInteger) -> PositiveInteger 
      
         (71)  22
                                                              Type: PositiveInteger
      
.   %/output

 
        	



%_fricas,title=""
f3(3.2,4.1,2) 
%/_fricas

    %output,preserve="false"
      f3(3.2,4.1,2)
       
         Compiling function f3 with type (Float,Float,PositiveInteger) -> 
            Float 
      
         (72)  22.8
                                                                        Type: Float
      
.   %/output


        	




