%beanshell
import javax.swing.*;
import javax.swing.event.*;
import java.util.ArrayList;

JEditorPane editorPane = new JEditorPane();
editorPane.setEditable(false);
editorPane.addHyperlinkListener(this);
//java.net.URL helpURL =new java.net.URL( "file:///C:/ted/download/yacas_manual/refchapter26.html#c26");

java.net.URL helpURL = jEdit.getPlugin("org.mathrider.yacasdocsplugin.YacasDocsPlugin").getPluginJAR().getClassLoader().getResource("yacas_manual/Algochapter1.html");

if (helpURL != null) {
    try {
        editorPane.setPage(helpURL);
    } catch (IOException e) {
        System.err.println("Attempted to read a bad URL: " + helpURL);
    }
} else {
    System.err.println("Couldn't find file: TextSamplerDemoHelp.html");
}

//Put the editor pane in a scroll pane.
JScrollPane editorScrollPane = new JScrollPane(editorPane);
editorScrollPane.setVerticalScrollBarPolicy(
                JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
//editorScrollPane.setPreferredSize(new Dimension(250, 145));
//editorScrollPane.setMinimumSize(new Dimension(10, 10));



import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
docker = jEdit.getActiveView().getDockableWindowManager();
frame = new javax.swing.JFrame();
guiBox = new Box(BoxLayout.Y_AXIS);
messageTextField = new JTextField();
guiBox.add(messageTextField);
button1 = new JButton("Close GeoGebra");
button1.setBackground(Color.green);
button1.addActionListener(this);
guiBox.add(button1);
button2 = new JButton("Open GeoGebra");
button2.setBackground(Color.yellow);
button2.addActionListener(this);
guiBox.add(button2);
contentPane = frame.getContentPane();
contentPane.add(editorScrollPane);//guiBox,BorderLayout.NORTH);
frame.pack();
frame.setAlwaysOnTop(true);
frame.setTitle("MathRider");
frame.setSize(new Dimension(400, 400));
frame.setResizable(true);
frame.setPreferredSize(new Dimension(250, 200));
frame.setLocationRelativeTo(null); // added
frame.show();

actionPerformed(event)
{
    src = event.getSource();

    if (src == button1)
    {
      messageTextField.setText("GeoGebra closed.");
      docker.hideDockableWindow( "geogebra" );
    }
    else if (src == button2)
    {
      messageTextField.setText("GeoGebra opened.");
      docker.showDockableWindow( "geogebra" );
    }

}//end method



hyperlinkUpdate(event)
{
  url = event.getURL();
  System.out.println("YYYY: " + url.getPath() + " reference: " + url.getRef() + " query: " + url.getQuery() );
  if(event.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
  {
    reference = url.getRef();
    query = url.getQuery();
    if(reference != null)
    {
        editorPane.setPage(url);
    }
    else
    {   
        match = findFileForFunctionInref(query);
        if(! match.equals(""))
        {
            path = url.getPath();
            path = path.replaceFirst("ref.html", match);
            path = path + "#" + query;
            path = "file://" + path;
            System.out.println("TTT path: " + path );
            url2 = new URL(path);
            editorPane.setPage(url2);
        }//end if
    }
    
  }//end if.  + getRef())
}//end method.





findFileForFunctionInref(seach) 
{

funcs_refchapter1 = new String[] {};
funcs_refchapter2 =  new String[]{
"+"
, "-"
, "*"
, "/"
, "^"
, "Div"
, "Mod"
, "Gcd"
, "Lcm"
, "<<"
, ">>"
, "FromBase"
, "ToBase"
, "N"
, "Rationalize"
, "ContFrac"
, "Decimal"
, "Floor"
, "Ceil"
, "Round"
, "Min"
, "Max"
, "Numer"
, "Denom"
, "Pslq"
};
funcs_refchapter3 = new String[]{
"<"
, ">"
, "<="
, ">="
, "IsZero"
, "IsRational"
};
funcs_refchapter4 = new String[]{
"Sin"
, "Cos"
, "Tan"
, "ArcSin"
, "ArcCos"
, "ArcTan"
, "Exp"
, "Ln"
, "Sqrt"
, "Abs"
, "Sign"
, "D"
, "Curl"
, "Diverge"
, "Integrate"
, "Limit"
};
funcs_refchapter5 = new String[]{
"Random, RandomSeed"
, "RngCreate"
, "RngSeed"
, "Rng"
, "RandomIntegerMatrix"
, "RandomIntegerVector"
, "RandomPoly"
};
funcs_refchapter6 = new String[]{
"Add"
, "Sum"
, "Factorize"
, "Taylor"
, "InverseTaylor"
, "ReversePoly"
, "BigOh"
, "LagrangeInterpolant"
};
funcs_refchapter7 = new String[]{
"!"
, "!!"
, "***"
, "Subfactorial"
, "Bin"
, "Eulerian"
, "LeviCivita"
, "Permutations"
};
funcs_refchapter8 = new String[]{
"Gamma"
, "Zeta"
, "Bernoulli"
, "Euler"
, "LambertW"
};
funcs_refchapter9 = new String[]{
"Complex"
, "Re"
, "Im"
, "I"
, "Conjugate"
, "Arg"
};
funcs_refchapter10 = new String[]{
"LaplaceTransform"
};
funcs_refchapter11 = new String[]{
"Simplify"
, "RadSimp"
, "FactorialSimplify"
, "LnExpand"
, "LnCombine"
, "TrigSimpCombine"
};
funcs_refchapter12 = new String[]{
"Solve"
, "OldSolve"
, "SuchThat"
, "Eliminate"
, "PSolve"
, "MatrixSolve"
};
funcs_refchapter13 = new String[]{
"Newton"
, "FindRealRoots"
, "NumRealRoots"
, "MinimumBound"
, "MaximumBound"
};
funcs_refchapter14 = new String[]{
"CanProve"
};
funcs_refchapter15 = new String[]{
"OdeSolve"
, "OdeTest"
, "OdeOrder"
};
funcs_refchapter16 = new String[]{
"Dot, ."
, "InProduct"
, "CrossProduct"
, "Outer, o"
, "ZeroVector"
, "BaseVector"
, "Identity"
, "ZeroMatrix"
, "Diagonal"
, "DiagonalMatrix"
, "OrthogonalBasis"
, "OrthonormalBasis"
, "Normalize"
, "Transpose"
, "Determinant"
, "Trace"
, "Inverse"
, "Minor"
, "CoFactor"
, "MatrixPower"
, "SolveMatrix"
, "CharacteristicEquation"
, "EigenValues"
, "EigenVectors"
, "Sparsity"
, "Cholesky"
};
funcs_refchapter17 = new String[]{
"IsScalar"
, "IsVector"
, "IsMatrix"
, "IsSquareMatrix"
, "IsHermitian"
, "IsOrthogonal"
, "IsDiagonal"
, "IsLowerTriangular"
, "IsUpperTriangular"
, "IsSymmetric"
, "IsSkewSymmetric"
, "IsUnitary"
, "IsIdempotent"
};
funcs_refchapter18 = new String[]{
"JacobianMatrix"
, "VandermondeMatrix"
, "HessianMatrix"
, "HilbertMatrix"
, "HilbertInverseMatrix"
, "ToeplitzMatrix"
, "WronskianMatrix"
, "SylvesterMatrix"
};
funcs_refchapter19 = new String[]{
"Expand"
, "Degree"
, "Coef"
, "Content"
, "PrimitivePart"
, "LeadingCoef"
, "Monic"
, "SquareFree"
, "Horner"
, "ExpandBrackets"
, "EvaluateHornerScheme"
};
funcs_refchapter20 = new String[]{
"OrthoP"
, "OrthoH"
, "OrthoG"
, "OrthoL"
, "OrthoT"
, "OrthoU"
, "OrthoPSum"
, "OrthoHSum"
, "OrthoLSum"
, "OrthoGSum"
, "OrthoTSum"
, "OrthoUSum"
, "OrthoPoly"
, "OrthoPolySum"
};
funcs_refchapter21 = new String[]{
"Head"
, "Tail"
, "Length"
, "Map"
, "MapSingle"
, "MakeVector"
, "Select"
, "Nth"
, "DestructiveReverse"
, "Reverse"
, "List"
, "UnList"
, "Listify"
, "Concat"
, "Delete"
, "Insert"
, "DestructiveDelete"
, "DestructiveInsert"
, "Replace"
, "DestructiveReplace"
, "FlatCopy"
, "Contains"
, "Find"
, "Append"
, "DestructiveAppend"
, "RemoveDuplicates"
, "Push"
, "Pop"
, "PopFront"
, "PopBack"
, "Swap"
, "Count"
, "Intersection"
, "Union"
, "Difference"
, "FillList"
, "Drop"
, "Take"
, "Partition"
, "Assoc"
, "AssocIndices"
, "AssocDelete"
, "Flatten"
, "UnFlatten"
, "Type"
, "NrArgs"
, "VarList"
, "VarListArith"
, "VarListSome"
, "FuncList"
, "FuncListArith"
, "FuncListSome"
, "BubbleSort"
, "HeapSort"
, "PrintList"
, "Table"
, "TableForm"
, "GlobalPop"
, "GlobalPush"
};
funcs_refchapter22 = new String[]{
":"
, "@"
, "/@"
, ".."
, "NFunction"
, "Where"
, "AddTo"
};
funcs_refchapter23 = new String[]{
"MaxEvalDepth"
, "Hold"
, "Eval"
, "While"
, "Until"
, "If"
, "SystemCall"
, "Function"
, "Macro"
, "Use"
, "For"
, "ForEach"
, "Apply"
, "MapArgs"
, "Subst"
, "WithValue"
, "/:"
, "/::"
, "TraceStack"
, "TraceExp"
, "TraceRule"
, "Time"
};
funcs_refchapter24 = new String[]{
"!="
, "="
, "Not"
, "And"
, "Or"
, "IsFreeOf"
, "IsZeroVector"
, "IsNonObject"
, "IsEven"
, "IsOdd"
, "IsEvenFunction"
, "IsOddFunction"
, "IsFunction"
, "IsAtom"
, "IsString"
, "IsNumber"
, "IsList"
, "IsNumericList"
, "IsBound"
, "IsBoolean"
, "IsNegativeNumber"
, "IsNegativeInteger"
, "IsPositiveNumber"
, "IsPositiveInteger"
, "IsNotZero"
, "IsNonZeroInteger"
, "IsInfinity"
, "IsPositiveReal"
, "IsNegativeReal"
, "IsConstant"
, "IsGaussianInteger"
, "MatchLinear"
, "HasExpr"
, "HasExprArith"
, "HasExprSome"
, "HasFunc"
, "HasFuncArith"
, "HasFuncSome"
};
funcs_refchapter25 = new String[]{
"%"
, "True"
, "False"
, "EndOfFile"
};
funcs_refchapter26 = new String[]{
"Infinity"
, "Pi"
, "Undefined"
, "GoldenRatio"
, "Catalan"
, "gamma"
};
funcs_refchapter27 = new String[]{
":="
, "Set"
, "Clear"
, "Local"
, "++"
, "--"
, "Object"
, "SetGlobalLazyVariable"
, "UniqueConstant"
, "LocalSymbols"
};
funcs_refchapter28 = new String[]{
"FullForm"
, "Echo"
, "PrettyForm"
, "EvalFormula"
, "TeXForm"
, "CForm"
, "IsCFormable"
, "Write"
, "WriteString"
, "Space"
, "NewLine"
, "FromFile"
, "FromString"
, "ToFile"
, "ToString"
, "Read"
, "ToStdout"
, "ReadCmdLineString"
, "LispRead"
, "LispReadListed"
, "ReadToken"
, "Load"
, "Use"
, "DefLoad"
, "FindFile"
, "PatchLoad"
, "Nl"
, "V, InVerboseMode"
, "Plot2D"
, "Plot3DS"
, "XmlExplodeTag"
, "DefaultTokenizer"
, "XmlTokenizer"
, "OMForm"
, "OMRead"
, "OMDef"
};
funcs_refchapter29 = new String[]{
"StringMid'Set"
, "StringMid'Get"
, "String"
, "Atom"
, "ConcatStrings"
, "PatchString"
};
funcs_refchapter30 = new String[]{
"BernoulliDistribution"
, "BinomialDistribution"
, "tDistribution"
, "PDF"
, "ChiSquareTest"
};
funcs_refchapter31 = new String[]{
"IsPrime"
, "IsSmallPrime"
, "IsComposite"
, "IsCoprime"
, "IsSquareFree"
, "IsPrimePower"
, "NextPrime"
, "IsTwinPrime"
, "IsIrregularPrime"
, "IsCarmichaelNumber"
, "Factors"
, "IsAmicablePair"
, "Factor"
, "Divisors"
, "DivisorsSum"
, "ProperDivisors"
, "ProperDivisorsSum"
, "Moebius"
, "CatalanNumber"
, "FermatNumber"
, "HarmonicNumber"
, "StirlingNumber1"
, "StirlingNumber2"
, "DivisorsList"
, "SquareFreeDivisorsList"
, "MoebiusDivisorsList"
, "SumForDivisors"
, "RamanujanSum"
, "Cyclotomic"
, "PAdicExpand"
, "IsQuadraticResidue"
, "LegendreSymbol"
, "JacobiSymbol"
, "GaussianFactors"
, "GaussianNorm"
, "IsGaussianUnit"
, "IsGaussianPrime"
, "GaussianGcd"
};
funcs_refchapter32 = new String[]{
};

  if (containsFunc(funcs_refchapter1,seach))
    return "refchapter1.html";
  if (containsFunc(funcs_refchapter2,seach))
    return "refchapter2.html";
  if (containsFunc(funcs_refchapter3,seach))
    return "refchapter3.html";
  if (containsFunc(funcs_refchapter4,seach))
    return "refchapter4.html";
  if (containsFunc(funcs_refchapter5,seach))
    return "refchapter5.html";
  if (containsFunc(funcs_refchapter6,seach))
    return "refchapter6.html";
  if (containsFunc(funcs_refchapter7,seach))
    return "refchapter7.html";
  if (containsFunc(funcs_refchapter8,seach))
    return "refchapter8.html";
  if (containsFunc(funcs_refchapter9,seach))
    return "refchapter9.html";
  if (containsFunc(funcs_refchapter10,seach))
    return "refchapter10.html";
  if (containsFunc(funcs_refchapter11,seach))
    return "refchapter11.html";
  if (containsFunc(funcs_refchapter12,seach))
    return "refchapter12.html";
  if (containsFunc(funcs_refchapter13,seach))
    return "refchapter13.html";
  if (containsFunc(funcs_refchapter14,seach))
    return "refchapter14.html";
  if (containsFunc(funcs_refchapter15,seach))
    return "refchapter15.html";
  if (containsFunc(funcs_refchapter16,seach))
    return "refchapter16.html";
  if (containsFunc(funcs_refchapter17,seach))
    return "refchapter17.html";
  if (containsFunc(funcs_refchapter18,seach))
    return "refchapter18.html";
  if (containsFunc(funcs_refchapter19,seach))
    return "refchapter19.html";
  if (containsFunc(funcs_refchapter20,seach))
    return "refchapter20.html";
  if (containsFunc(funcs_refchapter21,seach))
    return "refchapter21.html";
  if (containsFunc(funcs_refchapter22,seach))
    return "refchapter22.html";
  if (containsFunc(funcs_refchapter23,seach))
    return "refchapter23.html";
  if (containsFunc(funcs_refchapter24,seach))
    return "refchapter24.html";
  if (containsFunc(funcs_refchapter25,seach))
    return "refchapter25.html";
  if (containsFunc(funcs_refchapter26,seach))
    return "refchapter26.html";
  if (containsFunc(funcs_refchapter27,seach))
    return "refchapter27.html";
  if (containsFunc(funcs_refchapter28,seach))
    return "refchapter28.html";
  if (containsFunc(funcs_refchapter29,seach))
    return "refchapter29.html";
  if (containsFunc(funcs_refchapter30,seach))
    return "refchapter30.html";
  if (containsFunc(funcs_refchapter31,seach))
    return "refchapter31.html";
  if (containsFunc(funcs_refchapter32,seach))
    return "refchapter32.html";
  return "";
 
  
}//end method.






findFileForFunctionInrefprog(seach) {
funcs_refprogchapter1 = new String[]{};
funcs_refprogchapter2 = new String[]{
"/*"
, "*/"
, "//"
, "Prog"
, "["
, "]"
, "Bodied"
, "Infix"
, "Postfix"
, "Prefix"
, "IsBodied"
, "IsInfix"
, "IsPostfix"
, "IsPrefix"
, "OpPrecedence"
, "OpLeftPrecedence"
, "OpRightPrecedence"
, "RightAssociative"
, "LeftPrecedence"
, "RightPrecedence"
, "RuleBase"
, "RuleBaseListed"
, "Rule"
, "HoldArg"
, "Retract"
, "UnFence"
, "HoldArgNr"
, "RuleBaseArgList"
, "MacroSet"
, "MacroClear"
, "MacroLocal"
, "MacroRuleBase"
, "MacroRuleBaseListed"
, "MacroRule"
, "Backquoting"
, "DefMacroRuleBase"
, "DefMacroRuleBaseListed"
, "ExtraInfo'Set, ExtraInfo'Get"
, "GarbageCollect"
, "FindFunction"
, "Secure"
};
funcs_refprogchapter3 = new String[]{
"MultiplyNum"
, "CachedConstant"
, "NewtonNum"
, "SumTaylorNum"
, "IntPowerNum"
, "BinSplitNum"
, "BinSplitData"
, "BinSplitFinal"
, "MathSetExactBits"
, "MathGetExactBits"
, "InNumericMode"
, "NonN"
, "IntLog"
, "IntNthRoot"
, "NthRoot"
, "ContFracList"
, "ContFracEval"
, "GuessRational"
, "NearRational"
, "BracketRational"
, "TruncRadian"
, "Builtin'Precision'Set"
, "Builtin'Precision'Get"
};
funcs_refprogchapter4 = new String[]{
"Check"
, "TrapError"
, "GetCoreError"
, "Assert"
, "DumpErrors"
, "ClearErrors"
, "IsError"
, "GetError"
, "ClearError"
, "GetErrorTableau"
, "CurrentFile"
, "CurrentLine"
};
funcs_refprogchapter5 = new String[]{
"MathNot"
, "MathAnd"
, "MathOr"
, "BitAnd"
, "BitOr"
, "BitXor"
, "Equals"
, "GreaterThan"
, "LessThan"
, "Math..."
, "Fast..."
, "ShiftLeft"
, "ShiftRight"
, "IsPromptShown"
, "GetTime"
};
funcs_refprogchapter6 = new String[]{
"IsGeneric"
, "GenericTypeName"
, "Array'Create"
, "Array'Size"
, "Array'Get"
, "Array'Set"
, "Array'CreateFromList"
, "Array'ToList"
};
funcs_refprogchapter7 = new String[]{
"Verify"
, "TestYacas"
, "LogicVerify"
, "LogicTest"
, "KnownFailure"
, "RoundTo"
, "VerifyArithmetic"
, "RandVerifyArithmetic"
, "VerifyDiv"
};
funcs_refprogchapter8 = new String[]{
};
funcs_refprogchapter9 = new String[]{
};
funcs_refprogchapter10 = new String[]{
};
  if (containsFunc(funcs_refprogchapter1,seach))
    return "refprogchapter1.html";
  if (containsFunc(funcs_refprogchapter2,seach))
    return "refprogchapter2.html";
  if (containsFunc(funcs_refprogchapter3,seach))
    return "refprogchapter3.html";
  if (containsFunc(funcs_refprogchapter4,seach))
    return "refprogchapter4.html";
  if (containsFunc(funcs_refprogchapter5,seach))
    return "refprogchapter5.html";
  if (containsFunc(funcs_refprogchapter6,seach))
    return "refprogchapter6.html";
  if (containsFunc(funcs_refprogchapter7,seach))
    return "refprogchapter7.html";
  if (containsFunc(funcs_refprogchapter8,seach))
    return "refprogchapter8.html";
  if (containsFunc(funcs_refprogchapter9,seach))
    return "refprogchapter9.html";
  if (containsFunc(funcs_refprogchapter10,seach))
    return "refprogchapter10.html";
  return "";
}//end method.


findFileForFunction(seach)
{
  file = "";
  if (file.equals(""))
    file = findFileForFunctionInref(seach);
  if (file.equals(""))
    file = findFileForFunctionInrefprog(seach);
  return file;
}//end method.

containsFunc(chapter,func)
{
  for (i=0;i<chapter.length;i++)
  {
    if (chapter[i].equals(func))
      return true;
  }
  return false;
}

     %output 
      
     %end

%end
