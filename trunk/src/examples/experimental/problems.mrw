%group

    %piper,output="geogebra"  //Note: make indent level of output one more level than the indent level of the fold.  
        Write(2+2);

        %geogebra
          4
        %end

    %end
        
%end


%beanshell
import java.io.*;
//Print the contents of the Piper script zip file.
 instance = org.mathrider.jpiperplugin.JPiperInterpreter.getInstance();
 scriptZip = instance.getScriptsZip();
 entries = scriptZip.entries();
 
 while( entries.hasMoreElements())
 {
    element = entries.nextElement();
    System.out.println("XXXXX " + element);
 }
 
 entry = scriptZip.getEntry("assoc.rep/code.pi");
 System.out.println("YYYYYY " + entry);
 
 fis = scriptZip.getInputStream(entry);
 //
        entry = entry.toString().replaceAll("/","-");
         // Create temp file.
        File tempFile = File.createTempFile(entry, ".pi");
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
	//File originFile = new File("c:\\file1.txt");
    //File destinationFile = new File("c:\\file1.txt");
    //if (!originFile.exists() || destinationFile.exists()) {
      //return;
    //}
    try {
      byte[] readData = new byte[1024];
      //FileInputStream fis = new FileInputStream(originFile);
      FileOutputStream fos = new FileOutputStream(tempFile);
      int i = fis.read(readData);

      while (i != -1) {
        fos.write(readData, 0, i);
        i = fis.read(readData);
      }
      fis.close();
      fos.flush();
      fos.close();
    } catch (IOException e) {
      System.out.println(e);
    }//end try/catch.
    
    
    
    //textArea = org.gjt.sp.jedit.jEdit.createTextArea();
    
    activeView = org.gjt.sp.jedit.jEdit.getActiveView();
    
    //buffer = org.gjt.sp.jedit.jEdit.openFile(activeView, tempFile.getAbsolutePath());
    
   // jf = new javax.swing.JFrame();
   // cf = jf.getContentPane();
   // cf.add(textArea);
   // jf.show();
   
   
				void delayDisplay()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						buffer = org.gjt.sp.jedit.jEdit.openFile(activeView, tempFile.getAbsolutePath());//

					}
					org.gjt.sp.jedit.io.VFSManager.runInAWTThread(this);
				
				}//end method.
				
	delayDisplay();

    %error 
      Sourced file: C:\DOCUME~1\Ted\LOCALS~1\Temp\mathrider49640.mws_tmp : Cannot access field: toString, on object: assoc.rep/code.pi entry .toString .replaceAll ( "/" , "-" )  Line: 33
    %end

%end


%piper
c := Sum(i,1,11,1/(i*(i+1)));
Write(V(N(c)));

f := 10/(10+1);
Write(N(f));

    %output
      11/12 10/11
    %end

%end

%piper
k := 10;
g := k/(k+1) + 1/((k+1) * ((k+1)+1));
h := (k+1) / (k+1)+1;
Write(g, h);

    %output
      11/12 2
    %end

%end

%piper
Set(e,2.71828182847786963038);
f(x) = N((.6*10^-6)* D(x) 40*(e^(-15000*x))*Sin(30000*x));
Write(f(x));

    %output
      6e-7*(40*2.71828182847786963038^(-15000*x)*30000*Cos(30000*x)+(-600000)*2.71828182847786963038^(-15000*x)*Sin(30000*x))
    %end

%end
f(x) := (.6*10^-6) *

%piper
Set(e,Exp(1));
a := (.6*10^-6) * N((.6*10^-6)* D(x) 40*(e^(-15000*x))*Sin(30000*x));
Write(a);

    %output
      (3.6e-7*(40*Exp(1)^(-15000*x)*30000*Cos(30000*x)+(-600000)*Exp(1)^(-15000*x)*Sin(30000*x)))/1000000
    %end

%end

%piper
Set(e,2.71828);
df := D(x) 40*e^(-15000*x)*Sin(30000*x);
Write(df);

    %output
      40*2.71828^(-15000*x)*30000*Cos(30000*x)+(-40)*2.71828^(-15000*x)*15000*Ln(2.71828)*Sin(30000*x)
    %end

%end

%piper
Write(25!);

    %output
      15511210043330985984000000
    %end

%end

%piper
b := (6*a + 5) / (a + 2);
Write(b);

    %output
      (6*a+5)/(a+2)
    %end

%end

%piper
c := 



;
d := k * e(k-1);
%end



%piper

e := 2.71828;
d(x) := N(Eval((0.6*10^-6) * D(x) 40*(e^(-15000*x))*Sin(30000*x) ));
y := d(0);
Write(y);

    %output
      0.72
    %end

%end







%piper,macro="P2D_GeoGebra"
f(a) := (6*a + 5)/(a+2);
b := 1;
ForEach(x,1 .. 10)
    [
        c := f(b);
        Write(N(Eval(c)));
        b := c;
    ];

    %output
      3.66666666666666666667 4.76470588235294117647 4.96521739130434782609 4.99500624219725343321 4.99928609673389255756 4.99989800341688553433 4.99998542884723967725 4.99999791840241548584 4.99999970262882806839 4.99999995751840220508
    %end

%end


%beanshell,name="P2D_GeoGebra",scope="global"


P2D_GeoGebra(str)
{
    vals = str.split(" ");
    
    x = 0;
    for(val:vals)
    {
        ggb.evalCommand("(" + x++ +"," + val + ")");
    }//end for.

    output(str);
    
}

data = "3.66666666666666666667 4.76470588235294117647 4.96521739130434782609 4.99500624219725343321 4.99928609673389255756 4.99989800341688553433 4.99998542884723967725 4.99999791840241548584 4.99999970262882806839 4.99999995751840220508";
P2D_GeoGebra(data);

    %output 
      3.66666666666666666667 4.76470588235294117647 4.96521739130434782609 4.99500624219725343321 4.99928609673389255756 4.99989800341688553433 4.99998542884723967725 4.99999791840241548584 4.99999970262882806839 4.99999995751840220508
    %end

%end


%piper,output="latex"
    /* This is a great example problem to use in MathRider.
    1) Enter expression.
    2) If it is a complicated expression, view it in LaTeX form to make sure it has been entered
    correctly.  In this problem, if parentheses are not placed around the exponents then then the
    expression is evaluated differently than if they are present.
    3) Adjust the expression until it is correct.
    */
    
    a :=((1-x^(2*k))/(1-x))*((1-x^(2*(k+1)))/(1-x));
    Write(a);

    %hoteqn
      $\frac{\left( 1 - x ^{2 \left( k + 1\right) }\right)  \left( 1 - x ^{2 k}\right) }{\left( 1 - x\right)  ^{2}} $
    %end

%end

%piper, output="latex"

Write(Simplify(a));

    %hoteqn
      $\frac{x ^{2 k + 2 \left( k + 1\right) } - x ^{2 \left( k + 1\right) } + 1 - x ^{2 k}}{x ^{2} - 2 x + 1} $

        %output
          HotEqn updated.
        %end

    %end

%end




%piper,output=""

    
    a := (((1-x^(2*k))/(1-x))*(1 + x^(2*(k+1)-1)));
    Write(Simplify(a));

    %output
      (x^(2*(k+1)-1)-x^(2*k+2*(k+1)-1)+1-x^(2*k))/(1-x)
    %end

%end



%piper,output=""

    
    a := Hold(((1-x^(2^k))/(1-x))*(1 + x^(2^((k+1)-1))));
    b := Hold((1-x^(2^(k+1)))/(1-x));
    Write(a:Eval(a):Simplify(a));
    //Write(TestPiper(a,b));

    %output
      (1-x^2^k)/(1-x)*(1+x^2^(k+1-1)):((x^2^k+1)*(1-x^2^k))/(1-x):(1-x^2^k^2)/(1-x)
    %end

%end



%piper,output="latex"

    
    a :=  Hold((1+x^2^k) * (1-x^2^k) );
    b := Hold( 1/2 *(k+1)*(k+2) );
    Write(a:Simplify(a));

    %hoteqn
      $\left( 1 + x ^{2 ^{k}}\right)  \left( 1 - x ^{2 ^{k}}\right) :1 - x ^{2 ^{k ^{2}}}$

        %output
          HotEqn updated.
        %end

    %end

%end

%piper
    a := (1-x^2^k) * (1+x^2^k);
    Write(Simplify(FullForm(a)));

    %output
      (* 
          (- 1 
            (^ x 
              (^ 2 k )))
          (+ 
            (^ x 
              (^ 2 k ))1 ))
      1-x^2^k^2
    %end

%end

%piper

a := FromString("(* 
          (- 1 
            (^ x 
              (^ 2 k )))
          (+ 
            (^ x 
              (^ 2 k ))1 ))") LispRead();
              
Write(a);

    %output
      (1-x^2^k)*(x^2^k+1)
    %end

%end

%piper

a := FromString("(* 3 (MathSin 4))") LispRead();
              
Write(Eval(a));

    %output
      -2.2704074859
    %end

%end





%piper
//Why doesn't this work?
a := FromString("(+ 5 .5 2.5  )") LispRead();
              
Write(Eval(a));

    %output
      +(5,.5,2.5)
    %end

%end


%piper
//Why doesn't this work?
a := FromString("(+ 1 2 3)") LispRead();
              
Write(a);

    %output
      +(1,2,3)
    %end

%end

%piper,output=""
//Good example problem for newbies book.  From problem 19 in "Mathematical Reasoning".
a(k) := (k+2)/(2*k+2);
b(k) := ( ((k+1)/(2*k)) * (1-(1/(k+1)^2) ) );
c(k) := (k+1)/(2*k) - (k+1)/(2*k*(k+1)^2);
d(k) := (k^3+3*k^2+2*k)/(2*k^3+4*k^2+2*k);
e(k) := (k^2+3*k+2)/(2*k^2+4*k+2);


//Write(d(k));
Write(TestPiper(a(k),e(k)));
//Write(Together(c(k)));
//Write(Simplify(c(k)));
//Write(Factor(Numer(Together(c(k)))):Factor(Denom(Together(c(k)))));

    %output
      True
    %end

%end


%beanshell
ProcessBuilder pb = new ProcessBuilder("C:\\Program Files\\Maxima-5.15.0\\bin\\maxima.bat");
 //Map<String, String> env = pb.environment();
 //env.put("VAR1", "myValue");
 //env.remove("OTHERVAR");
 //env.put("VAR2", env.get("VAR1") + "suffix");
 //pb.directory("myDir");
 Process p = pb.start();
%end


%beanshell
command = new java.util.ArrayList();
command.add("C:\\Program Files\\Maxima-5.15.0\\bin\\maxima.bat");
ProcessBuilder pb = new ProcessBuilder(command);
 //Map<String, String> env = pb.environment();
 //env.put("VAR1", "myValue");
 //env.remove("OTHERVAR");
 //env.put("VAR2", env.get("VAR1") + "suffix");
 //pb.directory("myDir");
 Process p = pb.start();
 in = p.getInputStream();
 out = p.getOutputStream();
 sb = new StringBuffer();
 //cv = s.read();
 //s.read();
while(in.available() == 0)
{
}

 while(in.available() != 0)
 {
    cv = in.read();
    ch = (char)cv;
    //System.out.println("xxxx " + ch);
    sb.append(ch);
 }
 
 System.out.println("xxxx " + sb.toString());
 
 
//Write then read.
sb.delete(0,sb.length());
outmess = "2+2;\n".getBytes();
out.write(outmess);
out.flush();
 while(in.available() == 0)
{
}

 while(in.available() != 0)
 {
    cv = in.read();
    ch = (char) cv;
    //System.out.println("xxxx " + ch);
    sb.append(ch);
 }
 
  System.out.println("xxxx " + sb.toString());

    %output 
      
    %end

%end



%beanshell
maxima() 
{
    command = new java.util.ArrayList();
    command.add("C:\\Program Files\\Maxima-5.15.0\\bin\\maxima.bat");
    pb = new ProcessBuilder(command);
    //Map<String, String> env = pb.environment();
    //env.put("VAR1", "myValue");
    //env.remove("OTHERVAR");
    //env.put("VAR2", env.get("VAR1") + "suffix");
    //pb.directory("myDir");
    Process p = pb.start();
    inputStream = p.getInputStream();
    outputStream = p.getOutputStream();
    sb = new StringBuffer();
    
    keepRunning = true;
    
    
    send(snd)
    {
    }
    
    run() 
    {
	
		
		while(keepRunning)
        {

			serialAvailable = inputStream.available();
			if(serialAvailable > 0)
            {
				byte[] bytes = new byte[serialAvailable];
				inputStream.read( bytes, 0, serialAvailable );
                System.out.println("GGGGGGG " + new String( bytes));

				//self.terminalOutputStream.write( bytes )
				
				//event = utility.DataEvent( self, bytes, self.packetMode )
				
				//self.notifyListeners( event )
            }//end if.
            
            Thread.sleep( 30 );
        }//end while.
        
    }//end run.
    return this;
    
}//end maxima.

max = maxima();

new Thread( max ).start();

    %output 
      
    %end

%end



%beanshell
class SerialPort( Runnable ):
	
	def __init__( self, name ):
		
		self.inputStream = None
		self.outputStream = None
		self.hardwareSerialPort = None  
		self.name = name
		self.description = None
		self.keepRunning = 1
		
		self.protocol = None
		
		self.packetMode = 0
		
		#Hack
		#self.inByte = 65
		
		self.inByteFIFO = utility.FIFO( None, "inByteFIFO, SerialPort" )
		
		self.listeners = []
		
		self.serialTerminal = serialterminalgui.SerialTerminal()
		
		self.serialTerminal.setSerialPort( self )
		
		#Note: temporary test.
		self.terminalOutputStream = jutility.PipedOutputStream( self.serialTerminal.inputStream )
		self.terminalInputStream = jutility.PipedInputStream( self.serialTerminal.outputStream )
		

		
		Thread( self.serialTerminal, self.name+"_terminal"  ).start()
		
		Thread( self, self.name  ).start()  #Note: It looks like SerialPort is being started too soon.

		#self.addEventListener( self.serialTerminal )


		self.dummyPort = utility.DummySerialPort()
		
		#self.lineHolder = utility.FIFO( None )
		

		
		
	def sendData( self, data ):
		self.outputStream.write( data )
		
	def write( self, byte ):
		pass
		
	def getName( self ):
		return self.name
		
	def getDescription( self ):
		return self.description
		
	def addDataEventListener( self, listener ):
		self.listeners.append( listener )
		
	def notifyListeners( self, dataEvent ):
		
		for listener in self.listeners:
			listener.dataEvent( dataEvent )
			
			
			
	def close( self ):
		
		self.keepRunning = 0
		
		if self.hardwareSerialPort != None:
			self.hardwareSerialPort.close()
			
		self.outputStream.close()
		self.inputStream.close()
		
		self.serialTerminal.close()
		
		self.terminalOutputStream.close()
		self.terminalInputStream.close()
		
		
	def toPacketMode( self ):
		self.packetMode = 1
			
			
	def run( self ):
		
		#Note: Hack to prevent issuing inputStream.available() to None reference.
		while self.inputStream == None:
			Thread.sleep( 10 )		
		
		while self.keepRunning == 1:
			
			
			
			serialAvailable = self.inputStream.available()
			if serialAvailable > 0 :
				bytes = jarray.zeros( serialAvailable, 'b' )
				
				self.inputStream.read( bytes, 0, serialAvailable )

				self.terminalOutputStream.write( bytes )
				
				event = utility.DataEvent( self, bytes, self.packetMode )
				
				self.notifyListeners( event )
				                                              
#				#Grab lines.
#				for singleByte in bytes:
#					
#					if singleByte != 0x0a:
#						self.lineHolder.push( chr( singleByte ) )
#					else:
#						line = ''.join( self.lineHolder.getLine() )
#						self.serialTerminal.appendMessage( line )
#						
#						event = utility.DataEvent( self, line )
#						
#						self.notifyListeners( event )
#						
						
				
					
			terminalAvailable = self.terminalInputStream.available()
			if  terminalAvailable > 0:
				bytes = jarray.zeros( terminalAvailable, 'b' )
				self.terminalInputStream.read( bytes, 0, terminalAvailable)
				
				
				
				
				self.outputStream.write( bytes )


			Thread.sleep( 30 )

%end

%maxima,name="test"
2+3;
5+7;
print("hello");

    %output,name="test"
      
    %end

%end


%beanshell,scope="ide"
v = view;
		dwm = v.getDockableWindowManager();
		con = dwm.getDockable("console");
        con.setShell("Maxima");

    %output 
      
    %end

%end

%lisp
(defun compress (x)
    ;;If a cons was passed in then compress it.
    (if (consp x)
        (compr (car x) 1 (cdr x))
        ;;Else just return what was passed in.
        x))
        
;;; elt: element.  n: number in a sequence. lst: the rest of the list.
(defun compr (elt n lst)
    ;; If the rest of the list is null, then just call n-elts once.
    (if (null lst)
        (list (n-elts elt n))
        
        ;; If the rest of the list is not null then set the variable next to the next character in the list.
        (let ((next (car lst)))
        
            ;; If element is the same as the next character in the list then compress again.
            (if (eql next elt)
                (compr elt (+ n 1) (cdr lst))
            
                ;; If element is not the same then 
                (cons (n-elts elt n)
                    (compr next 1 (cdr lst )))))))
                
(defun n-elts (elt n)
    (if (> n 1)
        (list n elt)
        elt))

    %output
      
    %end

%end


MAXIMA> (compress '(1 1 1))

  1> (COMPRESS (1 1 1))
    2> (COMPR 1 1 (1 1))
      3> (COMPR 1 2 (1))
        4> (COMPR 1 3 NIL)
          5> (N-ELTS 1 3)
          <5 (N-ELTS (3 1))
        <4 (COMPR ((3 1)))
      <3 (COMPR ((3 1)))
    <2 (COMPR ((3 1)))
  <1 (COMPRESS ((3 1)))
((3 1))


%lisp
(defun our-nthcdr (n lst)
    (if (zerop n)
        lst
        (our-nthcdr (- n 1) (cdr lst))))

    %output
      
    %end

%end

MAXIMA> (our-nthcdr 2 '(a b c))

  1> (OUR-NTHCDR 2 (A B C))
    2> (OUR-NTHCDR 1 (B C))
      3> (OUR-NTHCDR 0 (C))
      <3 (OUR-NTHCDR (C))
    <2 (OUR-NTHCDR (C))
  <1 (OUR-NTHCDR (C))
(C)


%beanshell,scope="ide"

import javax.swing.*;
import javax.swing.tree.*;
import java.awt.event.*;
import java.awt.*;
import org.mathrider.piperdocsplugin.FunctionInfo;

docker = jEdit.getActiveView().getDockableWindowManager();
frame = new javax.swing.JFrame();




//{{{ functions array.
functions = new String[][]
{
{"+","Arithmetic addition.","Alphabetical","Numbers (Operations)"},
{"-","Arithmetic subtraction or negation.","Alphabetical","Numbers (Operations)"},
{"*","Arithmetic multiplication.","Alphabetical","Numbers (Operations)"},
{"/","Arithmetic division.","Alphabetical","Numbers (Operations)"},
{"<","Test for \"less than\".","Alphabetical","Numbers (Predicates)"},
{">","Test for \"greater than\".","Alphabetical","Numbers (Predicates)"},
{"<=","Test for \"less than or equal\".","Alphabetical","Numbers (Predicates)"},
{">=","Test for \"greater than or equal\".","Alphabetical","Numbers (Predicates)"},
{"^","Arithmetic power.","Alphabetical","Numbers (Operations)"},
{"<<","Binary shift left operator.","Alphabetical","Numbers (Operations)"},
{">>","Binary shift right operator","Alphabetical","Numbers (Operations)"},
{"!","Factorial.","Alphabetical","Numbers (Operations)","Combinatorics"},
{"!!","Factorial and related functions.","Alphabetical","Numbers (Operations)","Combinatorics"},
{"***","Factorial and related functions.","Alphabetical","Numbers (Operations)","Combinatorics"},
{".","Return the dot product of tensors.","Alphabetical","Linear Algebra"},
{":","Prepend an item to a list, or concatenate strings.","Alphabetical","Functional Operators"},
{"@","Apply a function.","Alphabetical","Functional Operators"},
{"/@","Apply a function to all entries in a list.","Alphabetical","Functional Operators"},
{"..","Construct a list of consecutive integers.","Alphabetical","Functional Operators"},
{"/:","Local simplification rules.","Alphabetical","Control Flow"},
{"/::","Local simplification rules.","Alphabetical","Control Flow"},
{"!=","Test for \"not equal\".","Alphabetical","Predicates"},
{"=","Test for equality of expressions.","Alphabetical","Predicates"},
{"%","The previous result.","Alphabetical","Constants (System)"},
{":=","Assign a variable or a list; define a function.","Alphabetical","Variables"},
{"++","Increment a variable.","Alphabetical","Variables"},
{"--","Decrement a variable.","Alphabetical","Variables"},
{"o","Return the outer tensor product.","Alphabetical","Linear Algebra"},
{"Abs","Absolute value (or modulus) of a number.","Alphabetical","Calculus Related (Symbolic)"},
{"Add","Find the sum of a list of values.","Alphabetical","Series"},
{"AddTo","Add an equation to a set of equations or set of set of equations.","Alphabetical","Functional Operators"},
{"And","Logical conjunction.","Alphabetical","Predicates"},
{"Append","Append an entry at the end of a list.","Alphabetical","Lists (Operations)"},
{"Apply","Apply a function to arguments.","Alphabetical","Control Flow"},
{"ArcCos","Inverse trigonometric function arc-cosine.","Alphabetical","Calculus Related (Symbolic)"},
{"ArcSin","Inverse trigonometric function arc-sine.","Alphabetical","Calculus Related (Symbolic)"},
{"ArcTan","Inverse trigonometric function arc-tangent.","Alphabetical","Calculus Related (Symbolic)"},
{"Arg","Argument of a complex number.","Alphabetical","Numbers (Complex)"},
{"Array'Create","","Alphabetical"},
{"Array'CreateFromList","","Alphabetical"},
{"Array'Returns","","Alphabetical"},
{"Array'Set","","Alphabetical"},
{"Array'Size","","Alphabetical"},
{"Array'ToList","","Alphabetical"},
{"Assert","","Alphabetical"},
{"Assoc","Return an element stored in an association list.","Alphabetical","Lists (Operations)"},
{"AssocDelete","Delete an entry in an association list.","Alphabetical","Lists (Operations)"},
{"AssocIndices","Return the keys in an association list.","Alphabetical","Lists (Operations)"},
{"Atom","Convert string to atom.","Alphabetical","String Manipulation"},
{"BaseVector","Base vector.","Alphabetical","Linear Algebra"},
{"Bernoulli","Bernoulli numbers and polynomials","Alphabetical","Functions (Special)"},
{"BernoulliDistribution","Bernoulli distribution.","Alphabetical","Probability & Statistics"},
{"BigOh","Drop all terms of a certain order in a polynomial.","Alphabetical","Series"},
{"Bin","Binomial coefficients.","Alphabetical","Combinatorics"},
{"BinomialDistribution","Binomial distribution.","Alphabetical","Probability & Statistics"},
{"BinSplitData","","Alphabetical"},
{"BinSplitFinal","","Alphabetical"},
{"BinSplitNum","","Alphabetical"},
{"BitAnd","","Alphabetical"},
{"BitOr","","Alphabetical"},
{"BitXor","","Alphabetical"},
{"Bodied","","Alphabetical"},
{"BracketRational","","Alphabetical"},
{"BubbleSort","Sort a list.","Alphabetical","Lists (Operations)"},
{"Builtin'Precision'Returns","","Alphabetical"},
{"Builtin'Precision'Set","","Alphabetical"},
{"CachedConstant","","Alphabetical"},
{"CanProve","Try to prove a statement.","Alphabetical","Propositional Logic"},
{"Catalan","Catalan's Constant.","Alphabetical","Constants (Mathematical)"},
{"CatalanNumber","Teturn the nth Catalan Number.","Alphabetical","Number Theory"},
{"Ceil","Round a number upwards.","Alphabetical","Numbers (Operations)"},
{"CForm","Export an expression to C++ code form.","Alphabetical","Input/Output"},
{"CharacteristicEquation","Return the characteristic polynomial of a matrix.","Alphabetical","Linear Algebra"},
{"Check","","Alphabetical"},
{"ChiSquareTest","Pearson's ChiSquare test.","Alphabetical","Probability & Statistics"},
{"Cholesky","Find the Cholesky Decomposition of a matrix.","Alphabetical","Linear Algebra"},
{"Clear","Unassign a variable.","Alphabetical","Variables"},
{"ClearError","","Alphabetical"},
{"ClearErrors","","Alphabetical"},
{"Coef","Return the coefficient of a polynomial.","Alphabetical","Polynomials (Operations)"},
{"CoFactor","Return the cofactor of a matrix.","Alphabetical","Linear Algebra"},
{"Complex","Construct a complex number.","Alphabetical","Numbers (Complex)"},
{"Concat","Concatenate lists.","Alphabetical","Lists (Operations)"},
{"ConcatStrings","Concatenate strings.","Alphabetical","String Manipulation"},
{"Conjugate","Complex conjugate.","Alphabetical","Numbers (Complex)"},
{"Contains","Test whether a list contains a certain element.","Alphabetical","Lists (Operations)"},
{"Content","Return the content of a univariate polynomial.","Alphabetical","Polynomials (Operations)"},
{"ContFrac","Continued fraction expansion.","Alphabetical","Numbers (Operations)"},
{"ContFracEval","","Alphabetical"},
{"ContFracList","","Alphabetical"},
{"Cos","Trigonometric cosine function.","Alphabetical","Calculus Related (Symbolic)"},
{"Count","Count the number of occurrences of an expression.","Alphabetical","Lists (Operations)"},
{"CrossProduct","Outer product of vectors.","Alphabetical","Linear Algebra"},
{"Curl","Curl of a vector field.","Alphabetical","Calculus Related (Symbolic)"},
{"CurrentFile","","Alphabetical"},
{"CurrentLine","","Alphabetical"},
{"Cyclotomic","Construct the cyclotomic polynomial.","Alphabetical","Number Theory"},
{"D","Take derivative of an expression with respect to a variable.","Alphabetical","Calculus Related (Symbolic)"},
{"Decimal","Decimal representation of a rational.","Alphabetical","Numbers (Operations)"},
{"DefaultTokenizer","Select the default syntax tokenizer for parsing the input.","Alphabetical","Input/Output"},
{"DefLoad","Load a .def file.","Alphabetical","Input/Output"},
{"DefMacroRuleBase","","Alphabetical"},
{"DefMacroRuleBaseListed","","Alphabetical"},
{"Degree","Return the degree of a polynomial.","Alphabetical","Polynomials (Operations)"},
{"Delete","Delete an element from a list.","Alphabetical","Lists (Operations)"},
{"Denom","Denominator of an expression","Alphabetical","Numbers (Operations)"},
{"DestructiveAppend","Destructively append an entry to a list.","Alphabetical","Lists (Operations)"},
{"DestructiveDelete","Delete an element destructively from a list.","Alphabetical","Lists (Operations)"},
{"DestructiveInsert","Insert an element destructively into a list.","Alphabetical","Lists (Operations)"},
{"DestructiveReplace","Replace an entry destructively in a list.","Alphabetical","Lists (Operations)"},
{"DestructiveReverse","Reverse a list destructively.","Alphabetical","Lists (Operations)"},
{"Determinant","Return the determinant of a matrix.","Alphabetical","Linear Algebra"},
{"Diagonal","Extract the diagonal from a matrix.","Alphabetical","Linear Algebra"},
{"DiagonalMatrix","Construct a diagonal matrix.","Alphabetical","Linear Algebra"},
{"Difference","Return the difference of two lists.","Alphabetical","Lists (Operations)"},
{"Div","Determine divisor of two mathematical objects.","Alphabetical","Numbers (Operations)"},
{"Diverge","Divergence of a vector field.","Alphabetical","Calculus Related (Symbolic)"},
{"Divisors","Number of divisors.","Alphabetical","Number Theory"},
{"DivisorsList","The list of divisors.","Alphabetical","Number Theory"},
{"DivisorsSum","The sum of divisors.","Alphabetical","Number Theory"},
{"Dot","Return the dot product of tensors","Alphabetical","Linear Algebra"},
{"Drop","Drop a range of elements from a list.","Alphabetical","Lists (Operations)"},
{"DumpErrors","","Alphabetical"},
{"Echo","High-level printing routine.","Alphabetical","Input/Output"},
{"EigenValues","Return the eigenvalues of a matrix.","Alphabetical","Linear Algebra"},
{"EigenVectors","Return the eigenvectors of a matrix.","Alphabetical","Linear Algebra"},
{"Eliminate","Substitute and simplify.","Alphabetical","Solvers (Symbolic)"},
{"EndOfFile","End-of-file marker","Alphabetical","Constants (System)"},
{"Equals","","Alphabetical"},
{"Euler","Euler numbers and polynomials.","Alphabetical","Functions (Special)"},
{"Eulerian","Eulerian numbers.","Alphabetical","Combinatorics"},
{"Eval","Force evaluation of an expression.","Alphabetical","Control Flow"},
{"EvalFormula","Print an evaluation nicely with ASCII art.","Alphabetical","Input/Output"},
{"EvaluateHornerScheme","Fast evaluation of polynomials.","Alphabetical","Polynomials (Operations)"},
{"Exp","Exponential function.","Alphabetical","Calculus Related (Symbolic)"},
{"Expand","Transform a polynomial to an expanded form.","Alphabetical","Polynomials (Operations)"},
{"ExpandBrackets","Expand all brackets.","Alphabetical","Polynomials (Operations)"},
{"ExtraInfo'Returns","","Alphabetical"},
{"ExtraInfo'Set","","Alphabetical"},
{"Factor","Factorization, in pretty form.","Alphabetical","Number Theory"},
{"FactorialSimplify","Simplify hypergeometric expressions containing factorials.","Alphabetical","Expression Simplification"},
{"Factorize","Find the product of a list of values.","Alphabetical","Series"},
{"Factors","Factorization.","Alphabetical","Number Theory"},
{"False","Boolean constant representing false.","Alphabetical","Constants (System)"},
{"FermatNumber","Return the nth Fermat Number.","Alphabetical","Number Theory"},
{"FillList","Fill a list with a certain expression.","Alphabetical","Lists (Operations)"},
{"Find","Return the index at which a certain element occurs.","Alphabetical","Lists (Operations)"},
{"FindFile","Find a file in the current path.","Alphabetical","Input/Output"},
{"FindFunction","","Alphabetical"},
{"FindRealRoots","Find the real roots of a polynomial.","Alphabetical","Solvers (Numeric)"},
{"FlatCopy","Copy the top level of a list.","Alphabetical","Lists (Operations)"},
{"Flatten","Flatten expression with respect to some operator.","Alphabetical","Lists (Operations)"},
{"Floor","Round a number downwards.","Alphabetical","Numbers (Operations)"},
{"For","C-style for loop.","Alphabetical","Control Flow"},
{"ForEach","Loop over all entries in a list","Alphabetical","Control Flow"},
{"FromBase","Conversion of a number from non-decimal base to decimal base","Alphabetical","Numbers (Operations)"},
{"FromFile","Connect current input to a file.","Alphabetical","Input/Output"},
{"FromString","Connect current input to a string.","Alphabetical","Input/Output"},
{"FullForm","Print an expression in Lisp format.","Alphabetical","Input/Output"},
{"FuncList","Return a list of functions used in an expression.","Alphabetical","Lists (Operations)"},
{"FuncListArith","Return a list of functions used in an expression.","Alphabetical","Lists (Operations)"},
{"FuncListSome","Return a list of functions used in an expression.","Alphabetical","Lists (Operations)"},
{"Function","Declare or define a function.","Alphabetical","Control Flow"},
{"Gamma","Euler's Gamma function.","Alphabetical","Functions (Special)"},
{"gamma","Euler's constant gamma.","Alphabetical","Constants (Mathematical)"},
{"GarbageCollect","","Alphabetical"},
{"GaussianFactors","Factorization in Gaussian integers.","Alphabetical","Number Theory"},
{"GaussianGcd","Greatest common divisor in Gaussian integers.","Alphabetical","Number Theory"},
{"GaussianNorm","Norm of a Gaussian integer.","Alphabetical","Number Theory"},
{"Gcd","Greatest common divisor.","Alphabetical","Numbers (Operations)"},
{"GenericTypeName","","Alphabetical"},
{"ReturnsCoreError","","Alphabetical"},
{"ReturnsError","","Alphabetical"},
{"ReturnsErrorTableau","","Alphabetical"},
{"ReturnsTime","","Alphabetical"},
{"GlobalPop","Restore variables using a global stack.","Alphabetical","Lists (Operations)"},
{"GlobalPush","Save variables using a global stack.","Alphabetical","Lists (Operations)"},
{"GoldenRatio","The Golden Ratio.","Alphabetical","Constants (Mathematical)"},
{"GreaterThan","","Alphabetical"},
{"GuessRational","","Alphabetical"},
{"HarmonicNumber","Teturn the nth Harmonic Number.","Alphabetical","Number Theory"},
{"HasExpr","Check for expression containing a subexpression.","Alphabetical","Predicates"},
{"HasExprArith","Check for expression containing a subexpression.","Alphabetical","Predicates"},
{"HasExprSome","Check for expression containing a subexpression.","Alphabetical","Predicates"},
{"HasFunc","Check for expression containing a function.","Alphabetical","Predicates"},
{"HasFuncArith","Check for expression containing a function.","Alphabetical","Predicates"},
{"HasFuncSome","Check for expression containing a function.","Alphabetical","Predicates"},
{"Head","Return the first element of a list.","Alphabetical","Lists (Operations)"},
{"HeapSort","Sort a list.","Alphabetical","Lists (Operations)"},
{"HessianMatrix","Create a Hessian matrix.","Alphabetical","Matrices (Special)"},
{"HilbertInverseMatrix","Create a Hilbert inverse matrix.","Alphabetical","Matrices (Special)"},
{"HilbertMatrix","Create a Hilbert matrix.","Alphabetical","Matrices (Special)"},
{"Hold","Keep expression unevaluated.","Alphabetical","Control Flow"},
{"HoldArg","","Alphabetical"},
{"HoldArgNr","","Alphabetical"},
{"Horner","Convert a polynomial into the Horner form.","Alphabetical","Polynomials (Operations)"},
{"I","Imaginary unit.","Alphabetical","Numbers (Complex)"},
{"Identity","Make identity matrix.","Alphabetical","Linear Algebra"},
{"If","Implements a branch point (makes a decision).","Alphabetical","Control Flow"},
{"Im","Imaginary part of a complex number.","Alphabetical","Numbers (Complex)"},
{"Infinity","Constant representing mathematical infinity.","Alphabetical","Constants (Mathematical)"},
{"Infix","","Alphabetical"},
{"InNumericMode","","Alphabetical"},
{"InProduct","Inner product of vectors (deprecated).","Alphabetical","Linear Algebra"},
{"Insert","Insert an element into a list.","Alphabetical","Lists (Operations)"},
{"Integrate","Integration.","Alphabetical","Calculus Related (Symbolic)"},
{"Intersection","Return the intersection of two lists.","Alphabetical","Lists (Operations)"},
{"IntLog","","Alphabetical"},
{"IntNthRoot","","Alphabetical"},
{"IntPowerNum","","Alphabetical"},
{"InVerboseMode","","Alphabetical"},
{"Inverse","Return the inverse of a matrix","Alphabetical","Linear Algebra"},
{"InverseTaylor","Taylor expansion of inverse.","Alphabetical","Series"},
{"IsAmicablePair","Test for a pair of amicable numbers.","Alphabetical","Number Theory"},
{"IsAtom","Test for an atom.","Alphabetical","Predicates"},
{"IsBodied","","Alphabetical"},
{"IsBoolean","Test for a Boolean value.","Alphabetical","Predicates"},
{"IsBound","Test for a bound variable.","Alphabetical","Predicates"},
{"IsCarmichaelNumber","Test for a Carmichael number.","Alphabetical","Number Theory"},
{"IsCFormable","Check possibility of exporting expression to C++ code form.","Alphabetical","Input/Output"},
{"IsComposite","Test for a composite number.","Alphabetical","Number Theory"},
{"IsConstant","Test for a constant.","Alphabetical","Predicates"},
{"IsCoprime","Test if integers are coprime.","Alphabetical","Number Theory"},
{"IsDiagonal","Test for a diagonal matrix.","Alphabetical","Matrices (Predicates)"},
{"IsError","","Alphabetical"},
{"IsEven","Test for an even integer.","Alphabetical","Predicates"},
{"IsEvenFunction","Return true if function is an even function, False otherwise.","Alphabetical","Predicates"},
{"IsFreeOf","Test whether expression depends on variable.","Alphabetical","Predicates"},
{"IsFunction","Test for a composite object.","Alphabetical","Predicates"},
{"IsGaussianInteger","Test for a Gaussian integer.","Alphabetical","Predicates"},
{"IsGaussianPrime","Test for a Gaussian prime.","Alphabetical","Number Theory"},
{"IsGaussianUnit","Test for a Gaussian unit.","Alphabetical","Number Theory"},
{"IsGeneric","","Alphabetical"},
{"IsHermitian","Test for a Hermitian matrix.","Alphabetical","Matrices (Predicates)"},
{"IsIdempotent","Test for an idempotent matrix.","Alphabetical","Matrices (Predicates)"},
{"IsInfinity","Test for an infinity","Alphabetical","Predicates"},
{"IsInfix","","Alphabetical"},
{"IsIrregularPrime","Test for an irregular prime.","Alphabetical","Number Theory"},
{"IsList","Test for a list.","Alphabetical","Predicates"},
{"IsLowerTriangular","Test for a lower triangular matrix.","Alphabetical","Matrices (Predicates)"},
{"IsMatrix","Test for a matrix.","Alphabetical","Matrices (Predicates)"},
{"IsNegativeInteger","Test for a negative integer.","Alphabetical","Predicates"},
{"IsNegativeNumber","Test for a negative number.","Alphabetical","Predicates"},
{"IsNegativeReal","Test for a numerically negative value.","Alphabetical","Predicates"},
{"IsNonObject","Test whether argument is not an Object()","Alphabetical","Predicates"},
{"IsNonZeroInteger","Test for a nonzero integer.","Alphabetical","Predicates"},
{"IsNotZero","Test for a nonzero number.","Alphabetical","Predicates"},
{"IsNumber","Test for a number.","Alphabetical","Predicates"},
{"IsNumericList","Test for a list of numbers.","Alphabetical","Predicates"},
{"IsOdd","Test for an odd integer.","Alphabetical","Predicates"},
{"IsOddFunction","Return true if function is an odd function, False otherwise.","Alphabetical","Predicates"},
{"IsOrthogonal","Test for an orthogonal matrix.","Alphabetical","Matrices (Predicates)"},
{"IsPositiveInteger","Test for a positive integer.","Alphabetical","Predicates"},
{"IsPositiveNumber","Test for a positive number.","Alphabetical","Predicates"},
{"IsPositiveReal","Test for a numerically positive value.","Alphabetical","Predicates"},
{"IsPostfix","","Alphabetical"},
{"IsPrefix","","Alphabetical"},
{"IsPrime","Test for a prime number.","Alphabetical","Number Theory"},
{"IsPrimePower","Test for a power of a prime number.","Alphabetical","Number Theory"},
{"IsPromptShown","","Alphabetical"},
{"IsQuadraticResidue","Functions related to finite groups.","Alphabetical","Number Theory"},
{"IsRational","Test whether argument is a rational.","Alphabetical","Numbers (Predicates)"},
{"IsScalar","Test for a scalar.","Alphabetical","Matrices (Predicates)"},
{"IsSkewSymmetric","Test for a skew-symmetric matrix.","Alphabetical","Matrices (Predicates)"},
{"IsSmallPrime","Test for a small prime number.","Alphabetical","Number Theory"},
{"IsSquareFree","Test for a square-free number.","Alphabetical","Number Theory"},
{"IsSquareMatrix","Test for a square matrix.","Alphabetical","Matrices (Predicates)"},
{"IsString","Test for an string.","Alphabetical","Predicates"},
{"IsSymmetric","Test for a symmetric matrix.","Alphabetical","Matrices (Predicates)"},
{"IsTwinPrime","Test for a twin prime.","Alphabetical","Number Theory"},
{"IsUnitary","Test for a unitary matrix.","Alphabetical","Matrices (Predicates)"},
{"IsUpperTriangular","Test for an upper triangular matrix.","Alphabetical","Matrices (Predicates)"},
{"IsVector","Test for a vector.","Alphabetical","Matrices (Predicates)"},
{"IsZero","Test whether argument is zero.","Alphabetical","Numbers (Predicates)"},
{"IsZeroVector","Test whether list contains only zeroes.","Alphabetical","Predicates"},
{"JacobianMatrix","Calculate a Jacobian matrix of n functions in n variables.","Alphabetical","Matrices (Special)"},
{"JacobiSymbol","Functions related to finite groups.","Alphabetical","Number Theory"},
{"KnownFailure","","Alphabetical"},
{"LagrangeInterpolant","Polynomial interpolation.","Alphabetical","Series"},
{"LambertW","Lambert's W function.","Alphabetical","Functions (Special)"},
{"LaplaceTransform","Laplace transform","Alphabetical","Transforms"},
{"Lcm","Least common multiple.","Alphabetical","Numbers (Operations)"},
{"LeadingCoef","Return the leading coefficient of a polynomial.","Alphabetical","Polynomials (Operations)"},
{"LeftPrecedence","","Alphabetical"},
{"LegendreSymbol","Functions related to finite groups.","Alphabetical","Number Theory"},
{"Length","Return the length of a list or string.","Alphabetical","Lists (Operations)"},
{"LessThan","","Alphabetical"},
{"LeviCivita","Totally anti-symmetric Levi-Civita symbol.","Alphabetical","Combinatorics"},
{"Limit","Limit of an expression.","Alphabetical","Calculus Related (Symbolic)"},
{"LispRead","Read expressions in Lisp syntax.","Alphabetical","Input/Output"},
{"LispReadListed","Read expressions in Lisp syntax.","Alphabetical","Input/Output"},
{"List","Construct a list.","Alphabetical","Lists (Operations)"},
{"Listify","Convert a function application to a list.","Alphabetical","Lists (Operations)"},
{"Ln","Natural logarithm.","Alphabetical","Calculus Related (Symbolic)"},
{"LnCombine","Combine logarithmic expressions using standard logarithm rules","Alphabetical","Expression Simplification"},
{"LnExpand","Expand a logarithmic expression using standard logarithm rules.","Alphabetical","Expression Simplification"},
{"Load","Evaluate all expressions in a file.","Alphabetical","Input/Output"},
{"Local","Declare new local variables.","Alphabetical","Variables"},
{"LocalSymbols","Create unique local symbols with the given prefix.","Alphabetical","Variables"},
{"LogicTest","","Alphabetical"},
{"LogicVerify","","Alphabetical"},
{"Macro","Declare or define a macro.","Alphabetical","Control Flow"},
{"MakeVector","Creates a vector containing uniquely numbered variable names.","Alphabetical","Lists (Operations)"},
{"Map","Apply an n-ary function to all entries in a list.","Alphabetical","Lists (Operations)"},
{"MapArgs","Apply a function to all top-level arguments.","Alphabetical","Control Flow"},
{"MapSingle","Apply a unary function to all entries in a list.","Alphabetical","Lists (Operations)"},
{"MatchLinear","Match an expression to a polynomial of degree one in a variable.","Alphabetical","Predicates"},
{"MathAbs","","Alphabetical"},
{"MathAdd","","Alphabetical"},
{"MathAnd","","Alphabetical"},
{"MathArcCos","","Alphabetical"},
{"MathArcCosh","","Alphabetical"},
{"MathArcSin","","Alphabetical"},
{"MathArcSinh","","Alphabetical"},
{"MathArcTan","","Alphabetical"},
{"MathArcTanh","","Alphabetical"},
{"MathCeil","","Alphabetical"},
{"MathCos","","Alphabetical"},
{"MathCosh","","Alphabetical"},
{"MathDiv","","Alphabetical"},
{"MathDivide","","Alphabetical"},
{"MathExp","","Alphabetical"},
{"MathFloor","","Alphabetical"},
{"MathGcd","","Alphabetical"},
{"MathReturnsExactBits","","Alphabetical"},
{"MathLog","","Alphabetical"},
{"MathMod","","Alphabetical"},
{"MathMultiply","","Alphabetical"},
{"MathNot","","Alphabetical"},
{"MathOr","","Alphabetical"},
{"MathPower","","Alphabetical"},
{"MathSetExactBits","","Alphabetical"},
{"MathSin","","Alphabetical"},
{"MathSinh","","Alphabetical"},
{"MathSqrt","","Alphabetical"},
{"MathSubtract","","Alphabetical"},
{"MathTan","","Alphabetical"},
{"MathTanh","","Alphabetical"},
{"MatrixPower","Return the nth power of a square matrix.","Alphabetical","Linear Algebra"},
{"MatrixSolve","Solve a system of equations.","Alphabetical","Solvers (Symbolic)"},
{"Max","Maximum of a number of values.","Alphabetical","Numbers (Operations)"},
{"MaxEvalDepth","Set the maximum evaluation depth.","Alphabetical","Control Flow"},
{"MaximumBound","Return upper bounds on the absolute values of real roots of a polynomial.","Alphabetical","Solvers (Numeric)"},
{"Min","Minimum of a number of values.","Alphabetical","Numbers (Operations)"},
{"MinimumBound","Return lower bounds on the absolute values of real roots of a polynomial.","Alphabetical","Solvers (Numeric)"},
{"Minor","Return the principal minor of a matrix.","Alphabetical","Linear Algebra"},
{"Mod","Determine remainder of two mathematical objects after dividing one by the other","Alphabetical","Numbers (Operations)"},
{"Moebius","The Moebius function.","Alphabetical","Number Theory"},
{"MoebiusDivisorsList","The list of divisors and Moebius values.","Alphabetical","Number Theory"},
{"Monic","Return the monic part of a polynomial.","Alphabetical","Polynomials (Operations)"},
{"MultiplyNum","","Alphabetical"},
{"N","Try determine numerical approximation of expression.","Alphabetical","Numbers (Operations)"},
{"NearRational","","Alphabetical"},
{"NewLine","Print one or more newline characters.","Alphabetical","Input/Output"},
{"Newton","Solve an equation numerically with Newton's method.","Alphabetical","Solvers (Numeric)"},
{"NewtonNum","","Alphabetical"},
{"NextPrime","Generate a prime following a number.","Alphabetical","Number Theory"},
{"NFunction","Make wrapper for numeric functions.","Alphabetical","Functional Operators"},
{"Nl","The newline character.","Alphabetical","Input/Output"},
{"NonN","","Alphabetical"},
{"Normalize","Normalize a vector.","Alphabetical","Linear Algebra"},
{"Not","Logical negation","Alphabetical","Predicates"},
{"NrArgs","Return the number of top-level arguments.","Alphabetical","Lists (Operations)"},
{"Nth","Return the n-th element of a list.","Alphabetical","Lists (Operations)"},
{"NthRoot","","Alphabetical"},
{"Numer","numerator of an expression","Alphabetical","Numbers (Operations)"},
{"NumRealRoots","Return the number of real roots of a polynomial.","Alphabetical","Solvers (Numeric)"},
{"Object","Create an incomplete type.","Alphabetical","Variables"},
{"OdeOrder","Return order of an ODE.","Alphabetical","Differential Equations"},
{"OdeSolve","General ODE solver.","Alphabetical","Differential Equations"},
{"OdeTest","Test the solution of an ODE.","Alphabetical","Differential Equations"},
{"OldSolve","Old version of Solve.","Alphabetical","Solvers (Symbolic)"},
{"OMDef","Define translations from Piper to OpenMath and vice-versa.","Alphabetical","Input/Output"},
{"OMForm","Convert Piper expression to OpenMath.","Alphabetical","Input/Output"},
{"OMRead","Convert expression from OpenMath to Piper expression.","Alphabetical","Input/Output"},
{"OpLeftPrecedence","","Alphabetical"},
{"OpPrecedence","","Alphabetical"},
{"OpRightPrecedence","","Alphabetical"},
{"Or","Logical disjunction.","Alphabetical","Predicates"},
{"OrthoG","Gegenbauer orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthogonalBasis","Create an orthogonal basis.","Alphabetical","Linear Algebra"},
{"OrthoGSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoH","Hermite orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoHSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoL","Laguerre orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoLSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthonormalBasis","Create an orthonormal basis.","Alphabetical","Linear Algebra"},
{"OrthoP","Legendre and Jacobi orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoPoly","Internal function for constructing orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoPolySum","Internal function for computing series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoPSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoT","Chebyshev polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoTSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoU","Chebyshev polynomials.","Alphabetical","Polynomials (Special)"},
{"OrthoUSum","Sums of series of orthogonal polynomials.","Alphabetical","Polynomials (Special)"},
{"Outer","Return outer tensor product.","Alphabetical","Linear Algebra"},
{"PAdicExpand","P-adic expansion.","Alphabetical","Number Theory"},
{"Partition","Partition a list in sublists of equal length.","Alphabetical","Lists (Operations)"},
{"PatchLoad","Execute commands between <? and ?> in file.","Alphabetical","Input/Output"},
{"PatchString","Execute commands between <? and ?> in strings.","Alphabetical","String Manipulation"},
{"PDF","Probability density function.","Alphabetical","Probability & Statistics"},
{"Permutations","Return all permutations of a list.","Alphabetical","Combinatorics"},
{"Pi","Mathematical constant pi.","Alphabetical","Constants (Mathematical)"},
{"Plot2D","Adaptive two-dimensional plotting.","Alphabetical","Input/Output"},
{"Plot3DS","Three-dimensional (surface) plotting.","Alphabetical","Input/Output"},
{"Pop","Remove an element from a stack.","Alphabetical","Lists (Operations)"},
{"PopBack","Remove an element from the bottom of a stack.","Alphabetical","Lists (Operations)"},
{"PopFront","Remove an element from the top of a stack.","Alphabetical","Lists (Operations)"},
{"Postfix","","Alphabetical"},
{"Prefix","","Alphabetical"},
{"PrettyForm","Print an expression nicely with ASCII art.","Alphabetical","Input/Output"},
{"PrimitivePart","Return the primitive part of a univariate polynomial.","Alphabetical","Polynomials (Operations)"},
{"PrintList","Print list with padding.","Alphabetical","Lists (Operations)"},
{"Prog","","Alphabetical"},
{"ProperDivisors","The number of proper divisors.","Alphabetical","Number Theory"},
{"ProperDivisorsSum","The sum of proper divisors.","Alphabetical","Number Theory"},
{"Pslq","Search for integer relations between reals.","Alphabetical","Numbers (Operations)"},
{"PSolve","Solve a polynomial equation.","Alphabetical","Solvers (Symbolic)"},
{"Push","Add an element on top of a stack.","Alphabetical","Lists (Operations)"},
{"RadSimp","Simplify an expression with nested radicals.","Alphabetical","Expression Simplification"},
{"RamanujanSum","Compute the \"Ramanujan sum\".","Alphabetical","Number Theory"},
{"Random","Pseudo-random number generator.","Alphabetical","Numbers (Random)"},
{"RandomIntegerMatrix","Generate a matrix of random integers.","Alphabetical","Numbers (Random)"},
{"RandomIntegerVector","Generate a vector of random integers.","Alphabetical","Numbers (Random)"},
{"RandomPoly","Construct a random polynomial.","Alphabetical","Numbers (Random)"},
{"RandomSeed","Initialize random number generator.","Alphabetical","Numbers (Random)"},
{"RandVerifyArithmetic","","Alphabetical"},
{"Rationalize","Convert floating point numbers to fractions.","Alphabetical","Numbers (Operations)"},
{"Re","Real part of a complex number.","Alphabetical","Numbers (Complex)"},
{"Read","Read an expression from current input.","Alphabetical","Input/Output"},
{"ReadCmdLineString","Read an expression from the command line and return in a string.","Alphabetical","Input/Output"},
{"ReadToken","Read a token from current input.","Alphabetical","Input/Output"},
{"RemoveDuplicates","Remove any duplicates from a list.","Alphabetical","Lists (Operations)"},
{"Replace","Replace an entry in a list.","Alphabetical","Lists (Operations)"},
{"Retract","","Alphabetical"},
{"Reverse","Return the reversed list (without touching the original).","Alphabetical","Lists (Operations)"},
{"ReversePoly","Solve h(f(x))=g(x)+O(x^n) for h.","Alphabetical","Series"},
{"RightAssociative","","Alphabetical"},
{"RightPrecedence","","Alphabetical"},
{"Rng","Manipulate random number generators as objects.","Alphabetical","Numbers (Random)"},
{"RngCreate","Manipulate random number generators as objects.","Alphabetical","Numbers (Random)"},
{"RngSeed","Manipulate random number generators as objects.","Alphabetical","Numbers (Random)"},
{"Round","Round a number to the nearest integer.","Alphabetical","Numbers (Operations)"},
{"RoundTo","","Alphabetical"},
{"Rule","","Alphabetical"},
{"RuleBase","","Alphabetical"},
{"RuleBaseArgList","","Alphabetical"},
{"RuleBaseListed","","Alphabetical"},
{"Secure","","Alphabetical"},
{"Select","Select entries satisfying some predicate.","Alphabetical","Lists (Operations)"},
{"Set","Assign a variable.","Alphabetical","Variables"},
{"SetGlobalLazyVariable","Global variable is to be evaluated lazily.","Alphabetical","Variables"},
{"ShiftLeft","","Alphabetical"},
{"ShiftRight","","Alphabetical"},
{"Sign","Sign of a number.","Alphabetical","Calculus Related (Symbolic)"},
{"Simplify","Try to simplify an expression.","Alphabetical","Expression Simplification"},
{"Sin","Trigonometric sine function.","Alphabetical","Calculus Related (Symbolic)"},
{"Solve","Solve an equation symbolically.","Alphabetical","Solvers (Symbolic)"},
{"SolveMatrix","Solve a linear system.","Alphabetical","Linear Algebra"},
{"Space","Print one or more spaces.","Alphabetical","Input/Output"},
{"Sparsity","Return the sparsity of a matrix.","Alphabetical","Linear Algebra"},
{"Sqrt","Square root.","Alphabetical","Calculus Related (Symbolic)"},
{"SquareFree","Return the square-free part of polynomial","Alphabetical","Polynomials (Operations)"},
{"SquareFreeDivisorsList","The list of square-free divisors.","Alphabetical","Number Theory"},
{"StirlingNumber1","Return the n,mth Stirling Number of the first kind.","Alphabetical","Number Theory"},
{"StirlingNumber2","Return the n,mth Stirling Number of the second kind.","Alphabetical","Number Theory"},
{"String","Convert atom to string.","Alphabetical","String Manipulation"},
{"StringMid'Returns","","Alphabetical"},
{"StringMid'Get","Retrieve a substring.","Alphabetical","String Manipulation"},
{"StringMid'Set","Change a substring.","Alphabetical","String Manipulation"},
{"Subfactorial","Factorial and related functions.","Alphabetical","Combinatorics"},
{"Subst","Perform a substitution.","Alphabetical","Control Flow"},
{"SuchThat","Special purpose solver.","Alphabetical","Solvers (Symbolic)"},
{"Sum","Find the sum of a sequence.","Alphabetical","Series"},
{"SumForDivisors","Loop over divisors.","Alphabetical","Number Theory"},
{"SumTaylorNum","","Alphabetical"},
{"Swap","Swap two elements in a list.","Alphabetical","Lists (Operations)"},
{"SylvesterMatrix","Calculate a Sylvester matrix of two polynomials.","Alphabetical","Matrices (Special)"},
{"SystemCall","Pass a command to the operating system.","Alphabetical","Control Flow"},
{"Table","Evaluate while some variable ranges over interval.","Alphabetical","Lists (Operations)"},
{"TableForm","Print each entry in a list on a line.","Alphabetical","Lists (Operations)"},
{"Tail","Return a list without its first element.","Alphabetical","Lists (Operations)"},
{"Take","Take a sublist from a list, dropping the rest.","Alphabetical","Lists (Operations)"},
{"Tan","Trigonometric tangent function.","Alphabetical","Calculus Related (Symbolic)"},
{"Taylor","Univariate Taylor series expansion.","Alphabetical","Series"},
{"tDistribution","Student's t distribution.","Alphabetical","Probability & Statistics"},
{"TestPiper","","Alphabetical"},
{"TeXForm","Export expressions in LaTeX form.","Alphabetical","Input/Output"},
{"Time","Measure the time taken by a function.","Alphabetical","Control Flow"},
{"ToBase","Conversion of a number in decimal base to non-decimal base.","Alphabetical","Numbers (Operations)"},
{"ToeplitzMatrix","Create a Toeplitz matrix.","Alphabetical","Matrices (Special)"},
{"ToFile","Connect current output to a file.","Alphabetical","Input/Output"},
{"ToStdout","Select initial output stream for output.","Alphabetical","Input/Output"},
{"ToString","Connect current output to a string.","Alphabetical","Input/Output"},
{"Trace","Return the trace of a matrix.","Alphabetical","Linear Algebra"},
{"TraceExp","Evaluate with tracing enabled.","Alphabetical","Control Flow"},
{"TraceRule","Turn on tracing for a particular function.","Alphabetical","Control Flow"},
{"TraceStack","Show calling stack after an error occurs.","Alphabetical","Control Flow"},
{"Transpose","Return the transpose of a matrix.","Alphabetical","Linear Algebra"},
{"TrapError","","Alphabetical"},
{"TrigSimpCombine","Combine products of trigonometric functions.","Alphabetical","Expression Simplification"},
{"True","Boolean constant representing true.","Alphabetical","Constants (System)"},
{"TruncRadian","","Alphabetical"},
{"Type","Return the type of an expression.","Alphabetical","Lists (Operations)"},
{"Undefined","Constant signifying an undefined result.","Alphabetical","Constants (Mathematical)"},
{"UnFence","","Alphabetical"},
{"UnFlatten","The inverse operation of Flatten.","Alphabetical","Lists (Operations)"},
{"Union","Return the union of two lists.","Alphabetical","Lists (Operations)"},
{"UniqueConstant","Create a unique identifier.","Alphabetical","Variables"},
{"UnList","Convert a list to a function application.","Alphabetical","Lists (Operations)"},
{"Until","Loop until a condition is met.","Alphabetical","Control Flow"},
{"Use","Load a file, but not more than once.","Alphabetical","Control Flow","Input/Output"},
{"V, InVerboseMode","Set verbose output mode.","Alphabetical","Input/Output"},
{"VandermondeMatrix","Create a Vandermonde matrix.","Alphabetical","Matrices (Special)"},
{"VarList","Return a list of variables appearing in an expression.","Alphabetical","Lists (Operations)"},
{"VarListArith","Return a list of variables appearing in an expression.","Alphabetical","Lists (Operations)"},
{"VarListSome","Return a list of variables appearing in an expression.","Alphabetical","Lists (Operations)"},
{"Verify","","Alphabetical"},
{"VerifyArithmetic","","Alphabetical"},
{"VerifyDiv","","Alphabetical"},
{"Where","Substitute result into expression.","Alphabetical","Functional Operators"},
{"While","Loop while a condition is met.","Alphabetical","Control Flow"},
{"WithValue","Temporary assignment during an evaluation.","Alphabetical","Control Flow"},
{"Write","Low-level printing routine.","Alphabetical","Input/Output"},
{"WriteString","Low-level printing routine for strings.","Alphabetical","Input/Output"},
{"WronskianMatrix","Create a Wronskian matrix.","Alphabetical","Matrices (Special)"},
{"XmlExplodeTag","Convert XML strings to tag objects.","Alphabetical","Input/Output"},
{"XmlTokenizer","Select an XML syntax tokenizer for parsing the input.","Alphabetical","Input/Output"},
{"ZeroMatrix","Make a zero matrix.","Alphabetical","Linear Algebra"},
{"ZeroVector","Create a vector with all zeroes.","Alphabetical","Linear Algebra"},
{"Zeta","Riemann's Zeta function.","Alphabetical","Functions (Special)"}
};

jlist = new java.util.Vector();


categories = new DefaultMutableTreeNode("Categories");

categories.add(new DefaultMutableTreeNode(new FunctionInfo("Alphabetical","All functions in alphabetical order.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Calculus Related (Symbolic)","Functions for differentiation, integration, and solving of equations.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Combinatorics","Combinatorics related functions.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Numbers (Complex)","Functions that allow manipulation of complex numbers.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Differential Equations","In this section, some facilities for solving differential equations are described. Currently only simple equations without auxiliary conditions are supported.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Expression Simplification","This section describes the functions offered that allow simplification of expressions.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Linear Algebra","Functions used to manipulate vectors (represented as lists) and matrices (represented as lists of lists).")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Numbers (Operations)","Besides the usual arithmetical operations, Piper defines some more advanced operations on numbers. Many of them also work on polynomials.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Matrices (Predicates)","Predicates related to matrices.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Numbers (Predicates)","Predicates relating to numbers.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Propositional Logic","Functions for propositional logic.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Numbers (Random)","Random number related functions.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Series","Functions which operate on series.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Functions (Special)","In this section, special and transcendental mathematical functions are described.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Solvers (Numeric)","Functions for solving equations numerically.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Solvers (Symbolic)","By solving one tries to find a mathematical object that meets certain criteria.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Transforms","In this section, some facilities for various transforms are described.")));

categories.add(new DefaultMutableTreeNode(new FunctionInfo("Matrices (Special)","Various special matricies")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Polynomials (Operations)","Functions to manipulate polynomials, including functions for constructing and evaluating orthogonal polynomials.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Polynomials (Special)","Special polynomials.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Lists (Operations)","Most objects that can be of variable size are represented as lists.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Functional Operators","These operators can help the user to program in the style of functional programming languages such as Miranda or Haskell.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Control Flow","Controls the order in which statements or function calls are executed.")));

categories.add(new DefaultMutableTreeNode(new FunctionInfo("Predicates","A predicate is a function that returns a boolean value, i.e. True or False.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Constants (System)","System related constants.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Constants (Mathematical)","Mathematical constants.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Variables","Functions that work with variables.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Input/Output","Functions for input, output, and plotting.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("String Manipulation","Functions for manipulating strings.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Probability & Statistics","Probability and statistics.")));
categories.add(new DefaultMutableTreeNode(new FunctionInfo("Number Theory","Functions that are of interest in number theory. They typically operate on integers")));
//categories.add(new DefaultMutableTreeNode(new FunctionInfo("Predicates","test")));

for(row = 0;row < functions.length;row++)
{
    //Populate JList.
    jlist.addElement(functions[row][0]);
    
    //Populate JTree.
    for(column=2; column < functions[row].length; column++)
    {
        category = functions[row][column];
        System.out.println("XXXXX " + functions[row][column]);
        
        
        boolean hasCategory = false;
        global.children = categories.children();
        for(DefaultMutableTreeNode child:children)
        {
            if(child.getUserObject().toString().equalsIgnoreCase(category)) //Add leaf to existing category.
            {
                child.add(new DefaultMutableTreeNode(new org.mathrider.piperdocsplugin.FunctionInfo(functions[row][0],functions[row][1]) ));
                hasCategory = true;
            }

            
        }//end for.
        
        if(hasCategory == false)
        {
            leaf = new DefaultMutableTreeNode(new org.mathrider.piperdocsplugin.FunctionInfo(functions[row][0],functions[row][1]));
            category = new DefaultMutableTreeNode(functions[row][column]);
            category.add(leaf);
            categories.add(category);
        }
        
/*
        if(categories.containsKey(category)) //Add leaf to existing category.
        {
            categoryNode = categories.get(category);
            categoryNode.add(new DefaultMutableTreeNode(functions[row][0]));
        }
        else //Create new category and add leaf;
        {
            categoryLeaf = new DefaultMutableTreeNode(functions[row][0]);
            categoryNode = new DefaultMutableTreeNode(categoryLeaf);
            categories.put(category,categoryNode);
        }
 
*/
    }//end for.

    
}//end for/

tree = new org.mathrider.piperdocsplugin.FunctionInfoTree(categories);


ToolTipManager.sharedInstance().registerComponent(tree);

tree.getSelectionModel().setSelectionMode(javax.swing.tree.TreeSelectionModel.SINGLE_TREE_SELECTION);
//tree.addTreeSelectionListener(this);
treeView = new JScrollPane(tree);
frame.add(treeView, BorderLayout.EAST);


list = new javax.swing.JList(jlist);
    list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    list.addListSelectionListener(this);
    JScrollPane pane = new JScrollPane(list);
 
    frame.add(pane, BorderLayout.WEST);


contentPane = frame.getContentPane();

frame.pack();
frame.setAlwaysOnTop(true);
frame.setTitle("MathRider");
frame.setSize(new Dimension(300, 500));
frame.setResizable(true);
frame.setPreferredSize(new Dimension(250, 200));
frame.setLocationRelativeTo(null); // added
frame.show();

    %output 
      
    %end

%end




:indentSize=4:tabSize=4:wrap=none:
