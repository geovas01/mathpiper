%uasm65,title=""
;****************************************************************************
;  UMON65 Understandable Monitor for the 6500 series microprocessors.
;  Copyright 2015 by Ted Kosan.
;
;
;****************************************************************************


;****************************************************************************
;                                Equates Area.
;****************************************************************************   


;
;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
;
;Transmitt Receive Register.
6551TRR:	equ A000h ;400ah


;Status Register.  
;		    Status			          cleared by
;	b0	Parity error * (1: error)       self clearing **
;	b1	Framing error * (1: error)      self clearing **
;	b2	Overrun * (1: error)            self clearing **
;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
;                                                                                                            
;	note: * no interrupt generated for these conditions
;	      ** cleared automatically after a read of RDR and the next 
;		error free receipt of data
6551StR:	equ A001h ;400bh 

6551Sleep: equ A002h	; When an lda to this address is performed the emulator
			;can be put to sleep.


;Comand Register  
;	b0	Data Terminal Ready
;			0 : disable receiver and all interrupts (DTR high)
;			1 : enable receiver and all interrupts (DTR low)
;	b1	Receiver Interrupt Enable
;			0 : IRQ interrupt enabled from bit 3 of status register
;			1 : IRQ interrupt disabled
;	b3,b2	Transmitter Control
;				Transmit Interrupt    RTS level    Transmitter
;			00	   disabled		high		off
;			01	   enabled		low		on
;			10	   disabled		low		on
;			11	   disabled		low	   Transmit BRK
;	b4	Normal/Echo Mode for Receiver
;			0 : normal
;			1 : echo (bits 2 and 3 must be 0)
;	b5	Parity Enable
;			0 : parity disabled, no parity bit generated or received
;			1 : parity enabled
;	b7,b6	Parity
;			00 : odd parity receiver and transmitter
;			01 : even parity receiver and transmitter
;			10 : mark parity bit transmitted, parity check disabled
;			11 : space parity bit transmitted, parity check disabled


;6551CmR	equ 0b202h  

;Control Register
;
;	b3-b0	baud rate generator:
;			0000 : 16x external clock
;			0001 : 50 baud
;			0010 : 75
;			0011 : 110
;			0100 : 134.5
;			0101 : 150
;			0110 : 300
;			0111 : 600
;			1000 : 1200
;			1001 : 1800
;			1010 : 2400
;			1011 : 3600
;			1100 : 4800
;			1101 : 7200
;			1110 : 9600
;			1111 : 19,200
;	b4	receiver clock source
;			0 : external receiver clock
;			1 : baud rate generator
;	b6,b5	word length                                                                  
;			00 : 8 bits
;			01 : 7
;			10 : 6
;			11 : 5
;	b7	stop bits
;			0 : 1 stop bit
;			1 : 2 stop bits
;			    (1 stop bit if parity and word length = 8)
;			    (1 1/2 stop bits if word length = 5 and no parity)
;6551CtR	equ 0b203h  




;InPort0 Equate.
InPort0:	equ 0a000h

;OutPort0 Equate.
OutPort0:	equ 0a100h

;****************************************************************************
;                       General Purpose Pointer Area.
;****************************************************************************
	org 0000h
	
GenPoint:	dwd ?
IRQVect:	dwd ?		;
BRKVect:	dwd ?		;Break command indirect vector.
MessPtr:	dwd ?		;
PointerA:	dwd ?		;
PointerB:	dwd ?		;
PointerC:	dwd ?		;
NOpAdPtr:	dwd ?		;
BOpAdPtr:	dwd ?		;
BrkPt1Ad:	dwd ?		;
BrkPt2Ad:	dwd ?		;
BrkPt3Ad:	dwd ?		;                                                                                       
BrkPt4Ad:	dwd ?		;


	
;****************************************************************************
;                   General Purpose Variable Storage Area.
;****************************************************************************
;	org 0200h 

		  
Obj1:		dbt ?
Obj2:		dbt ?
Obj3:		dbt ?
Obj2Flg:	dbt ?
Obj3Flg:	dbt ?
AddMode:	dbt ?
SrchTabl:	dbt 10d(?)
SrchBtCt:	dbt ?
TempAdd:	dwd ?
TempAdd2:	dwd ?
BrkPt1St:	dbt ?
BrkPt2St:	dbt ?
BrkPt3St:	dbt ?
BrkPt4St:	dbt ?
BP1OpHld:	dbt ?
BP2OpHld:	dbt ?
BP3OpHld:	dbt ?
BP4OpHld:	dbt ?
BPNumHld:	dbt ?
BrValHld:	dbt ?
TrBrkFlg:	dbt ?
CurInsLn:	dbt ?
NOpCdHld:	dbt ?
BOpCdHld:	dbt ?
BrnchFlg:	dbt ?
TracCnt:	dbt ?
AddHold:	dwd ?
ObCdHld1:	dbt ?
ObCdHld2:	dbt ?
OpCdHold:	dbt ?
TempA:		dbt ?
UPgmCntr:	dwd ?
UAccum:		dbt ?
UXReg:		dbt ?
UYReg:		dbt ?
UStkPtr:	dbt ?
UStatReg:	dbt ?
ASCIIbuf:	dbt 16d(?)
EndAdd:		dwd ?
OpOffSet:	dbt ?
OpFld1:		dbt 20d(?)
OpFld2:		dbt 20d(?)
OpFld3:		dbt 20d(?)	
CodeCntr:	dbt ?
Number:		dbt ?
ChkSum:		dbt ?
RecLen:		dbt ?
CkSumAc:		dwd ?
RecType: 	dbt ?
wait0:		dbt ?
wait1:		dbt ?
			dbt ?
InptBufr:	dbt 40d(?)
Command:	dbt ?
RegTemp:	dbt ?
DataTemp:	dbt ?

;****************************************************************************
;                        Monitor Eprom Entry Point.
;****************************************************************************
	org 0e000h Note
	;org 1000h
	jmp Start

;****************************************************************************
;                  Monitor Utility Subroutine Jump Table.
;****************************************************************************
	jmp OutChar	;Output byte in A register to serial port.
	
	jmp GetChar	;Get a byte from the serial port.
	
	jmp GetCharW	;Wait and get a byte from the serial port.
	
	jmp PrntMess	;Print a message to the serial port.
	
	jmp OutSpace	;Output spaces to the serial port.
	
	jmp OutHex	;Output a HEX number to the serial port.
	
	jmp DgtToBin	;Convert an ASCII digit into binary.
	
	jmp GetLine	;Input a line from the serial port.
	

; Beginning of UMON65.
;****************************************************************************
;                       Start of UMON65 Main Routine.
;
;
;****************************************************************************
start:
	ldx #0ffh	;Initialize stack pointer and clear decimal
	txs		; mode.
;	cli		;
	cld		;
	
	jsr InitVars	;Initialize variables.
	
	lda 0aa00h		; If the byte at 0c000h is not zero, there is a program
	cmp #0d			; in the EEPROM. Run this program instead of
	beq EnterMon	; entering the monitor.
	jmp 0c000h		;

;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
		
;****************************************************************************
;                     Check Computer's Configuration.
;****************************************************************************
CkConfig:
	;lda InPort0	;Get the switch settings and mask out the 
	;and #00001111b	; switch's high nibble.

;CkMon:
	
	;cmp #1d	;If the switch is set to a 1 then print the
	;bne CkEEPROM	; UMON65 monitor startup message and enter the
EnterMon:
	ldx #OpenMess<	; monitor through the maskable interrupt vector.
	ldy #OpenMess>	;
	jsr PrntMess	;
	;brk		    ;
    lda #00000000b	 ;Initialize user's status register.
	sta UStatReg	;

	
	lda #0d	    ;Initialize user's accumulator.
	sta UAccum	;
	
	sta UXReg	;Initialize user's X register.
	
	sta UYReg	;Initialize user's Y register.
	
	lda #0ffh    ;Initialize user's stack pointer
	sta UStkPtr	 ;.
    
    jmp ResetEntryPoint

CkEEPROM:
	cmp #2d		;If the switch is set to a 2 then get the
	bne DoLgtSho	; switch's high nibble and jump to a program
	;lda InPort0	; present in the EEPROM which is indicated by
	and #11110000b	; the high nibble's value.  The program can be
	lsr a		; located at 1 of the following 16 locations:
	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
	clc
	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
	sta PointerA+1d	; 15-DE00.
	lda #0d		;
	sta PointerA	;
	jmp (PointerA)	;
			
DoLgtSho:
	jmp LghtShow
	
;****************************************************************************
;                            Light Show Subroutine.
;****************************************************************************
LghtShow:
	ldy #0h		;Make the Y register count from 0 to 255 and
	sty TempA	; output each number in the count to the
	;sty OutPort0	; light register.
LSOtLoop:		;
	ldx #100d	;
LSInLoop:		;
	iny		;
	bne LSInLoop	;
	dex		;
	bne LSInLoop	;
	inc TempA	;
	lda TempA	;
	;sta OutPort0	;
	jmp LSOtLoop	;

;****************************************************************************
;                            Monitor's Main Loop.
;****************************************************************************
MainLoop:	

	jsr GetLineP	;Get a typed line from the serial port.

	jsr ParsLine	;Break line into fields.
	
	jsr CkValCmd	;Check to see if a valid monitor command was
			; entered and if so execute that command's code.
	jmp MainLoop

	
;****************************************************************************
;                    Get Line From Serial Port Subroutine.
;****************************************************************************
GetLineP:
	ldx #Prompt<	;Print Prompt.
	ldy #Prompt>	;
	jsr PrntMess	;

GetLine:	
	ldy #0d		;Initialize Y index register.
	sty OpOffSet	;Initialize opcode holder offset pointer.
	sty command	;Initialize command holder.
	sty OpFld1	;Initialize operand field 1 buffer.
	sty OpFld2	;Initialize operand field 2 buffer.
	sty OpFld3	;Initialize operand field 3 buffer.
	
	ldy #0d		;Clear input buffer.
	lda #0d		;
ClrInpBf:		;
	sta InptBufr,y	;
	iny		;
	cpy #39d	;
	bne ClrInpBf	;
	
	ldy #0h		;Use Y register as buffer pointer.
	
GtAnChar:
	jsr GetCharW
;	jsr OutChar	;Echo character.  ;Note: remove for muvium.

	cmp #0h		;If no character is entered then try again.
	beq GtAnChar	;
	
	cmp #8d		;Check to see if the user entered a Delete or
	bne CkDel	; a Backspace.  If so then erase the character
	jmp DoDelete	; to the left of the cursor.
CkDel:			;
	cmp #127d	;
	bne GtCkChar	;
DoDelete:		;
	dey		;
	bmi AtStart	;
	lda #32d	;
	jsr OutChar	;
	lda #8d		;
	jsr OutChar	;
	jmp GtAnChar	;

AtStart:
	ldy #0d
	jmp GtAnChar
	
GtCkChar:
	cmp #13d	;If a CR was entered then accept line and exit,
	beq GtLnDone	; if not then accept the next character and
	sta InptBufr,y	; place it into the input buffer.
	iny		;
	
	cpy #39d	;Do not let buffer expand past 40 characters.
	bne GtAnChar
	ldy #39d	;Set buffer at 40 characters if over 40 characters.

	jmp GtAnChar	;
	
GtLnDone:
	;If a NL is in the input buffer then remove it.
	dey
	lda InptBufr,y
	cmp #10d
	beq PutNull
	iny
PutNull:
	lda #0h		;Put a NULL at end of the input buffer.
	sta InptBufr,y	;
		
	rts
	
;****************************************************************************
;                       Parse Input Buffer Subroutine.
;****************************************************************************
ParseOpr:	;Entry point if parsing for a UASM command is not
	ldy #0ffh	; desired.
	jmp GtAnoOpr	;
	
ParsLine:
	ldy #0d

	lda InptBufr,y
	beq ExtPrsLn	;If NULL or CR encountered then return.
	
	cmp #63d	;Check for upper case letter.
	bmi ParError	;
	cmp #90d	;	
	bpl CkSmCase	;
	
	sec
	bcs GetCmd	;
	
CkSmCase:
	cmp #97d	;Check for lower case letter.
	bmi ParError	;
	cmp #122d	;
	bpl ParError	;
	                
GetCmd:
	sta command	;Store command in command buffer.
                        
GtAnoOpr:       
	iny		;Point Y to the next operand field and check to
	cpy #20d	;make sure that the input line is not too long.
	beq ParError	;
	                
	lda InptBufr,y	;Check for the end of the input line.
	cmp #0d		;
	beq ExtPrsLn	;
	                
	cmp #32d	;Check for a space between operand fields.
	beq GtAnoOpr	;
	                
ScanOprn:              
	ldx OpOffSet	;Point X to the beginning of the current operand
	txa		; field holder and point OpOffSet to the beginning
	clc             
	adc #20d	; of the next operand field holder.
	sta OpOffSet	;
	
TranDgt:
	lda InptBufr,y	;
	                
	cmp #32d	;If a space is encountered then stop scanning.
	beq DoneScan	;
	                
	Cmp #0d		;If a CR is encountered then stop scanning.
	beq doneScan	;
	                
	sta OpFld1,x	;Transfer current operand from input buffer into
	inx		; current operand field holder.
	iny		;
	cpy #40d
	beq ParError
	
	jmp TranDgt	
	
DoneScan:
	lda #0h		;Put a NULL at the end of the current operand field
	sta OpFld1,x	; holder.
	
	jmp GtAnoOpr

ParError:
	rts
ExtPrsLn:
	rts

;****************************************************************************
;                     Check for Valid Command Subroutine.
;****************************************************************************
CkValCmd:
	sec
	
	lda command
	jsr ToLower

	cmp #108d	;Check for Load command.
	bne NxtCmd1	;
	jsr LdSRecs	;
	jmp ExitCmd	;
                        
NxtCmd1:
	cmp #100d	;Check for Dump command.
	bne NxtCmd2	;
	jsr Dump	;
	jmp ExitCmd	;
                        
NxtCmd2:
	cmp #114d	;Check for Register command.
	bne NxtCmd3	;
	jsr Register	;
	jmp ExitCmd	;
		
NxtCmd3:
	cmp #103d	;Check for Go command.
	bne NxtCmd4	;
	jsr Go		;
	jmp ExitCmd	;
	
NxtCmd4:
	cmp #101d	;Check for Enter command.
	bne NxtCmd5	;
	jsr Enter	;
	jmp ExitCmd	;
	
NxtCmd5:
	cmp #102d	;Check for Fill command.
	bne NxtCmd6	;
	jsr Fill	;
	jmp ExitCmd	;

NxtCmd6:
	cmp #117d	;Check for Unassemble command.
	bne NxtCmd7	;
	jsr UnAssem	;
	jmp ExitCmd	;

NxtCmd7:
	cmp #116d	;Check for Trace command.
	bne NxtCmd8	;
	jsr Trace	;
	jmp ExitCmd	;

NxtCmd8:
	cmp #98d	;Check for Breakpoint command.
	bne NxtCmd9	;
	jsr BreakPnt	;
	jmp ExitCmd	;
	
NxtCmd9:
	cmp #115d	;Check for Search command.
	bne NxtCmd10	;
	jsr Search	;
	jmp ExitCmd	;

NxtCmd10:
	cmp #109d	;Check for Move command.
	bne NxtCmd11	;
	jsr Move	;
	jmp ExitCmd	;
	
NxtCmd11:
	cmp #'a'	;Check for Assemble command.
	bne NxtCmd12	;
	jsr Assemble	;
	jmp ExitCmd	;

NxtCmd12:
	cmp #104d	;Check for Help command.
	bne NxtCmd13	;
	jsr Help	;
	jmp ExitCmd	;
NxtCmd13:                 
	cmp #63d	;
	bne ExitCmd	;
	jsr Help	;
	jmp ExitCmd	;

ExitCmd:
	bcs CmdOk
	
CmdError:		;If there was an error with a command then
	ldx #CmdErMes<	; print a question mark.
	ldy #CmdErMes>	;
	jsr PrntMess	;
	clc		;
	rts		;
	
CmdOk:
	sec
	rts

;****************************************************************************
;                     Maskable Interrupt Service Subroutine.
;****************************************************************************
MaskInt:
	sei		;Disable interrupts.

	sta TempA	;Save accumulator.
			
	pla		;Check to see if BRK command was executed.
	pha		;
	and #10h	;
	bne DoBRK	;
	
	lda TempA	;Restore accumulator.

IRQ:	
	jmp (IRQVect)
	
DoBRK:
	jmp (BRKVect)

	
;****************************************************************************
;                          Break Service Subroutine.
;****************************************************************************
	
BRK:
	pla		;Save user's status register.
	sta UStatReg	;

	
	lda TempA	;Save user's accumulator.
	sta UAccum	;
	
	stx UXReg	;Save user's X register.
	
	sty UYReg	;Save user's Y register.
	
	tsx
    
    inx ;Remove the remaining 2 bytes that were pushed on the
    inx ; stack by the brk command.
    
	stx UStkPtr	;Save user's stack pointer.
	
	pla		;Save program counter of break instruction
	sec		; that caused execution of this code.
	sbc #1d		;
	sta UPgmCntr	;
	pla		; 
	sbc #0d		;
	sta UPgmCntr+1d	;
;	cli

ResetEntryPoint:
	ldy #0d		;Print user's registers.
	sty OpFld1	;
	jsr Register	;

	lda TrBrkFlg	;If this break was placed by the trace command
	cmp #1d		; then go back to the trace subroutine.
	bne RepBPOp	;
	jmp Tr2ndEnt	;
	
RepBPOp:
	ldy #3d		;Replace the opcodes of all breakpointed
	ldx #6d		; addresses.
CkBPStBr:              ;
	lda BrkPt1St,y	;
	cmp #1d		;
	bne NxtBPStB	;
	lda BP1OpHld,y	;
	sta (BrkPt1Ad,x);
NxtBPStB:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPStBr	;
	
GoMain:
	jmp MainLoop	;Enter monitor.


;****************************************************************************
;                       Assemble Command Subroutine.
;****************************************************************************
Assemble:

	ldx #0d		;Get address to start assembling at and store
	jsr GetAdd	; in pointer A.
	bcs AAddOk	;
	jmp ErrAsem	;
AAddOk:		;
	stx PointerA	;
	sty PointerA+1d	;

AsemTop:		;On new line print current address being
	ldx #CRLF<	; assembled at and get next instruction to be
	ldy #CRLF>	; assembled from user.
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr GetLine	;
	jsr ParseOpr	;
	
	lda OpFld1	;Check for operator to be assembled. If no
	cmp #0d		; operator is found then exit Assemble 
	beq AsemDone	; subroutine.
	cmp #32d	;
	bne ACont	;
AsemDone:              ;
	jmp ExitAsem	;
	
ACont:			;Convert operator in input buffer to upper case,
	ldy #0d		; check to see if it is in the operator table and
ConvAno:		;
	lda OpFld1,y	; output a question mark if operator was not found.
	jsr ToUpper	;
	sta OpFld1,y	;
	iny		;
	cpy #3d		;
	bne ConvAno	;
	jsr OptrScan	;
	bcs AOptrOk	;
	
PrntQues:
	jsr PrntAdd	;If there was an error assembling the instruction
	lda #32d	; input from the user into object code then re-
	jsr OutChar	; output the line and print a question mark.
	ldx #OpFld1<	;
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;
	lda #32d	;
	jsr OutChar	;
	lda #63d	;
	jsr OutChar	;
	jmp AsemTop	;
	
AOptrOk:		;Check address mode of operand and print a quesion
	jsr AdMdScan	; mark if error occures while scanning operand.
	bcs AOpndOk	;
	jmp PrntQues
		
AOpndOk:		;Check to see if address mode of operand is a
	jsr AdMdTbSc	; valid address mode for instruction.
	bcs AOpTbFnd	;
	jmp PrntQues
		
AOpTbFnd:		;Extract object code from operand.
	jsr OpndScan	;
	bcs PrntAssm	;
	jmp PrntQues	;
	
PrntAssm:
	jsr PrntAdd	;Re-output current address.
	
	ldy #0d		;
	
	lda Obj1	;Output opcode, store it in memory, point to next
	sta (PointerA),y; byte, and print one space.
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj2Flg	;Output second object code byte if present, store it in
	beq NoObjCd	; it in memory, point to next byte, and print one
	lda Obj2	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj3Flg	;Output third object code byte if present, store
	beq NoObjCd3	; it in memory, point to next byte, and print one
	lda Obj3	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	jmp NoExSpcs

NoObjCd:		;If fewer then 3 bytes of object code are output
	lda #32d	; then output spaces instead.
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
NoObjCd3:
	lda #32d	;
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
	
NoExSpcs:
	lda #32d	;
	jsr OutChar	;
	ldx #OpFld1<	;Re-output instruction that user had entered in.
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;

	jmp AsemTop
	
	
ErrAsem:
	clc
	rts
	
ExitAsem:
	sec
	rts
	

;****************************************************************************
;                       Operator Scan Subroutine.
;****************************************************************************
OptrScan:

	ldx #OpTable<	;Point pointer B to beginning of the operator
	stx PointerB	; table.
	ldx #Optable>	;
	stx PointerB+1d	;
	
OSCkAno:
	ldy #0d		;Compare a digit of the operator that the user
OSCkAnCM:		;
	lda (PointerB),y; entered with the analogous digit of the
	cmp OpFld1,y	; operator in the operator table.
	beq CharMtch	;
	
OptScan2:
	lda PointerB	;Point pointer B to the beginning of the next
	clc		; operator in the operator table.
	adc #10d	;
	sta PointerB	;
	bcc OSNoCary	;
	inc PointerB+1d	;
	
OSNoCary:
	ldy #4d		;Check for the end of the operator table.
	lda (PointerB),y;
	cmp #'Z'	;
	beq OSNoMtch	;
	jmp OSCkAno	;
	
CharMtch:		;Check for an operator match in the operator
	iny		; table.
	cpy #3d		;
	beq OSMatch	;
	jmp OSCkAnCM	;
	
OSNoMtch:
	clc
	rts
	
OSMatch:
	sec
	rts


;****************************************************************************
;                     Address Mode Scan Subroutine.
;****************************************************************************
AdMdScan:

AMSCkIMP:
	ldy #0d		;Check for implied addressing mode.
	lda OpFld2,y	;
	cmp #0d		;
	bne AMSCkIMM	;
	lda #'P'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkIMM:		;Check for immediate addressing mode.
	cmp #'#'	;
	bne AMSCkACC	;
	lda #'M'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkACC:		;Check for accumulator addressing mode.
	cmp #'A'	;
	beq CkSpNull	;
	cmp #'a'	;
	beq CkSpNull	;
	jmp AMSCkREL	;
CkSpNull:		;
	iny		;
	lda OpFld2,y	;
	Cmp #0d		;
	beq IsAcc	;
	cmp #32d	;
	beq IsAcc	;
	jmp AMSCkREL	;
IsAcc:			;
	lda #'C'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkREL:		;Check for relative addressing mode.
	ldy #6d		;
	lda (PointerB),y;
	cmp #'L'	;
	bne AMSCkA_I	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkA_I:		;Dispatch to absolute or indexed check code.
	ldy #0d		;
	lda OpFld2,y	;
	cmp #'('	;
	bne AMSCkAB?	;
	jmp AMSCkId?	;
	
AMSCkAB?:		;Check to see if operand is absolute addressing
	ldy #0d		; mode or absolute indexed addressing mode.
AMSScnAB:		;
	lda OpFld2,y	;
	cmp #','	;
	beq CkXorY	;
	cmp #0d		;
	beq IsABS	;
	iny		;
	jmp AMSScnAB	;
	
CkXorY:		;Check for absolute X or absolute Y addressing
	iny		; mode.
	lda OpFld2,y	;                                                                        
	cmp #'X'	;
	beq IsABX	;
	cmp #'x'	;
	beq IsABX	;
	cmp #'Y'	;
	beq IsABY	;
	cmp #'y'	;
	beq IsABY	;
	jmp ErrAMS	;
	
IsABX:			;Save ABS, ABX or ABY mode in the variable to be
	lda #'X'	; returned.
	sta AddMode	;
	jmp ExitAMS	;
IsABY:			;
	lda #'Y'	;
	sta AddMode	;
	jmp ExitAMS	;
IsABS:			;
	lda #'S'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkId?:		;Dispatch to code that checks for IIR, IRI or
	iny		; IND addressing modes.
	lda OpFld2,y	;
	cmp #','	;
	beq CkIIR	;
	cmp #')'	;
	beq CkIRIIND	;
	cpy #11d	;
	bne AMSCkId?	;
	jmp ErrAMS	;

CkIIR:			;Check for IIR addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'X'	;
	beq IsIIR	;
	cmp #'x'	;
	beq IsIIR	;
	jmp ErrAMS	;
	
IsIIR:
	lda #'R'	;Save IIR addressing mode code in variable to be
	sta AddMode	; returned.
	jmp ExitAMS	;
	
CkIRIIND:		;Check for IND addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #0d		;
	beq IsIND	;
	cmp #','	;
	beq CkIRI	;
	jmp ErrAMS	;
	
CkIRI:			;Check for IRI addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'Y'	;
	beq IsIRI	;
	cmp #'y'	;
	beq IsIRI	;
	jmp ErrAMS	;
	
IsIND:			;Save IND or IRI addressing mode code in variable
	lda #'D'	; to be returned.
	sta AddMode	;
	jmp ExitAMS	;
IsIRI:			;
	lda #'I'	;
	sta AddMode	;
	jmp ExitAMS	;
	
ErrAMS:
	clc
	rts
	
ExitAMS:
	sec
	rts
	
	
;****************************************************************************
;                   Address Mode Table Search Subroutine.
;****************************************************************************
AdMdTbSc:		
	ldy #6d		;Check for address mode match between contents
	lda (PointerB),y; of variable AddMode & OpTable.
	cmp AddMode	;
	beq ExitAdMd	;
	
	lda PointerB	;Pointer Pointer B to next operator in
	clc		; operator table.
	adc #10d	;
	sta PointerB	;
	bcc AdMdNoCy	;
	inc PointerB+1d	;
	
AdMdNoCy:		;Check to see if next operator is the same type
	jsr OSCkANO	; that we are currently trying to assemble.
	bcs AdMdTbSc	;
	
ErrAdMd:
	clc
	rts
	
ExitAdMd:
	sec
	rts

;****************************************************************************
;                       Operand Scan Subroutine.
;****************************************************************************
OpndScan:

	lda #0d		;Initialize the flags that indicate whether or
	sta Obj2Flg	; not there are object bytes in addition to
	sta Obj3Flg	; the opcode object byte.
	
	ldy #7d		;Get the opcode of the instruction being 
	lda (PointerB),y; currently assembled from the opcode table
	sta Obj1	; and put it in Obj1.
	
	lda AddMode	;Check to see what address mode the instruction
	cmp #'P'	; currently being assembled is.
	beq OpndIMP	;
	cmp #'C'	;
	beq OpndACC	;
	cmp #'M'	;
	beq OpndIMM	;
	cmp #'S'	;
	beq OpndAB??	;
	cmp #'X'	;
	beq OpndAB??	;
	cmp #'Y'	;
	beq OpndAB??	;
	cmp #'I'	;
	beq OpndIN??	;
	cmp #'R'	;
	beq OpndIN??	;
	cmp #'D'	;
	beq OpndIN??	;
	cmp #'L'	;
	beq OpndAB??	;
	jmp ErrOpndS	;

OpndIMP:		;Process implied addressing mode.
	jmp ExtOpndS	;
	
OpndACC:		;Process accumulator addressing mode.
	jmp ExtOpndS	;
	
OpndIMM:		;Process immediate addressing mode.
	jsr ScnForHex	;
	bcs OpnMHFnd	;
	jmp ErrOpndS	;
OpnMHFnd:		;
	jsr AsToBin	;
	bcs OpndCvOk	;
	jmp ErrOpndS	;
OpndCvOk:		;
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;


OpndAB??:		;Process absolute, absolute X, absolute Y.
	jsr ScnForHex	; Check for relative addressing mode and send
	bcs OpnAHFnd	; to appropriate code if found.
	jmp ErrOpndS	;
OpnAHFnd:		;
	jsr GetAdd	;
	bcs OpndAdOk	;
	jmp ErrOpndS	;
OpndAdOk:		;
	lda AddMode	;
	cmp #'L'	;
	beq OpndDoBr	;
DoAdd:			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;

OpndIN??:		;Process indirect indexed, indexed indirect and
	jsr ScnForHex	; indirect addressing modes.
	bcs OpnINFnd	;
	jmp ErrOpndS	;
OpnINFnd:		;
	jsr GetAdd	;
	bcs OpINAdOk	;
	jmp ErrOpndS	;
OpINAdOk:		;
	lda AddMode	;
	cmp #'D'	;
	beq DoIND	;
	cpy #0d		;
	bne ErrOpndS	;
	stx Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
DoIND:			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;
	
OpndDoBr:		;Put address to be branched to in TempAdd and
	stx TempAdd	; the address of the first byte of the next
	sty TempAdd+1d	; instruction in TempAdd2.
	lda PointerA	;
	sta TempAdd2	;
	lda PointerA+1d	;
	sta TempAdd2+1d	;
	ldy #8d		;
	lda (PointerB),y;
	clc		;
	adc TempAdd2	;
	sta TempAdd2	;
	bcc OpBrNoOv	;
	inc TempAdd2+1d	;
OpBrNoOv:
	sec		;Subtract the address of the first byte of the
	lda TempAdd	; next instruction from the address to be branched
	sbc TempAdd2	; to in order to get the branch offset.
	sta TempAdd	;
	lda TempAdd+1d	;
	sbc TempAdd2+1d	;
	sta TempAdd+1d	;
	
	lda TempAdd+1d	;Check to make sure that MSB of the offset does
	cmp #0ffh	; not indicate a number greater than 127 or less
	beq OpCkNOff	; than 128.
	cmp #0d		;
	bne ErrOpndS	;
	
OpCkPOff:		;Check to make sure that LSB of the offset does
	lda TempAdd	; not contain a number greater than 127 or less
	cmp #128d	; than 128.
	bpl ErrOpndS	;
	jmp OffOk	;
OpCkNOff:		;
	lda TempAdd	;
	cmp #128d	;
	bmi ErrOpndS	;
	
OffOk:			;If offset is OK then put it in Obj2 and return.
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
	
ErrOpndS:
	clc
	rts
	
ExtOpndS:
	sec
	rts


;****************************************************************************
;                     Scan For Hex Digit Subroutine.
;****************************************************************************
ScnForHex:
	ldx #20d		
	
SFHNxtDg:
	ldy #0d		;Scan until either an upper case or a lower case
	lda OpFld1,x	; hex digit is encountered in the input buffer.
SFHCkDgt:		;
	cmp DgtTblUC,y	;
	beq ExitSFH	;
	cmp DgtTblLC,y	;
	beq ExitSFH	;
	iny		;
	cpy #16d	;
	beq IncBfPtr	;
	jmp SFHCkDgt	;

IncBfPtr:		;Point to the next digit in the input buffer.
	inx		;
	cpx #31d	;
	beq ErrSFH	;
	jmp SFHNxtDg	;

ErrSFH:
	clc
	rts
	
ExitSFH:
	sec
	rts
	
	
;****************************************************************************
;                       Breakpoint Command Subroutine.
;****************************************************************************
BreakPnt:
	lda OpFld1	;Check for a +, - or a ? in operand field #1.
	cmp #43d	;
	beq DoPlus	;
	cmp #45d	;
	beq DoMinus	;
	cmp #63d	;
	beq DmpBPAdd	;
	jmp ExitBP	;
DoPlus:		;
	jmp Plus	;
DoMinus:		;
	jmp Minus	;
	
DmpBPAdd:
	ldx #CRLF<	;If question mark was entered then dump current
	ldy #CRLF>	; breakpoints.
	jsr PrntMess	;
	ldy #0ffh	;
	ldx #0ffh	;
OtAdAgin:		;
	iny		;
	inx		;
	lda BrkPt1Ad,y	;
	sta PointerA	;
	iny		;
	lda BrkPt1Ad,y	;
	sta PointerA+1d	;
	lda BrkPt1St,x	;
	beq AdEmpty	;
	jsr PrntAdd	;
AdEmpty:		;
	cpy #7d		;
	bne OtAdAgin	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp ExitBP	;
	
Minus:
	lda OpFld2	;If minus was found in operand field #1 check for
	cmp #0d		; an address in operand field #2.  If no address
	beq ClrAllBP	; was found then clear all breakpoints, if an
	ldx #20d	; address was found then clear that one breakpoint.
	jsr GetAdd	;
	bcs Clr1BP	;
	jmp ExitBP	;
	
ClrAllBP:
	ldy #3d		;Clear all breakpoints.
ZeroBP:		;
	lda #0d		;
	sta BrkPt1St,y	;
	dey		;
	bpl ZeroBP	;
	jmp ExitBP	;
	
Clr1BP:
	stx TempAdd	;Search for a match between a breakpoint address
	sty TempAdd+1d	; in the breakpoint address table and the address
	ldy #3d		; that was entered.
	ldx #6d		;
CkBPAdd:		;
	jsr CmpBPAdd	;
	bcs FoundBP	;
	dey		;
	dex		;
	dex		;
	bpl CkBPAdd	;
	
BPNtFnd:		
	ldx #NoBPMess<	;If no match was found then print an error message
	ldy #NoBPMess>	; and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
FoundBP:
	lda #0d		;If match was found then zero out that breakpoint's
	sta BrkPt1St,y	; status indicator and exit.
	jmp ExitBP	;

Plus:
	lda OpFld2	;If a plus was entered then check operand field
	cmp #0d		; #2 for the address of the new breakpoint.
	beq OutBP2	;
	ldx #20d	;
	jsr GetAdd	;
	bcs BPAdOk	;
OutBP2:		;
	jmp ExitBP	;


BPAdOk:
	stx TempAdd	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddP:		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmp	;
	jsr CmpBPAdd	;
	bcs OutBP2	;
NoCmp:			;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddP	;
	

	ldy #0d		;If a plus was entered then search breakpoint
CkNxtBP:		;
	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
	cmp #0d		;
	beq EmptyBP	;
	iny		;
	cpy #4d		;
	bne CkNxtBP	;
	
AllBPFull:
	ldx #BPFulMes<	;If all breakpoints are full then print an error
	ldy #BPFulMes>	; message and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
EmptyBP:
	sty BPNumHld	;
	lda #1d		;
	sta BrkPt1St,y	;
	
	
NxtBPSlt0:
	cpy #0d		;Store new address in first position of
	bne NxtBPSlt1	; breakpoint table.
	lda TempAdd	;
	sta BrkPt1Ad	;
	lda TempAdd+1d	;
	sta BrkPt1Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt1:		;
	cpy #1d		;Store new address in second position of
	bne NxtBPSlt2	; breakpoint table.
	lda TempAdd	;
	sta BrkPt2Ad	;
	lda TempAdd+1d	;
	sta BrkPt2Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt2:		;
	cpy #2d		;Store new address in third position of
	bne NxtBPSlt3	; breakpoint table.
	lda TempAdd	;
	sta BrkPt3Ad	;
	lda TempAdd+1d	;
	sta BrkPt3Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt3:		;
	lda TempAdd	;Store new address in forth position of
	sta BrkPt4Ad	; breakpoint table.
	lda TempAdd+1d	;
	sta BrkPt4Ad+1d	;
	jmp ExitBP	;

ExitBP:
	rts


;****************************************************************************
;                   Compare Breakpoint Address Subroutine.
;****************************************************************************
CmpBPAdd:
	cpy #0d		;Compare LSB of first breakpoint address.
	bne CmpNxt1	;
	lda TempAdd+1d	;
	cmp BrkPt1Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt1:		;
	cpy #1d		;Compare MSB of second breakpoint address.
	bne CmpNxt2	;
	lda TempAdd+1d	;
	cmp BrkPt2Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt2:		;
	cpy #2d		;Compare MSB of third breakpoint address.
	bne CmpNxt3	;
	lda TempAdd+1d	;
	cmp BrkPt3Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt3:		;
	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
	cmp BrkPt4Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CChkFLSB:
	lda TempAdd	;Compare LSB of breakpoint address.
	cmp BrkPt1Ad,x	;
	beq BPMatch	;
	jmp NoMatch	;
	
BPMatch:		;Return with carry set if addresses match.
	sec		;
	rts		;
	
NoMatch:		;Return with carry cleared if addresses
	clc		; do not match.
	rts		;


;****************************************************************************
;                     Dump command Subroutine
;****************************************************************************
Dump:
	
	ldx #0h
	
	lda OpFld1,x	;If no operands then do a standard dump.
	cmp #0h		;
	beq DoStdDmp	;

	jsr AsToBin	;Get start address from operand field #1 and place
	bcs DgtOk1	; in zero page pointer.
	jmp ErrDump	;
DgtOk1:		;
	sta PointerA+1d	;
	inx		;
	jsr AsToBin	;
	bcs DgtOk2	;
	jmp ErrDump	;
DgtOk2:		;
	sta PointerA	;
	
	ldx #20d	;If no end address was entered then perform a
	lda OpFld1,x	; standard dump.
	cmp #0h		;
	beq DoStdDmp	;
	
	Jsr AsToBin	;Get end address from operand field #2 and place
	bcs OpFldOk1	; in the variable EndAdd.
	jmp ErrDump	;
OpFldOk1:		;
	sta EndAdd+1d	;
	inx 		;
	jsr AsToBin	;
	bcs OpFldOk2	;
	jmp ErrDump	;
OpFldOk2:		;
	sta EndAdd	;
	
	jmp DoDump	
	
DoStdDmp:
	lda PointerA+1d	;Adjust end address so that it will only dump the
	sta EndAdd+1d	; contents of 16 memory locations.
	lda PointerA	;
	sta EndAdd	;
	clc   		;Note: check to make sure this is correct.
	adc #15d	;
	sta EndAdd	;
	bcc DoDump	;
	inc EndAdd+1d	;
	
DoDump:
	lda #13d	;Output a CRLF.
	jsr OutChar	;
	lda #10d	;
	jsr OutChar	;

	ldx #0d		;
	ldy #0d		;

	jsr PrntAdd	;Output address of first dump memory location.
	
DumpAgin:
	lda (PointerA),y;Get byte from memory location.

	jsr PutASCBf	;Put character in ASCII buffer.
	
	jsr OutHex	;Convert to ASCII/Hex and print.
	
	inx
	cpx #16d	;
	bne Chk8	;
	jsr DumpASC	;Output ASCII interpretion of dumped line.
	
Chk8:			;
	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
	bne OutSpc	; the dump screen.
	lda #32d	;
	jsr OutChar	;
	lda #45d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	jmp ChkEndAd	;
	
OutSpc:
	lda #32d	;Print a space between hex characters on dump screen.
	jsr OutChar	;
	
ChkEndAd:
	lda PointerA	;Check pointer against end address holder.  Exit
	cmp EndAdd	; subroutine if the end address has been reached,
	bne PointNxt	; increment pointer and dump the contents of 
	lda PointerA+1d	; another memory location if not.
	cmp EndAdd+1d	;
	beq ExitDump	;
PointNxt:
	inc PointerA	;
	bne NoCary2	;
	inc PointerA+1d	;
NoCary2:		;

ChkCR:			;Perform end of dump line functions.
	cpx #16d	;
	bne NotEnd	;
	
	lda #10d	;Print a CRLF and reset X register to point to
	jsr OutChar	; beginning of new dump line.
	lda #13d	;
	jsr Outchar	;
	jsr PrntAdd	;
	ldx #0d		;
NotEnd:
	
	jmp DumpAgin	;

ErrDump:
	clc
	rts

ExitDump:
	inc PointerA	;Point to next location in memory to be dumped
	bne NoCary3	;
	inc PointerA+1d	;
NoCary3:		;
	sec
	rts

;****************************************************************************
;                 Output the ASCII interpretation of the dumped line.
;****************************************************************************
DumpASC:
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	ldx #0d		;
OutAsc:
	lda ASCIIbuf,x	;
	jsr OutChar	;
	inx		;
	cpx #16d	;
	bne OutAsc	;
	rts


;****************************************************************************
;         Put byte from memory into ASCII buffer from Dump command.
;****************************************************************************
PutASCBf:
	pha
	cmp #32d
	bmi Period
	cmp #127d
	bpl Period
	sta ASCIIbuf,x
	jmp ExitPut
Period:
	lda #46d
	sta ASCIIbuf,x
ExitPut:
	pla
	rts
	
;****************************************************************************
;                        Enter Command Subroutine.
;****************************************************************************
Enter:
	lda OpFld1	;Check for operand in operand field #1.
	cmp #0d		;
	bne ChkOp2	;
	jmp ErrEntr	;
	
ChkOp2:
	lda OpFld2	;Check for operand in operand field #2.
	cmp #0d		;
	bne ProcEntr	;
	jmp ErrEntr	;
	
ProcEntr:
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs EnAddOk	;
	jmp ErrEntr	;

EnAddOk:
	stx PointerA	;Put address from operand field #1 into
	sty PointerA+1d	; zero page variable Pointer.
	
	ldx #20d	;Get list of bytes to be entered into memory
	jsr GetList	; from operand field #2 and put them in memory
	bcc ErrEntr	; starting at Pointer.
	jmp ExitEntr	;
	
ErrEntr:
	clc
	rts	

ExitEntr:
	sec
	rts


;****************************************************************************
;                        Get List Subroutine
;
;	Zero page variable Pointer points to location in memory where
;	 list members will be placed.
;****************************************************************************
GetList:
	ldy #0d
	
	sty DataTemp	;Use this variable to count bytes in list.	
	
GLNxtByt:
	lda OpFld1,x	;Check for NULL that terminates current
	beq ListErr	; operand field.
	
	jsr AsToBin	;Convert byte in list to binary form and place
	bcs StInMem	; in memory.
	jmp ListErr	;
StInMem:		;
	sta (PointerA),y;
	inc PointerA	;
	bne LstNoOv	;
	inc PointerA+1d	;
LstNoOv:		;
	inc DataTemp	;
	lda DataTemp	;
	cmp #10d	;
	beq ExtGtLst	;
	
	inx		;Point to comma between bytes.

	lda OpFld1,x	;Check for NULL that terminates current
	beq ExtGtLst	; operand field.
	
	inx		;Point to next byte in list.
	
	jmp GLNxtByt	;
	
ExtGtLst:
	sec
	rts

ListErr:
	clc
	rts

;****************************************************************************
;                        Fill Command Subroutine.
;****************************************************************************
Fill:

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs FAdd1ok	;
	jmp ErrFill	;
FAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs FAdd2ok	;
	jmp ErrFill	;
FAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
FillAgin:
	ldx #40d	;Get list and place in memory.
	jsr GetList	;
	bcc ErrFill	;

	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq ChkFLSB	;
;	bmi ExitFill 	;
	jmp FillAgin 	;
ChkFLSB:
	lda EndAdd	; 
	cmp PointerA	;
	beq ExitFill	;
	
	jmp  FillAgin	;
	

ErrFill:
	clc
	rts

ExitFill:
	sec
	rts

;****************************************************************************
;                        Go Command Subroutine
;****************************************************************************
Go:

	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq CurentPC	;
			
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs GAddOk	;
	jmp ErrGo	;
	
GAddOk:		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;

CurentPC:
	ldx UPgmCntr	;
	stx TempAdd	;
	ldy UPgmCntr+1d	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddG:		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmpG	;
	jsr CmpBPAdd	;
	bcs MaError	;
NoCmpG:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddG	;
	jmp NoMatchG	;

MaError:
	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
	ldy #GoBPErrM>	; error message and exit.
	jsr PrntMess	;
	jmp ExitGo	;

NoMatchG:
	ldy #3d		;Check all active breakpoints in table, save
	ldx #6d		; the opcodes of the breakpointed addresses, 
CkBPSt:		;
	lda BrkPt1St,y	; and replace them with BRKs.
	cmp #1d		;
	bne NxtBPSt	;
	lda (BrkPt1Ad,x);
	sta BP1OpHld,y	;
	lda #0d		;
	sta (BrkPt1Ad,x);
NxtBPSt:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPSt	;

	pla		;Remove Go command's return address and the check
	pla		; command's return address from the stack.
	pla		;
	pla		;
    
    lda OpFld1	;Check for operand.
	cmp #0d		;
	beq DoNotRestoreRegistersGo
 
    ldx #0ffh    ;Restore user's registers.
    txs          ;
    lda UStatReg ;
	pha          ;
	lda UAccum	 ;
	ldx UXReg	 ;
	ldy UYReg	 ;
    plp          ;
   
DoNotRestoreRegistersGo:
	
	jmp (UPgmCntr)	;Start executing at address being pointed to by
			; UPGmCntr.	

ErrGo:
	clc
	rts
	
ExitGo:
	sec
	rts

;****************************************************************************
;                       Help Command Subroutine.
;****************************************************************************
Help:
	ldx #HelpMess<
	ldy #HelpMess>
	jsr PrntMess
	rts

;****************************************************************************
;                     Load Command Subroutine
;****************************************************************************
LdSRecs:
	ldx #SRecStMs<
	ldy #SRecStMs>	
	jsr PrntMess
	
	jsr GetCharW	;Wait for first character of record.
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp CkS		;
	
GtAnCh:		;
	jsr GetCharW	;Check for an S.
CkS:			;
	cmp #83d	;
	bne GtAnCh	;
	
	jsr OutChar	;Print an S to the user.
	
	jsr GetCharW	;Get record type ECHO it and store it.
	jsr OutChar	;
	sta RecType	;
	
	cmp #48d	;Check for header record and process.
	bne NtHdr	;
	jsr ProcHdr	;
	bcc SError	;
	jmp NextLine	;
	
NtHdr:			;
	cmp #49d	;Check for code record and process.
	bne NtCd	;
	jsr ProcCode	;
	bcc SError	;
	jmp NextLine	;
	
NtCd:			;
	cmp #57d	;Check for termination record process, and print
	bne SError	; records loaded message.
	jsr ProcTerm	;
	bcc SError	;
	ldx #SRecEnMs<	;
	ldy #SRecEnMs>	;
	jsr PrntMess	;
	jmp ExitSRec	;
	
NextLine:
	jmp GtAnCh

SError:
	ldx #SRecErMe<
	ldy #SRecErMe>	
	jsr PrntMess
	sec
	rts
	
ExitSRec:
	jsr GetCharW
	sec
	rts
	
;****************************************************************************
;                Process Record Length and Address Subroutine
;****************************************************************************
PrRLeAdd:	
	
	lda #0h		;Zero out Checksum accumulator.
	sta CkSumAc	;
	sta CkSumAc+1h	;
	
	jsr Getnum	;Fetch record length and update checksum
	sta RecLen	; accumulator.
	jsr AccCkSum	;
	
	tax		;Adjust code byte counter and store it.
	dex		;
	dex		;
	dex		;
	txa		;
	sta CodeCntr	;
	
	jsr GetNum	;Get most significant byte of address and
	sta PointerA+1h	; store it.
	jsr AccCkSum	;
	
	jsr GetNum	;Get least significant byte of address and
	sta PointerA	; store it.
	jsr AccCkSum	;
	
	rts
	
;****************************************************************************
;        Get Code Byte Without Loading into Memory Subroutine.
;****************************************************************************
GtCodNld:
	
	lda CodeCntr
	beq ExitNld
	
GetOneNl:
	jsr GetNum
	jsr AccCkSum
	dec CodeCntr
	Bne GetOneNl
	
ExitNld:
	rts

;****************************************************************************
;        Get Code Byte and Load it into Memory Subroutine.
;****************************************************************************
GtCodLd:

	lda CodeCntr
	beq ExitLd
	
	ldy #0h
GtOneLd:
	jsr GetNum
	jsr AccCkSum
	sta (PointerA),y	
	inc PointerA
	bne NxtCode
	inc PointerA+1h
NxtCode:
	dec CodeCntr
	bne GtOneld
	
ExitLd:
	rts

;****************************************************************************
;                      Check Checksum Subroutine.
;****************************************************************************
ChkChkSm:

	lda CkSumAc	;Invert lowest byte of the checksum accumulator
	eor #0ffh	; and store it in CkhSum.
	sta ChkSum	;
	
	jsr GetNum	;Compare calculated checksum against S record	
	cmp ChkSum	; checksum.
	beq CkSumOK	;
	clc
	jmp Chkexit
CkSumOK:
	sec
Chkexit:
	rts

;****************************************************************************
;                       Get Number Subroutine.
;****************************************************************************
GetNum:
	tya
	pha

	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in most significat nibble
	bcc ExtGtNum	;
	asl a		; of number.
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in least significant
	bcc ExtGtNum	;
	ora number	; nibble of number.
	sta number	;
	
	pla
	tay
	lda number
ExtGtNum:
	rts

;****************************************************************************
;                    Accumulate Checksum Subroutine.
;****************************************************************************
AccCkSum:
	pha
	clc
	adc CkSumAc
	sta CkSumAc
	bcc NoOvrFlo
	inc CkSumAc+1h
NoOvrFlo:
	pla
	rts

;****************************************************************************
;                ASCII Digit to Binary Number Subroutine.
;
;        Enter with register 'A' containing the number to convert.
;        If the number was valid return its binary conversion in the
;        A register.  If the number is not convertable then clear the
;        carry flag and return.
;****************************************************************************
DgtToBin:
	
	stx RegTemp	;Save the character to convert.
	
	ldx #0h		
	
AnothDgt:
	cmp DgtTblUC,x	;Search through character table and try to find
	beq Match	; a match for the character present in the X
	cmp DgtTblLC,x	; register.
	beq Match	;
	
	inx		;If a match was not found then increment the
	cpx #16d	; table index register and check the next
	beq DgtError	; character.  If all the characters have been 
	jmp AnothDgt	; checked then return with an error.
	
DgtError:
	lda #0h
	clc
	jmp DgtExit

Match:
	txa
	sec
	
	ldx RegTemp
DgtExit:	rts
	
;****************************************************************************
;                    Process Header Record Subroutine.
;****************************************************************************

ProcHdr:

	jsr PrRLeAdd
	jsr GtCodNld		
	jsr ChkChkSm
	
	rts

;****************************************************************************
;                     Process Code Record Subroutine
;****************************************************************************
ProcCode:

	jsr PrRLeAdd
	jsr GtCodLd
	jsr ChkChksm
	
	rts

;****************************************************************************
;                     Process Termination Record Subroutine
;****************************************************************************
ProcTerm:

	jsr PrRLeAdd
	jsr GtCodNld	
	jsr ChkChkSm

	rts

;****************************************************************************
;                       Move Command Subroutine.
;****************************************************************************
Move:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq MOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs MAdd1ok	;
MOut:			;
	jmp ExitMove	;
MAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs MAdd2ok	;
	jmp ExitMove	;
MAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne MNOvFlo	;
	inc EndAdd+1d	;
	
MNOvFlo:		;
	ldx #40d	;Get destination address.
	jsr GetAdd	;
	bcs MAdd3ok	;
	jmp ExitMove	;
MAdd3ok:		;
	stx PointerB	;
	sty PointerB+1d	;

	ldy #0d		;Move bytes between start address and end address
MCont:			;to memory starting at destination address.
	lda (PointerA),y; 
	sta (PointerB),y;
	inc PointerB	;
	bne MNoOvf1	;
	inc PointerB+1d	;
MNoOvf1:		;
	inc PointerA	;
	bne MNoOvf2	;
	inc PointerA+1d	;
MNoOvf2:		;
	lda PointerA	;
	cmp EndAdd	;
	beq MCkMSB	;
	jmp MCont	;
MCkMSB:		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitMove	;
	jmp MCont	;
	
ExitMove:
	rts


;****************************************************************************
;                     Register Command Subroutine
;****************************************************************************
Register:
	pha
	txa
	pha
	tya
	pha
	php
	
	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq GenReg	;
	jmp SpecReg	;
	
GenReg:		;
	ldx #RegMess<	;Output register headings.
	ldy #RegMess>	;
	jsr PrntMess	;
	
	ldy #3d		;Output contents of user's program counter.
	jsr OutSpace	;
	lda UPgmCntr+1d	;
	jsr OutHex	;
	lda UPgmCntr	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's accumulator.
	jsr OutSpace	;
	lda UAccum	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's X register.
	jsr OutSpace	;
	lda UXreg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Y register.
	jsr OutSpace	;
	lda UYReg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Stack Pointer.
	jsr OutSpace	;
	lda UStkPtr	;
	jsr OutHex	;
	
	ldy #7d		;Output contents of user's Status register.
	jsr OutSpace	;
	lda UStatReg	;
	ldx #8d		;
NextFlag:		;
	rol a		;
	bcs OutOne	;
OutZero:		;
	pha		;
	lda #30h	;
	jsr OutChar	;
	pla		;
	jmp CkBtPos	;
OutOne:		;
	pha		;
	lda #31h	;
	jsr OutChar	;
	pla		;
CkBtPos:		;
	dex		;
	bne NextFlag	;
	jmp ExitReg	;
	
	
SpecReg:
	lda #13d
	jsr OutChar
	lda #10d
	jsr OutChar
	lda OpFld1
	jsr ToLower

CkPCReg:		;
	cmp #112d	;Get value for Program Counter from user.
	bne CkAReg	;
	lda UpgmCntr+1d	;
	jsr OutHex	;
	lda UpgmCntr	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetPC	;
	jmp ExitReg	;
GetPC:	ldx #0d		;
	jsr AsToBin	;
	bcs PCMSBOK	;
	jmp ExitReg	;
PCMSBOK:	tay		;
	inx		;
	jsr AsToBin	;
	bcs PCLSBOK	;
	jmp ExitReg	;
PCLSBOK:	sta UPgmCntr	;
	sty UPgmCntr+1d	;
	jmp ExitReg	;
	
CkAReg:		;Get value for Accumulator from user.
	cmp #97d	;
	bne CkXReg	;
	lda UAccum	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetA	;
	jmp ExitReg	;
GetA:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs AOK		;
	jmp ExitReg	;
AOK:			;
	sta UAccum	;
	jmp ExitReg	;
	
CkXReg:		;Get value for X register from user.
	cmp #120d	;
	bne CkYReg	;
	lda UXreg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetX	;
	jmp ExitReg	;
GetX:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs XOK		;
	jmp ExitReg	;
XOK:			;
	sta UXReg	;
	jmp ExitReg	;
	
CkYReg:		;Get value for Y register from user.
	cmp #121d	;
	bne CkForS	;
	lda UYReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetY	;
	jmp ExitReg	;
GetY:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs YOK		;
	jmp ExitReg	;
YOK:			;
	sta UYReg	;
	jmp ExitReg	;
	
CkForS:		;Check if user is accessing the Stack Pointer or
	cmp #115d	; the Status Register.
	beq CkPorR	;
	jmp RegInErr	;
CkPorR:		;
	lda OpFld1+1d	;
	jsr ToLower	;
	cmp #112d	;
	beq CkSpReg	;
	cmp #114d	;
	beq CkSRReg	;
	jmp RegInErr	;

CkSpReg:		;
	lda UStkPtr	;Get value for Stack Pointer from user.
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSP	;
	jmp ExitReg	;
GetSP:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs SPOK	;
	jmp ExitReg	;
SPOK:			;
	sta UStkPtr	;
	jmp ExitReg	;
	
CkSRReg:		;Get value for Status Register from user.
	lda UStatReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSR	;
	jmp ExitReg	;
GetSR:	ldx #0d		;
	jsr AsToBin	;
	bcs SROK	;
	jmp ExitReg	;
SROK:	sta UStatReg	;
	jmp ExitReg	;

RegInErr:
	clc
	jmp ErrRegOt
	
ExitReg:
	sec
ErrRegOt:
	plp
	pla
	tay
	pla
	tax
	pla
	rts

;****************************************************************************
;                       Search Command Subroutine.
;****************************************************************************
Search:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq SOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs SAdd1ok	;
SOut:			;
	jmp ExitSrch	;
SAdd1ok:		;
	stx PointerB	;
	sty PointerB+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs SAdd2ok	;
	jmp ExitSrch	;
SAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne SNOvFlo	;
	inc EndAdd+1d	;
	
SNOvFlo:		;
	ldx #40d	;Get search list from operand field #3 and store
	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
	sta PointerA	; SrchBtCt.
	lda #SrchTabl>	;
	sta PointerA+1d	;
	jsr GetList	;
	bcc ExitSrch	;
	lda DataTemp	;
	sta SrchBtCt	;
	
	lda PointerB	;Transfer start address from pointer A to 
	sta PointerA	; pointer B.  Output a CRLF.
	lda PointerB+1d	;
	sta PointerA+1d	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	
SCkByte1:		;Compare list with memory.
	ldx #0d		;
	ldy #0d		;
SCkByte2:		;
	lda (PointerA),y;
	cmp SrchTabl,x	;
	beq SMatch	;
	
IncScPtr:
	jsr IncPntrA	;Increment memory pointer and check to see if
	lda PointerA	; the end address has been reached.
	cmp EndAdd	;
	beq SckMSB	;
	jmp SCkByte1	;
SCkMSB:		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitSrch	;
	jmp SCkByte1	;
	
SMatch:		;
	iny		;Check to see if all bytes in search list match
	inx		; bytes in memory.
	cpx SrchBtCt	;
	beq SFulMtch	;
	jmp SCkByte2	;

SFulMtch:		;
	jsr PrntAdd	;Output address where match was found.
	jsr IncPntrA	;
	jmp SCkByte1	;

ExitSrch:
	rts



;****************************************************************************
;                       Trace Command Subroutine.
;****************************************************************************
Trace:

	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq TNoOper	;
	
	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs TAdd1ok	;
	jmp ErrTrce	;
TAdd1ok:		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;
	
	lda OpFld2	;Check to see if a trace count has been 
	cmp #0d		; specified.
	bne GtTrcCnt	;

TNoOper:
	ldy #1d		;Set trace count to 1.
	sty TracCnt	;
	jmp StartTrc	;

GtTrcCnt:	
	ldx #20d	;Get trace count from user.
	jsr AsToBin	;
	bcs TrValOK	;
	jmp ErrTrce	;
TrValOK:		;
	sta TracCnt	;
	
StartTrc:
	pla		;Remove trace command's return address and
	pla		; the check command routine's return address from
	pla		; the stack.
	pla		;

ContTrc:	
	ldy UPgmCntr	;Transfer user's program counter to pointer A.
	sty PointerA	;
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;

	ldy #0d		;Get opcode of current instruction.
	lda (PointerA),y;
	sta OpCdHold	;
	
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs TOpCdFnd	; an opcode.
	jmp ErrTrce

TOpCdFnd:
	ldy #8d		;Get number of bytes in the current instruction
	lda (PointerB),y; information from opcode table.
	sta CurInsLn	;
	
	ldy #1d		;Get opcode of current instruction.
	lda OpCdHold	;

TrRTS:			;If the opcode is an RTS then copy the return
	cmp #60h	; address from the stack, save the opcode to
	bne TNxtOp0	; be returned to, and place a BRK at the return
	lda #2d		; address.
	sta BrnchFlg	;
	pla		;
	sta BOpAdPtr	;
	pla		;
	sta BOpAdPtr+1d	;
	pha		;
	lda BOpAdPtr	;
	pha		;
	inc BOpAdPtr	;
	bne NNOvflo	;
	inc BOpAdPtr+1d	;
NNOvflo:		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp0:		;
	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
	bne TNxtOp1	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp1:
	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
	bne TNxtOp2	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta PointerC	;
	iny		;
	lda (PointerA),y;
	sta PointerC+1d	;
	ldy #0d		;
	lda (PointerC),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerC),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
		
	
TNxtOp2:
	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
	bne TNxtOp3	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp3:
	ldy #0d		;Check to see if the current instruction is an
	lda (PointerB),y; actual branch.
	cmp #'B'	;
	bne NoBrnch2	;
	ldy #1d		;
	lda (PointerB),y;
	cmp #'I'	;
	bne Branch	;
NoBrnch2:		;
	jmp NoBranch	;
	
Branch:		;If the opcode is a branch, Bxx aaaa,
	lda #1d		; then save the opcode of the instruction that
	sta BrnchFlg	; will be branched to and replace it with a BRK.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta BOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
			;
	ldy #1d		;
	lda (PointerA),y;
	sta BrValHld	;
	bpl AddAdd	;
SubAdd:		;
	dec BrValHld	;
	lda BrValHld	;
	eor #0ffh	;
	sta BrValHld	;
	sec		;
	lda BOpAdPtr	;
	sbc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	sbc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
AddAdd:		;
	clc		;
	lda BOpAdPtr	;
	adc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
GtBrOpCd:		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp Both	;
	
NoBranch:
	lda #0d		;Set branch flag to 0 to indicate the current
	sta BrnchFlg	; instruction is not a branch instruction.

Both:
	ldy CurInsLn	;
	lda (PointerA),y;Save the opcode of the next instruction to be
	sta NOpCdHld	; executed if no branch is taken and replace it
			; with a BRK command.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta NOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta NOpAdPtr+1d	;
	lda #0d		;
	sta (PointerA),y;
	
ChBkVect:
	lda #1d		    ;Make BRK jump here instead of main.
	sta TrBrkFlg	;
	
    lda OpFld1	;Check to see if user entered address.
	cmp #0d		;
	beq DoNotRestoreStackPointer
    ldx #0ffh    
    txs          ;
DoNotRestoreStackPointer:

	lda UStatReg	;Restore user's registers.
	pha		        ;
	lda UAccum	    ;
	ldx UXreg	    ;
	ldy UYReg	    ;
	plp		        ;
    
	jmp (UPgmCntr)	;Jump to user's code.
	
Tr2ndEnt:
	lda #0d		;Reset trace break flag.
	sta TrBrkFlg	;
	
CkBrnch:		;
	ldy #0d		;Check to see which opcodes need to be restored.
	lda BrnchFlg	;
	cmp #0d		;
	beq NoBrnch	;
	cmp #1d		;
	beq Brnch	;
	
DoJmp:
	lda BOpCdHld	;Restore opcode to be jumped to.
	sta (BOpAdPtr),y;
	jmp UpDtPtrA	;

Brnch:
	lda BOpCdHld	;Restore opcode to be branched to.
	sta (BOpAdPtr),y;
	
NoBrnch:
	lda NOpCdHld	;Restore opcode that will be executed next in
	sta (NOpAdPtr),y; the instruction stream.

UpDtPtrA:
	ldy UPgmCntr	;Set pointer A to point to the next instruction
	sty PointerA	; to be executed for unassemble.
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;
	
	ldx #CRLF<	;Unassemble next instruction in memory.
	ldy #CRLF>	;
	jsr PrntMess	;
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	jsr StartUnA	;
	
NxtIn:
	dec TracCnt	;Decrement trace count and trace again if it
	beq OutTrce	; is not zero.
	jmp ContTrc	;

OutTrce:
	jmp MainLoop	;Enter the main monitor loop using a jump
			; because the trace command's return address
			; and the check command routine's return address
			; were removed when a trace was initiated.
ErrTrce:
	clc
	rts	

ExitTrce:
	sec
	rts	

;****************************************************************************
;                       Scan for Valid Opcode Subroutine.
;****************************************************************************
ScanOpCd:
	
	ldx #OpTable<	;Point pointer B to beginning of opcode table.
	stx PointerB	;
	ldx #OpTable>	;
	stx PointerB+1d	;
	
CkTblEnd:
	ldy #4d		;Check for end of opcode table.
	lda (PointerB),y;
	cmp #90d	;
	beq OpCdNtFd	;
	
CkNxtOp:		;
	ldy #7d		;Check for an opcode match in the opcode table.
	lda (PointerB),y;
	cmp OpCdHold	;
	beq OpCdFndS	;
	
	lda PointerB	;Point pointer B to next entry in opcode table.
	clc		;
	adc #10d	;
	sta PointerB	;
	bcc ScNoCary	;
	inc PointerB+1d	;
		
ScNoCary:
	jmp CkTblEnd
	
	
OpCdFndS:
	sec
	rts
	
OpCdNtFd:
	clc
	rts
	
;****************************************************************************
;                       Unassemble Command Subroutine.
;****************************************************************************
UnAssem:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq UNoOper	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs UAdd1ok	;
	jmp ErrUnAs	;
UAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	lda OpFld2	;Check to see if an end address has been 
	cmp #0d		; specified.
	bne GtUEndAd	;
	
UNoOper:
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	clc		;If no end address has been specified by the
	lda PointerA	; user then set the end address to start address
	adc #20d	; + 20d.
	sta EndAdd	;
	bcc UNoCary	;
	ldx EndAdd+1d	;
	inx		;
	stx EndAdd+1d	;
UNoCary:		;
	jmp StartUnA	;
	
GtUEndAd:
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs UAdd2ok	;
	jmp ErrUnAs	;
UAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
StartUnA:
	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq UChkFLSB	;
	bcc UOut	;
	jmp UNotFin 	;
UChkFLSB:
	lda EndAdd	; 
	cmp PointerA	;
	bcc UOut	;
	jmp UNotFin	;
UOut:			;
	jmp ExitUnAs	;

UNotFin:		;
	ldy #0d		;Get opcode byte from memory and save.
	lda (PointerA),y;
	sta OpCdHold	;
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs OpCdFnd	; an opcode.

NtOpCode:
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;

	lda OpCdHold	;Print the bad opcode.
	jsr OutHex	;
	
	ldx #BadOpMes<	;If byte was not an opcode then print question
	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
	jsr PrntMess	;
	jsr IncPntrA	;
	jmp StartUnA	;

OpCdFnd:
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr IncPntrA	;

CkAdMode:
	ldy #6d		;Get addressing mode indicator from table.
	lda (PointerB),y;
	
NxAdMo1:		;
	cmp #'P'	;Check for implied addressing mode.
	bne NxAdMo2	;
	jmp ImpAdMo	;
	
NxAdMo2:		;
	cmp #'M'	;Check for immediate addressing mode.
	bne NxAdMo3	;
	jmp ImmAdMo	;	

NxAdMo3:		;
	cmp #'S'	;Check for absolute addressing mode.
	bne NxAdMo4	;
	jmp AbsxyAdM	;	

NxAdMo4:		;
	cmp #'X'	;Check for absolute x addressing mode.
	bne NxAdMo5	;
	jmp AbsxyAdM	;

NxAdMo5:		;
	cmp #'Y'	;Check for absolute y addressing mode.
	bne NxAdMo6	;
	jmp AbsxyAdM	;

NxAdMo6:		;
	cmp #'R'	;Check for indexed indirect addressing mode.
	bne NxAdMo7	;
	jmp IIRAdMo	;

NxAdMo7:		;
	cmp #'L'	;Check for relative addressing mode.
	bne NxAdMo8 	;
	jmp RelAdMo	;

NxAdMo8:		;
	cmp #'C'	;Check for accumulator addressing mode.
	bne NxAdMo9 	;
	jmp AccAdMo	;

NxAdMo9:		;
	cmp #'D'	;Check for indirect addressing mode.
	bne NxAdMo10 	;
	jmp IndAdMo	;

NxAdMo10:
	cmp #'I'	;Check for indirect indexed addressing mode.
	bne BdOpCd	;
	jmp IRIAdMo	;

BdOpCd:		;
	jmp NtOpCode	;


ImpAdMo:
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	jmp StartUnA

AccAdMo:
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	lda #65d	;Print a capital A for accumulator addressing.
	jsr OutChar	;
	
	jmp StartUnA


ImmAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #35d	;Print a pound sign.
	jsr OutChar	;
	
	lda ObCdHld1	;Print immediate operand value.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	jmp StartUnA


AbsxyAdM:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	ldy #6d		;Check to see if address mode is abs, abx or
	lda (PointerB),y; aby.
	cmp #'X'	;
	beq AbxAdMo	;
	cmp #'Y'	;
	beq AbyAdMo	;
	
AbsAM:
	jmp StartUnA

AbxAdMo:
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	jmp StartUna
	
AbyAdMo:
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;

	jmp StartUnA


RelAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda PointerA	;Store a copy of the next instruction's start
	sta AddHold	; address.
	lda PointerA+1d	;
	sta AddHold+1d	;
	
	lda ObCdHld1	;Check to see if branch is positive or negative.
	bmi NegBrnch	;
	
PosBrnch:		;If branch is positive then find address being
	lda AddHold	; branched to by adding offset to start address
	clc		; of next instruction in memory.
	adc ObCdHld1	;
	sta AddHold	;
	bcc OutBrAdd	;
	inc AddHold+1d	;
	jmp OutBrAdd	;
		
NegBrnch:
	dec ObCdHld1	;If branch is negative then find address being
	lda ObCdHld1	; branched to by subtracting offset from start
	eor #0ffh	; address of next instruction in memory.
	sta ObCdHld1	;
	lda AddHold	;
	sec		;
	sbc ObCdHld1	;
	sta AddHold	;
	bcs OutBrAdd	;
	dec AddHold+1d	;
	
OutBrAdd:
	lda AddHold+1d	;Print address being branched to.
	jsr OutHex	;
	lda AddHold	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	jmp StartUnA


IRIAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;
	
	jmp StartUnA
	
IIRAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA

IndAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA
	
ErrUnAs:
	clc
	rts

ExitUnAs:
	sec
	rts


;****************************************************************************
;                       Print Mnemonic Subroutine.
;****************************************************************************
PrntMnem:

	ldy #0d		;Use loop to print all three characters of
PrntMore:
	lda (PointerB),y; mnemonic.
	jsr OutChar	;
	iny		;
	cpy #3d		;
	bne PrntMore	;
	
	lda #32d	;Print a space after the mnemonic.
	jsr OutChar	;
	
	rts

;****************************************************************************
;                       Increment Pointer A Subroutine.
;****************************************************************************
IncPntrA:
	inc PointerA
	bne NoOvFl1
	inc PointerA+1d
NoOvFl1:
	rts



;****************************************************************************
;                        Get Address Subroutine
;
;	X returns LSB of address.  Y returns MSB of address.
;****************************************************************************
GetAdd:		;Convert address found in operand field #x
	jsr AsToBin	; into binary.
	bcs AdMSBOK	;
	jmp ErrGtAd	;
AdMSBOK:		;
	tay		;
	inx		;
	jsr AsToBin	;
	bcs AdLSBOK	;
	jmp ErrGtAd	;
AdLSBOK:		;
	tax

	sec		;If conversion OK then set carry flag and
	rts		; return.
	
ErrGtAd:		;
	clc		;If error then clear carry and return.
	rts		;


;****************************************************************************
;                     Output a Colon Prompt Subroutine.
;****************************************************************************
OutColn:
	ldx #ColnPrmt<
	ldy #ColnPrmt>
	jsr PrntMess
	rts

;****************************************************************************
;                     Out Spaces Subroutine
;
;       Enter with the Y register indicating the number of spaces to output.
;****************************************************************************
OutSpace:		;Output the number of spaces indicated by
	pha		; the Y register.
OtAnoSpc:
	lda #32d
	jsr OutChar
	dey
	bne OtAnoSpc
	pla
	rts


;****************************************************************************
;              Covert ASCII character to lower case Subroutine.
;****************************************************************************
ToLower:
	cmp #65d
	bmi ExitToLo
	cmp #91d
	bpl ExitToLo
	clc
	adc #32d
ExitTolo:
	rts


;****************************************************************************
;              Covert ASCII character to upper case Subroutine.
;****************************************************************************
ToUpper:
	cmp #'a'
	bmi ExitToUp
	cmp #123d
	bpl ExitToUp
	sec
	sbc #32d
ExitToUp:
	rts



;****************************************************************************
;                         Print address.
;****************************************************************************
PrntAdd:
	lda PointerA+1d	;
	jsr OutHex	;
	lda PointerA	;
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	
	rts

;****************************************************************************
;                         Ascii to Binary Subroutine.
;****************************************************************************
AsToBin:		;X points to digits to be converted using
			; OpFld1 as a base.

	lda OpFld1,x	;Convert most significant digit to binary.
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	asl a		;
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	inx		;Convert least significant digit to binary.
	lda OpFld1,x	;
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	ora number	;
	
	sta number	;Store full binary number in number.
	sec
ExtAs2Bn:
	rts
	
;****************************************************************************
;                     Output a Hex byte to the serial port.
;
;            Enter with the number to be output in the A register.
;****************************************************************************
OutHex:
	sta number
	
	lsr a		;Output most significant digit of hex byte to
	lsr a		; serial port.
	lsr a		;
	lsr a		;
	and #0fh	;
	cmp #0ah	;
	bpl Letter1	;
	ora #30h	;
	jmp Print1st	;
Letter1:		;
	sec
	sbc #9d		;
	ora #40h
Print1st:
	jsr OutChar	;
	
	lda number	;Output least significant digit of hex byte to
	and #0fh	; serial port.
	cmp #0ah	;
	bpl Letter2	;
	ora #30h	;
	jmp Print2nd	;
Letter2:		;
	sec
	sbc #9d		;
	ora #40h	;
Print2nd:		;
	jsr OutChar	;
	
	lda number
	rts
	
;****************************************************************************
;                     Initialize Variables Subroutine
;****************************************************************************
InitVars:

	;lda #1ah	;Initialize ACIA control register, 2400
	;sta 6551CtR	; Baud.
	
	;lda #0bh	;Initialize ACIA command register.
	;sta 6551CmR	;
		
	lda #BRK<	;Initialize BRK vector.
	sta BRKVect	;
	lda #BRK>	;
	sta BRKVect+1d	;
	
	lda #0d		;Initialize trace break flag.
	sta TrBrkFlg	;
	
	lda #0d		;Initialize break point status variables.
	sta BrkPt1St	;
	sta BrkPt2St	;
	sta BrkPt3St	;
	sta BrkPt4St	;
	
	lda #0d		;Set the output port to all zeros (turn
	;sta OutPort0	; off all of the LEDs).
	
	rts

;****************************************************************************
;                          Print Message Subroutine.
;
; X holds the message pointer's low byte (< means less than) and Y holds its 
; high byte (> means greater than).  The message must have a NULL (0) after 
; the last character in the  Message so the PrntMess subroutine knows when to 
; stop printing.
;****************************************************************************
PrntMess:
	pha
	
	stx MessPtr	;Initialize pointer that will point to each
	sty MessPtr+1h	; character of message.
	
	ldy #0h
	
OutMess:		;
	lda (MessPtr),y	;Get a character from the message and if it is
	beq ExitMess	; a NULL (0) then exit this subroutine.
	
	jsr OutChar	;Output the character to the serial port.
	
	inc MessPtr	;Increment the message pointer to point to the
	bne PrNoOvf	; next character in the message.
	inc MessPtr+1d	;
	
PrNoOvf:
	jmp OutMess
		
ExitMess:
	pla
	
	rts

;****************************************************************************
;           Get Character (Don't Wait) From Serial Channel Subroutine
;****************************************************************************
GetChar:
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
	lda 6551StR	;Check ACIA to see if a character has been
	and #00001000b	; received and return with a NULL if no
	beq NoChar	; character was present.
	
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	jmp ExitGtCh	;
	
NoChar:
	lda #0d
	sta RegTemp
	
ExitGtCh:
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;             Get Character (Wait) From Serial Channel Subroutine
;****************************************************************************
GetCharW:
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
GtCkAgn:	
	lda 6551StR	;Check the ACIA's receiver buffer full register
	and #00001000b	; and wait until a character is received.
	bne CharRec	;
	
	lda 6551Sleep ;Allow the emulator to be put to sleep.
	jmp GtCkAgn
	
CharRec:
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;                 Output Character to Serial Channel Subroutine 
;                   Character to print is in register 'A'
;****************************************************************************
OutChar:
	
	sta RegTemp	;Save registers.
	php		;
	tya		;
	pha		;
	txa		;
	pha		;
	
OtCkAgn:
	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
	and #00010000b	; register and wait until the buffer is empty.
	beq OtCkAgn	;
	
	lda RegTemp	;Output a character to the ACIA's Transmitt
	sta 6551TRR	; register.
	
	pla		;Restore registers.
	tax		;
	pla		;
	tay		;
	plp		;
	lda RegTemp	;
		
	rts


;****************************************************************************
;                          Delay Subroutine
;****************************************************************************
delay:
	pha
	txa
	pha
	tya
	pha
	
	lda #0h
	sta wait0
	lda #10h
	sta wait1
	
	
dw0:
	dec wait0
	bne dw0
	dec wait1
	bne dw0
	
	pla
	tay
	pla                                                                        
	tax
	pla
	rts


;****************************************************************************
;                Constants
;****************************************************************************

UARTval:	dbt 16h,0bh
DgtTblUC:	dbt "0123456789ABCDEF"
			dbt 0h
DgtTblLC:	dbt "0123456789abcdef"
			dbt 0h
OpenMess:	dbt 10d,13d,10d
			dbt "UMON65 V1.19 - Understandable Monitor for the 6500 series microprocessors."
			dbt 10d,13d
			dbt 0h
prompt:		dbt 10d,13d
			dbt "-"
			dbt 0h
CRLF:		dbt 10d,13d,0d
SRecStMs:	dbt 10d,13d
			dbt "Send S records when you are ready..."
			dbt 10d,13d,0d
SRecErMe:	dbt 10d,13d,7d
			dbt "Error Loading S Records..."
			dbt 10d,13d,0d
SRecEnMs:	dbt 10d,13d,7d
			dbt "S records successfully loaded (press <enter> to continue)."
			dbt 0d
RegMess:		dbt 10d,13d,10d
			dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
			dbt 10d,13d,0d
ColnPrmt:	dbt 10d,13d
			dbt " :"
			dbt 0d
BadOpMes:	dbt "        ???"
			dbt 0d
BPFulMes:	dbt 10d,13d
			dbt "All breakpoints are currently in use."
			dbt 0d
NoBPMess:	dbt 10d,13d
			dbt "No breakpoint exists at this address."
			dbt 0d
GoBPErrM:	dbt 10d,13d
			dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
			dbt 0d
CmdErMes:	dbt 10d,13d
			dbt "?"
			dbt 0d
HelpMess:	dbt 10d,13d,10d
			dbt "Assemble       A start_address"
			dbt 10d,13d
			dbt "Breakpoint     B (+,-,?) address"
			dbt 10d,13d
			dbt "Dump           D [start_address [end_address]]"
			dbt 10d,13d
			dbt "Enter          E address list"
			dbt 10d,13d
			dbt "Fill           F start_address end_address list"
			dbt 10d,13d
			dbt "Go             G [start_address]"
			dbt 10d,13d
			dbt "Help           H or ?"
			dbt 10d,13d
			dbt "Load           L"
			dbt 10d,13d
			dbt "Move           M start_address end_address destination_address"
			dbt 10d,13d
			dbt "Register       R [PC,AC,XR,YR,SP,SR]"
			dbt 10d,13d
			dbt "Search         S start_address end_address list"
			dbt 10d,13d
			dbt "Trace          T [start_address [value]]"
			dbt 10d,13d
			dbt "Unassemble     U [start_address [end_address]]"
			dbt 10d,13d,0d
	

OpTable:		dbt "ADC IMM"
			dbt 069h,2h,2h
			dbt "ADC ABS"
			dbt 06Dh,3h,4h
			dbt "ADC ABX"
			dbt 07Dh,3h,4h
			dbt "ADC ABY"
			dbt 079h,3h,4h
			dbt "ADC IIR"
			dbt 061h,2h,6h
			dbt "ADC IRI"
			dbt 071h,2h,5h
			dbt "AND IMM"
			dbt 029h,2h,2h
			dbt "AND ABS"
			dbt 02Dh,3h,4h
			dbt "AND ABX"
			dbt 03Dh,3h,4h
			dbt "AND ABY"
			dbt 039h,3h,4h
			dbt "AND IIR"
			dbt 021h,2h,6h
			dbt "AND IRI"
			dbt 031h,2h,5h
			dbt "ASL ACC"
			dbt 00Ah,1h,2h
			dbt "ASL ABS"
			dbt 00Eh,3h,6h
			dbt "ASL ABX"
			dbt 01Eh,3h,7h
			dbt "BCC REL"
			dbt 090h,2h,2h
			dbt "BCS REL"
			dbt 0B0h,2h,2h
			dbt "BEQ REL"
			dbt 0F0h,2h,2h
			dbt "BIT ABS"
			dbt 02Ch,3h,4h
			dbt "BMI REL"
			dbt 030h,2h,2h
			dbt "BNE REL"
			dbt 0D0h,2h,2h
			dbt "BPL REL"
			dbt 010h,2h,2h
			dbt "BRK IMP"
			dbt 000h,1h,7h
			dbt "BVC REL"
			dbt 050h,2h,2h
			dbt "BVS REL"
			dbt 070h,2h,2h
			dbt "CLC IMP"
			dbt 018h,1h,2h
			dbt "CLD IMP"
			dbt 0D8h,1h,2h
			dbt "CLI IMP"
			dbt 058h,1h,2h
			dbt "CLV IMP"
			dbt 0B8h,1h,2h
			dbt "CMP IMM"
			dbt 0C9h,2h,2h
			dbt "CMP ABS"
			dbt 0CDh,3h,4h
			dbt "CMP ABX"
			dbt 0DDh,3h,4h
			dbt "CMP ABY"
			dbt 0D9h,3h,4h
			dbt "CMP IIR"
			dbt 0C1h,2h,6h
			dbt "CMP IRI"
			dbt 0D1h,2h,5h
			dbt "CPX IMM"
			dbt 0E0h,2h,2h
			dbt "CPX ABS"
			dbt 0ECh,3h,4h
			dbt "CPY IMM"
			dbt 0C0h,2h,2h
			dbt "CPY ABS"
			dbt 0CCh,3h,4h
			dbt "DEC ABS"
			dbt 0CEh,3h,6h
			dbt "DEC ABX"
			dbt 0DEh,3h,7h
			dbt "DEX IMP"
			dbt 0CAh,1h,2h
			dbt "DEY IMP"
			dbt 088h,1h,2h
			dbt "EOR IMM"
			dbt 049h,2h,2h
			dbt "EOR ABS"
			dbt 04Dh,3h,4h
			dbt "EOR ABX"
			dbt 05Dh,3h,4h
			dbt "EOR ABY"
			dbt 059h,3h,4h
			dbt "EOR IIR"
			dbt 041h,2h,6h
			dbt "EOR IRI"
			dbt 051h,2h,5h
			dbt "INC ABS"
			dbt 0EEh,3h,6h
			dbt "INC ABX"
			dbt 0FEh,3h,7h
			dbt "INX IMP"
			dbt 0E8h,1h,2h
			dbt "INY IMP"
			dbt 0C8h,1h,2h
			dbt "JMP ABS"
			dbt 04Ch,3h,3h
			dbt "JMP IND"
			dbt 06Ch,3h,5h
			dbt "JSR ABS"
			dbt 020h,3h,6h
			dbt "LDA IMM"
			dbt 0A9h,2h,2h
			dbt "LDA ABS"
			dbt 0ADh,3h,4h
			dbt "LDA ABX"
			dbt 0BDh,3h,4h
			dbt "LDA ABY"
			dbt 0B9h,3h,4h
			dbt "LDA IIR"
			dbt 0A1h,2h,6h
			dbt "LDA IRI"
			dbt 0B1h,2h,5h
			dbt "LDX IMM"
			dbt 0A2h,2h,2h
			dbt "LDX ABS"
			dbt 0AEh,3h,4h
			dbt "LDX ABY"
			dbt 0BEh,3h,4h
			dbt "LDY IMM"
			dbt 0A0h,2h,2h
			dbt "LDY ABS"
			dbt 0ACh,3h,4h
			dbt "LDY ABX"
			dbt 0BCh,3h,4h
			dbt "LSR ACC"
			dbt 04Ah,1h,2h
			dbt "LSR ABS"
			dbt 04Eh,3h,6h
			dbt "LSR ABX"
			dbt 05Eh,3h,7h
			dbt "NOP IMP"
			dbt 0EAh,1h,2h
			dbt "ORA IMM"
			dbt 009h,2h,2h
			dbt "ORA ABS"
			dbt 00Dh,3h,4h
			dbt "ORA ABX"
			dbt 01Dh,3h,4h
			dbt "ORA ABY"
			dbt 019h,3h,4h
			dbt "ORA IIR"
			dbt 001h,2h,6h
			dbt "ORA IRI"
			dbt 011h,2h,5h
			dbt "PHA IMP"
			dbt 048h,1h,3h
			dbt "PHP IMP"
			dbt 008h,1h,3h
			dbt "PLA IMP"
			dbt 068h,1h,4h
			dbt "PLP IMP"
			dbt 028h,1h,4h
			dbt "ROL ACC"
			dbt 02Ah,1h,2h
			dbt "ROL ABS"
			dbt 02Eh,3h,6h
			dbt "ROL ABX"
			dbt 03Eh,3h,7h
			dbt "ROR ACC"
			dbt 06Ah,1h,2h
			dbt "ROR ABS"
			dbt 06Eh,3h,6h
			dbt "ROR ABX"
			dbt 07Eh,3h,7h
			dbt "RTI IMP"
			dbt 040h,1h,6h
			dbt "RTS IMP"
			dbt 060h,1h,6h
			dbt "SBC IMM"
			dbt 0E9h,2h,2h
			dbt "SBC ABS"
			dbt 0EDh,3h,4h
			dbt "SBC ABX"
			dbt 0FDh,3h,4h
			dbt "SBC ABY"
			dbt 0F9h,3h,4h
			dbt "SBC IIR"
			dbt 0E1h,2h,6h
			dbt "SBC IRI"
			dbt 0F1h,2h,5h
			dbt "SEC IMP"
			dbt 038h,1h,2h
			dbt "SED IMP"
			dbt 0F8h,1h,2h
			dbt "SEI IMP"
			dbt 078h,1h,2h
			dbt "STA ABS"
			dbt 08Dh,3h,4h
			dbt "STA ABX"
			dbt 09Dh,3h,5h
			dbt "STA ABY"
			dbt 099h,3h,5h
			dbt "STA IIR"
			dbt 081h,2h,6h
			dbt "STA IRI"
			dbt 091h,2h,6h
			dbt "STX ABS"
			dbt 08Eh,3h,4h
			dbt "STY ABS"
			dbt 08Ch,3h,4h
			dbt "TAX IMP"
			dbt 0AAh,1h,2h
			dbt "TAY IMP"
			dbt 0A8h,1h,2h
			dbt "TSX IMP"
			dbt 0BAh,1h,2h
			dbt "TXA IMP"
			dbt 08Ah,1h,2h
			dbt "TXS IMP"
			dbt 09Ah,1h,2h
			dbt "TYA IMP"
			dbt 098h,1h,2h
			dbt "ZZZ ZZZ"
			dbt 000h,0h,0h
		
;****************************************************************************
;       Initialize 6502 reset vector and maskable interrupt vector.
;****************************************************************************
			org 0fffch	;Initialize reset vector.
			dbt 00h,0e0h	;                                                                                         
;	
			org 0fffeh	;Initialize maskable interrupt vector.
			dbt #MaskInt<	;
			dbt #MaskInt>	;
			end
		
; ,output="array",start_address="E000"
%/uasm65

    %output,sequence="17",timestamp="2015-02-11 16:07:07.779",preserve="false"
      *** List file ***
      
                      000001 |;****************************************************************************
                      000002 |;  UMON65 Understandable Monitor for the 6500 series microprocessors.
                      000003 |;  Copyright 2015 by Ted Kosan.
                      000004 |;
                      000005 |;
                      000006 |;****************************************************************************
                      000007 |
                      000008 |
                      000009 |;****************************************************************************
                      000010 |;                                Equates Area.
                      000011 |;****************************************************************************   
                      000012 |
                      000013 |
                      000014 |;
                      000015 |;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
                      000016 |;
                      000017 |;Transmitt Receive Register.
      0000            000018 |6551TRR:	equ A000h ;400ah
                      000019 |
                      000020 |
                      000021 |;Status Register.  
                      000022 |;		    Status			          cleared by
                      000023 |;	b0	Parity error * (1: error)       self clearing **
                      000024 |;	b1	Framing error * (1: error)      self clearing **
                      000025 |;	b2	Overrun * (1: error)            self clearing **
                      000026 |;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
                      000027 |;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
                      000028 |;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
                      000029 |;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
                      000030 |;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
                      000031 |;                                                                                                            
                      000032 |;	note: * no interrupt generated for these conditions
                      000033 |;	      ** cleared automatically after a read of RDR and the next 
                      000034 |;		error free receipt of data
      0000            000035 |6551StR:	equ A001h ;400bh 
                      000036 |
      0000            000037 |6551Sleep: equ A002h	; When an lda to this address is performed the emulator
                      000038 |			;can be put to sleep.
                      000039 |
                      000040 |
                      000041 |;Comand Register  
                      000042 |;	b0	Data Terminal Ready
                      000043 |;			0 : disable receiver and all interrupts (DTR high)
                      000044 |;			1 : enable receiver and all interrupts (DTR low)
                      000045 |;	b1	Receiver Interrupt Enable
                      000046 |;			0 : IRQ interrupt enabled from bit 3 of status register
                      000047 |;			1 : IRQ interrupt disabled
                      000048 |;	b3,b2	Transmitter Control
                      000049 |;				Transmit Interrupt    RTS level    Transmitter
                      000050 |;			00	   disabled		high		off
                      000051 |;			01	   enabled		low		on
                      000052 |;			10	   disabled		low		on
                      000053 |;			11	   disabled		low	   Transmit BRK
                      000054 |;	b4	Normal/Echo Mode for Receiver
                      000055 |;			0 : normal
                      000056 |;			1 : echo (bits 2 and 3 must be 0)
                      000057 |;	b5	Parity Enable
                      000058 |;			0 : parity disabled, no parity bit generated or received
                      000059 |;			1 : parity enabled
                      000060 |;	b7,b6	Parity
                      000061 |;			00 : odd parity receiver and transmitter
                      000062 |;			01 : even parity receiver and transmitter
                      000063 |;			10 : mark parity bit transmitted, parity check disabled
                      000064 |;			11 : space parity bit transmitted, parity check disabled
                      000065 |
                      000066 |
                      000067 |;6551CmR	equ 0b202h  
                      000068 |
                      000069 |;Control Register
                      000070 |;
                      000071 |;	b3-b0	baud rate generator:
                      000072 |;			0000 : 16x external clock
                      000073 |;			0001 : 50 baud
                      000074 |;			0010 : 75
                      000075 |;			0011 : 110
                      000076 |;			0100 : 134.5
                      000077 |;			0101 : 150
                      000078 |;			0110 : 300
                      000079 |;			0111 : 600
                      000080 |;			1000 : 1200
                      000081 |;			1001 : 1800
                      000082 |;			1010 : 2400
                      000083 |;			1011 : 3600
                      000084 |;			1100 : 4800
                      000085 |;			1101 : 7200
                      000086 |;			1110 : 9600
                      000087 |;			1111 : 19,200
                      000088 |;	b4	receiver clock source
                      000089 |;			0 : external receiver clock
                      000090 |;			1 : baud rate generator
                      000091 |;	b6,b5	word length                                                                  
                      000092 |;			00 : 8 bits
                      000093 |;			01 : 7
                      000094 |;			10 : 6
                      000095 |;			11 : 5
                      000096 |;	b7	stop bits
                      000097 |;			0 : 1 stop bit
                      000098 |;			1 : 2 stop bits
                      000099 |;			    (1 stop bit if parity and word length = 8)
                      000100 |;			    (1 1/2 stop bits if word length = 5 and no parity)
                      000101 |;6551CtR	equ 0b203h  
                      000102 |
                      000103 |
                      000104 |
                      000105 |
                      000106 |;InPort0 Equate.
      0000            000107 |InPort0:	equ 0a000h
                      000108 |
                      000109 |;OutPort0 Equate.
      0000            000110 |OutPort0:	equ 0a100h
                      000111 |
                      000112 |;****************************************************************************
                      000113 |;                       General Purpose Pointer Area.
                      000114 |;****************************************************************************
      0000            000115 |	org 0000h
                      000116 |	
      0000 00 00      000117 |GenPoint:	dwd ?
      0002 00 00      000118 |IRQVect:	dwd ?		;
      0004 00 00      000119 |BRKVect:	dwd ?		;Break command indirect vector.
      0006 00 00      000120 |MessPtr:	dwd ?		;
      0008 00 00      000121 |PointerA:	dwd ?		;
      000A 00 00      000122 |PointerB:	dwd ?		;
      000C 00 00      000123 |PointerC:	dwd ?		;
      000E 00 00      000124 |NOpAdPtr:	dwd ?		;
      0010 00 00      000125 |BOpAdPtr:	dwd ?		;
      0012 00 00      000126 |BrkPt1Ad:	dwd ?		;
      0014 00 00      000127 |BrkPt2Ad:	dwd ?		;
      0016 00 00      000128 |BrkPt3Ad:	dwd ?		;                                                                                       
      0018 00 00      000129 |BrkPt4Ad:	dwd ?		;
                      000130 |
                      000131 |
                      000132 |	
                      000133 |;****************************************************************************
                      000134 |;                   General Purpose Variable Storage Area.
                      000135 |;****************************************************************************
                      000136 |;	org 0200h 
                      000137 |
                      000138 |		  
      001A 00         000139 |Obj1:		dbt ?
      001B 00         000140 |Obj2:		dbt ?
      001C 00         000141 |Obj3:		dbt ?
      001D 00         000142 |Obj2Flg:	dbt ?
      001E 00         000143 |Obj3Flg:	dbt ?
      001F 00         000144 |AddMode:	dbt ?
      0020 00         000145 |SrchTabl:	dbt 10d(?)
      0021 00 00 00         
      0024 00 00 00         
      0027 00 00 00         
      002A 00         000146 |SrchBtCt:	dbt ?
      002B 00 00      000147 |TempAdd:	dwd ?
      002D 00 00      000148 |TempAdd2:	dwd ?
      002F 00         000149 |BrkPt1St:	dbt ?
      0030 00         000150 |BrkPt2St:	dbt ?
      0031 00         000151 |BrkPt3St:	dbt ?
      0032 00         000152 |BrkPt4St:	dbt ?
      0033 00         000153 |BP1OpHld:	dbt ?
      0034 00         000154 |BP2OpHld:	dbt ?
      0035 00         000155 |BP3OpHld:	dbt ?
      0036 00         000156 |BP4OpHld:	dbt ?
      0037 00         000157 |BPNumHld:	dbt ?
      0038 00         000158 |BrValHld:	dbt ?
      0039 00         000159 |TrBrkFlg:	dbt ?
      003A 00         000160 |CurInsLn:	dbt ?
      003B 00         000161 |NOpCdHld:	dbt ?
      003C 00         000162 |BOpCdHld:	dbt ?
      003D 00         000163 |BrnchFlg:	dbt ?
      003E 00         000164 |TracCnt:	dbt ?
      003F 00 00      000165 |AddHold:	dwd ?
      0041 00         000166 |ObCdHld1:	dbt ?
      0042 00         000167 |ObCdHld2:	dbt ?
      0043 00         000168 |OpCdHold:	dbt ?
      0044 00         000169 |TempA:		dbt ?
      0045 00 00      000170 |UPgmCntr:	dwd ?
      0047 00         000171 |UAccum:		dbt ?
      0048 00         000172 |UXReg:		dbt ?
      0049 00         000173 |UYReg:		dbt ?
      004A 00         000174 |UStkPtr:	dbt ?
      004B 00         000175 |UStatReg:	dbt ?
      004C 00         000176 |ASCIIbuf:	dbt 16d(?)
      004D 00 00 00         
      0050 00 00 00         
      0053 00 00 00         
      0056 00 00 00         
      0059 00 00 00         
      005C 00 00      000177 |EndAdd:		dwd ?
      005E 00         000178 |OpOffSet:	dbt ?
      005F 00         000179 |OpFld1:		dbt 20d(?)
      0060 00 00 00         
      0063 00 00 00         
      0066 00 00 00         
      0069 00 00 00         
      006C 00 00 00         
      006F 00 00 00         
      0072 00               
      0073 00         000180 |OpFld2:		dbt 20d(?)
      0074 00 00 00         
      0077 00 00 00         
      007A 00 00 00         
      007D 00 00 00         
      0080 00 00 00         
      0083 00 00 00         
      0086 00               
      0087 00         000181 |OpFld3:		dbt 20d(?)	
      0088 00 00 00         
      008B 00 00 00         
      008E 00 00 00         
      0091 00 00 00         
      0094 00 00 00         
      0097 00 00 00         
      009A 00               
      009B 00         000182 |CodeCntr:	dbt ?
      009C 00         000183 |Number:		dbt ?
      009D 00         000184 |ChkSum:		dbt ?
      009E 00         000185 |RecLen:		dbt ?
      009F 00 00      000186 |CkSumAc:		dwd ?
      00A1 00         000187 |RecType: 	dbt ?
      00A2 00         000188 |wait0:		dbt ?
      00A3 00         000189 |wait1:		dbt ?
      00A4 00         000190 |			dbt ?
      00A5 00         000191 |InptBufr:	dbt 40d(?)
      00A6 00 00 00         
      00A9 00 00 00         
      00AC 00 00 00         
      00AF 00 00 00         
      00B2 00 00 00         
      00B5 00 00 00         
      00B8 00 00 00         
      00BB 00 00 00         
      00BE 00 00 00         
      00C1 00 00 00         
      00C4 00 00 00         
      00C7 00 00 00         
      00CA 00 00 00         
      00CD 00         000192 |Command:	dbt ?
      00CE 00         000193 |RegTemp:	dbt ?
      00CF 00         000194 |DataTemp:	dbt ?
                      000195 |
                      000196 |;****************************************************************************
                      000197 |;                        Monitor Eprom Entry Point.
                      000198 |;****************************************************************************
      E000            000199 |	org 0e000h Note
                      000200 |	;org 1000h
      E000 4C 1B E0   000201 |	jmp Start
                      000202 |
                      000203 |;****************************************************************************
                      000204 |;                  Monitor Utility Subroutine Jump Table.
                      000205 |;****************************************************************************
      E003 4C FA F3   000206 |	jmp OutChar	;Output byte in A register to serial port.
                      000207 |	
      E006 4C B6 F3   000208 |	jmp GetChar	;Get a byte from the serial port.
                      000209 |	
      E009 4C D9 F3   000210 |	jmp GetCharW	;Wait and get a byte from the serial port.
                      000211 |	
      E00C 4C 99 F3   000212 |	jmp PrntMess	;Print a message to the serial port.
                      000213 |	
      E00F 4C E9 F2   000214 |	jmp OutSpace	;Output spaces to the serial port.
                      000215 |	
      E012 4C 45 F3   000216 |	jmp OutHex	;Output a HEX number to the serial port.
                      000217 |	
      E015 4C 79 EA   000218 |	jmp DgtToBin	;Convert an ASCII digit into binary.
                      000219 |	
      E018 4C 8E E0   000220 |	jmp GetLine	;Input a line from the serial port.
                      000221 |	
                      000222 |
                      000223 |; Beginning of UMON65.
                      000224 |;****************************************************************************
                      000225 |;                       Start of UMON65 Main Routine.
                      000226 |;
                      000227 |;
                      000228 |;****************************************************************************
      E01B            000229 |start:
      E01B A2 FF      000230 |	ldx #0ffh	;Initialize stack pointer and clear decimal
      E01D 9A         000231 |	txs		; mode.
                      000232 |;	cli		;
      E01E D8         000233 |	cld		;
                      000234 |	
      E01F 20 79 F3   000235 |	jsr InitVars	;Initialize variables.
                      000236 |	
      E022 AD 00 AA   000237 |	lda 0aa00h		; If the byte at 0c000h is not zero, there is a program
      E025 C9 00      000238 |	cmp #0d			; in the EEPROM. Run this program instead of
      E027 F0 03      000239 |	beq EnterMon	; entering the monitor.
      E029 4C 00 C0   000240 |	jmp 0c000h		;
                      000241 |
                      000242 |;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
                      000243 |		
                      000244 |;****************************************************************************
                      000245 |;                     Check Computer's Configuration.
                      000246 |;****************************************************************************
      E02C            000247 |CkConfig:
                      000248 |	;lda InPort0	;Get the switch settings and mask out the 
                      000249 |	;and #00001111b	; switch's high nibble.
                      000250 |
                      000251 |;CkMon:
                      000252 |	
                      000253 |	;cmp #1d	;If the switch is set to a 1 then print the
                      000254 |	;bne CkEEPROM	; UMON65 monitor startup message and enter the
      E02C            000255 |EnterMon:
      E02C A2 5B      000256 |	ldx #OpenMess<	; monitor through the maskable interrupt vector.
      E02E A0 F4      000257 |	ldy #OpenMess>	;
      E030 20 99 F3   000258 |	jsr PrntMess	;
                      000259 |	;brk		    ;
      E033 A9 00      000260 |    lda #00000000b	 ;Initialize user's status register.
      E035 8D 4B 00   000261 |	sta UStatReg	;
                      000262 |
                      000263 |	
      E038 A9 00      000264 |	lda #0d	    ;Initialize user's accumulator.
      E03A 8D 47 00   000265 |	sta UAccum	;
                      000266 |	
      E03D 8D 48 00   000267 |	sta UXReg	;Initialize user's X register.
                      000268 |	
      E040 8D 49 00   000269 |	sta UYReg	;Initialize user's Y register.
                      000270 |	
      E043 A9 FF      000271 |	lda #0ffh    ;Initialize user's stack pointer
      E045 8D 4A 00   000272 |	sta UStkPtr	 ;.
                      000273 |    
      E048 4C 27 E2   000274 |    jmp ResetEntryPoint
                      000275 |
      E04B            000276 |CkEEPROM:
      E04B C9 02      000277 |	cmp #2d		;If the switch is set to a 2 then get the
      E04D D0 13      000278 |	bne DoLgtSho	; switch's high nibble and jump to a program
                      000279 |	;lda InPort0	; present in the EEPROM which is indicated by
      E04F 29 F0      000280 |	and #11110000b	; the high nibble's value.  The program can be
      E051 4A         000281 |	lsr a		; located at 1 of the following 16 locations:
      E052 4A         000282 |	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
      E053 4A         000283 |	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
      E054 18         000284 |	clc
      E055 69 C0      000285 |	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
      E057 8D 09 00   000286 |	sta PointerA+1d	; 15-DE00.
      E05A A9 00      000287 |	lda #0d		;
      E05C 8D 08 00   000288 |	sta PointerA	;
      E05F 6C 08 00   000289 |	jmp (PointerA)	;
                      000290 |			
      E062            000291 |DoLgtSho:
      E062 4C 65 E0   000292 |	jmp LghtShow
                      000293 |	
                      000294 |;****************************************************************************
                      000295 |;                            Light Show Subroutine.
                      000296 |;****************************************************************************
      E065            000297 |LghtShow:
      E065 A0 00      000298 |	ldy #0h		;Make the Y register count from 0 to 255 and
      E067 8C 44 00   000299 |	sty TempA	; output each number in the count to the
                      000300 |	;sty OutPort0	; light register.
      E06A            000301 |LSOtLoop:		;
      E06A A2 64      000302 |	ldx #100d	;
      E06C            000303 |LSInLoop:		;
      E06C C8         000304 |	iny		;
      E06D D0 FD      000305 |	bne LSInLoop	;
      E06F CA         000306 |	dex		;
      E070 D0 FA      000307 |	bne LSInLoop	;
      E072 EE 44 00   000308 |	inc TempA	;
      E075 AD 44 00   000309 |	lda TempA	;
                      000310 |	;sta OutPort0	;
      E078 4C 6A E0   000311 |	jmp LSOtLoop	;
                      000312 |
                      000313 |;****************************************************************************
                      000314 |;                            Monitor's Main Loop.
                      000315 |;****************************************************************************
      E07B            000316 |MainLoop:	
                      000317 |
      E07B 20 87 E0   000318 |	jsr GetLineP	;Get a typed line from the serial port.
                      000319 |
      E07E 20 F9 E0   000320 |	jsr ParsLine	;Break line into fields.
                      000321 |	
      E081 20 51 E1   000322 |	jsr CkValCmd	;Check to see if a valid monitor command was
                      000323 |			; entered and if so execute that command's code.
      E084 4C 7B E0   000324 |	jmp MainLoop
                      000325 |
                      000326 |	
                      000327 |;****************************************************************************
                      000328 |;                    Get Line From Serial Port Subroutine.
                      000329 |;****************************************************************************
      E087            000330 |GetLineP:
      E087 A2 AB      000331 |	ldx #Prompt<	;Print Prompt.
      E089 A0 F4      000332 |	ldy #Prompt>	;
      E08B 20 99 F3   000333 |	jsr PrntMess	;
                      000334 |
      E08E            000335 |GetLine:	
      E08E A0 00      000336 |	ldy #0d		;Initialize Y index register.
      E090 8C 5E 00   000337 |	sty OpOffSet	;Initialize opcode holder offset pointer.
      E093 8C CD 00   000338 |	sty command	;Initialize command holder.
      E096 8C 5F 00   000339 |	sty OpFld1	;Initialize operand field 1 buffer.
      E099 8C 73 00   000340 |	sty OpFld2	;Initialize operand field 2 buffer.
      E09C 8C 87 00   000341 |	sty OpFld3	;Initialize operand field 3 buffer.
                      000342 |	
      E09F A0 00      000343 |	ldy #0d		;Clear input buffer.
      E0A1 A9 00      000344 |	lda #0d		;
      E0A3            000345 |ClrInpBf:		;
      E0A3 99 A5 00   000346 |	sta InptBufr,y	;
      E0A6 C8         000347 |	iny		;
      E0A7 C0 27      000348 |	cpy #39d	;
      E0A9 D0 F8      000349 |	bne ClrInpBf	;
                      000350 |	
      E0AB A0 00      000351 |	ldy #0h		;Use Y register as buffer pointer.
                      000352 |	
      E0AD            000353 |GtAnChar:
      E0AD 20 D9 F3   000354 |	jsr GetCharW
                      000355 |;	jsr OutChar	;Echo character.  ;Note: remove for muvium.
                      000356 |
      E0B0 C9 00      000357 |	cmp #0h		;If no character is entered then try again.
      E0B2 F0 F9      000358 |	beq GtAnChar	;
                      000359 |	
      E0B4 C9 08      000360 |	cmp #8d		;Check to see if the user entered a Delete or
      E0B6 D0 03      000361 |	bne CkDel	; a Backspace.  If so then erase the character
      E0B8 4C BF E0   000362 |	jmp DoDelete	; to the left of the cursor.
      E0BB            000363 |CkDel:			;
      E0BB C9 7F      000364 |	cmp #127d	;
      E0BD D0 15      000365 |	bne GtCkChar	;
      E0BF            000366 |DoDelete:		;
      E0BF 88         000367 |	dey		;
      E0C0 30 0D      000368 |	bmi AtStart	;
      E0C2 A9 20      000369 |	lda #32d	;
      E0C4 20 FA F3   000370 |	jsr OutChar	;
      E0C7 A9 08      000371 |	lda #8d		;
      E0C9 20 FA F3   000372 |	jsr OutChar	;
      E0CC 4C AD E0   000373 |	jmp GtAnChar	;
                      000374 |
      E0CF            000375 |AtStart:
      E0CF A0 00      000376 |	ldy #0d
      E0D1 4C AD E0   000377 |	jmp GtAnChar
                      000378 |	
      E0D4            000379 |GtCkChar:
      E0D4 C9 0D      000380 |	cmp #13d	;If a CR was entered then accept line and exit,
      E0D6 F0 0D      000381 |	beq GtLnDone	; if not then accept the next character and
      E0D8 99 A5 00   000382 |	sta InptBufr,y	; place it into the input buffer.
      E0DB C8         000383 |	iny		;
                      000384 |	
      E0DC C0 27      000385 |	cpy #39d	;Do not let buffer expand past 40 characters.
      E0DE D0 CD      000386 |	bne GtAnChar
      E0E0 A0 27      000387 |	ldy #39d	;Set buffer at 40 characters if over 40 characters.
                      000388 |
      E0E2 4C AD E0   000389 |	jmp GtAnChar	;
                      000390 |	
      E0E5            000391 |GtLnDone:
                      000392 |	;If a NL is in the input buffer then remove it.
      E0E5 88         000393 |	dey
      E0E6 B9 A5 00   000394 |	lda InptBufr,y
      E0E9 C9 0A      000395 |	cmp #10d
      E0EB F0 01      000396 |	beq PutNull
      E0ED C8         000397 |	iny
      E0EE            000398 |PutNull:
      E0EE A9 00      000399 |	lda #0h		;Put a NULL at end of the input buffer.
      E0F0 99 A5 00   000400 |	sta InptBufr,y	;
                      000401 |		
      E0F3 60         000402 |	rts
                      000403 |	
                      000404 |;****************************************************************************
                      000405 |;                       Parse Input Buffer Subroutine.
                      000406 |;****************************************************************************
      E0F4            000407 |ParseOpr:	;Entry point if parsing for a UASM command is not
      E0F4 A0 FF      000408 |	ldy #0ffh	; desired.
      E0F6 4C 16 E1   000409 |	jmp GtAnoOpr	;
                      000410 |	
      E0F9            000411 |ParsLine:
      E0F9 A0 00      000412 |	ldy #0d
                      000413 |
      E0FB B9 A5 00   000414 |	lda InptBufr,y
      E0FE F0 50      000415 |	beq ExtPrsLn	;If NULL or CR encountered then return.
                      000416 |	
      E100 C9 3F      000417 |	cmp #63d	;Check for upper case letter.
      E102 30 4B      000418 |	bmi ParError	;
      E104 C9 5A      000419 |	cmp #90d	;	
      E106 10 03      000420 |	bpl CkSmCase	;
                      000421 |	
      E108 38         000422 |	sec
      E109 B0 08      000423 |	bcs GetCmd	;
                      000424 |	
      E10B            000425 |CkSmCase:
      E10B C9 61      000426 |	cmp #97d	;Check for lower case letter.
      E10D 30 40      000427 |	bmi ParError	;
      E10F C9 7A      000428 |	cmp #122d	;
      E111 10 3C      000429 |	bpl ParError	;
                      000430 |	                
      E113            000431 |GetCmd:
      E113 8D CD 00   000432 |	sta command	;Store command in command buffer.
                      000433 |                        
      E116            000434 |GtAnoOpr:       
      E116 C8         000435 |	iny		;Point Y to the next operand field and check to
      E117 C0 14      000436 |	cpy #20d	;make sure that the input line is not too long.
      E119 F0 34      000437 |	beq ParError	;
                      000438 |	                
      E11B B9 A5 00   000439 |	lda InptBufr,y	;Check for the end of the input line.
      E11E C9 00      000440 |	cmp #0d		;
      E120 F0 2E      000441 |	beq ExtPrsLn	;
                      000442 |	                
      E122 C9 20      000443 |	cmp #32d	;Check for a space between operand fields.
      E124 F0 F0      000444 |	beq GtAnoOpr	;
                      000445 |	                
      E126            000446 |ScanOprn:              
      E126 AE 5E 00   000447 |	ldx OpOffSet	;Point X to the beginning of the current operand
      E129 8A         000448 |	txa		; field holder and point OpOffSet to the beginning
      E12A 18         000449 |	clc             
      E12B 69 14      000450 |	adc #20d	; of the next operand field holder.
      E12D 8D 5E 00   000451 |	sta OpOffSet	;
                      000452 |	
      E130            000453 |TranDgt:
      E130 B9 A5 00   000454 |	lda InptBufr,y	;
                      000455 |	                
      E133 C9 20      000456 |	cmp #32d	;If a space is encountered then stop scanning.
      E135 F0 10      000457 |	beq DoneScan	;
                      000458 |	                
      E137 C9 00      000459 |	Cmp #0d		;If a CR is encountered then stop scanning.
      E139 F0 0C      000460 |	beq doneScan	;
                      000461 |	                
      E13B 9D 5F 00   000462 |	sta OpFld1,x	;Transfer current operand from input buffer into
      E13E E8         000463 |	inx		; current operand field holder.
      E13F C8         000464 |	iny		;
      E140 C0 28      000465 |	cpy #40d
      E142 F0 0B      000466 |	beq ParError
                      000467 |	
      E144 4C 30 E1   000468 |	jmp TranDgt	
                      000469 |	
      E147            000470 |DoneScan:
      E147 A9 00      000471 |	lda #0h		;Put a NULL at the end of the current operand field
      E149 9D 5F 00   000472 |	sta OpFld1,x	; holder.
                      000473 |	
      E14C 4C 16 E1   000474 |	jmp GtAnoOpr
                      000475 |
      E14F            000476 |ParError:
      E14F 60         000477 |	rts
      E150            000478 |ExtPrsLn:
      E150 60         000479 |	rts
                      000480 |
                      000481 |;****************************************************************************
                      000482 |;                     Check for Valid Command Subroutine.
                      000483 |;****************************************************************************
      E151            000484 |CkValCmd:
      E151 38         000485 |	sec
                      000486 |	
      E152 AD CD 00   000487 |	lda command
      E155 20 F4 F2   000488 |	jsr ToLower
                      000489 |
      E158 C9 6C      000490 |	cmp #108d	;Check for Load command.
      E15A D0 06      000491 |	bne NxtCmd1	;
      E15C 20 70 E9   000492 |	jsr LdSRecs	;
      E15F 4C E4 E1   000493 |	jmp ExitCmd	;
                      000494 |                        
      E162            000495 |NxtCmd1:
      E162 C9 64      000496 |	cmp #100d	;Check for Dump command.
      E164 D0 06      000497 |	bne NxtCmd2	;
      E166 20 42 E7   000498 |	jsr Dump	;
      E169 4C E4 E1   000499 |	jmp ExitCmd	;
                      000500 |                        
      E16C            000501 |NxtCmd2:
      E16C C9 72      000502 |	cmp #114d	;Check for Register command.
      E16E D0 06      000503 |	bne NxtCmd3	;
      E170 20 26 EB   000504 |	jsr Register	;
      E173 4C E4 E1   000505 |	jmp ExitCmd	;
                      000506 |		
      E176            000507 |NxtCmd3:
      E176 C9 67      000508 |	cmp #103d	;Check for Go command.
      E178 D0 06      000509 |	bne NxtCmd4	;
      E17A 20 E7 E8   000510 |	jsr Go		;
      E17D 4C E4 E1   000511 |	jmp ExitCmd	;
                      000512 |	
      E180            000513 |NxtCmd4:
      E180 C9 65      000514 |	cmp #101d	;Check for Enter command.
      E182 D0 06      000515 |	bne NxtCmd5	;
      E184 20 40 E8   000516 |	jsr Enter	;
      E187 4C E4 E1   000517 |	jmp ExitCmd	;
                      000518 |	
      E18A            000519 |NxtCmd5:
      E18A C9 66      000520 |	cmp #102d	;Check for Fill command.
      E18C D0 06      000521 |	bne NxtCmd6	;
      E18E 20 A6 E8   000522 |	jsr Fill	;
      E191 4C E4 E1   000523 |	jmp ExitCmd	;
                      000524 |
      E194            000525 |NxtCmd6:
      E194 C9 75      000526 |	cmp #117d	;Check for Unassemble command.
      E196 D0 06      000527 |	bne NxtCmd7	;
      E198 20 B7 EF   000528 |	jsr UnAssem	;
      E19B 4C E4 E1   000529 |	jmp ExitCmd	;
                      000530 |
      E19E            000531 |NxtCmd7:
      E19E C9 74      000532 |	cmp #116d	;Check for Trace command.
      E1A0 D0 06      000533 |	bne NxtCmd8	;
      E1A2 20 7C ED   000534 |	jsr Trace	;
      E1A5 4C E4 E1   000535 |	jmp ExitCmd	;
                      000536 |
      E1A8            000537 |NxtCmd8:
      E1A8 C9 62      000538 |	cmp #98d	;Check for Breakpoint command.
      E1AA D0 06      000539 |	bne NxtCmd9	;
      E1AC 20 DA E5   000540 |	jsr BreakPnt	;
      E1AF 4C E4 E1   000541 |	jmp ExitCmd	;
                      000542 |	
      E1B2            000543 |NxtCmd9:
      E1B2 C9 73      000544 |	cmp #115d	;Check for Search command.
      E1B4 D0 06      000545 |	bne NxtCmd10	;
      E1B6 20 EB EC   000546 |	jsr Search	;
      E1B9 4C E4 E1   000547 |	jmp ExitCmd	;
                      000548 |
      E1BC            000549 |NxtCmd10:
      E1BC C9 6D      000550 |	cmp #109d	;Check for Move command.
      E1BE D0 06      000551 |	bne NxtCmd11	;
      E1C0 20 BA EA   000552 |	jsr Move	;
      E1C3 4C E4 E1   000553 |	jmp ExitCmd	;
                      000554 |	
      E1C6            000555 |NxtCmd11:
      E1C6 C9 61      000556 |	cmp #'a'	;Check for Assemble command.
      E1C8 D0 06      000557 |	bne NxtCmd12	;
      E1CA 20 51 E2   000558 |	jsr Assemble	;
      E1CD 4C E4 E1   000559 |	jmp ExitCmd	;
                      000560 |
      E1D0            000561 |NxtCmd12:
      E1D0 C9 68      000562 |	cmp #104d	;Check for Help command.
      E1D2 D0 06      000563 |	bne NxtCmd13	;
      E1D4 20 68 E9   000564 |	jsr Help	;
      E1D7 4C E4 E1   000565 |	jmp ExitCmd	;
      E1DA            000566 |NxtCmd13:                 
      E1DA C9 3F      000567 |	cmp #63d	;
      E1DC D0 06      000568 |	bne ExitCmd	;
      E1DE 20 68 E9   000569 |	jsr Help	;
      E1E1 4C E4 E1   000570 |	jmp ExitCmd	;
                      000571 |
      E1E4            000572 |ExitCmd:
      E1E4 B0 09      000573 |	bcs CmdOk
                      000574 |	
      E1E6            000575 |CmdError:		;If there was an error with a command then
      E1E6 A2 26      000576 |	ldx #CmdErMes<	; print a question mark.
      E1E8 A0 F6      000577 |	ldy #CmdErMes>	;
      E1EA 20 99 F3   000578 |	jsr PrntMess	;
      E1ED 18         000579 |	clc		;
      E1EE 60         000580 |	rts		;
                      000581 |	
      E1EF            000582 |CmdOk:
      E1EF 38         000583 |	sec
      E1F0 60         000584 |	rts
                      000585 |
                      000586 |;****************************************************************************
                      000587 |;                     Maskable Interrupt Service Subroutine.
                      000588 |;****************************************************************************
      E1F1            000589 |MaskInt:
      E1F1 78         000590 |	sei		;Disable interrupts.
                      000591 |
      E1F2 8D 44 00   000592 |	sta TempA	;Save accumulator.
                      000593 |			
      E1F5 68         000594 |	pla		;Check to see if BRK command was executed.
      E1F6 48         000595 |	pha		;
      E1F7 29 10      000596 |	and #10h	;
      E1F9 D0 06      000597 |	bne DoBRK	;
                      000598 |	
      E1FB AD 44 00   000599 |	lda TempA	;Restore accumulator.
                      000600 |
      E1FE            000601 |IRQ:	
      E1FE 6C 02 00   000602 |	jmp (IRQVect)
                      000603 |	
      E201            000604 |DoBRK:
      E201 6C 04 00   000605 |	jmp (BRKVect)
                      000606 |
                      000607 |	
                      000608 |;****************************************************************************
                      000609 |;                          Break Service Subroutine.
                      000610 |;****************************************************************************
                      000611 |	
      E204            000612 |BRK:
      E204 68         000613 |	pla		;Save user's status register.
      E205 8D 4B 00   000614 |	sta UStatReg	;
                      000615 |
                      000616 |	
      E208 AD 44 00   000617 |	lda TempA	;Save user's accumulator.
      E20B 8D 47 00   000618 |	sta UAccum	;
                      000619 |	
      E20E 8E 48 00   000620 |	stx UXReg	;Save user's X register.
                      000621 |	
      E211 8C 49 00   000622 |	sty UYReg	;Save user's Y register.
                      000623 |	
      E214 BA         000624 |	tsx
                      000625 |    
      E215 E8         000626 |    inx ;Remove the remaining 2 bytes that were pushed on the
      E216 E8         000627 |    inx ; stack by the brk command.
                      000628 |    
      E217 8E 4A 00   000629 |	stx UStkPtr	;Save user's stack pointer.
                      000630 |	
      E21A 68         000631 |	pla		;Save program counter of break instruction
      E21B 38         000632 |	sec		; that caused execution of this code.
      E21C E9 01      000633 |	sbc #1d		;
      E21E 8D 45 00   000634 |	sta UPgmCntr	;
      E221 68         000635 |	pla		; 
      E222 E9 00      000636 |	sbc #0d		;
      E224 8D 46 00   000637 |	sta UPgmCntr+1d	;
                      000638 |;	cli
                      000639 |
      E227            000640 |ResetEntryPoint:
      E227 A0 00      000641 |	ldy #0d		;Print user's registers.
      E229 8C 5F 00   000642 |	sty OpFld1	;
      E22C 20 26 EB   000643 |	jsr Register	;
                      000644 |
      E22F AD 39 00   000645 |	lda TrBrkFlg	;If this break was placed by the trace command
      E232 C9 01      000646 |	cmp #1d		; then go back to the trace subroutine.
      E234 D0 03      000647 |	bne RepBPOp	;
      E236 4C 32 EF   000648 |	jmp Tr2ndEnt	;
                      000649 |	
      E239            000650 |RepBPOp:
      E239 A0 03      000651 |	ldy #3d		;Replace the opcodes of all breakpointed
      E23B A2 06      000652 |	ldx #6d		; addresses.
      E23D            000653 |CkBPStBr:              ;
      E23D B9 2F 00   000654 |	lda BrkPt1St,y	;
      E240 C9 01      000655 |	cmp #1d		;
      E242 D0 05      000656 |	bne NxtBPStB	;
      E244 B9 33 00   000657 |	lda BP1OpHld,y	;
      E247 81 12      000658 |	sta (BrkPt1Ad,x);
      E249            000659 |NxtBPStB:		;
      E249 88         000660 |	dey		;
      E24A CA         000661 |	dex		;
      E24B CA         000662 |	dex		;
      E24C 10 EF      000663 |	bpl CkBPStBr	;
                      000664 |	
      E24E            000665 |GoMain:
      E24E 4C 7B E0   000666 |	jmp MainLoop	;Enter monitor.
                      000667 |
                      000668 |
                      000669 |;****************************************************************************
                      000670 |;                       Assemble Command Subroutine.
                      000671 |;****************************************************************************
      E251            000672 |Assemble:
                      000673 |
      E251 A2 00      000674 |	ldx #0d		;Get address to start assembling at and store
      E253 20 CA F2   000675 |	jsr GetAdd	; in pointer A.
      E256 B0 03      000676 |	bcs AAddOk	;
      E258 4C 47 E3   000677 |	jmp ErrAsem	;
      E25B            000678 |AAddOk:		;
      E25B 8E 08 00   000679 |	stx PointerA	;
      E25E 8C 09 00   000680 |	sty PointerA+1d	;
                      000681 |
      E261            000682 |AsemTop:		;On new line print current address being
      E261 A2 AF      000683 |	ldx #CRLF<	; assembled at and get next instruction to be
      E263 A0 F4      000684 |	ldy #CRLF>	; assembled from user.
      E265 20 99 F3   000685 |	jsr PrntMess	;
      E268 20 0C F3   000686 |	jsr PrntAdd	;
      E26B 20 8E E0   000687 |	jsr GetLine	;
      E26E 20 F4 E0   000688 |	jsr ParseOpr	;
                      000689 |	
      E271 AD 5F 00   000690 |	lda OpFld1	;Check for operator to be assembled. If no
      E274 C9 00      000691 |	cmp #0d		; operator is found then exit Assemble 
      E276 F0 04      000692 |	beq AsemDone	; subroutine.
      E278 C9 20      000693 |	cmp #32d	;
      E27A D0 03      000694 |	bne ACont	;
      E27C            000695 |AsemDone:              ;
      E27C 4C 49 E3   000696 |	jmp ExitAsem	;
                      000697 |	
      E27F            000698 |ACont:			;Convert operator in input buffer to upper case,
      E27F A0 00      000699 |	ldy #0d		; check to see if it is in the operator table and
      E281            000700 |ConvAno:		;
      E281 B9 5F 00   000701 |	lda OpFld1,y	; output a question mark if operator was not found.
      E284 20 00 F3   000702 |	jsr ToUpper	;
      E287 99 5F 00   000703 |	sta OpFld1,y	;
      E28A C8         000704 |	iny		;
      E28B C0 03      000705 |	cpy #3d		;
      E28D D0 F2      000706 |	bne ConvAno	;
      E28F 20 4B E3   000707 |	jsr OptrScan	;
      E292 B0 28      000708 |	bcs AOptrOk	;
                      000709 |	
      E294            000710 |PrntQues:
      E294 20 0C F3   000711 |	jsr PrntAdd	;If there was an error assembling the instruction
      E297 A9 20      000712 |	lda #32d	; input from the user into object code then re-
      E299 20 FA F3   000713 |	jsr OutChar	; output the line and print a question mark.
      E29C A2 5F      000714 |	ldx #OpFld1<	;
      E29E A0 00      000715 |	ldy #OpFld1>	;
      E2A0 20 99 F3   000716 |	jsr PrntMess	;
      E2A3 A9 20      000717 |	lda #32d  	;
      E2A5 20 FA F3   000718 |	jsr OutChar	;
      E2A8 A2 73      000719 |	ldx #OpFld2<	;
      E2AA A0 00      000720 |	ldy #OpFld2>	;
      E2AC 20 99 F3   000721 |	jsr PrntMess	;
      E2AF A9 20      000722 |	lda #32d	;
      E2B1 20 FA F3   000723 |	jsr OutChar	;
      E2B4 A9 3F      000724 |	lda #63d	;
      E2B6 20 FA F3   000725 |	jsr OutChar	;
      E2B9 4C 61 E2   000726 |	jmp AsemTop	;
                      000727 |	
      E2BC            000728 |AOptrOk:		;Check address mode of operand and print a quesion
      E2BC 20 83 E3   000729 |	jsr AdMdScan	; mark if error occures while scanning operand.
      E2BF B0 03      000730 |	bcs AOpndOk	;
      E2C1 4C 94 E2   000731 |	jmp PrntQues
                      000732 |		
      E2C4            000733 |AOpndOk:		;Check to see if address mode of operand is a
      E2C4 20 78 E4   000734 |	jsr AdMdTbSc	; valid address mode for instruction.
      E2C7 B0 03      000735 |	bcs AOpTbFnd	;
      E2C9 4C 94 E2   000736 |	jmp PrntQues
                      000737 |		
      E2CC            000738 |AOpTbFnd:		;Extract object code from operand.
      E2CC 20 98 E4   000739 |	jsr OpndScan	;
      E2CF B0 03      000740 |	bcs PrntAssm	;
      E2D1 4C 94 E2   000741 |	jmp PrntQues	;
                      000742 |	
      E2D4            000743 |PrntAssm:
      E2D4 20 0C F3   000744 |	jsr PrntAdd	;Re-output current address.
                      000745 |	
      E2D7 A0 00      000746 |	ldy #0d		;
                      000747 |	
      E2D9 AD 1A 00   000748 |	lda Obj1	;Output opcode, store it in memory, point to next
      E2DC 91 08      000749 |	sta (PointerA),y; byte, and print one space.
      E2DE 20 45 F3   000750 |	jsr OutHex	;
      E2E1 20 C1 F2   000751 |	jsr IncPntrA	;
      E2E4 A9 20      000752 |	lda #32d	;
      E2E6 20 FA F3   000753 |	jsr OutChar	;
                      000754 |	
      E2E9 AD 1D 00   000755 |	lda Obj2Flg	;Output second object code byte if present, store it in
      E2EC F0 28      000756 |	beq NoObjCd	; it in memory, point to next byte, and print one
      E2EE AD 1B 00   000757 |	lda Obj2	; space.
      E2F1 91 08      000758 |	sta (PointerA),y;
      E2F3 20 45 F3   000759 |	jsr OutHex	;
      E2F6 20 C1 F2   000760 |	jsr IncPntrA	;
      E2F9 A9 20      000761 |	lda #32d	;
      E2FB 20 FA F3   000762 |	jsr OutChar	;
                      000763 |	
      E2FE AD 1E 00   000764 |	lda Obj3Flg	;Output third object code byte if present, store
      E301 F0 1E      000765 |	beq NoObjCd3	; it in memory, point to next byte, and print one
      E303 AD 1C 00   000766 |	lda Obj3	; space.
      E306 91 08      000767 |	sta (PointerA),y;
      E308 20 45 F3   000768 |	jsr OutHex	;
      E30B 20 C1 F2   000769 |	jsr IncPntrA	;
      E30E A9 20      000770 |	lda #32d	;
      E310 20 FA F3   000771 |	jsr OutChar	;
      E313 4C 2C E3   000772 |	jmp NoExSpcs
                      000773 |
      E316            000774 |NoObjCd:		;If fewer then 3 bytes of object code are output
      E316 A9 20      000775 |	lda #32d	; then output spaces instead.
      E318 20 FA F3   000776 |	jsr OutChar	;
      E31B 20 FA F3   000777 |	jsr OutChar	;
      E31E 20 FA F3   000778 |	jsr OutChar
      E321            000779 |NoObjCd3:
      E321 A9 20      000780 |	lda #32d	;
      E323 20 FA F3   000781 |	jsr OutChar	;
      E326 20 FA F3   000782 |	jsr OutChar	;
      E329 20 FA F3   000783 |	jsr OutChar
                      000784 |	
      E32C            000785 |NoExSpcs:
      E32C A9 20      000786 |	lda #32d	;
      E32E 20 FA F3   000787 |	jsr OutChar	;
      E331 A2 5F      000788 |	ldx #OpFld1<	;Re-output instruction that user had entered in.
      E333 A0 00      000789 |	ldy #OpFld1>	;
      E335 20 99 F3   000790 |	jsr PrntMess	;
      E338 A9 20      000791 |	lda #32d  	;
      E33A 20 FA F3   000792 |	jsr OutChar	;
      E33D A2 73      000793 |	ldx #OpFld2<	;
      E33F A0 00      000794 |	ldy #OpFld2>	;
      E341 20 99 F3   000795 |	jsr PrntMess	;
                      000796 |
      E344 4C 61 E2   000797 |	jmp AsemTop
                      000798 |	
                      000799 |	
      E347            000800 |ErrAsem:
      E347 18         000801 |	clc
      E348 60         000802 |	rts
                      000803 |	
      E349            000804 |ExitAsem:
      E349 38         000805 |	sec
      E34A 60         000806 |	rts
                      000807 |	
                      000808 |
                      000809 |;****************************************************************************
                      000810 |;                       Operator Scan Subroutine.
                      000811 |;****************************************************************************
      E34B            000812 |OptrScan:
                      000813 |
      E34B A2 2C      000814 |	ldx #OpTable<	;Point pointer B to beginning of the operator
      E34D 8E 0A 00   000815 |	stx PointerB	; table.
      E350 A2 F8      000816 |	ldx #Optable>	;
      E352 8E 0B 00   000817 |	stx PointerB+1d	;
                      000818 |	
      E355            000819 |OSCkAno:
      E355 A0 00      000820 |	ldy #0d		;Compare a digit of the operator that the user
      E357            000821 |OSCkAnCM:		;
      E357 B1 0A      000822 |	lda (PointerB),y; entered with the analogous digit of the
      E359 D9 5F 00   000823 |	cmp OpFld1,y	; operator in the operator table.
      E35C F0 19      000824 |	beq CharMtch	;
                      000825 |	
      E35E            000826 |OptScan2:
      E35E AD 0A 00   000827 |	lda PointerB	;Point pointer B to the beginning of the next
      E361 18         000828 |	clc		; operator in the operator table.
      E362 69 0A      000829 |	adc #10d	;
      E364 8D 0A 00   000830 |	sta PointerB	;
      E367 90 03      000831 |	bcc OSNoCary	;
      E369 EE 0B 00   000832 |	inc PointerB+1d	;
                      000833 |	
      E36C            000834 |OSNoCary:
      E36C A0 04      000835 |	ldy #4d		;Check for the end of the operator table.
      E36E B1 0A      000836 |	lda (PointerB),y;
      E370 C9 5A      000837 |	cmp #'Z'	;
      E372 F0 0B      000838 |	beq OSNoMtch	;
      E374 4C 55 E3   000839 |	jmp OSCkAno	;
                      000840 |	
      E377            000841 |CharMtch:		;Check for an operator match in the operator
      E377 C8         000842 |	iny		; table.
      E378 C0 03      000843 |	cpy #3d		;
      E37A F0 05      000844 |	beq OSMatch	;
      E37C 4C 57 E3   000845 |	jmp OSCkAnCM	;
                      000846 |	
      E37F            000847 |OSNoMtch:
      E37F 18         000848 |	clc
      E380 60         000849 |	rts
                      000850 |	
      E381            000851 |OSMatch:
      E381 38         000852 |	sec
      E382 60         000853 |	rts
                      000854 |
                      000855 |
                      000856 |;****************************************************************************
                      000857 |;                     Address Mode Scan Subroutine.
                      000858 |;****************************************************************************
      E383            000859 |AdMdScan:
                      000860 |
      E383            000861 |AMSCkIMP:
      E383 A0 00      000862 |	ldy #0d		;Check for implied addressing mode.
      E385 B9 73 00   000863 |	lda OpFld2,y	;
      E388 C9 00      000864 |	cmp #0d		;
      E38A D0 08      000865 |	bne AMSCkIMM	;
      E38C A9 50      000866 |	lda #'P'	;
      E38E 8D 1F 00   000867 |	sta AddMode	;
      E391 4C 76 E4   000868 |	jmp ExitAMS	;
                      000869 |	
      E394            000870 |AMSCkIMM:		;Check for immediate addressing mode.
      E394 C9 23      000871 |	cmp #'#'	;
      E396 D0 08      000872 |	bne AMSCkACC	;
      E398 A9 4D      000873 |	lda #'M'	;
      E39A 8D 1F 00   000874 |	sta AddMode	;
      E39D 4C 76 E4   000875 |	jmp ExitAMS	;
                      000876 |	
      E3A0            000877 |AMSCkACC:		;Check for accumulator addressing mode.
      E3A0 C9 41      000878 |	cmp #'A'	;
      E3A2 F0 07      000879 |	beq CkSpNull	;
      E3A4 C9 61      000880 |	cmp #'a'	;
      E3A6 F0 03      000881 |	beq CkSpNull	;
      E3A8 4C C2 E3   000882 |	jmp AMSCkREL	;
      E3AB            000883 |CkSpNull:		;
      E3AB C8         000884 |	iny		;
      E3AC B9 73 00   000885 |	lda OpFld2,y	;
      E3AF C9 00      000886 |	Cmp #0d		;
      E3B1 F0 07      000887 |	beq IsAcc	;
      E3B3 C9 20      000888 |	cmp #32d	;
      E3B5 F0 03      000889 |	beq IsAcc	;
      E3B7 4C C2 E3   000890 |	jmp AMSCkREL	;
      E3BA            000891 |IsAcc:			;
      E3BA A9 43      000892 |	lda #'C'	;
      E3BC 8D 1F 00   000893 |	sta AddMode	;
      E3BF 4C 76 E4   000894 |	jmp ExitAMS	;
                      000895 |	
      E3C2            000896 |AMSCkREL:		;Check for relative addressing mode.
      E3C2 A0 06      000897 |	ldy #6d		;
      E3C4 B1 0A      000898 |	lda (PointerB),y;
      E3C6 C9 4C      000899 |	cmp #'L'	;
      E3C8 D0 06      000900 |	bne AMSCkA_I	;
      E3CA 8D 1F 00   000901 |	sta AddMode	;
      E3CD 4C 76 E4   000902 |	jmp ExitAMS	;
                      000903 |	
      E3D0            000904 |AMSCkA_I:		;Dispatch to absolute or indexed check code.
      E3D0 A0 00      000905 |	ldy #0d		;
      E3D2 B9 73 00   000906 |	lda OpFld2,y	;
      E3D5 C9 28      000907 |	cmp #'('	;
      E3D7 D0 03      000908 |	bne AMSCkAB?	;
      E3D9 4C 1C E4   000909 |	jmp AMSCkId?	;
                      000910 |	
      E3DC            000911 |AMSCkAB?:		;Check to see if operand is absolute addressing
      E3DC A0 00      000912 |	ldy #0d		; mode or absolute indexed addressing mode.
      E3DE            000913 |AMSScnAB:		;
      E3DE B9 73 00   000914 |	lda OpFld2,y	;
      E3E1 C9 2C      000915 |	cmp #','	;
      E3E3 F0 08      000916 |	beq CkXorY	;
      E3E5 C9 00      000917 |	cmp #0d		;
      E3E7 F0 2B      000918 |	beq IsABS	;
      E3E9 C8         000919 |	iny		;
      E3EA 4C DE E3   000920 |	jmp AMSScnAB	;
                      000921 |	
      E3ED            000922 |CkXorY:		;Check for absolute X or absolute Y addressing
      E3ED C8         000923 |	iny		; mode.
      E3EE B9 73 00   000924 |	lda OpFld2,y	;                                                                        
      E3F1 C9 58      000925 |	cmp #'X'	;
      E3F3 F0 0F      000926 |	beq IsABX	;
      E3F5 C9 78      000927 |	cmp #'x'	;
      E3F7 F0 0B      000928 |	beq IsABX	;
      E3F9 C9 59      000929 |	cmp #'Y'	;
      E3FB F0 0F      000930 |	beq IsABY	;
      E3FD C9 79      000931 |	cmp #'y'	;
      E3FF F0 0B      000932 |	beq IsABY	;
      E401 4C 74 E4   000933 |	jmp ErrAMS	;
                      000934 |	
      E404            000935 |IsABX:			;Save ABS, ABX or ABY mode in the variable to be
      E404 A9 58      000936 |	lda #'X'	; returned.
      E406 8D 1F 00   000937 |	sta AddMode	;
      E409 4C 76 E4   000938 |	jmp ExitAMS	;
      E40C            000939 |IsABY:			;
      E40C A9 59      000940 |	lda #'Y'	;
      E40E 8D 1F 00   000941 |	sta AddMode	;
      E411 4C 76 E4   000942 |	jmp ExitAMS	;
      E414            000943 |IsABS:			;
      E414 A9 53      000944 |	lda #'S'	;
      E416 8D 1F 00   000945 |	sta AddMode	;
      E419 4C 76 E4   000946 |	jmp ExitAMS	;
                      000947 |	
      E41C            000948 |AMSCkId?:		;Dispatch to code that checks for IIR, IRI or
      E41C C8         000949 |	iny		; IND addressing modes.
      E41D B9 73 00   000950 |	lda OpFld2,y	;
      E420 C9 2C      000951 |	cmp #','	;
      E422 F0 0B      000952 |	beq CkIIR	;
      E424 C9 29      000953 |	cmp #')'	;
      E426 F0 1E      000954 |	beq CkIRIIND	;
      E428 C0 0B      000955 |	cpy #11d	;
      E42A D0 F0      000956 |	bne AMSCkId?	;
      E42C 4C 74 E4   000957 |	jmp ErrAMS	;
                      000958 |
      E42F            000959 |CkIIR:			;Check for IIR addressing mode.
      E42F C8         000960 |	iny		;
      E430 B9 73 00   000961 |	lda OpFld2,y	;
      E433 C9 58      000962 |	cmp #'X'	;
      E435 F0 07      000963 |	beq IsIIR	;
      E437 C9 78      000964 |	cmp #'x'	;
      E439 F0 03      000965 |	beq IsIIR	;
      E43B 4C 74 E4   000966 |	jmp ErrAMS	;
                      000967 |	
      E43E            000968 |IsIIR:
      E43E A9 52      000969 |	lda #'R'	;Save IIR addressing mode code in variable to be
      E440 8D 1F 00   000970 |	sta AddMode	; returned.
      E443 4C 76 E4   000971 |	jmp ExitAMS	;
                      000972 |	
      E446            000973 |CkIRIIND:		;Check for IND addressing mode.
      E446 C8         000974 |	iny		;
      E447 B9 73 00   000975 |	lda OpFld2,y	;
      E44A C9 00      000976 |	cmp #0d		;
      E44C F0 16      000977 |	beq IsIND	;
      E44E C9 2C      000978 |	cmp #','	;
      E450 F0 03      000979 |	beq CkIRI	;
      E452 4C 74 E4   000980 |	jmp ErrAMS	;
                      000981 |	
      E455            000982 |CkIRI:			;Check for IRI addressing mode.
      E455 C8         000983 |	iny		;
      E456 B9 73 00   000984 |	lda OpFld2,y	;
      E459 C9 59      000985 |	cmp #'Y'	;
      E45B F0 0F      000986 |	beq IsIRI	;
      E45D C9 79      000987 |	cmp #'y'	;
      E45F F0 0B      000988 |	beq IsIRI	;
      E461 4C 74 E4   000989 |	jmp ErrAMS	;
                      000990 |	
      E464            000991 |IsIND:			;Save IND or IRI addressing mode code in variable
      E464 A9 44      000992 |	lda #'D'	; to be returned.
      E466 8D 1F 00   000993 |	sta AddMode	;
      E469 4C 76 E4   000994 |	jmp ExitAMS	;
      E46C            000995 |IsIRI:			;
      E46C A9 49      000996 |	lda #'I'	;
      E46E 8D 1F 00   000997 |	sta AddMode	;
      E471 4C 76 E4   000998 |	jmp ExitAMS	;
                      000999 |	
      E474            001000 |ErrAMS:
      E474 18         001001 |	clc
      E475 60         001002 |	rts
                      001003 |	
      E476            001004 |ExitAMS:
      E476 38         001005 |	sec
      E477 60         001006 |	rts
                      001007 |	
                      001008 |	
                      001009 |;****************************************************************************
                      001010 |;                   Address Mode Table Search Subroutine.
                      001011 |;****************************************************************************
      E478            001012 |AdMdTbSc:		
      E478 A0 06      001013 |	ldy #6d		;Check for address mode match between contents
      E47A B1 0A      001014 |	lda (PointerB),y; of variable AddMode & OpTable.
      E47C CD 1F 00   001015 |	cmp AddMode	;
      E47F F0 15      001016 |	beq ExitAdMd	;
                      001017 |	
      E481 AD 0A 00   001018 |	lda PointerB	;Pointer Pointer B to next operator in
      E484 18         001019 |	clc		; operator table.
      E485 69 0A      001020 |	adc #10d	;
      E487 8D 0A 00   001021 |	sta PointerB	;
      E48A 90 03      001022 |	bcc AdMdNoCy	;
      E48C EE 0B 00   001023 |	inc PointerB+1d	;
                      001024 |	
      E48F            001025 |AdMdNoCy:		;Check to see if next operator is the same type
      E48F 20 55 E3   001026 |	jsr OSCkANO	; that we are currently trying to assemble.
      E492 B0 E4      001027 |	bcs AdMdTbSc	;
                      001028 |	
      E494            001029 |ErrAdMd:
      E494 18         001030 |	clc
      E495 60         001031 |	rts
                      001032 |	
      E496            001033 |ExitAdMd:
      E496 38         001034 |	sec
      E497 60         001035 |	rts
                      001036 |
                      001037 |;****************************************************************************
                      001038 |;                       Operand Scan Subroutine.
                      001039 |;****************************************************************************
      E498            001040 |OpndScan:
                      001041 |
      E498 A9 00      001042 |	lda #0d		;Initialize the flags that indicate whether or
      E49A 8D 1D 00   001043 |	sta Obj2Flg	; not there are object bytes in addition to
      E49D 8D 1E 00   001044 |	sta Obj3Flg	; the opcode object byte.
                      001045 |	
      E4A0 A0 07      001046 |	ldy #7d		;Get the opcode of the instruction being 
      E4A2 B1 0A      001047 |	lda (PointerB),y; currently assembled from the opcode table
      E4A4 8D 1A 00   001048 |	sta Obj1	; and put it in Obj1.
                      001049 |	
      E4A7 AD 1F 00   001050 |	lda AddMode	;Check to see what address mode the instruction
      E4AA C9 50      001051 |	cmp #'P'	; currently being assembled is.
      E4AC F0 27      001052 |	beq OpndIMP	;
      E4AE C9 43      001053 |	cmp #'C'	;
      E4B0 F0 26      001054 |	beq OpndACC	;
      E4B2 C9 4D      001055 |	cmp #'M'	;
      E4B4 F0 25      001056 |	beq OpndIMM	;
      E4B6 C9 53      001057 |	cmp #'S'	;
      E4B8 F0 3C      001058 |	beq OpndAB??	;
      E4BA C9 58      001059 |	cmp #'X'	;
      E4BC F0 38      001060 |	beq OpndAB??	;
      E4BE C9 59      001061 |	cmp #'Y'	;
      E4C0 F0 34      001062 |	beq OpndAB??	;
      E4C2 C9 49      001063 |	cmp #'I'	;
      E4C4 F0 58      001064 |	beq OpndIN??	;
      E4C6 C9 52      001065 |	cmp #'R'	;
      E4C8 F0 54      001066 |	beq OpndIN??	;
      E4CA C9 44      001067 |	cmp #'D'	;
      E4CC F0 50      001068 |	beq OpndIN??	;
      E4CE C9 4C      001069 |	cmp #'L'	;
      E4D0 F0 24      001070 |	beq OpndAB??	;
      E4D2 4C B1 E5   001071 |	jmp ErrOpndS	;
                      001072 |
      E4D5            001073 |OpndIMP:		;Process implied addressing mode.
      E4D5 4C B3 E5   001074 |	jmp ExtOpndS	;
                      001075 |	
      E4D8            001076 |OpndACC:		;Process accumulator addressing mode.
      E4D8 4C B3 E5   001077 |	jmp ExtOpndS	;
                      001078 |	
      E4DB            001079 |OpndIMM:		;Process immediate addressing mode.
      E4DB 20 B5 E5   001080 |	jsr ScnForHex	;
      E4DE B0 03      001081 |	bcs OpnMHFnd	;
      E4E0 4C B1 E5   001082 |	jmp ErrOpndS	;
      E4E3            001083 |OpnMHFnd:		;
      E4E3 20 23 F3   001084 |	jsr AsToBin	;
      E4E6 B0 03      001085 |	bcs OpndCvOk	;
      E4E8 4C B1 E5   001086 |	jmp ErrOpndS	;
      E4EB            001087 |OpndCvOk:		;
      E4EB 8D 1B 00   001088 |	sta Obj2	;
      E4EE A9 01      001089 |	lda #1d		;
      E4F0 8D 1D 00   001090 |	sta Obj2Flg	;
      E4F3 4C B3 E5   001091 |	jmp ExtOpndS	;
                      001092 |
                      001093 |
      E4F6            001094 |OpndAB??:		;Process absolute, absolute X, absolute Y.
      E4F6 20 B5 E5   001095 |	jsr ScnForHex	; Check for relative addressing mode and send
      E4F9 B0 03      001096 |	bcs OpnAHFnd	; to appropriate code if found.
      E4FB 4C B1 E5   001097 |	jmp ErrOpndS	;
      E4FE            001098 |OpnAHFnd:		;
      E4FE 20 CA F2   001099 |	jsr GetAdd	;
      E501 B0 03      001100 |	bcs OpndAdOk	;
      E503 4C B1 E5   001101 |	jmp ErrOpndS	;
      E506            001102 |OpndAdOk:		;
      E506 AD 1F 00   001103 |	lda AddMode	;
      E509 C9 4C      001104 |	cmp #'L'	;
      E50B F0 48      001105 |	beq OpndDoBr	;
      E50D            001106 |DoAdd:			;
      E50D 8E 1B 00   001107 |	stx Obj2	;
      E510 8C 1C 00   001108 |	sty Obj3	;
      E513 A9 01      001109 |	lda #1d		;
      E515 8D 1D 00   001110 |	sta Obj2Flg	;
      E518 8D 1E 00   001111 |	sta Obj3Flg	;
      E51B 4C B3 E5   001112 |	jmp ExtOpndS	;
                      001113 |
      E51E            001114 |OpndIN??:		;Process indirect indexed, indexed indirect and
      E51E 20 B5 E5   001115 |	jsr ScnForHex	; indirect addressing modes.
      E521 B0 03      001116 |	bcs OpnINFnd	;
      E523 4C B1 E5   001117 |	jmp ErrOpndS	;
      E526            001118 |OpnINFnd:		;
      E526 20 CA F2   001119 |	jsr GetAdd	;
      E529 B0 03      001120 |	bcs OpINAdOk	;
      E52B 4C B1 E5   001121 |	jmp ErrOpndS	;
      E52E            001122 |OpINAdOk:		;
      E52E AD 1F 00   001123 |	lda AddMode	;
      E531 C9 44      001124 |	cmp #'D'	;
      E533 F0 0F      001125 |	beq DoIND	;
      E535 C0 00      001126 |	cpy #0d		;
      E537 D0 78      001127 |	bne ErrOpndS	;
      E539 8E 1B 00   001128 |	stx Obj2	;
      E53C A9 01      001129 |	lda #1d		;
      E53E 8D 1D 00   001130 |	sta Obj2Flg	;
      E541 4C B3 E5   001131 |	jmp ExtOpndS	;
      E544            001132 |DoIND:			;
      E544 8E 1B 00   001133 |	stx Obj2	;
      E547 8C 1C 00   001134 |	sty Obj3	;
      E54A A9 01      001135 |	lda #1d		;
      E54C 8D 1D 00   001136 |	sta Obj2Flg	;
      E54F 8D 1E 00   001137 |	sta Obj3Flg	;
      E552 4C B3 E5   001138 |	jmp ExtOpndS	;
                      001139 |	
      E555            001140 |OpndDoBr:		;Put address to be branched to in TempAdd and
      E555 8E 2B 00   001141 |	stx TempAdd	; the address of the first byte of the next
      E558 8C 2C 00   001142 |	sty TempAdd+1d	; instruction in TempAdd2.
      E55B AD 08 00   001143 |	lda PointerA	;
      E55E 8D 2D 00   001144 |	sta TempAdd2	;
      E561 AD 09 00   001145 |	lda PointerA+1d	;
      E564 8D 2E 00   001146 |	sta TempAdd2+1d	;
      E567 A0 08      001147 |	ldy #8d		;
      E569 B1 0A      001148 |	lda (PointerB),y;
      E56B 18         001149 |	clc		;
      E56C 6D 2D 00   001150 |	adc TempAdd2	;
      E56F 8D 2D 00   001151 |	sta TempAdd2	;
      E572 90 03      001152 |	bcc OpBrNoOv	;
      E574 EE 2E 00   001153 |	inc TempAdd2+1d	;
      E577            001154 |OpBrNoOv:
      E577 38         001155 |	sec		;Subtract the address of the first byte of the
      E578 AD 2B 00   001156 |	lda TempAdd	; next instruction from the address to be branched
      E57B ED 2D 00   001157 |	sbc TempAdd2	; to in order to get the branch offset.
      E57E 8D 2B 00   001158 |	sta TempAdd	;
      E581 AD 2C 00   001159 |	lda TempAdd+1d	;
      E584 ED 2E 00   001160 |	sbc TempAdd2+1d	;
      E587 8D 2C 00   001161 |	sta TempAdd+1d	;
                      001162 |	
      E58A AD 2C 00   001163 |	lda TempAdd+1d	;Check to make sure that MSB of the offset does
      E58D C9 FF      001164 |	cmp #0ffh	; not indicate a number greater than 127 or less
      E58F F0 0E      001165 |	beq OpCkNOff	; than 128.
      E591 C9 00      001166 |	cmp #0d		;
      E593 D0 1C      001167 |	bne ErrOpndS	;
                      001168 |	
      E595            001169 |OpCkPOff:		;Check to make sure that LSB of the offset does
      E595 AD 2B 00   001170 |	lda TempAdd	; not contain a number greater than 127 or less
      E598 C9 80      001171 |	cmp #128d	; than 128.
      E59A 10 15      001172 |	bpl ErrOpndS	;
      E59C 4C A6 E5   001173 |	jmp OffOk	;
      E59F            001174 |OpCkNOff:		;
      E59F AD 2B 00   001175 |	lda TempAdd	;
      E5A2 C9 80      001176 |	cmp #128d	;
      E5A4 30 0B      001177 |	bmi ErrOpndS	;
                      001178 |	
      E5A6            001179 |OffOk:			;If offset is OK then put it in Obj2 and return.
      E5A6 8D 1B 00   001180 |	sta Obj2	;
      E5A9 A9 01      001181 |	lda #1d		;
      E5AB 8D 1D 00   001182 |	sta Obj2Flg	;
      E5AE 4C B3 E5   001183 |	jmp ExtOpndS	;
                      001184 |	
      E5B1            001185 |ErrOpndS:
      E5B1 18         001186 |	clc
      E5B2 60         001187 |	rts
                      001188 |	
      E5B3            001189 |ExtOpndS:
      E5B3 38         001190 |	sec
      E5B4 60         001191 |	rts
                      001192 |
                      001193 |
                      001194 |;****************************************************************************
                      001195 |;                     Scan For Hex Digit Subroutine.
                      001196 |;****************************************************************************
      E5B5            001197 |ScnForHex:
      E5B5 A2 14      001198 |	ldx #20d		
                      001199 |	
      E5B7            001200 |SFHNxtDg:
      E5B7 A0 00      001201 |	ldy #0d		;Scan until either an upper case or a lower case
      E5B9 BD 5F 00   001202 |	lda OpFld1,x	; hex digit is encountered in the input buffer.
      E5BC            001203 |SFHCkDgt:		;
      E5BC D9 39 F4   001204 |	cmp DgtTblUC,y	;
      E5BF F0 17      001205 |	beq ExitSFH	;
      E5C1 D9 4A F4   001206 |	cmp DgtTblLC,y	;
      E5C4 F0 12      001207 |	beq ExitSFH	;
      E5C6 C8         001208 |	iny		;
      E5C7 C0 10      001209 |	cpy #16d	;
      E5C9 F0 03      001210 |	beq IncBfPtr	;
      E5CB 4C BC E5   001211 |	jmp SFHCkDgt	;
                      001212 |
      E5CE            001213 |IncBfPtr:		;Point to the next digit in the input buffer.
      E5CE E8         001214 |	inx		;
      E5CF E0 1F      001215 |	cpx #31d	;
      E5D1 F0 03      001216 |	beq ErrSFH	;
      E5D3 4C B7 E5   001217 |	jmp SFHNxtDg	;
                      001218 |
      E5D6            001219 |ErrSFH:
      E5D6 18         001220 |	clc
      E5D7 60         001221 |	rts
                      001222 |	
      E5D8            001223 |ExitSFH:
      E5D8 38         001224 |	sec
      E5D9 60         001225 |	rts
                      001226 |	
                      001227 |	
                      001228 |;****************************************************************************
                      001229 |;                       Breakpoint Command Subroutine.
                      001230 |;****************************************************************************
      E5DA            001231 |BreakPnt:
      E5DA AD 5F 00   001232 |	lda OpFld1	;Check for a +, - or a ? in operand field #1.
      E5DD C9 2B      001233 |	cmp #43d	;
      E5DF F0 0B      001234 |	beq DoPlus	;
      E5E1 C9 2D      001235 |	cmp #45d	;
      E5E3 F0 0A      001236 |	beq DoMinus	;
      E5E5 C9 3F      001237 |	cmp #63d	;
      E5E7 F0 09      001238 |	beq DmpBPAdd	;
      E5E9 4C FA E6   001239 |	jmp ExitBP	;
      E5EC            001240 |DoPlus:		;
      E5EC 4C 66 E6   001241 |	jmp Plus	;
      E5EF            001242 |DoMinus:		;
      E5EF 4C 22 E6   001243 |	jmp Minus	;
                      001244 |	
      E5F2            001245 |DmpBPAdd:
      E5F2 A2 AF      001246 |	ldx #CRLF<	;If question mark was entered then dump current
      E5F4 A0 F4      001247 |	ldy #CRLF>	; breakpoints.
      E5F6 20 99 F3   001248 |	jsr PrntMess	;
      E5F9 A0 FF      001249 |	ldy #0ffh	;
      E5FB A2 FF      001250 |	ldx #0ffh	;
      E5FD            001251 |OtAdAgin:		;
      E5FD C8         001252 |	iny		;
      E5FE E8         001253 |	inx		;
      E5FF B9 12 00   001254 |	lda BrkPt1Ad,y	;
      E602 8D 08 00   001255 |	sta PointerA	;
      E605 C8         001256 |	iny		;
      E606 B9 12 00   001257 |	lda BrkPt1Ad,y	;
      E609 8D 09 00   001258 |	sta PointerA+1d	;
      E60C BD 2F 00   001259 |	lda BrkPt1St,x	;
      E60F F0 03      001260 |	beq AdEmpty	;
      E611 20 0C F3   001261 |	jsr PrntAdd	;
      E614            001262 |AdEmpty:		;
      E614 C0 07      001263 |	cpy #7d		;
      E616 D0 E5      001264 |	bne OtAdAgin	;
      E618 A2 AF      001265 |	ldx #CRLF<	;
      E61A A0 F4      001266 |	ldy #CRLF>	;
      E61C 20 99 F3   001267 |	jsr PrntMess	;
      E61F 4C FA E6   001268 |	jmp ExitBP	;
                      001269 |	
      E622            001270 |Minus:
      E622 AD 73 00   001271 |	lda OpFld2	;If minus was found in operand field #1 check for
      E625 C9 00      001272 |	cmp #0d		; an address in operand field #2.  If no address
      E627 F0 0A      001273 |	beq ClrAllBP	; was found then clear all breakpoints, if an
      E629 A2 14      001274 |	ldx #20d	; address was found then clear that one breakpoint.
      E62B 20 CA F2   001275 |	jsr GetAdd	;
      E62E B0 10      001276 |	bcs Clr1BP	;
      E630 4C FA E6   001277 |	jmp ExitBP	;
                      001278 |	
      E633            001279 |ClrAllBP:
      E633 A0 03      001280 |	ldy #3d		;Clear all breakpoints.
      E635            001281 |ZeroBP:		;
      E635 A9 00      001282 |	lda #0d		;
      E637 99 2F 00   001283 |	sta BrkPt1St,y	;
      E63A 88         001284 |	dey		;
      E63B 10 F8      001285 |	bpl ZeroBP	;
      E63D 4C FA E6   001286 |	jmp ExitBP	;
                      001287 |	
      E640            001288 |Clr1BP:
      E640 8E 2B 00   001289 |	stx TempAdd	;Search for a match between a breakpoint address
      E643 8C 2C 00   001290 |	sty TempAdd+1d	; in the breakpoint address table and the address
      E646 A0 03      001291 |	ldy #3d		; that was entered.
      E648 A2 06      001292 |	ldx #6d		;
      E64A            001293 |CkBPAdd:		;
      E64A 20 FB E6   001294 |	jsr CmpBPAdd	;
      E64D B0 0F      001295 |	bcs FoundBP	;
      E64F 88         001296 |	dey		;
      E650 CA         001297 |	dex		;
      E651 CA         001298 |	dex		;
      E652 10 F6      001299 |	bpl CkBPAdd	;
                      001300 |	
      E654            001301 |BPNtFnd:		
      E654 A2 BC      001302 |	ldx #NoBPMess<	;If no match was found then print an error message
      E656 A0 F5      001303 |	ldy #NoBPMess>	; and exit.
      E658 20 99 F3   001304 |	jsr PrntMess	;
      E65B 4C FA E6   001305 |	jmp ExitBP	;
                      001306 |	
      E65E            001307 |FoundBP:
      E65E A9 00      001308 |	lda #0d		;If match was found then zero out that breakpoint's
      E660 99 2F 00   001309 |	sta BrkPt1St,y	; status indicator and exit.
      E663 4C FA E6   001310 |	jmp ExitBP	;
                      001311 |
      E666            001312 |Plus:
      E666 AD 73 00   001313 |	lda OpFld2	;If a plus was entered then check operand field
      E669 C9 00      001314 |	cmp #0d		; #2 for the address of the new breakpoint.
      E66B F0 07      001315 |	beq OutBP2	;
      E66D A2 14      001316 |	ldx #20d	;
      E66F 20 CA F2   001317 |	jsr GetAdd	;
      E672 B0 03      001318 |	bcs BPAdOk	;
      E674            001319 |OutBP2:		;
      E674 4C FA E6   001320 |	jmp ExitBP	;
                      001321 |
                      001322 |
      E677            001323 |BPAdOk:
      E677 8E 2B 00   001324 |	stx TempAdd	;
      E67A 8C 2C 00   001325 |	sty TempAdd+1d	;
      E67D A0 03      001326 |	ldy #3d		;Check to make sure that breakpoint address has
      E67F A2 06      001327 |	ldx #6d		; not already been entered into table.
      E681            001328 |CkBPAddP:		;
      E681 B9 2F 00   001329 |	lda BrkPt1St,y	;
      E684 C9 00      001330 |	cmp #0d		;
      E686 F0 05      001331 |	beq NoCmp	;
      E688 20 FB E6   001332 |	jsr CmpBPAdd	;
      E68B B0 E7      001333 |	bcs OutBP2	;
      E68D            001334 |NoCmp:			;
      E68D 88         001335 |	dey		;
      E68E CA         001336 |	dex		;
      E68F CA         001337 |	dex		;
      E690 10 EF      001338 |	bpl CkBPAddP	;
                      001339 |	
                      001340 |
      E692 A0 00      001341 |	ldy #0d		;If a plus was entered then search breakpoint
      E694            001342 |CkNxtBP:		;
      E694 B9 2F 00   001343 |	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
      E697 C9 00      001344 |	cmp #0d		;
      E699 F0 0F      001345 |	beq EmptyBP	;
      E69B C8         001346 |	iny		;
      E69C C0 04      001347 |	cpy #4d		;
      E69E D0 F4      001348 |	bne CkNxtBP	;
                      001349 |	
      E6A0            001350 |AllBPFull:
      E6A0 A2 94      001351 |	ldx #BPFulMes<	;If all breakpoints are full then print an error
      E6A2 A0 F5      001352 |	ldy #BPFulMes>	; message and exit.
      E6A4 20 99 F3   001353 |	jsr PrntMess	;
      E6A7 4C FA E6   001354 |	jmp ExitBP	;
                      001355 |	
      E6AA            001356 |EmptyBP:
      E6AA 8C 37 00   001357 |	sty BPNumHld	;
      E6AD A9 01      001358 |	lda #1d		;
      E6AF 99 2F 00   001359 |	sta BrkPt1St,y	;
                      001360 |	
                      001361 |	
      E6B2            001362 |NxtBPSlt0:
      E6B2 C0 00      001363 |	cpy #0d		;Store new address in first position of
      E6B4 D0 0F      001364 |	bne NxtBPSlt1	; breakpoint table.
      E6B6 AD 2B 00   001365 |	lda TempAdd	;
      E6B9 8D 12 00   001366 |	sta BrkPt1Ad	;
      E6BC AD 2C 00   001367 |	lda TempAdd+1d	;
      E6BF 8D 13 00   001368 |	sta BrkPt1Ad+1d	;
      E6C2 4C FA E6   001369 |	jmp ExitBP	;
                      001370 |	
      E6C5            001371 |NxtBPSlt1:		;
      E6C5 C0 01      001372 |	cpy #1d		;Store new address in second position of
      E6C7 D0 0F      001373 |	bne NxtBPSlt2	; breakpoint table.
      E6C9 AD 2B 00   001374 |	lda TempAdd	;
      E6CC 8D 14 00   001375 |	sta BrkPt2Ad	;
      E6CF AD 2C 00   001376 |	lda TempAdd+1d	;
      E6D2 8D 15 00   001377 |	sta BrkPt2Ad+1d	;
      E6D5 4C FA E6   001378 |	jmp ExitBP	;
                      001379 |	
      E6D8            001380 |NxtBPSlt2:		;
      E6D8 C0 02      001381 |	cpy #2d		;Store new address in third position of
      E6DA D0 0F      001382 |	bne NxtBPSlt3	; breakpoint table.
      E6DC AD 2B 00   001383 |	lda TempAdd	;
      E6DF 8D 16 00   001384 |	sta BrkPt3Ad	;
      E6E2 AD 2C 00   001385 |	lda TempAdd+1d	;
      E6E5 8D 17 00   001386 |	sta BrkPt3Ad+1d	;
      E6E8 4C FA E6   001387 |	jmp ExitBP	;
                      001388 |	
      E6EB            001389 |NxtBPSlt3:		;
      E6EB AD 2B 00   001390 |	lda TempAdd	;Store new address in forth position of
      E6EE 8D 18 00   001391 |	sta BrkPt4Ad	; breakpoint table.
      E6F1 AD 2C 00   001392 |	lda TempAdd+1d	;
      E6F4 8D 19 00   001393 |	sta BrkPt4Ad+1d	;
      E6F7 4C FA E6   001394 |	jmp ExitBP	;
                      001395 |
      E6FA            001396 |ExitBP:
      E6FA 60         001397 |	rts
                      001398 |
                      001399 |
                      001400 |;****************************************************************************
                      001401 |;                   Compare Breakpoint Address Subroutine.
                      001402 |;****************************************************************************
      E6FB            001403 |CmpBPAdd:
      E6FB C0 00      001404 |	cpy #0d		;Compare LSB of first breakpoint address.
      E6FD D0 0B      001405 |	bne CmpNxt1	;
      E6FF AD 2C 00   001406 |	lda TempAdd+1d	;
      E702 CD 13 00   001407 |	cmp BrkPt1Ad+1d	;
      E705 F0 2C      001408 |	beq CChkFLSB	;
      E707 4C 40 E7   001409 |	jmp NoMatch 	;
                      001410 |	
      E70A            001411 |CmpNxt1:		;
      E70A C0 01      001412 |	cpy #1d		;Compare MSB of second breakpoint address.
      E70C D0 0B      001413 |	bne CmpNxt2	;
      E70E AD 2C 00   001414 |	lda TempAdd+1d	;
      E711 CD 15 00   001415 |	cmp BrkPt2Ad+1d	;
      E714 F0 1D      001416 |	beq CChkFLSB	;
      E716 4C 40 E7   001417 |	jmp NoMatch 	;
                      001418 |	
      E719            001419 |CmpNxt2:		;
      E719 C0 02      001420 |	cpy #2d		;Compare MSB of third breakpoint address.
      E71B D0 0B      001421 |	bne CmpNxt3	;
      E71D AD 2C 00   001422 |	lda TempAdd+1d	;
      E720 CD 17 00   001423 |	cmp BrkPt3Ad+1d	;
      E723 F0 0E      001424 |	beq CChkFLSB	;
      E725 4C 40 E7   001425 |	jmp NoMatch 	;
                      001426 |	
      E728            001427 |CmpNxt3:		;
      E728 AD 2C 00   001428 |	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
      E72B CD 19 00   001429 |	cmp BrkPt4Ad+1d	;
      E72E F0 03      001430 |	beq CChkFLSB	;
      E730 4C 40 E7   001431 |	jmp NoMatch 	;
                      001432 |	
      E733            001433 |CChkFLSB:
      E733 AD 2B 00   001434 |	lda TempAdd	;Compare LSB of breakpoint address.
      E736 DD 12 00   001435 |	cmp BrkPt1Ad,x	;
      E739 F0 03      001436 |	beq BPMatch	;
      E73B 4C 40 E7   001437 |	jmp NoMatch	;
                      001438 |	
      E73E            001439 |BPMatch:		;Return with carry set if addresses match.
      E73E 38         001440 |	sec		;
      E73F 60         001441 |	rts		;
                      001442 |	
      E740            001443 |NoMatch:		;Return with carry cleared if addresses
      E740 18         001444 |	clc		; do not match.
      E741 60         001445 |	rts		;
                      001446 |
                      001447 |
                      001448 |;****************************************************************************
                      001449 |;                     Dump command Subroutine
                      001450 |;****************************************************************************
      E742            001451 |Dump:
                      001452 |	
      E742 A2 00      001453 |	ldx #0h
                      001454 |	
      E744 BD 5F 00   001455 |	lda OpFld1,x	;If no operands then do a standard dump.
      E747 C9 00      001456 |	cmp #0h		;
      E749 F0 3A      001457 |	beq DoStdDmp	;
                      001458 |
      E74B 20 23 F3   001459 |	jsr AsToBin	;Get start address from operand field #1 and place
      E74E B0 03      001460 |	bcs DgtOk1	; in zero page pointer.
      E750 4C 06 E8   001461 |	jmp ErrDump	;
      E753            001462 |DgtOk1:		;
      E753 8D 09 00   001463 |	sta PointerA+1d	;
      E756 E8         001464 |	inx		;
      E757 20 23 F3   001465 |	jsr AsToBin	;
      E75A B0 03      001466 |	bcs DgtOk2	;
      E75C 4C 06 E8   001467 |	jmp ErrDump	;
      E75F            001468 |DgtOk2:		;
      E75F 8D 08 00   001469 |	sta PointerA	;
                      001470 |	
      E762 A2 14      001471 |	ldx #20d	;If no end address was entered then perform a
      E764 BD 5F 00   001472 |	lda OpFld1,x	; standard dump.
      E767 C9 00      001473 |	cmp #0h		;
      E769 F0 1A      001474 |	beq DoStdDmp	;
                      001475 |	
      E76B 20 23 F3   001476 |	Jsr AsToBin	;Get end address from operand field #2 and place
      E76E B0 03      001477 |	bcs OpFldOk1	; in the variable EndAdd.
      E770 4C 06 E8   001478 |	jmp ErrDump	;
      E773            001479 |OpFldOk1:		;
      E773 8D 5D 00   001480 |	sta EndAdd+1d	;
      E776 E8         001481 |	inx 		;
      E777 20 23 F3   001482 |	jsr AsToBin	;
      E77A B0 03      001483 |	bcs OpFldOk2	;
      E77C 4C 06 E8   001484 |	jmp ErrDump	;
      E77F            001485 |OpFldOk2:		;
      E77F 8D 5C 00   001486 |	sta EndAdd	;
                      001487 |	
      E782 4C 9C E7   001488 |	jmp DoDump	
                      001489 |	
      E785            001490 |DoStdDmp:
      E785 AD 09 00   001491 |	lda PointerA+1d	;Adjust end address so that it will only dump the
      E788 8D 5D 00   001492 |	sta EndAdd+1d	; contents of 16 memory locations.
      E78B AD 08 00   001493 |	lda PointerA	;
      E78E 8D 5C 00   001494 |	sta EndAdd	;
      E791 18         001495 |	clc   		;Note: check to make sure this is correct.
      E792 69 0F      001496 |	adc #15d	;
      E794 8D 5C 00   001497 |	sta EndAdd	;
      E797 90 03      001498 |	bcc DoDump	;
      E799 EE 5D 00   001499 |	inc EndAdd+1d	;
                      001500 |	
      E79C            001501 |DoDump:
      E79C A9 0D      001502 |	lda #13d	;Output a CRLF.
      E79E 20 FA F3   001503 |	jsr OutChar	;
      E7A1 A9 0A      001504 |	lda #10d	;
      E7A3 20 FA F3   001505 |	jsr OutChar	;
                      001506 |
      E7A6 A2 00      001507 |	ldx #0d		;
      E7A8 A0 00      001508 |	ldy #0d		;
                      001509 |
      E7AA 20 0C F3   001510 |	jsr PrntAdd	;Output address of first dump memory location.
                      001511 |	
      E7AD            001512 |DumpAgin:
      E7AD B1 08      001513 |	lda (PointerA),y;Get byte from memory location.
                      001514 |
      E7AF 20 2A E8   001515 |	jsr PutASCBf	;Put character in ASCII buffer.
                      001516 |	
      E7B2 20 45 F3   001517 |	jsr OutHex	;Convert to ASCII/Hex and print.
                      001518 |	
      E7B5 E8         001519 |	inx
      E7B6 E0 10      001520 |	cpx #16d	;
      E7B8 D0 03      001521 |	bne Chk8	;
      E7BA 20 12 E8   001522 |	jsr DumpASC	;Output ASCII interpretion of dumped line.
                      001523 |	
      E7BD            001524 |Chk8:			;
      E7BD E0 08      001525 |	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
      E7BF D0 12      001526 |	bne OutSpc	; the dump screen.
      E7C1 A9 20      001527 |	lda #32d	;
      E7C3 20 FA F3   001528 |	jsr OutChar	;
      E7C6 A9 2D      001529 |	lda #45d	;
      E7C8 20 FA F3   001530 |	jsr OutChar	;
      E7CB A9 20      001531 |	lda #32d	;
      E7CD 20 FA F3   001532 |	jsr OutChar	;
      E7D0 4C D8 E7   001533 |	jmp ChkEndAd	;
                      001534 |	
      E7D3            001535 |OutSpc:
      E7D3 A9 20      001536 |	lda #32d	;Print a space between hex characters on dump screen.
      E7D5 20 FA F3   001537 |	jsr OutChar	;
                      001538 |	
      E7D8            001539 |ChkEndAd:
      E7D8 AD 08 00   001540 |	lda PointerA	;Check pointer against end address holder.  Exit
      E7DB CD 5C 00   001541 |	cmp EndAdd	; subroutine if the end address has been reached,
      E7DE D0 08      001542 |	bne PointNxt	; increment pointer and dump the contents of 
      E7E0 AD 09 00   001543 |	lda PointerA+1d	; another memory location if not.
      E7E3 CD 5D 00   001544 |	cmp EndAdd+1d	;
      E7E6 F0 20      001545 |	beq ExitDump	;
      E7E8            001546 |PointNxt:
      E7E8 EE 08 00   001547 |	inc PointerA	;
      E7EB D0 03      001548 |	bne NoCary2	;
      E7ED EE 09 00   001549 |	inc PointerA+1d	;
      E7F0            001550 |NoCary2:		;
                      001551 |
      E7F0            001552 |ChkCR:			;Perform end of dump line functions.
      E7F0 E0 10      001553 |	cpx #16d	;
      E7F2 D0 0F      001554 |	bne NotEnd	;
                      001555 |	
      E7F4 A9 0A      001556 |	lda #10d	;Print a CRLF and reset X register to point to
      E7F6 20 FA F3   001557 |	jsr OutChar	; beginning of new dump line.
      E7F9 A9 0D      001558 |	lda #13d	;
      E7FB 20 FA F3   001559 |	jsr Outchar	;
      E7FE 20 0C F3   001560 |	jsr PrntAdd	;
      E801 A2 00      001561 |	ldx #0d		;
      E803            001562 |NotEnd:
                      001563 |	
      E803 4C AD E7   001564 |	jmp DumpAgin	;
                      001565 |
      E806            001566 |ErrDump:
      E806 18         001567 |	clc
      E807 60         001568 |	rts
                      001569 |
      E808            001570 |ExitDump:
      E808 EE 08 00   001571 |	inc PointerA	;Point to next location in memory to be dumped
      E80B D0 03      001572 |	bne NoCary3	;
      E80D EE 09 00   001573 |	inc PointerA+1d	;
      E810            001574 |NoCary3:		;
      E810 38         001575 |	sec
      E811 60         001576 |	rts
                      001577 |
                      001578 |;****************************************************************************
                      001579 |;                 Output the ASCII interpretation of the dumped line.
                      001580 |;****************************************************************************
      E812            001581 |DumpASC:
      E812 A9 20      001582 |	lda #32d	;
      E814 20 FA F3   001583 |	jsr OutChar	;
      E817 A9 20      001584 |	lda #32d	;
      E819 20 FA F3   001585 |	jsr OutChar	;
      E81C A2 00      001586 |	ldx #0d		;
      E81E            001587 |OutAsc:
      E81E BD 4C 00   001588 |	lda ASCIIbuf,x	;
      E821 20 FA F3   001589 |	jsr OutChar	;
      E824 E8         001590 |	inx		;
      E825 E0 10      001591 |	cpx #16d	;
      E827 D0 F5      001592 |	bne OutAsc	;
      E829 60         001593 |	rts
                      001594 |
                      001595 |
                      001596 |;****************************************************************************
                      001597 |;         Put byte from memory into ASCII buffer from Dump command.
                      001598 |;****************************************************************************
      E82A            001599 |PutASCBf:
      E82A 48         001600 |	pha
      E82B C9 20      001601 |	cmp #32d
      E82D 30 0A      001602 |	bmi Period
      E82F C9 7F      001603 |	cmp #127d
      E831 10 06      001604 |	bpl Period
      E833 9D 4C 00   001605 |	sta ASCIIbuf,x
      E836 4C 3E E8   001606 |	jmp ExitPut
      E839            001607 |Period:
      E839 A9 2E      001608 |	lda #46d
      E83B 9D 4C 00   001609 |	sta ASCIIbuf,x
      E83E            001610 |ExitPut:
      E83E 68         001611 |	pla
      E83F 60         001612 |	rts
                      001613 |	
                      001614 |;****************************************************************************
                      001615 |;                        Enter Command Subroutine.
                      001616 |;****************************************************************************
      E840            001617 |Enter:
      E840 AD 5F 00   001618 |	lda OpFld1	;Check for operand in operand field #1.
      E843 C9 00      001619 |	cmp #0d		;
      E845 D0 03      001620 |	bne ChkOp2	;
      E847 4C 6E E8   001621 |	jmp ErrEntr	;
                      001622 |	
      E84A            001623 |ChkOp2:
      E84A AD 73 00   001624 |	lda OpFld2	;Check for operand in operand field #2.
      E84D C9 00      001625 |	cmp #0d		;
      E84F D0 03      001626 |	bne ProcEntr	;
      E851 4C 6E E8   001627 |	jmp ErrEntr	;
                      001628 |	
      E854            001629 |ProcEntr:
      E854 A2 00      001630 |	ldx #0d		;Get address from operand field #1.
      E856 20 CA F2   001631 |	jsr GetAdd	;
      E859 B0 03      001632 |	bcs EnAddOk	;
      E85B 4C 6E E8   001633 |	jmp ErrEntr	;
                      001634 |
      E85E            001635 |EnAddOk:
      E85E 8E 08 00   001636 |	stx PointerA	;Put address from operand field #1 into
      E861 8C 09 00   001637 |	sty PointerA+1d	; zero page variable Pointer.
                      001638 |	
      E864 A2 14      001639 |	ldx #20d	;Get list of bytes to be entered into memory
      E866 20 72 E8   001640 |	jsr GetList	; from operand field #2 and put them in memory
      E869 90 03      001641 |	bcc ErrEntr	; starting at Pointer.
      E86B 4C 70 E8   001642 |	jmp ExitEntr	;
                      001643 |	
      E86E            001644 |ErrEntr:
      E86E 18         001645 |	clc
      E86F 60         001646 |	rts	
                      001647 |
      E870            001648 |ExitEntr:
      E870 38         001649 |	sec
      E871 60         001650 |	rts
                      001651 |
                      001652 |
                      001653 |;****************************************************************************
                      001654 |;                        Get List Subroutine
                      001655 |;
                      001656 |;	Zero page variable Pointer points to location in memory where
                      001657 |;	 list members will be placed.
                      001658 |;****************************************************************************
      E872            001659 |GetList:
      E872 A0 00      001660 |	ldy #0d
                      001661 |	
      E874 8C CF 00   001662 |	sty DataTemp	;Use this variable to count bytes in list.	
                      001663 |	
      E877            001664 |GLNxtByt:
      E877 BD 5F 00   001665 |	lda OpFld1,x	;Check for NULL that terminates current
      E87A F0 28      001666 |	beq ListErr	; operand field.
                      001667 |	
      E87C 20 23 F3   001668 |	jsr AsToBin	;Convert byte in list to binary form and place
      E87F B0 03      001669 |	bcs StInMem	; in memory.
      E881 4C A4 E8   001670 |	jmp ListErr	;
      E884            001671 |StInMem:		;
      E884 91 08      001672 |	sta (PointerA),y;
      E886 EE 08 00   001673 |	inc PointerA	;
      E889 D0 03      001674 |	bne LstNoOv	;
      E88B EE 09 00   001675 |	inc PointerA+1d	;
      E88E            001676 |LstNoOv:		;
      E88E EE CF 00   001677 |	inc DataTemp	;
      E891 AD CF 00   001678 |	lda DataTemp	;
      E894 C9 0A      001679 |	cmp #10d	;
      E896 F0 0A      001680 |	beq ExtGtLst	;
                      001681 |	
      E898 E8         001682 |	inx		;Point to comma between bytes.
                      001683 |
      E899 BD 5F 00   001684 |	lda OpFld1,x	;Check for NULL that terminates current
      E89C F0 04      001685 |	beq ExtGtLst	; operand field.
                      001686 |	
      E89E E8         001687 |	inx		;Point to next byte in list.
                      001688 |	
      E89F 4C 77 E8   001689 |	jmp GLNxtByt	;
                      001690 |	
      E8A2            001691 |ExtGtLst:
      E8A2 38         001692 |	sec
      E8A3 60         001693 |	rts
                      001694 |
      E8A4            001695 |ListErr:
      E8A4 18         001696 |	clc
      E8A5 60         001697 |	rts
                      001698 |
                      001699 |;****************************************************************************
                      001700 |;                        Fill Command Subroutine.
                      001701 |;****************************************************************************
      E8A6            001702 |Fill:
                      001703 |
      E8A6 A2 00      001704 |	ldx #0d		;Get start address.
      E8A8 20 CA F2   001705 |	jsr GetAdd	;
      E8AB B0 03      001706 |	bcs FAdd1ok	;
      E8AD 4C E3 E8   001707 |	jmp ErrFill	;
      E8B0            001708 |FAdd1ok:		;
      E8B0 8E 08 00   001709 |	stx PointerA	;
      E8B3 8C 09 00   001710 |	sty PointerA+1d	;
                      001711 |	
      E8B6 A2 14      001712 |	ldx #20d	;Get end address.
      E8B8 20 CA F2   001713 |	jsr GetAdd	;
      E8BB B0 03      001714 |	bcs FAdd2ok	;
      E8BD 4C E3 E8   001715 |	jmp ErrFill	;
      E8C0            001716 |FAdd2ok:		;
      E8C0 8E 5C 00   001717 |	stx EndAdd	;
      E8C3 8C 5D 00   001718 |	sty EndAdd+1d	;
                      001719 |	
      E8C6            001720 |FillAgin:
      E8C6 A2 28      001721 |	ldx #40d	;Get list and place in memory.
      E8C8 20 72 E8   001722 |	jsr GetList	;
      E8CB 90 16      001723 |	bcc ErrFill	;
                      001724 |
      E8CD AD 5D 00   001725 |	lda EndAdd+1d	;Check to see if end address has been reached.
      E8D0 CD 09 00   001726 |	cmp PointerA+1d	;
      E8D3 F0 03      001727 |	beq ChkFLSB	;
                      001728 |;	bmi ExitFill 	;
      E8D5 4C C6 E8   001729 |	jmp FillAgin 	;
      E8D8            001730 |ChkFLSB:
      E8D8 AD 5C 00   001731 |	lda EndAdd	; 
      E8DB CD 08 00   001732 |	cmp PointerA	;
      E8DE F0 05      001733 |	beq ExitFill	;
                      001734 |	
      E8E0 4C C6 E8   001735 |	jmp  FillAgin	;
                      001736 |	
                      001737 |
      E8E3            001738 |ErrFill:
      E8E3 18         001739 |	clc
      E8E4 60         001740 |	rts
                      001741 |
      E8E5            001742 |ExitFill:
      E8E5 38         001743 |	sec
      E8E6 60         001744 |	rts
                      001745 |
                      001746 |;****************************************************************************
                      001747 |;                        Go Command Subroutine
                      001748 |;****************************************************************************
      E8E7            001749 |Go:
                      001750 |
      E8E7 AD 5F 00   001751 |	lda OpFld1	;Check for operand.
      E8EA C9 00      001752 |	cmp #0d		;
      E8EC F0 10      001753 |	beq CurentPC	;
                      001754 |			
      E8EE A2 00      001755 |	ldx #0d		;Get address from operand field #1.
      E8F0 20 CA F2   001756 |	jsr GetAdd	;
      E8F3 B0 03      001757 |	bcs GAddOk	;
      E8F5 4C 64 E9   001758 |	jmp ErrGo	;
                      001759 |	
      E8F8            001760 |GAddOk:		;
      E8F8 8E 45 00   001761 |	stx UPgmCntr	;
      E8FB 8C 46 00   001762 |	sty UPgmCntr+1d	;
                      001763 |
      E8FE            001764 |CurentPC:
      E8FE AE 45 00   001765 |	ldx UPgmCntr	;
      E901 8E 2B 00   001766 |	stx TempAdd	;
      E904 AC 46 00   001767 |	ldy UPgmCntr+1d	;
      E907 8C 2C 00   001768 |	sty TempAdd+1d	;
      E90A A0 03      001769 |	ldy #3d		;Check to make sure that breakpoint address has
      E90C A2 06      001770 |	ldx #6d		; not already been entered into table.
      E90E            001771 |CkBPAddG:		;
      E90E B9 2F 00   001772 |	lda BrkPt1St,y	;
      E911 C9 00      001773 |	cmp #0d		;
      E913 F0 05      001774 |	beq NoCmpG	;
      E915 20 FB E6   001775 |	jsr CmpBPAdd	;
      E918 B0 08      001776 |	bcs MaError	;
      E91A            001777 |NoCmpG:		;
      E91A 88         001778 |	dey		;
      E91B CA         001779 |	dex		;
      E91C CA         001780 |	dex		;
      E91D 10 EF      001781 |	bpl CkBPAddG	;
      E91F 4C 2C E9   001782 |	jmp NoMatchG	;
                      001783 |
      E922            001784 |MaError:
      E922 A2 E4      001785 |	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
      E924 A0 F5      001786 |	ldy #GoBPErrM>	; error message and exit.
      E926 20 99 F3   001787 |	jsr PrntMess	;
      E929 4C 66 E9   001788 |	jmp ExitGo	;
                      001789 |
      E92C            001790 |NoMatchG:
      E92C A0 03      001791 |	ldy #3d		;Check all active breakpoints in table, save
      E92E A2 06      001792 |	ldx #6d		; the opcodes of the breakpointed addresses, 
      E930            001793 |CkBPSt:		;
      E930 B9 2F 00   001794 |	lda BrkPt1St,y	; and replace them with BRKs.
      E933 C9 01      001795 |	cmp #1d		;
      E935 D0 09      001796 |	bne NxtBPSt	;
      E937 A1 12      001797 |	lda (BrkPt1Ad,x);
      E939 99 33 00   001798 |	sta BP1OpHld,y	;
      E93C A9 00      001799 |	lda #0d		;
      E93E 81 12      001800 |	sta (BrkPt1Ad,x);
      E940            001801 |NxtBPSt:		;
      E940 88         001802 |	dey		;
      E941 CA         001803 |	dex		;
      E942 CA         001804 |	dex		;
      E943 10 EB      001805 |	bpl CkBPSt	;
                      001806 |
      E945 68         001807 |	pla		;Remove Go command's return address and the check
      E946 68         001808 |	pla		; command's return address from the stack.
      E947 68         001809 |	pla		;
      E948 68         001810 |	pla		;
                      001811 |    
      E949 AD 5F 00   001812 |    lda OpFld1	;Check for operand.
      E94C C9 00      001813 |	cmp #0d		;
      E94E F0 11      001814 |	beq DoNotRestoreRegistersGo
                      001815 | 
      E950 A2 FF      001816 |    ldx #0ffh    ;Restore user's registers.
      E952 9A         001817 |    txs          ;
      E953 AD 4B 00   001818 |    lda UStatReg ;
      E956 48         001819 |	pha          ;
      E957 AD 47 00   001820 |	lda UAccum	 ;
      E95A AE 48 00   001821 |	ldx UXReg	 ;
      E95D AC 49 00   001822 |	ldy UYReg	 ;
      E960 28         001823 |    plp          ;
                      001824 |   
      E961            001825 |DoNotRestoreRegistersGo:
                      001826 |	
      E961 6C 45 00   001827 |	jmp (UPgmCntr)	;Start executing at address being pointed to by
                      001828 |			; UPGmCntr.	
                      001829 |
      E964            001830 |ErrGo:
      E964 18         001831 |	clc
      E965 60         001832 |	rts
                      001833 |	
      E966            001834 |ExitGo:
      E966 38         001835 |	sec
      E967 60         001836 |	rts
                      001837 |
                      001838 |;****************************************************************************
                      001839 |;                       Help Command Subroutine.
                      001840 |;****************************************************************************
      E968            001841 |Help:
      E968 A2 2A      001842 |	ldx #HelpMess<
      E96A A0 F6      001843 |	ldy #HelpMess>
      E96C 20 99 F3   001844 |	jsr PrntMess
      E96F 60         001845 |	rts
                      001846 |
                      001847 |;****************************************************************************
                      001848 |;                     Load Command Subroutine
                      001849 |;****************************************************************************
      E970            001850 |LdSRecs:
      E970 A2 B2      001851 |	ldx #SRecStMs<
      E972 A0 F4      001852 |	ldy #SRecStMs>	
      E974 20 99 F3   001853 |	jsr PrntMess
                      001854 |	
      E977 20 D9 F3   001855 |	jsr GetCharW	;Wait for first character of record.
      E97A A2 AF      001856 |	ldx #CRLF<	;
      E97C A0 F4      001857 |	ldy #CRLF>	;
      E97E 20 99 F3   001858 |	jsr PrntMess	;
      E981 4C 87 E9   001859 |	jmp CkS		;
                      001860 |	
      E984            001861 |GtAnCh:		;
      E984 20 D9 F3   001862 |	jsr GetCharW	;Check for an S.
      E987            001863 |CkS:			;
      E987 C9 53      001864 |	cmp #83d	;
      E989 D0 F9      001865 |	bne GtAnCh	;
                      001866 |	
      E98B 20 FA F3   001867 |	jsr OutChar	;Print an S to the user.
                      001868 |	
      E98E 20 D9 F3   001869 |	jsr GetCharW	;Get record type ECHO it and store it.
      E991 20 FA F3   001870 |	jsr OutChar	;
      E994 8D A1 00   001871 |	sta RecType	;
                      001872 |	
      E997 C9 30      001873 |	cmp #48d	;Check for header record and process.
      E999 D0 08      001874 |	bne NtHdr	;
      E99B 20 9C EA   001875 |	jsr ProcHdr	;
      E99E 90 25      001876 |	bcc SError	;
      E9A0 4C C2 E9   001877 |	jmp NextLine	;
                      001878 |	
      E9A3            001879 |NtHdr:			;
      E9A3 C9 31      001880 |	cmp #49d	;Check for code record and process.
      E9A5 D0 08      001881 |	bne NtCd	;
      E9A7 20 A6 EA   001882 |	jsr ProcCode	;
      E9AA 90 19      001883 |	bcc SError	;
      E9AC 4C C2 E9   001884 |	jmp NextLine	;
                      001885 |	
      E9AF            001886 |NtCd:			;
      E9AF C9 39      001887 |	cmp #57d	;Check for termination record process, and print
      E9B1 D0 12      001888 |	bne SError	; records loaded message.
      E9B3 20 B0 EA   001889 |	jsr ProcTerm	;
      E9B6 90 0D      001890 |	bcc SError	;
      E9B8 A2 FB      001891 |	ldx #SRecEnMs<	;
      E9BA A0 F4      001892 |	ldy #SRecEnMs>	;
      E9BC 20 99 F3   001893 |	jsr PrntMess	;
      E9BF 4C CE E9   001894 |	jmp ExitSRec	;
                      001895 |	
      E9C2            001896 |NextLine:
      E9C2 4C 84 E9   001897 |	jmp GtAnCh
                      001898 |
      E9C5            001899 |SError:
      E9C5 A2 DB      001900 |	ldx #SRecErMe<
      E9C7 A0 F4      001901 |	ldy #SRecErMe>	
      E9C9 20 99 F3   001902 |	jsr PrntMess
      E9CC 38         001903 |	sec
      E9CD 60         001904 |	rts
                      001905 |	
      E9CE            001906 |ExitSRec:
      E9CE 20 D9 F3   001907 |	jsr GetCharW
      E9D1 38         001908 |	sec
      E9D2 60         001909 |	rts
                      001910 |	
                      001911 |;****************************************************************************
                      001912 |;                Process Record Length and Address Subroutine
                      001913 |;****************************************************************************
      E9D3            001914 |PrRLeAdd:	
                      001915 |	
      E9D3 A9 00      001916 |	lda #0h		;Zero out Checksum accumulator.
      E9D5 8D 9F 00   001917 |	sta CkSumAc	;
      E9D8 8D A0 00   001918 |	sta CkSumAc+1h	;
                      001919 |	
      E9DB 20 43 EA   001920 |	jsr Getnum	;Fetch record length and update checksum
      E9DE 8D 9E 00   001921 |	sta RecLen	; accumulator.
      E9E1 20 6A EA   001922 |	jsr AccCkSum	;
                      001923 |	
      E9E4 AA         001924 |	tax		;Adjust code byte counter and store it.
      E9E5 CA         001925 |	dex		;
      E9E6 CA         001926 |	dex		;
      E9E7 CA         001927 |	dex		;
      E9E8 8A         001928 |	txa		;
      E9E9 8D 9B 00   001929 |	sta CodeCntr	;
                      001930 |	
      E9EC 20 43 EA   001931 |	jsr GetNum	;Get most significant byte of address and
      E9EF 8D 09 00   001932 |	sta PointerA+1h	; store it.
      E9F2 20 6A EA   001933 |	jsr AccCkSum	;
                      001934 |	
      E9F5 20 43 EA   001935 |	jsr GetNum	;Get least significant byte of address and
      E9F8 8D 08 00   001936 |	sta PointerA	; store it.
      E9FB 20 6A EA   001937 |	jsr AccCkSum	;
                      001938 |	
      E9FE 60         001939 |	rts
                      001940 |	
                      001941 |;****************************************************************************
                      001942 |;        Get Code Byte Without Loading into Memory Subroutine.
                      001943 |;****************************************************************************
      E9FF            001944 |GtCodNld:
                      001945 |	
      E9FF AD 9B 00   001946 |	lda CodeCntr
      EA02 F0 0B      001947 |	beq ExitNld
                      001948 |	
      EA04            001949 |GetOneNl:
      EA04 20 43 EA   001950 |	jsr GetNum
      EA07 20 6A EA   001951 |	jsr AccCkSum
      EA0A CE 9B 00   001952 |	dec CodeCntr
      EA0D D0 F5      001953 |	Bne GetOneNl
                      001954 |	
      EA0F            001955 |ExitNld:
      EA0F 60         001956 |	rts
                      001957 |
                      001958 |;****************************************************************************
                      001959 |;        Get Code Byte and Load it into Memory Subroutine.
                      001960 |;****************************************************************************
      EA10            001961 |GtCodLd:
                      001962 |
      EA10 AD 9B 00   001963 |	lda CodeCntr
      EA13 F0 17      001964 |	beq ExitLd
                      001965 |	
      EA15 A0 00      001966 |	ldy #0h
      EA17            001967 |GtOneLd:
      EA17 20 43 EA   001968 |	jsr GetNum
      EA1A 20 6A EA   001969 |	jsr AccCkSum
      EA1D 91 08      001970 |	sta (PointerA),y	
      EA1F EE 08 00   001971 |	inc PointerA
      EA22 D0 03      001972 |	bne NxtCode
      EA24 EE 09 00   001973 |	inc PointerA+1h
      EA27            001974 |NxtCode:
      EA27 CE 9B 00   001975 |	dec CodeCntr
      EA2A D0 EB      001976 |	bne GtOneld
                      001977 |	
      EA2C            001978 |ExitLd:
      EA2C 60         001979 |	rts
                      001980 |
                      001981 |;****************************************************************************
                      001982 |;                      Check Checksum Subroutine.
                      001983 |;****************************************************************************
      EA2D            001984 |ChkChkSm:
                      001985 |
      EA2D AD 9F 00   001986 |	lda CkSumAc	;Invert lowest byte of the checksum accumulator
      EA30 49 FF      001987 |	eor #0ffh	; and store it in CkhSum.
      EA32 8D 9D 00   001988 |	sta ChkSum	;
                      001989 |	
      EA35 20 43 EA   001990 |	jsr GetNum	;Compare calculated checksum against S record	
      EA38 CD 9D 00   001991 |	cmp ChkSum	; checksum.
      EA3B F0 04      001992 |	beq CkSumOK	;
      EA3D 18         001993 |	clc
      EA3E 4C 42 EA   001994 |	jmp Chkexit
      EA41            001995 |CkSumOK:
      EA41 38         001996 |	sec
      EA42            001997 |Chkexit:
      EA42 60         001998 |	rts
                      001999 |
                      002000 |;****************************************************************************
                      002001 |;                       Get Number Subroutine.
                      002002 |;****************************************************************************
      EA43            002003 |GetNum:
      EA43 98         002004 |	tya
      EA44 48         002005 |	pha
                      002006 |
      EA45 20 D9 F3   002007 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA48 20 79 EA   002008 |	jsr DgtToBin	; and position hex digit in most significat nibble
      EA4B 90 1C      002009 |	bcc ExtGtNum	;
      EA4D 0A         002010 |	asl a		; of number.
      EA4E 0A         002011 |	asl a		;
      EA4F 0A         002012 |	asl a		;
      EA50 0A         002013 |	asl a		;
      EA51 29 F0      002014 |	and #0f0h	;
      EA53 8D 9C 00   002015 |	sta number	;
                      002016 |	
      EA56 20 D9 F3   002017 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA59 20 79 EA   002018 |	jsr DgtToBin	; and position hex digit in least significant
      EA5C 90 0B      002019 |	bcc ExtGtNum	;
      EA5E 0D 9C 00   002020 |	ora number	; nibble of number.
      EA61 8D 9C 00   002021 |	sta number	;
                      002022 |	
      EA64 68         002023 |	pla
      EA65 A8         002024 |	tay
      EA66 AD 9C 00   002025 |	lda number
      EA69            002026 |ExtGtNum:
      EA69 60         002027 |	rts
                      002028 |
                      002029 |;****************************************************************************
                      002030 |;                    Accumulate Checksum Subroutine.
                      002031 |;****************************************************************************
      EA6A            002032 |AccCkSum:
      EA6A 48         002033 |	pha
      EA6B 18         002034 |	clc
      EA6C 6D 9F 00   002035 |	adc CkSumAc
      EA6F 8D 9F 00   002036 |	sta CkSumAc
      EA72 90 03      002037 |	bcc NoOvrFlo
      EA74 EE A0 00   002038 |	inc CkSumAc+1h
      EA77            002039 |NoOvrFlo:
      EA77 68         002040 |	pla
      EA78 60         002041 |	rts
                      002042 |
                      002043 |;****************************************************************************
                      002044 |;                ASCII Digit to Binary Number Subroutine.
                      002045 |;
                      002046 |;        Enter with register 'A' containing the number to convert.
                      002047 |;        If the number was valid return its binary conversion in the
                      002048 |;        A register.  If the number is not convertable then clear the
                      002049 |;        carry flag and return.
                      002050 |;****************************************************************************
      EA79            002051 |DgtToBin:
                      002052 |	
      EA79 8E CE 00   002053 |	stx RegTemp	;Save the character to convert.
                      002054 |	
      EA7C A2 00      002055 |	ldx #0h		
                      002056 |	
      EA7E            002057 |AnothDgt:
      EA7E DD 39 F4   002058 |	cmp DgtTblUC,x	;Search through character table and try to find
      EA81 F0 13      002059 |	beq Match	; a match for the character present in the X
      EA83 DD 4A F4   002060 |	cmp DgtTblLC,x	; register.
      EA86 F0 0E      002061 |	beq Match	;
                      002062 |	
      EA88 E8         002063 |	inx		;If a match was not found then increment the
      EA89 E0 10      002064 |	cpx #16d	; table index register and check the next
      EA8B F0 03      002065 |	beq DgtError	; character.  If all the characters have been 
      EA8D 4C 7E EA   002066 |	jmp AnothDgt	; checked then return with an error.
                      002067 |	
      EA90            002068 |DgtError:
      EA90 A9 00      002069 |	lda #0h
      EA92 18         002070 |	clc
      EA93 4C 9B EA   002071 |	jmp DgtExit
                      002072 |
      EA96            002073 |Match:
      EA96 8A         002074 |	txa
      EA97 38         002075 |	sec
                      002076 |	
      EA98 AE CE 00   002077 |	ldx RegTemp
      EA9B 60         002078 |DgtExit:	rts
                      002079 |	
                      002080 |;****************************************************************************
                      002081 |;                    Process Header Record Subroutine.
                      002082 |;****************************************************************************
                      002083 |
      EA9C            002084 |ProcHdr:
                      002085 |
      EA9C 20 D3 E9   002086 |	jsr PrRLeAdd
      EA9F 20 FF E9   002087 |	jsr GtCodNld		
      EAA2 20 2D EA   002088 |	jsr ChkChkSm
                      002089 |	
      EAA5 60         002090 |	rts
                      002091 |
                      002092 |;****************************************************************************
                      002093 |;                     Process Code Record Subroutine
                      002094 |;****************************************************************************
      EAA6            002095 |ProcCode:
                      002096 |
      EAA6 20 D3 E9   002097 |	jsr PrRLeAdd
      EAA9 20 10 EA   002098 |	jsr GtCodLd
      EAAC 20 2D EA   002099 |	jsr ChkChksm
                      002100 |	
      EAAF 60         002101 |	rts
                      002102 |
                      002103 |;****************************************************************************
                      002104 |;                     Process Termination Record Subroutine
                      002105 |;****************************************************************************
      EAB0            002106 |ProcTerm:
                      002107 |
      EAB0 20 D3 E9   002108 |	jsr PrRLeAdd
      EAB3 20 FF E9   002109 |	jsr GtCodNld	
      EAB6 20 2D EA   002110 |	jsr ChkChkSm
                      002111 |
      EAB9 60         002112 |	rts
                      002113 |
                      002114 |;****************************************************************************
                      002115 |;                       Move Command Subroutine.
                      002116 |;****************************************************************************
      EABA            002117 |Move:
      EABA AD 5F 00   002118 |	lda OpFld1	;Check for operands.
      EABD C9 00      002119 |	cmp #0d		;
      EABF F0 07      002120 |	beq MOut	;
                      002121 |
      EAC1 A2 00      002122 |	ldx #0d		;Get start address.
      EAC3 20 CA F2   002123 |	jsr GetAdd	;
      EAC6 B0 03      002124 |	bcs MAdd1ok	;
      EAC8            002125 |MOut:			;
      EAC8 4C 25 EB   002126 |	jmp ExitMove	;
      EACB            002127 |MAdd1ok:		;
      EACB 8E 08 00   002128 |	stx PointerA	;
      EACE 8C 09 00   002129 |	sty PointerA+1d	;
                      002130 |	
      EAD1 A2 14      002131 |	ldx #20d	;Get end address and increment by 1.
      EAD3 20 CA F2   002132 |	jsr GetAdd	;
      EAD6 B0 03      002133 |	bcs MAdd2ok	;
      EAD8 4C 25 EB   002134 |	jmp ExitMove	;
      EADB            002135 |MAdd2ok:		;
      EADB 8E 5C 00   002136 |	stx EndAdd	;
      EADE 8C 5D 00   002137 |	sty EndAdd+1d	;
      EAE1 EE 5C 00   002138 |	inc EndAdd	;
      EAE4 D0 03      002139 |	bne MNOvFlo	;
      EAE6 EE 5D 00   002140 |	inc EndAdd+1d	;
                      002141 |	
      EAE9            002142 |MNOvFlo:		;
      EAE9 A2 28      002143 |	ldx #40d	;Get destination address.
      EAEB 20 CA F2   002144 |	jsr GetAdd	;
      EAEE B0 03      002145 |	bcs MAdd3ok	;
      EAF0 4C 25 EB   002146 |	jmp ExitMove	;
      EAF3            002147 |MAdd3ok:		;
      EAF3 8E 0A 00   002148 |	stx PointerB	;
      EAF6 8C 0B 00   002149 |	sty PointerB+1d	;
                      002150 |
      EAF9 A0 00      002151 |	ldy #0d		;Move bytes between start address and end address
      EAFB            002152 |MCont:			;to memory starting at destination address.
      EAFB B1 08      002153 |	lda (PointerA),y; 
      EAFD 91 0A      002154 |	sta (PointerB),y;
      EAFF EE 0A 00   002155 |	inc PointerB	;
      EB02 D0 03      002156 |	bne MNoOvf1	;
      EB04 EE 0B 00   002157 |	inc PointerB+1d	;
      EB07            002158 |MNoOvf1:		;
      EB07 EE 08 00   002159 |	inc PointerA	;
      EB0A D0 03      002160 |	bne MNoOvf2	;
      EB0C EE 09 00   002161 |	inc PointerA+1d	;
      EB0F            002162 |MNoOvf2:		;
      EB0F AD 08 00   002163 |	lda PointerA	;
      EB12 CD 5C 00   002164 |	cmp EndAdd	;
      EB15 F0 03      002165 |	beq MCkMSB	;
      EB17 4C FB EA   002166 |	jmp MCont	;
      EB1A            002167 |MCkMSB:		;
      EB1A AD 09 00   002168 |	lda PointerA+1d	;
      EB1D CD 5D 00   002169 |	cmp EndAdd+1d	;
      EB20 F0 03      002170 |	beq ExitMove	;
      EB22 4C FB EA   002171 |	jmp MCont	;
                      002172 |	
      EB25            002173 |ExitMove:
      EB25 60         002174 |	rts
                      002175 |
                      002176 |
                      002177 |;****************************************************************************
                      002178 |;                     Register Command Subroutine
                      002179 |;****************************************************************************
      EB26            002180 |Register:
      EB26 48         002181 |	pha
      EB27 8A         002182 |	txa
      EB28 48         002183 |	pha
      EB29 98         002184 |	tya
      EB2A 48         002185 |	pha
      EB2B 08         002186 |	php
                      002187 |	
      EB2C AD 5F 00   002188 |	lda OpFld1	;Check for operand.
      EB2F C9 00      002189 |	cmp #0d		;
      EB31 F0 03      002190 |	beq GenReg	;
      EB33 4C 9E EB   002191 |	jmp SpecReg	;
                      002192 |	
      EB36            002193 |GenReg:		;
      EB36 A2 39      002194 |	ldx #RegMess<	;Output register headings.
      EB38 A0 F5      002195 |	ldy #RegMess>	;
      EB3A 20 99 F3   002196 |	jsr PrntMess	;
                      002197 |	
      EB3D A0 03      002198 |	ldy #3d		;Output contents of user's program counter.
      EB3F 20 E9 F2   002199 |	jsr OutSpace	;
      EB42 AD 46 00   002200 |	lda UPgmCntr+1d	;
      EB45 20 45 F3   002201 |	jsr OutHex	;
      EB48 AD 45 00   002202 |	lda UPgmCntr	;
      EB4B 20 45 F3   002203 |	jsr OutHex	;
                      002204 |	
      EB4E A0 09      002205 |	ldy #9d		;Output contents of user's accumulator.
      EB50 20 E9 F2   002206 |	jsr OutSpace	;
      EB53 AD 47 00   002207 |	lda UAccum	;
      EB56 20 45 F3   002208 |	jsr OutHex	;
                      002209 |	
      EB59 A0 09      002210 |	ldy #9d		;Output contents of user's X register.
      EB5B 20 E9 F2   002211 |	jsr OutSpace	;
      EB5E AD 48 00   002212 |	lda UXreg	;
      EB61 20 45 F3   002213 |	jsr OutHex	;
                      002214 |	
      EB64 A0 08      002215 |	ldy #8d		;Output contents of user's Y register.
      EB66 20 E9 F2   002216 |	jsr OutSpace	;
      EB69 AD 49 00   002217 |	lda UYReg	;
      EB6C 20 45 F3   002218 |	jsr OutHex	;
                      002219 |	
      EB6F A0 08      002220 |	ldy #8d		;Output contents of user's Stack Pointer.
      EB71 20 E9 F2   002221 |	jsr OutSpace	;
      EB74 AD 4A 00   002222 |	lda UStkPtr	;
      EB77 20 45 F3   002223 |	jsr OutHex	;
                      002224 |	
      EB7A A0 07      002225 |	ldy #7d		;Output contents of user's Status register.
      EB7C 20 E9 F2   002226 |	jsr OutSpace	;
      EB7F AD 4B 00   002227 |	lda UStatReg	;
      EB82 A2 08      002228 |	ldx #8d		;
      EB84            002229 |NextFlag:		;
      EB84 2A         002230 |	rol a		;
      EB85 B0 0A      002231 |	bcs OutOne	;
      EB87            002232 |OutZero:		;
      EB87 48         002233 |	pha		;
      EB88 A9 30      002234 |	lda #30h	;
      EB8A 20 FA F3   002235 |	jsr OutChar	;
      EB8D 68         002236 |	pla		;
      EB8E 4C 98 EB   002237 |	jmp CkBtPos	;
      EB91            002238 |OutOne:		;
      EB91 48         002239 |	pha		;
      EB92 A9 31      002240 |	lda #31h	;
      EB94 20 FA F3   002241 |	jsr OutChar	;
      EB97 68         002242 |	pla		;
      EB98            002243 |CkBtPos:		;
      EB98 CA         002244 |	dex		;
      EB99 D0 E9      002245 |	bne NextFlag	;
      EB9B 4C E3 EC   002246 |	jmp ExitReg	;
                      002247 |	
                      002248 |	
      EB9E            002249 |SpecReg:
      EB9E A9 0D      002250 |	lda #13d
      EBA0 20 FA F3   002251 |	jsr OutChar
      EBA3 A9 0A      002252 |	lda #10d
      EBA5 20 FA F3   002253 |	jsr OutChar
      EBA8 AD 5F 00   002254 |	lda OpFld1
      EBAB 20 F4 F2   002255 |	jsr ToLower
                      002256 |
      EBAE            002257 |CkPCReg:		;
      EBAE C9 70      002258 |	cmp #112d	;Get value for Program Counter from user.
      EBB0 D0 3C      002259 |	bne CkAReg	;
      EBB2 AD 46 00   002260 |	lda UpgmCntr+1d	;
      EBB5 20 45 F3   002261 |	jsr OutHex	;
      EBB8 AD 45 00   002262 |	lda UpgmCntr	;
      EBBB 20 45 F3   002263 |	jsr OutHex	;
      EBBE 20 E1 F2   002264 |	jsr OutColn	;
      EBC1 20 8E E0   002265 |	jsr GetLine	;
      EBC4 20 F4 E0   002266 |	jsr ParseOpr	;
      EBC7 AD 5F 00   002267 |	lda OpFld1	;
      EBCA C9 00      002268 |	cmp #0d		;
      EBCC D0 03      002269 |	bne GetPC	;
      EBCE 4C E3 EC   002270 |	jmp ExitReg	;
      EBD1 A2 00      002271 |GetPC:	ldx #0d		;
      EBD3 20 23 F3   002272 |	jsr AsToBin	;
      EBD6 B0 03      002273 |	bcs PCMSBOK	;
      EBD8 4C E3 EC   002274 |	jmp ExitReg	;
      EBDB A8         002275 |PCMSBOK:	tay		;
      EBDC E8         002276 |	inx		;
      EBDD 20 23 F3   002277 |	jsr AsToBin	;
      EBE0 B0 03      002278 |	bcs PCLSBOK	;
      EBE2 4C E3 EC   002279 |	jmp ExitReg	;
      EBE5 8D 45 00   002280 |PCLSBOK:	sta UPgmCntr	;
      EBE8 8C 46 00   002281 |	sty UPgmCntr+1d	;
      EBEB 4C E3 EC   002282 |	jmp ExitReg	;
                      002283 |	
      EBEE            002284 |CkAReg:		;Get value for Accumulator from user.
      EBEE C9 61      002285 |	cmp #97d	;
      EBF0 D0 29      002286 |	bne CkXReg	;
      EBF2 AD 47 00   002287 |	lda UAccum	;
      EBF5 20 45 F3   002288 |	jsr OutHex	;
      EBF8 20 E1 F2   002289 |	jsr OutColn	;
      EBFB 20 8E E0   002290 |	jsr GetLine	;
      EBFE 20 F4 E0   002291 |	jsr ParseOpr	;
      EC01 AD 5F 00   002292 |	lda OpFld1	;
      EC04 C9 00      002293 |	cmp #0d		;
      EC06 D0 03      002294 |	bne GetA	;
      EC08 4C E3 EC   002295 |	jmp ExitReg	;
      EC0B            002296 |GetA:			;
      EC0B A2 00      002297 |	ldx #0d		;
      EC0D 20 23 F3   002298 |	jsr AsToBin	;
      EC10 B0 03      002299 |	bcs AOK		;
      EC12 4C E3 EC   002300 |	jmp ExitReg	;
      EC15            002301 |AOK:			;
      EC15 8D 47 00   002302 |	sta UAccum	;
      EC18 4C E3 EC   002303 |	jmp ExitReg	;
                      002304 |	
      EC1B            002305 |CkXReg:		;Get value for X register from user.
      EC1B C9 78      002306 |	cmp #120d	;
      EC1D D0 29      002307 |	bne CkYReg	;
      EC1F AD 48 00   002308 |	lda UXreg	;
      EC22 20 45 F3   002309 |	jsr OutHex	;
      EC25 20 E1 F2   002310 |	jsr OutColn	;
      EC28 20 8E E0   002311 |	jsr GetLine	;
      EC2B 20 F4 E0   002312 |	jsr ParseOpr	;
      EC2E AD 5F 00   002313 |	lda OpFld1	;
      EC31 C9 00      002314 |	cmp #0d		;
      EC33 D0 03      002315 |	bne GetX	;
      EC35 4C E3 EC   002316 |	jmp ExitReg	;
      EC38            002317 |GetX:			;
      EC38 A2 00      002318 |	ldx #0d		;
      EC3A 20 23 F3   002319 |	jsr AsToBin	;
      EC3D B0 03      002320 |	bcs XOK		;
      EC3F 4C E3 EC   002321 |	jmp ExitReg	;
      EC42            002322 |XOK:			;
      EC42 8D 48 00   002323 |	sta UXReg	;
      EC45 4C E3 EC   002324 |	jmp ExitReg	;
                      002325 |	
      EC48            002326 |CkYReg:		;Get value for Y register from user.
      EC48 C9 79      002327 |	cmp #121d	;
      EC4A D0 29      002328 |	bne CkForS	;
      EC4C AD 49 00   002329 |	lda UYReg	;
      EC4F 20 45 F3   002330 |	jsr OutHex	;
      EC52 20 E1 F2   002331 |	jsr OutColn	;
      EC55 20 8E E0   002332 |	jsr GetLine	;
      EC58 20 F4 E0   002333 |	jsr ParseOpr	;
      EC5B AD 5F 00   002334 |	lda OpFld1	;
      EC5E C9 00      002335 |	cmp #0d		;
      EC60 D0 03      002336 |	bne GetY	;
      EC62 4C E3 EC   002337 |	jmp ExitReg	;
      EC65            002338 |GetY:			;
      EC65 A2 00      002339 |	ldx #0d		;
      EC67 20 23 F3   002340 |	jsr AsToBin	;
      EC6A B0 03      002341 |	bcs YOK		;
      EC6C 4C E3 EC   002342 |	jmp ExitReg	;
      EC6F            002343 |YOK:			;
      EC6F 8D 49 00   002344 |	sta UYReg	;
      EC72 4C E3 EC   002345 |	jmp ExitReg	;
                      002346 |	
      EC75            002347 |CkForS:		;Check if user is accessing the Stack Pointer or
      EC75 C9 73      002348 |	cmp #115d	; the Status Register.
      EC77 F0 03      002349 |	beq CkPorR	;
      EC79 4C DF EC   002350 |	jmp RegInErr	;
      EC7C            002351 |CkPorR:		;
      EC7C AD 60 00   002352 |	lda OpFld1+1d	;
      EC7F 20 F4 F2   002353 |	jsr ToLower	;
      EC82 C9 70      002354 |	cmp #112d	;
      EC84 F0 07      002355 |	beq CkSpReg	;
      EC86 C9 72      002356 |	cmp #114d	;
      EC88 F0 2C      002357 |	beq CkSRReg	;
      EC8A 4C DF EC   002358 |	jmp RegInErr	;
                      002359 |
      EC8D            002360 |CkSpReg:		;
      EC8D AD 4A 00   002361 |	lda UStkPtr	;Get value for Stack Pointer from user.
      EC90 20 45 F3   002362 |	jsr OutHex	;
      EC93 20 E1 F2   002363 |	jsr OutColn	;
      EC96 20 8E E0   002364 |	jsr GetLine	;
      EC99 20 F4 E0   002365 |	jsr ParseOpr	;
      EC9C AD 5F 00   002366 |	lda OpFld1	;
      EC9F C9 00      002367 |	cmp #0d		;
      ECA1 D0 03      002368 |	bne GetSP	;
      ECA3 4C E3 EC   002369 |	jmp ExitReg	;
      ECA6            002370 |GetSP:			;
      ECA6 A2 00      002371 |	ldx #0d		;
      ECA8 20 23 F3   002372 |	jsr AsToBin	;
      ECAB B0 03      002373 |	bcs SPOK	;
      ECAD 4C E3 EC   002374 |	jmp ExitReg	;
      ECB0            002375 |SPOK:			;
      ECB0 8D 4A 00   002376 |	sta UStkPtr	;
      ECB3 4C E3 EC   002377 |	jmp ExitReg	;
                      002378 |	
      ECB6            002379 |CkSRReg:		;Get value for Status Register from user.
      ECB6 AD 4B 00   002380 |	lda UStatReg	;
      ECB9 20 45 F3   002381 |	jsr OutHex	;
      ECBC 20 E1 F2   002382 |	jsr OutColn	;
      ECBF 20 8E E0   002383 |	jsr GetLine	;
      ECC2 20 F4 E0   002384 |	jsr ParseOpr	;
      ECC5 AD 5F 00   002385 |	lda OpFld1	;
      ECC8 C9 00      002386 |	cmp #0d		;
      ECCA D0 03      002387 |	bne GetSR	;
      ECCC 4C E3 EC   002388 |	jmp ExitReg	;
      ECCF A2 00      002389 |GetSR:	ldx #0d		;
      ECD1 20 23 F3   002390 |	jsr AsToBin	;
      ECD4 B0 03      002391 |	bcs SROK	;
      ECD6 4C E3 EC   002392 |	jmp ExitReg	;
      ECD9 8D 4B 00   002393 |SROK:	sta UStatReg	;
      ECDC 4C E3 EC   002394 |	jmp ExitReg	;
                      002395 |
      ECDF            002396 |RegInErr:
      ECDF 18         002397 |	clc
      ECE0 4C E4 EC   002398 |	jmp ErrRegOt
                      002399 |	
      ECE3            002400 |ExitReg:
      ECE3 38         002401 |	sec
      ECE4            002402 |ErrRegOt:
      ECE4 28         002403 |	plp
      ECE5 68         002404 |	pla
      ECE6 A8         002405 |	tay
      ECE7 68         002406 |	pla
      ECE8 AA         002407 |	tax
      ECE9 68         002408 |	pla
      ECEA 60         002409 |	rts
                      002410 |
                      002411 |;****************************************************************************
                      002412 |;                       Search Command Subroutine.
                      002413 |;****************************************************************************
      ECEB            002414 |Search:
      ECEB AD 5F 00   002415 |	lda OpFld1	;Check for operands.
      ECEE C9 00      002416 |	cmp #0d		;
      ECF0 F0 07      002417 |	beq SOut	;
                      002418 |
      ECF2 A2 00      002419 |	ldx #0d		;Get start address.
      ECF4 20 CA F2   002420 |	jsr GetAdd	;
      ECF7 B0 03      002421 |	bcs SAdd1ok	;
      ECF9            002422 |SOut:			;
      ECF9 4C 7B ED   002423 |	jmp ExitSrch	;
      ECFC            002424 |SAdd1ok:		;
      ECFC 8E 0A 00   002425 |	stx PointerB	;
      ECFF 8C 0B 00   002426 |	sty PointerB+1d	;
                      002427 |	
      ED02 A2 14      002428 |	ldx #20d	;Get end address and increment by 1.
      ED04 20 CA F2   002429 |	jsr GetAdd	;
      ED07 B0 03      002430 |	bcs SAdd2ok	;
      ED09 4C 7B ED   002431 |	jmp ExitSrch	;
      ED0C            002432 |SAdd2ok:		;
      ED0C 8E 5C 00   002433 |	stx EndAdd	;
      ED0F 8C 5D 00   002434 |	sty EndAdd+1d	;
      ED12 EE 5C 00   002435 |	inc EndAdd	;
      ED15 D0 03      002436 |	bne SNOvFlo	;
      ED17 EE 5D 00   002437 |	inc EndAdd+1d	;
                      002438 |	
      ED1A            002439 |SNOvFlo:		;
      ED1A A2 28      002440 |	ldx #40d	;Get search list from operand field #3 and store
      ED1C A9 20      002441 |	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
      ED1E 8D 08 00   002442 |	sta PointerA	; SrchBtCt.
      ED21 A9 00      002443 |	lda #SrchTabl>	;
      ED23 8D 09 00   002444 |	sta PointerA+1d	;
      ED26 20 72 E8   002445 |	jsr GetList	;
      ED29 90 50      002446 |	bcc ExitSrch	;
      ED2B AD CF 00   002447 |	lda DataTemp	;
      ED2E 8D 2A 00   002448 |	sta SrchBtCt	;
                      002449 |	
      ED31 AD 0A 00   002450 |	lda PointerB	;Transfer start address from pointer A to 
      ED34 8D 08 00   002451 |	sta PointerA	; pointer B.  Output a CRLF.
      ED37 AD 0B 00   002452 |	lda PointerB+1d	;
      ED3A 8D 09 00   002453 |	sta PointerA+1d	;
      ED3D A2 AF      002454 |	ldx #CRLF<	;
      ED3F A0 F4      002455 |	ldy #CRLF>	;
      ED41 20 99 F3   002456 |	jsr PrntMess	;
                      002457 |	
      ED44            002458 |SCkByte1:		;Compare list with memory.
      ED44 A2 00      002459 |	ldx #0d		;
      ED46 A0 00      002460 |	ldy #0d		;
      ED48            002461 |SCkByte2:		;
      ED48 B1 08      002462 |	lda (PointerA),y;
      ED4A DD 20 00   002463 |	cmp SrchTabl,x	;
      ED4D F0 19      002464 |	beq SMatch	;
                      002465 |	
      ED4F            002466 |IncScPtr:
      ED4F 20 C1 F2   002467 |	jsr IncPntrA	;Increment memory pointer and check to see if
      ED52 AD 08 00   002468 |	lda PointerA	; the end address has been reached.
      ED55 CD 5C 00   002469 |	cmp EndAdd	;
      ED58 F0 03      002470 |	beq SckMSB	;
      ED5A 4C 44 ED   002471 |	jmp SCkByte1	;
      ED5D            002472 |SCkMSB:		;
      ED5D AD 09 00   002473 |	lda PointerA+1d	;
      ED60 CD 5D 00   002474 |	cmp EndAdd+1d	;
      ED63 F0 16      002475 |	beq ExitSrch	;
      ED65 4C 44 ED   002476 |	jmp SCkByte1	;
                      002477 |	
      ED68            002478 |SMatch:		;
      ED68 C8         002479 |	iny		;Check to see if all bytes in search list match
      ED69 E8         002480 |	inx		; bytes in memory.
      ED6A EC 2A 00   002481 |	cpx SrchBtCt	;
      ED6D F0 03      002482 |	beq SFulMtch	;
      ED6F 4C 48 ED   002483 |	jmp SCkByte2	;
                      002484 |
      ED72            002485 |SFulMtch:		;
      ED72 20 0C F3   002486 |	jsr PrntAdd	;Output address where match was found.
      ED75 20 C1 F2   002487 |	jsr IncPntrA	;
      ED78 4C 44 ED   002488 |	jmp SCkByte1	;
                      002489 |
      ED7B            002490 |ExitSrch:
      ED7B 60         002491 |	rts
                      002492 |
                      002493 |
                      002494 |
                      002495 |;****************************************************************************
                      002496 |;                       Trace Command Subroutine.
                      002497 |;****************************************************************************
      ED7C            002498 |Trace:
                      002499 |
      ED7C AD 5F 00   002500 |	lda OpFld1	;Check for operands.
      ED7F C9 00      002501 |	cmp #0d		;
      ED81 F0 17      002502 |	beq TNoOper	;
                      002503 |	
      ED83 A2 00      002504 |	ldx #0d		;Get start address.
      ED85 20 CA F2   002505 |	jsr GetAdd	;
      ED88 B0 03      002506 |	bcs TAdd1ok	;
      ED8A 4C 83 EF   002507 |	jmp ErrTrce	;
      ED8D            002508 |TAdd1ok:		;
      ED8D 8E 45 00   002509 |	stx UPgmCntr	;
      ED90 8C 46 00   002510 |	sty UPgmCntr+1d	;
                      002511 |	
      ED93 AD 73 00   002512 |	lda OpFld2	;Check to see if a trace count has been 
      ED96 C9 00      002513 |	cmp #0d		; specified.
      ED98 D0 08      002514 |	bne GtTrcCnt	;
                      002515 |
      ED9A            002516 |TNoOper:
      ED9A A0 01      002517 |	ldy #1d		;Set trace count to 1.
      ED9C 8C 3E 00   002518 |	sty TracCnt	;
      ED9F 4C AF ED   002519 |	jmp StartTrc	;
                      002520 |
      EDA2            002521 |GtTrcCnt:	
      EDA2 A2 14      002522 |	ldx #20d	;Get trace count from user.
      EDA4 20 23 F3   002523 |	jsr AsToBin	;
      EDA7 B0 03      002524 |	bcs TrValOK	;
      EDA9 4C 83 EF   002525 |	jmp ErrTrce	;
      EDAC            002526 |TrValOK:		;
      EDAC 8D 3E 00   002527 |	sta TracCnt	;
                      002528 |	
      EDAF            002529 |StartTrc:
      EDAF 68         002530 |	pla		;Remove trace command's return address and
      EDB0 68         002531 |	pla		; the check command routine's return address from
      EDB1 68         002532 |	pla		; the stack.
      EDB2 68         002533 |	pla		;
                      002534 |
      EDB3            002535 |ContTrc:	
      EDB3 AC 45 00   002536 |	ldy UPgmCntr	;Transfer user's program counter to pointer A.
      EDB6 8C 08 00   002537 |	sty PointerA	;
      EDB9 AC 46 00   002538 |	ldy UPgmCntr+1d	;
      EDBC 8C 09 00   002539 |	sty PointerA+1d	;
                      002540 |
      EDBF A0 00      002541 |	ldy #0d		;Get opcode of current instruction.
      EDC1 B1 08      002542 |	lda (PointerA),y;
      EDC3 8D 43 00   002543 |	sta OpCdHold	;
                      002544 |	
      EDC6 20 87 EF   002545 |	jsr ScanOpCd	;Check to see if byte from memory location was
      EDC9 B0 03      002546 |	bcs TOpCdFnd	; an opcode.
      EDCB 4C 83 EF   002547 |	jmp ErrTrce
                      002548 |
      EDCE            002549 |TOpCdFnd:
      EDCE A0 08      002550 |	ldy #8d		;Get number of bytes in the current instruction
      EDD0 B1 0A      002551 |	lda (PointerB),y; information from opcode table.
      EDD2 8D 3A 00   002552 |	sta CurInsLn	;
                      002553 |	
      EDD5 A0 01      002554 |	ldy #1d		;Get opcode of current instruction.
      EDD7 AD 43 00   002555 |	lda OpCdHold	;
                      002556 |
      EDDA            002557 |TrRTS:			;If the opcode is an RTS then copy the return
      EDDA C9 60      002558 |	cmp #60h	; address from the stack, save the opcode to
      EDDC D0 28      002559 |	bne TNxtOp0	; be returned to, and place a BRK at the return
      EDDE A9 02      002560 |	lda #2d		; address.
      EDE0 8D 3D 00   002561 |	sta BrnchFlg	;
      EDE3 68         002562 |	pla		;
      EDE4 8D 10 00   002563 |	sta BOpAdPtr	;
      EDE7 68         002564 |	pla		;
      EDE8 8D 11 00   002565 |	sta BOpAdPtr+1d	;
      EDEB 48         002566 |	pha		;
      EDEC AD 10 00   002567 |	lda BOpAdPtr	;
      EDEF 48         002568 |	pha		;
      EDF0 EE 10 00   002569 |	inc BOpAdPtr	;
      EDF3 D0 03      002570 |	bne NNOvflo	;
      EDF5 EE 11 00   002571 |	inc BOpAdPtr+1d	;
      EDF8            002572 |NNOvflo:		;
      EDF8 A0 00      002573 |	ldy #0d		;
      EDFA B1 10      002574 |	lda (BOpAdPtr),y;
      EDFC 8D 3C 00   002575 |	sta BOpCdHld	;
      EDFF A9 00      002576 |	lda #0d		;
      EE01 91 10      002577 |	sta (BOpAdPtr),y;
      EE03 4C 12 EF   002578 |	jmp ChBkVect	;
                      002579 |	
      EE06            002580 |TNxtOp0:		;
      EE06 C9 4C      002581 |	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
      EE08 D0 1E      002582 |	bne TNxtOp1	; then save the opcode of the instruction that
      EE0A A9 02      002583 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE0C 8D 3D 00   002584 |	sta BrnchFlg	;
      EE0F B1 08      002585 |	lda (PointerA),y;
      EE11 8D 10 00   002586 |	sta BOpAdPtr	;
      EE14 C8         002587 |	iny		;
      EE15 B1 08      002588 |	lda (PointerA),y;
      EE17 8D 11 00   002589 |	sta BOpAdPtr+1d	;
      EE1A A0 00      002590 |	ldy #0d		;
      EE1C B1 10      002591 |	lda (BOpAdPtr),y;
      EE1E 8D 3C 00   002592 |	sta BOpCdHld	;
      EE21 A9 00      002593 |	lda #0d		;
      EE23 91 10      002594 |	sta (BOpAdPtr),y;
      EE25 4C 12 EF   002595 |	jmp ChBkVect	;
                      002596 |	
      EE28            002597 |TNxtOp1:
      EE28 C9 6C      002598 |	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
      EE2A D0 2B      002599 |	bne TNxtOp2	; then save the opcode of the instruction that
      EE2C A9 02      002600 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE2E 8D 3D 00   002601 |	sta BrnchFlg	;
      EE31 B1 08      002602 |	lda (PointerA),y;
      EE33 8D 0C 00   002603 |	sta PointerC	;
      EE36 C8         002604 |	iny		;
      EE37 B1 08      002605 |	lda (PointerA),y;
      EE39 8D 0D 00   002606 |	sta PointerC+1d	;
      EE3C A0 00      002607 |	ldy #0d		;
      EE3E B1 0C      002608 |	lda (PointerC),y;
      EE40 8D 10 00   002609 |	sta BOpAdPtr	;
      EE43 C8         002610 |	iny		;
      EE44 B1 0C      002611 |	lda (PointerC),y;
      EE46 8D 11 00   002612 |	sta BOpAdPtr+1d	;
      EE49 A0 00      002613 |	ldy #0d		;
      EE4B B1 10      002614 |	lda (BOpAdPtr),y;
      EE4D 8D 3C 00   002615 |	sta BOpCdHld	;
      EE50 A9 00      002616 |	lda #0d		;
      EE52 91 10      002617 |	sta (BOpAdPtr),y;
      EE54 4C 12 EF   002618 |	jmp ChBkVect	;
                      002619 |		
                      002620 |	
      EE57            002621 |TNxtOp2:
      EE57 C9 20      002622 |	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
      EE59 D0 1E      002623 |	bne TNxtOp3	; then save the opcode of the instruction that
      EE5B A9 02      002624 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE5D 8D 3D 00   002625 |	sta BrnchFlg	;
      EE60 B1 08      002626 |	lda (PointerA),y;
      EE62 8D 10 00   002627 |	sta BOpAdPtr	;
      EE65 C8         002628 |	iny		;
      EE66 B1 08      002629 |	lda (PointerA),y;
      EE68 8D 11 00   002630 |	sta BOpAdPtr+1d	;
      EE6B A0 00      002631 |	ldy #0d		;
      EE6D B1 10      002632 |	lda (BOpAdPtr),y;
      EE6F 8D 3C 00   002633 |	sta BOpCdHld	;
      EE72 A9 00      002634 |	lda #0d		;
      EE74 91 10      002635 |	sta (BOpAdPtr),y;
      EE76 4C 12 EF   002636 |	jmp ChBkVect	;
                      002637 |	
      EE79            002638 |TNxtOp3:
      EE79 A0 00      002639 |	ldy #0d		;Check to see if the current instruction is an
      EE7B B1 0A      002640 |	lda (PointerB),y; actual branch.
      EE7D C9 42      002641 |	cmp #'B'	;
      EE7F D0 08      002642 |	bne NoBrnch2	;
      EE81 A0 01      002643 |	ldy #1d		;
      EE83 B1 0A      002644 |	lda (PointerB),y;
      EE85 C9 49      002645 |	cmp #'I'	;
      EE87 D0 03      002646 |	bne Branch	;
      EE89            002647 |NoBrnch2:		;
      EE89 4C EF EE   002648 |	jmp NoBranch	;
                      002649 |	
      EE8C            002650 |Branch:		;If the opcode is a branch, Bxx aaaa,
      EE8C A9 01      002651 |	lda #1d		; then save the opcode of the instruction that
      EE8E 8D 3D 00   002652 |	sta BrnchFlg	; will be branched to and replace it with a BRK.
      EE91 18         002653 |	clc		;
      EE92 AD 08 00   002654 |	lda PointerA	;
      EE95 6D 3A 00   002655 |	adc CurInsLn	;
      EE98 8D 10 00   002656 |	sta BOpAdPtr	;
      EE9B AD 09 00   002657 |	lda PointerA+1d	;
      EE9E 69 00      002658 |	adc #0d		;
      EEA0 8D 11 00   002659 |	sta BOpAdPtr+1d	;
                      002660 |			;
      EEA3 A0 01      002661 |	ldy #1d		;
      EEA5 B1 08      002662 |	lda (PointerA),y;
      EEA7 8D 38 00   002663 |	sta BrValHld	;
      EEAA 10 20      002664 |	bpl AddAdd	;
      EEAC            002665 |SubAdd:		;
      EEAC CE 38 00   002666 |	dec BrValHld	;
      EEAF AD 38 00   002667 |	lda BrValHld	;
      EEB2 49 FF      002668 |	eor #0ffh	;
      EEB4 8D 38 00   002669 |	sta BrValHld	;
      EEB7 38         002670 |	sec		;
      EEB8 AD 10 00   002671 |	lda BOpAdPtr	;
      EEBB ED 38 00   002672 |	sbc BrValHld	;
      EEBE 8D 10 00   002673 |	sta BOpAdPtr	;
      EEC1 AD 11 00   002674 |	lda BOpAdPtr+1d	;
      EEC4 E9 00      002675 |	sbc #0d		;
      EEC6 8D 11 00   002676 |	sta BOpAdPtr+1d	;
      EEC9 4C E1 EE   002677 |	jmp GtBrOpCd	;
      EECC            002678 |AddAdd:		;
      EECC 18         002679 |	clc		;
      EECD AD 10 00   002680 |	lda BOpAdPtr	;
      EED0 6D 38 00   002681 |	adc BrValHld	;
      EED3 8D 10 00   002682 |	sta BOpAdPtr	;
      EED6 AD 11 00   002683 |	lda BOpAdPtr+1d	;
      EED9 69 00      002684 |	adc #0d		;
      EEDB 8D 11 00   002685 |	sta BOpAdPtr+1d	;
      EEDE 4C E1 EE   002686 |	jmp GtBrOpCd	;
      EEE1            002687 |GtBrOpCd:		;
      EEE1 A0 00      002688 |	ldy #0d		;
      EEE3 B1 10      002689 |	lda (BOpAdPtr),y;
      EEE5 8D 3C 00   002690 |	sta BOpCdHld	;
      EEE8 A9 00      002691 |	lda #0d		;
      EEEA 91 10      002692 |	sta (BOpAdPtr),y;
      EEEC 4C F4 EE   002693 |	jmp Both	;
                      002694 |	
      EEEF            002695 |NoBranch:
      EEEF A9 00      002696 |	lda #0d		;Set branch flag to 0 to indicate the current
      EEF1 8D 3D 00   002697 |	sta BrnchFlg	; instruction is not a branch instruction.
                      002698 |
      EEF4            002699 |Both:
      EEF4 AC 3A 00   002700 |	ldy CurInsLn	;
      EEF7 B1 08      002701 |	lda (PointerA),y;Save the opcode of the next instruction to be
      EEF9 8D 3B 00   002702 |	sta NOpCdHld	; executed if no branch is taken and replace it
                      002703 |			; with a BRK command.
      EEFC 18         002704 |	clc		;
      EEFD AD 08 00   002705 |	lda PointerA	;
      EF00 6D 3A 00   002706 |	adc CurInsLn	;
      EF03 8D 0E 00   002707 |	sta NOpAdPtr	;
      EF06 AD 09 00   002708 |	lda PointerA+1d	;
      EF09 69 00      002709 |	adc #0d		;
      EF0B 8D 0F 00   002710 |	sta NOpAdPtr+1d	;
      EF0E A9 00      002711 |	lda #0d		;
      EF10 91 08      002712 |	sta (PointerA),y;
                      002713 |	
      EF12            002714 |ChBkVect:
      EF12 A9 01      002715 |	lda #1d		    ;Make BRK jump here instead of main.
      EF14 8D 39 00   002716 |	sta TrBrkFlg	;
                      002717 |	
      EF17 AD 5F 00   002718 |    lda OpFld1	;Check to see if user entered address.
      EF1A C9 00      002719 |	cmp #0d		;
      EF1C F0 03      002720 |	beq DoNotRestoreStackPointer
      EF1E A2 FF      002721 |    ldx #0ffh    
      EF20 9A         002722 |    txs          ;
      EF21            002723 |DoNotRestoreStackPointer:
                      002724 |
      EF21 AD 4B 00   002725 |	lda UStatReg	;Restore user's registers.
      EF24 48         002726 |	pha		        ;
      EF25 AD 47 00   002727 |	lda UAccum	    ;
      EF28 AE 48 00   002728 |	ldx UXreg	    ;
      EF2B AC 49 00   002729 |	ldy UYReg	    ;
      EF2E 28         002730 |	plp		        ;
                      002731 |    
      EF2F 6C 45 00   002732 |	jmp (UPgmCntr)	;Jump to user's code.
                      002733 |	
      EF32            002734 |Tr2ndEnt:
      EF32 A9 00      002735 |	lda #0d		;Reset trace break flag.
      EF34 8D 39 00   002736 |	sta TrBrkFlg	;
                      002737 |	
      EF37            002738 |CkBrnch:		;
      EF37 A0 00      002739 |	ldy #0d		;Check to see which opcodes need to be restored.
      EF39 AD 3D 00   002740 |	lda BrnchFlg	;
      EF3C C9 00      002741 |	cmp #0d		;
      EF3E F0 11      002742 |	beq NoBrnch	;
      EF40 C9 01      002743 |	cmp #1d		;
      EF42 F0 08      002744 |	beq Brnch	;
                      002745 |	
      EF44            002746 |DoJmp:
      EF44 AD 3C 00   002747 |	lda BOpCdHld	;Restore opcode to be jumped to.
      EF47 91 10      002748 |	sta (BOpAdPtr),y;
      EF49 4C 56 EF   002749 |	jmp UpDtPtrA	;
                      002750 |
      EF4C            002751 |Brnch:
      EF4C AD 3C 00   002752 |	lda BOpCdHld	;Restore opcode to be branched to.
      EF4F 91 10      002753 |	sta (BOpAdPtr),y;
                      002754 |	
      EF51            002755 |NoBrnch:
      EF51 AD 3B 00   002756 |	lda NOpCdHld	;Restore opcode that will be executed next in
      EF54 91 0E      002757 |	sta (NOpAdPtr),y; the instruction stream.
                      002758 |
      EF56            002759 |UpDtPtrA:
      EF56 AC 45 00   002760 |	ldy UPgmCntr	;Set pointer A to point to the next instruction
      EF59 8C 08 00   002761 |	sty PointerA	; to be executed for unassemble.
      EF5C AC 46 00   002762 |	ldy UPgmCntr+1d	;
      EF5F 8C 09 00   002763 |	sty PointerA+1d	;
                      002764 |	
      EF62 A2 AF      002765 |	ldx #CRLF<	;Unassemble next instruction in memory.
      EF64 A0 F4      002766 |	ldy #CRLF>	;
      EF66 20 99 F3   002767 |	jsr PrntMess	;
      EF69 AD 08 00   002768 |	lda PointerA	;
      EF6C 8D 5C 00   002769 |	sta EndAdd	;
      EF6F AD 09 00   002770 |	lda PointerA+1d	;
      EF72 8D 5D 00   002771 |	sta EndAdd+1d	;
      EF75 20 06 F0   002772 |	jsr StartUnA	;
                      002773 |	
      EF78            002774 |NxtIn:
      EF78 CE 3E 00   002775 |	dec TracCnt	;Decrement trace count and trace again if it
      EF7B F0 03      002776 |	beq OutTrce	; is not zero.
      EF7D 4C B3 ED   002777 |	jmp ContTrc	;
                      002778 |
      EF80            002779 |OutTrce:
      EF80 4C 7B E0   002780 |	jmp MainLoop	;Enter the main monitor loop using a jump
                      002781 |			; because the trace command's return address
                      002782 |			; and the check command routine's return address
                      002783 |			; were removed when a trace was initiated.
      EF83            002784 |ErrTrce:
      EF83 18         002785 |	clc
      EF84 60         002786 |	rts	
                      002787 |
      EF85            002788 |ExitTrce:
      EF85 38         002789 |	sec
      EF86 60         002790 |	rts	
                      002791 |
                      002792 |;****************************************************************************
                      002793 |;                       Scan for Valid Opcode Subroutine.
                      002794 |;****************************************************************************
      EF87            002795 |ScanOpCd:
                      002796 |	
      EF87 A2 2C      002797 |	ldx #OpTable<	;Point pointer B to beginning of opcode table.
      EF89 8E 0A 00   002798 |	stx PointerB	;
      EF8C A2 F8      002799 |	ldx #OpTable>	;
      EF8E 8E 0B 00   002800 |	stx PointerB+1d	;
                      002801 |	
      EF91            002802 |CkTblEnd:
      EF91 A0 04      002803 |	ldy #4d		;Check for end of opcode table.
      EF93 B1 0A      002804 |	lda (PointerB),y;
      EF95 C9 5A      002805 |	cmp #90d	;
      EF97 F0 1C      002806 |	beq OpCdNtFd	;
                      002807 |	
      EF99            002808 |CkNxtOp:		;
      EF99 A0 07      002809 |	ldy #7d		;Check for an opcode match in the opcode table.
      EF9B B1 0A      002810 |	lda (PointerB),y;
      EF9D CD 43 00   002811 |	cmp OpCdHold	;
      EFA0 F0 11      002812 |	beq OpCdFndS	;
                      002813 |	
      EFA2 AD 0A 00   002814 |	lda PointerB	;Point pointer B to next entry in opcode table.
      EFA5 18         002815 |	clc		;
      EFA6 69 0A      002816 |	adc #10d	;
      EFA8 8D 0A 00   002817 |	sta PointerB	;
      EFAB 90 03      002818 |	bcc ScNoCary	;
      EFAD EE 0B 00   002819 |	inc PointerB+1d	;
                      002820 |		
      EFB0            002821 |ScNoCary:
      EFB0 4C 91 EF   002822 |	jmp CkTblEnd
                      002823 |	
                      002824 |	
      EFB3            002825 |OpCdFndS:
      EFB3 38         002826 |	sec
      EFB4 60         002827 |	rts
                      002828 |	
      EFB5            002829 |OpCdNtFd:
      EFB5 18         002830 |	clc
      EFB6 60         002831 |	rts
                      002832 |	
                      002833 |;****************************************************************************
                      002834 |;                       Unassemble Command Subroutine.
                      002835 |;****************************************************************************
      EFB7            002836 |UnAssem:
      EFB7 AD 5F 00   002837 |	lda OpFld1	;Check for operands.
      EFBA C9 00      002838 |	cmp #0d		;
      EFBC F0 17      002839 |	beq UNoOper	;
                      002840 |
      EFBE A2 00      002841 |	ldx #0d		;Get start address.
      EFC0 20 CA F2   002842 |	jsr GetAdd	;
      EFC3 B0 03      002843 |	bcs UAdd1ok	;
      EFC5 4C AB F2   002844 |	jmp ErrUnAs	;
      EFC8            002845 |UAdd1ok:		;
      EFC8 8E 08 00   002846 |	stx PointerA	;
      EFCB 8C 09 00   002847 |	sty PointerA+1d	;
                      002848 |	
      EFCE AD 73 00   002849 |	lda OpFld2	;Check to see if an end address has been 
      EFD1 C9 00      002850 |	cmp #0d		; specified.
      EFD3 D0 21      002851 |	bne GtUEndAd	;
                      002852 |	
      EFD5            002853 |UNoOper:
      EFD5 AD 08 00   002854 |	lda PointerA	;
      EFD8 8D 5C 00   002855 |	sta EndAdd	;
      EFDB AD 09 00   002856 |	lda PointerA+1d	;
      EFDE 8D 5D 00   002857 |	sta EndAdd+1d	;
      EFE1 18         002858 |	clc		;If no end address has been specified by the
      EFE2 AD 08 00   002859 |	lda PointerA	; user then set the end address to start address
      EFE5 69 14      002860 |	adc #20d	; + 20d.
      EFE7 8D 5C 00   002861 |	sta EndAdd	;
      EFEA 90 07      002862 |	bcc UNoCary	;
      EFEC AE 5D 00   002863 |	ldx EndAdd+1d	;
      EFEF E8         002864 |	inx		;
      EFF0 8E 5D 00   002865 |	stx EndAdd+1d	;
      EFF3            002866 |UNoCary:		;
      EFF3 4C 06 F0   002867 |	jmp StartUnA	;
                      002868 |	
      EFF6            002869 |GtUEndAd:
      EFF6 A2 14      002870 |	ldx #20d	;Get end address.
      EFF8 20 CA F2   002871 |	jsr GetAdd	;
      EFFB B0 03      002872 |	bcs UAdd2ok	;
      EFFD 4C AB F2   002873 |	jmp ErrUnAs	;
      F000            002874 |UAdd2ok:		;
      F000 8E 5C 00   002875 |	stx EndAdd	;
      F003 8C 5D 00   002876 |	sty EndAdd+1d	;
                      002877 |	
      F006            002878 |StartUnA:
      F006 AD 5D 00   002879 |	lda EndAdd+1d	;Check to see if end address has been reached.
      F009 CD 09 00   002880 |	cmp PointerA+1d	;
      F00C F0 05      002881 |	beq UChkFLSB	;
      F00E 90 0E      002882 |	bcc UOut	;
      F010 4C 21 F0   002883 |	jmp UNotFin 	;
      F013            002884 |UChkFLSB:
      F013 AD 5C 00   002885 |	lda EndAdd	; 
      F016 CD 08 00   002886 |	cmp PointerA	;
      F019 90 03      002887 |	bcc UOut	;
      F01B 4C 21 F0   002888 |	jmp UNotFin	;
      F01E            002889 |UOut:			;
      F01E 4C AD F2   002890 |	jmp ExitUnAs	;
                      002891 |
      F021            002892 |UNotFin:		;
      F021 A0 00      002893 |	ldy #0d		;Get opcode byte from memory and save.
      F023 B1 08      002894 |	lda (PointerA),y;
      F025 8D 43 00   002895 |	sta OpCdHold	;
      F028 20 87 EF   002896 |	jsr ScanOpCd	;Check to see if byte from memory location was
      F02B B0 1D      002897 |	bcs OpCdFnd	; an opcode.
                      002898 |
      F02D            002899 |NtOpCode:
      F02D A2 AF      002900 |	ldx #CRLF<	;Print start address of current instruction.
      F02F A0 F4      002901 |	ldy #CRLF>	;
      F031 20 99 F3   002902 |	jsr PrntMess	;
      F034 20 0C F3   002903 |	jsr PrntAdd	;
                      002904 |
      F037 AD 43 00   002905 |	lda OpCdHold	;Print the bad opcode.
      F03A 20 45 F3   002906 |	jsr OutHex	;
                      002907 |	
      F03D A2 88      002908 |	ldx #BadOpMes<	;If byte was not an opcode then print question
      F03F A0 F5      002909 |	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
      F041 20 99 F3   002910 |	jsr PrntMess	;
      F044 20 C1 F2   002911 |	jsr IncPntrA	;
      F047 4C 06 F0   002912 |	jmp StartUnA	;
                      002913 |
      F04A            002914 |OpCdFnd:
      F04A A2 AF      002915 |	ldx #CRLF<	;Print start address of current instruction.
      F04C A0 F4      002916 |	ldy #CRLF>	;
      F04E 20 99 F3   002917 |	jsr PrntMess	;
      F051 20 0C F3   002918 |	jsr PrntAdd	;
      F054 20 C1 F2   002919 |	jsr IncPntrA	;
                      002920 |
      F057            002921 |CkAdMode:
      F057 A0 06      002922 |	ldy #6d		;Get addressing mode indicator from table.
      F059 B1 0A      002923 |	lda (PointerB),y;
                      002924 |	
      F05B            002925 |NxAdMo1:		;
      F05B C9 50      002926 |	cmp #'P'	;Check for implied addressing mode.
      F05D D0 03      002927 |	bne NxAdMo2	;
      F05F 4C A4 F0   002928 |	jmp ImpAdMo	;
                      002929 |	
      F062            002930 |NxAdMo2:		;
      F062 C9 4D      002931 |	cmp #'M'	;Check for immediate addressing mode.
      F064 D0 03      002932 |	bne NxAdMo3	;
      F066 4C CB F0   002933 |	jmp ImmAdMo	;	
                      002934 |
      F069            002935 |NxAdMo3:		;
      F069 C9 53      002936 |	cmp #'S'	;Check for absolute addressing mode.
      F06B D0 03      002937 |	bne NxAdMo4	;
      F06D 4C FE F0   002938 |	jmp AbsxyAdM	;	
                      002939 |
      F070            002940 |NxAdMo4:		;
      F070 C9 58      002941 |	cmp #'X'	;Check for absolute x addressing mode.
      F072 D0 03      002942 |	bne NxAdMo5	;
      F074 4C FE F0   002943 |	jmp AbsxyAdM	;
                      002944 |
      F077            002945 |NxAdMo5:		;
      F077 C9 59      002946 |	cmp #'Y'	;Check for absolute y addressing mode.
      F079 D0 03      002947 |	bne NxAdMo6	;
      F07B 4C FE F0   002948 |	jmp AbsxyAdM	;
                      002949 |
      F07E            002950 |NxAdMo6:		;
      F07E C9 52      002951 |	cmp #'R'	;Check for indexed indirect addressing mode.
      F080 D0 03      002952 |	bne NxAdMo7	;
      F082 4C 1B F2   002953 |	jmp IIRAdMo	;
                      002954 |
      F085            002955 |NxAdMo7:		;
      F085 C9 4C      002956 |	cmp #'L'	;Check for relative addressing mode.
      F087 D0 03      002957 |	bne NxAdMo8 	;
      F089 4C 68 F1   002958 |	jmp RelAdMo	;
                      002959 |
      F08C            002960 |NxAdMo8:		;
      F08C C9 43      002961 |	cmp #'C'	;Check for accumulator addressing mode.
      F08E D0 03      002962 |	bne NxAdMo9 	;
      F090 4C B5 F0   002963 |	jmp AccAdMo	;
                      002964 |
      F093            002965 |NxAdMo9:		;
      F093 C9 44      002966 |	cmp #'D'	;Check for indirect addressing mode.
      F095 D0 03      002967 |	bne NxAdMo10 	;
      F097 4C 5D F2   002968 |	jmp IndAdMo	;
                      002969 |
      F09A            002970 |NxAdMo10:
      F09A C9 49      002971 |	cmp #'I'	;Check for indirect indexed addressing mode.
      F09C D0 03      002972 |	bne BdOpCd	;
      F09E 4C D9 F1   002973 |	jmp IRIAdMo	;
                      002974 |
      F0A1            002975 |BdOpCd:		;
      F0A1 4C 2D F0   002976 |	jmp NtOpCode	;
                      002977 |
                      002978 |
      F0A4            002979 |ImpAdMo:
      F0A4 AD 43 00   002980 |	lda OpCdHold	;Print the opcode.
      F0A7 20 45 F3   002981 |	jsr OutHex	;
                      002982 |	
      F0AA A0 08      002983 |	ldy #8d		;Print spaces between object code field and
      F0AC 20 E9 F2   002984 |	jsr OutSpace	; operator field.
                      002985 |		
      F0AF 20 AF F2   002986 |	jsr PrntMnem	;Print the operator.
                      002987 |	
      F0B2 4C 06 F0   002988 |	jmp StartUnA
                      002989 |
      F0B5            002990 |AccAdMo:
      F0B5 AD 43 00   002991 |	lda OpCdHold	;Print the opcode.
      F0B8 20 45 F3   002992 |	jsr OutHex	;
                      002993 |	
      F0BB A0 08      002994 |	ldy #8d		;Print spaces between object code field and
      F0BD 20 E9 F2   002995 |	jsr OutSpace	; operator field.
                      002996 |		
      F0C0 20 AF F2   002997 |	jsr PrntMnem	;Print the operator.
                      002998 |	
      F0C3 A9 41      002999 |	lda #65d	;Print a capital A for accumulator addressing.
      F0C5 20 FA F3   003000 |	jsr OutChar	;
                      003001 |	
      F0C8 4C 06 F0   003002 |	jmp StartUnA
                      003003 |
                      003004 |
      F0CB            003005 |ImmAdMo:
      F0CB A0 00      003006 |	ldy #0d
                      003007 |
      F0CD AD 43 00   003008 |	lda OpCdHold	;Print the opcode and a space.
      F0D0 20 45 F3   003009 |	jsr OutHex	;
      F0D3 A9 20      003010 |	lda #32d	;
      F0D5 20 FA F3   003011 |	jsr OutChar	;
                      003012 |	
      F0D8 B1 08      003013 |	lda (PointerA),y;Print the second byte of the instruction and
      F0DA 8D 41 00   003014 |	sta ObCdHld1	; increment the memory pointer.
      F0DD 20 45 F3   003015 |	jsr OutHex	;
      F0E0 20 C1 F2   003016 |	jsr IncPntrA	;
                      003017 |	
      F0E3 A0 05      003018 |	ldy #5d		;Print spaces between object code field and
      F0E5 20 E9 F2   003019 |	jsr OutSpace	; operator field.
                      003020 |	
      F0E8 20 AF F2   003021 |	jsr PrntMnem	;Print the operator.
                      003022 |	
      F0EB A9 23      003023 |	lda #35d	;Print a pound sign.
      F0ED 20 FA F3   003024 |	jsr OutChar	;
                      003025 |	
      F0F0 AD 41 00   003026 |	lda ObCdHld1	;Print immediate operand value.
      F0F3 20 45 F3   003027 |	jsr OutHex	;
                      003028 |	
      F0F6 A9 68      003029 |	lda #104d	;Print lower case h to indicate hex number.
      F0F8 20 FA F3   003030 |	jsr OutChar	;
                      003031 |	
      F0FB 4C 06 F0   003032 |	jmp StartUnA
                      003033 |
                      003034 |
      F0FE            003035 |AbsxyAdM:
      F0FE A0 00      003036 |	ldy #0d
                      003037 |
      F100 AD 43 00   003038 |	lda OpCdHold	;Print the opcode and a space.
      F103 20 45 F3   003039 |	jsr OutHex	;
      F106 A9 20      003040 |	lda #32d	;
      F108 20 FA F3   003041 |	jsr OutChar	;
                      003042 |	
      F10B B1 08      003043 |	lda (PointerA),y;Print the second byte of the instruction and
      F10D 8D 41 00   003044 |	sta ObCdHld1	; increment the memory pointer
      F110 20 45 F3   003045 |	jsr OutHex	;
      F113 20 C1 F2   003046 |	jsr IncPntrA	;
                      003047 |	
      F116 A9 20      003048 |	lda #32d	;Print a space between obj codes.
      F118 20 FA F3   003049 |	jsr OutChar	;
                      003050 |	
      F11B B1 08      003051 |	lda (PointerA),y;Print the third byte of the instruction and
      F11D 8D 42 00   003052 |	sta ObCdHld2	; increment the memory pointer
      F120 20 45 F3   003053 |	jsr OutHex	;
      F123 20 C1 F2   003054 |	jsr IncPntrA	;
                      003055 |	
      F126 A0 02      003056 |	ldy #2d		;Print spaces between object code field and
      F128 20 E9 F2   003057 |	jsr OutSpace	; operator field.
                      003058 |	
      F12B 20 AF F2   003059 |	jsr PrntMnem	;Print the operator.
                      003060 |
      F12E AD 42 00   003061 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F131 20 45 F3   003062 |	jsr OutHex	;
      F134 AD 41 00   003063 |	lda ObCdHld1	;
      F137 20 45 F3   003064 |	jsr OutHex	;
                      003065 |	
      F13A A9 68      003066 |	lda #104d	;Print lower case h to indicate hex number.
      F13C 20 FA F3   003067 |	jsr OutChar	;
                      003068 |
      F13F A0 06      003069 |	ldy #6d		;Check to see if address mode is abs, abx or
      F141 B1 0A      003070 |	lda (PointerB),y; aby.
      F143 C9 58      003071 |	cmp #'X'	;
      F145 F0 07      003072 |	beq AbxAdMo	;
      F147 C9 59      003073 |	cmp #'Y'	;
      F149 F0 10      003074 |	beq AbyAdMo	;
                      003075 |	
      F14B            003076 |AbsAM:
      F14B 4C 06 F0   003077 |	jmp StartUnA
                      003078 |
      F14E            003079 |AbxAdMo:
      F14E A9 2C      003080 |	lda #44d	;Print comma and x.
      F150 20 FA F3   003081 |	jsr OutChar	;
      F153 A9 58      003082 |	lda #88d	;
      F155 20 FA F3   003083 |	jsr OutChar	;
                      003084 |	
      F158 4C 06 F0   003085 |	jmp StartUna
                      003086 |	
      F15B            003087 |AbyAdMo:
      F15B A9 2C      003088 |	lda #44d	;Print comma and y.
      F15D 20 FA F3   003089 |	jsr OutChar	;
      F160 A9 59      003090 |	lda #89d	;
      F162 20 FA F3   003091 |	jsr OutChar	;
                      003092 |
      F165 4C 06 F0   003093 |	jmp StartUnA
                      003094 |
                      003095 |
      F168            003096 |RelAdMo:
      F168 A0 00      003097 |	ldy #0d
                      003098 |
      F16A AD 43 00   003099 |	lda OpCdHold	;Print the opcode and a space.
      F16D 20 45 F3   003100 |	jsr OutHex	;
      F170 A9 20      003101 |	lda #32d	;
      F172 20 FA F3   003102 |	jsr OutChar	;
                      003103 |	
      F175 B1 08      003104 |	lda (PointerA),y;Print the second byte of the instruction and
      F177 8D 41 00   003105 |	sta ObCdHld1	; increment the memory pointer.
      F17A 20 45 F3   003106 |	jsr OutHex	;
      F17D 20 C1 F2   003107 |	jsr IncPntrA	;
                      003108 |	
      F180 A0 05      003109 |	ldy #5d		;Print spaces between object code field and
      F182 20 E9 F2   003110 |	jsr OutSpace	; operator field.
                      003111 |	
      F185 20 AF F2   003112 |	jsr PrntMnem	;Print the operator.
                      003113 |
      F188 AD 08 00   003114 |	lda PointerA	;Store a copy of the next instruction's start
      F18B 8D 3F 00   003115 |	sta AddHold	; address.
      F18E AD 09 00   003116 |	lda PointerA+1d	;
      F191 8D 40 00   003117 |	sta AddHold+1d	;
                      003118 |	
      F194 AD 41 00   003119 |	lda ObCdHld1	;Check to see if branch is positive or negative.
      F197 30 12      003120 |	bmi NegBrnch	;
                      003121 |	
      F199            003122 |PosBrnch:		;If branch is positive then find address being
      F199 AD 3F 00   003123 |	lda AddHold	; branched to by adding offset to start address
      F19C 18         003124 |	clc		; of next instruction in memory.
      F19D 6D 41 00   003125 |	adc ObCdHld1	;
      F1A0 8D 3F 00   003126 |	sta AddHold	;
      F1A3 90 20      003127 |	bcc OutBrAdd	;
      F1A5 EE 40 00   003128 |	inc AddHold+1d	;
      F1A8 4C C5 F1   003129 |	jmp OutBrAdd	;
                      003130 |		
      F1AB            003131 |NegBrnch:
      F1AB CE 41 00   003132 |	dec ObCdHld1	;If branch is negative then find address being
      F1AE AD 41 00   003133 |	lda ObCdHld1	; branched to by subtracting offset from start
      F1B1 49 FF      003134 |	eor #0ffh	; address of next instruction in memory.
      F1B3 8D 41 00   003135 |	sta ObCdHld1	;
      F1B6 AD 3F 00   003136 |	lda AddHold	;
      F1B9 38         003137 |	sec		;
      F1BA ED 41 00   003138 |	sbc ObCdHld1	;
      F1BD 8D 3F 00   003139 |	sta AddHold	;
      F1C0 B0 03      003140 |	bcs OutBrAdd	;
      F1C2 CE 40 00   003141 |	dec AddHold+1d	;
                      003142 |	
      F1C5            003143 |OutBrAdd:
      F1C5 AD 40 00   003144 |	lda AddHold+1d	;Print address being branched to.
      F1C8 20 45 F3   003145 |	jsr OutHex	;
      F1CB AD 3F 00   003146 |	lda AddHold	;
      F1CE 20 45 F3   003147 |	jsr OutHex	;
                      003148 |	
      F1D1 A9 68      003149 |	lda #104d	;Print lower case h to indicate hex number.
      F1D3 20 FA F3   003150 |	jsr OutChar	;
                      003151 |
      F1D6 4C 06 F0   003152 |	jmp StartUnA
                      003153 |
                      003154 |
      F1D9            003155 |IRIAdMo:
      F1D9 A0 00      003156 |	ldy #0d
                      003157 |
      F1DB AD 43 00   003158 |	lda OpCdHold	;Print the opcode and a space.
      F1DE 20 45 F3   003159 |	jsr OutHex	;
      F1E1 A9 20      003160 |	lda #32d	;
      F1E3 20 FA F3   003161 |	jsr OutChar	;
                      003162 |	
      F1E6 B1 08      003163 |	lda (PointerA),y;Print the second byte of the instruction and
      F1E8 8D 41 00   003164 |	sta ObCdHld1	; increment the memory pointer.
      F1EB 20 45 F3   003165 |	jsr OutHex	;
      F1EE 20 C1 F2   003166 |	jsr IncPntrA	;
                      003167 |	
      F1F1 A0 05      003168 |	ldy #5d		;Print spaces between object code field and
      F1F3 20 E9 F2   003169 |	jsr OutSpace	; operator field.
                      003170 |	
      F1F6 20 AF F2   003171 |	jsr PrntMnem	;Print the operator.
                      003172 |	
      F1F9 A9 28      003173 |	lda #40d	;Print (.
      F1FB 20 FA F3   003174 |	jsr OutChar	;
                      003175 |	
      F1FE AD 41 00   003176 |	lda ObCdHld1	;Print offset into zero page.
      F201 20 45 F3   003177 |	jsr OutHex	;
                      003178 |	
      F204 A9 68      003179 |	lda #104d	;Print lower case h to indicate hex.
      F206 20 FA F3   003180 |	jsr OutChar	;
                      003181 |	
      F209 A9 29      003182 |	lda #41d	;Print ).
      F20B 20 FA F3   003183 |	jsr OutChar	;
                      003184 |	
      F20E A9 2C      003185 |	lda #44d	;Print comma and y.
      F210 20 FA F3   003186 |	jsr OutChar	;
      F213 A9 59      003187 |	lda #89d	;
      F215 20 FA F3   003188 |	jsr OutChar	;
                      003189 |	
      F218 4C 06 F0   003190 |	jmp StartUnA
                      003191 |	
      F21B            003192 |IIRAdMo:
      F21B A0 00      003193 |	ldy #0d
                      003194 |
      F21D AD 43 00   003195 |	lda OpCdHold	;Print the opcode and a space.
      F220 20 45 F3   003196 |	jsr OutHex	;
      F223 A9 20      003197 |	lda #32d	;
      F225 20 FA F3   003198 |	jsr OutChar	;
                      003199 |	
      F228 B1 08      003200 |	lda (PointerA),y;Print the second byte of the instruction and
      F22A 8D 41 00   003201 |	sta ObCdHld1	; increment the memory pointer.
      F22D 20 45 F3   003202 |	jsr OutHex	;
      F230 20 C1 F2   003203 |	jsr IncPntrA	;
                      003204 |	
      F233 A0 05      003205 |	ldy #5d		;Print spaces between object code field and
      F235 20 E9 F2   003206 |	jsr OutSpace	; operator field.
                      003207 |	
      F238 20 AF F2   003208 |	jsr PrntMnem	;Print the operator.
                      003209 |	
      F23B A9 28      003210 |	lda #40d	;Print (.
      F23D 20 FA F3   003211 |	jsr OutChar	;
                      003212 |	
      F240 AD 41 00   003213 |	lda ObCdHld1	;Print offset into zero page.
      F243 20 45 F3   003214 |	jsr OutHex	;
                      003215 |	
      F246 A9 68      003216 |	lda #104d	;Print lower case h to indicate hex.
      F248 20 FA F3   003217 |	jsr OutChar	;
                      003218 |	
      F24B A9 2C      003219 |	lda #44d	;Print comma and x.
      F24D 20 FA F3   003220 |	jsr OutChar	;
      F250 A9 58      003221 |	lda #88d	;
      F252 20 FA F3   003222 |	jsr OutChar	;
                      003223 |	
      F255 A9 29      003224 |	lda #41d	;Print ).
      F257 20 FA F3   003225 |	jsr OutChar	;
                      003226 |	
      F25A 4C 06 F0   003227 |	jmp StartUnA
                      003228 |
      F25D            003229 |IndAdMo:
      F25D A0 00      003230 |	ldy #0d
                      003231 |
      F25F AD 43 00   003232 |	lda OpCdHold	;Print the opcode and a space.
      F262 20 45 F3   003233 |	jsr OutHex	;
      F265 A9 20      003234 |	lda #32d	;
      F267 20 FA F3   003235 |	jsr OutChar	;
                      003236 |	
      F26A B1 08      003237 |	lda (PointerA),y;Print the second byte of the instruction and
      F26C 8D 41 00   003238 |	sta ObCdHld1	; increment the memory pointer
      F26F 20 45 F3   003239 |	jsr OutHex	;
      F272 20 C1 F2   003240 |	jsr IncPntrA	;
                      003241 |	
      F275 A9 20      003242 |	lda #32d	;Print a space between obj codes.
      F277 20 FA F3   003243 |	jsr OutChar	;
                      003244 |	
      F27A B1 08      003245 |	lda (PointerA),y;Print the third byte of the instruction and
      F27C 8D 42 00   003246 |	sta ObCdHld2	; increment the memory pointer
      F27F 20 45 F3   003247 |	jsr OutHex	;
      F282 20 C1 F2   003248 |	jsr IncPntrA	;
                      003249 |	
      F285 A0 02      003250 |	ldy #2d		;Print spaces between object code field and
      F287 20 E9 F2   003251 |	jsr OutSpace	; operator field.
                      003252 |	
      F28A 20 AF F2   003253 |	jsr PrntMnem	;Print the operator.
                      003254 |
      F28D A9 28      003255 |	lda #40d	;Print (.
      F28F 20 FA F3   003256 |	jsr OutChar	;
                      003257 |	
      F292 AD 42 00   003258 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F295 20 45 F3   003259 |	jsr OutHex	;
      F298 AD 41 00   003260 |	lda ObCdHld1	;
      F29B 20 45 F3   003261 |	jsr OutHex	;
                      003262 |	
      F29E A9 68      003263 |	lda #104d	;Print lower case h to indicate hex number.
      F2A0 20 FA F3   003264 |	jsr OutChar	;
                      003265 |	
      F2A3 A9 29      003266 |	lda #41d	;Print ).
      F2A5 20 FA F3   003267 |	jsr OutChar	;
                      003268 |	
      F2A8 4C 06 F0   003269 |	jmp StartUnA
                      003270 |	
      F2AB            003271 |ErrUnAs:
      F2AB 18         003272 |	clc
      F2AC 60         003273 |	rts
                      003274 |
      F2AD            003275 |ExitUnAs:
      F2AD 38         003276 |	sec
      F2AE 60         003277 |	rts
                      003278 |
                      003279 |
                      003280 |;****************************************************************************
                      003281 |;                       Print Mnemonic Subroutine.
                      003282 |;****************************************************************************
      F2AF            003283 |PrntMnem:
                      003284 |
      F2AF A0 00      003285 |	ldy #0d		;Use loop to print all three characters of
      F2B1            003286 |PrntMore:
      F2B1 B1 0A      003287 |	lda (PointerB),y; mnemonic.
      F2B3 20 FA F3   003288 |	jsr OutChar	;
      F2B6 C8         003289 |	iny		;
      F2B7 C0 03      003290 |	cpy #3d		;
      F2B9 D0 F6      003291 |	bne PrntMore	;
                      003292 |	
      F2BB A9 20      003293 |	lda #32d	;Print a space after the mnemonic.
      F2BD 20 FA F3   003294 |	jsr OutChar	;
                      003295 |	
      F2C0 60         003296 |	rts
                      003297 |
                      003298 |;****************************************************************************
                      003299 |;                       Increment Pointer A Subroutine.
                      003300 |;****************************************************************************
      F2C1            003301 |IncPntrA:
      F2C1 EE 08 00   003302 |	inc PointerA
      F2C4 D0 03      003303 |	bne NoOvFl1
      F2C6 EE 09 00   003304 |	inc PointerA+1d
      F2C9            003305 |NoOvFl1:
      F2C9 60         003306 |	rts
                      003307 |
                      003308 |
                      003309 |
                      003310 |;****************************************************************************
                      003311 |;                        Get Address Subroutine
                      003312 |;
                      003313 |;	X returns LSB of address.  Y returns MSB of address.
                      003314 |;****************************************************************************
      F2CA            003315 |GetAdd:		;Convert address found in operand field #x
      F2CA 20 23 F3   003316 |	jsr AsToBin	; into binary.
      F2CD B0 03      003317 |	bcs AdMSBOK	;
      F2CF 4C DF F2   003318 |	jmp ErrGtAd	;
      F2D2            003319 |AdMSBOK:		;
      F2D2 A8         003320 |	tay		;
      F2D3 E8         003321 |	inx		;
      F2D4 20 23 F3   003322 |	jsr AsToBin	;
      F2D7 B0 03      003323 |	bcs AdLSBOK	;
      F2D9 4C DF F2   003324 |	jmp ErrGtAd	;
      F2DC            003325 |AdLSBOK:		;
      F2DC AA         003326 |	tax
                      003327 |
      F2DD 38         003328 |	sec		;If conversion OK then set carry flag and
      F2DE 60         003329 |	rts		; return.
                      003330 |	
      F2DF            003331 |ErrGtAd:		;
      F2DF 18         003332 |	clc		;If error then clear carry and return.
      F2E0 60         003333 |	rts		;
                      003334 |
                      003335 |
                      003336 |;****************************************************************************
                      003337 |;                     Output a Colon Prompt Subroutine.
                      003338 |;****************************************************************************
      F2E1            003339 |OutColn:
      F2E1 A2 83      003340 |	ldx #ColnPrmt<
      F2E3 A0 F5      003341 |	ldy #ColnPrmt>
      F2E5 20 99 F3   003342 |	jsr PrntMess
      F2E8 60         003343 |	rts
                      003344 |
                      003345 |;****************************************************************************
                      003346 |;                     Out Spaces Subroutine
                      003347 |;
                      003348 |;       Enter with the Y register indicating the number of spaces to output.
                      003349 |;****************************************************************************
      F2E9            003350 |OutSpace:		;Output the number of spaces indicated by
      F2E9 48         003351 |	pha		; the Y register.
      F2EA            003352 |OtAnoSpc:
      F2EA A9 20      003353 |	lda #32d
      F2EC 20 FA F3   003354 |	jsr OutChar
      F2EF 88         003355 |	dey
      F2F0 D0 F8      003356 |	bne OtAnoSpc
      F2F2 68         003357 |	pla
      F2F3 60         003358 |	rts
                      003359 |
                      003360 |
                      003361 |;****************************************************************************
                      003362 |;              Covert ASCII character to lower case Subroutine.
                      003363 |;****************************************************************************
      F2F4            003364 |ToLower:
      F2F4 C9 41      003365 |	cmp #65d
      F2F6 30 07      003366 |	bmi ExitToLo
      F2F8 C9 5B      003367 |	cmp #91d
      F2FA 10 03      003368 |	bpl ExitToLo
      F2FC 18         003369 |	clc
      F2FD 69 20      003370 |	adc #32d
      F2FF            003371 |ExitTolo:
      F2FF 60         003372 |	rts
                      003373 |
                      003374 |
                      003375 |;****************************************************************************
                      003376 |;              Covert ASCII character to upper case Subroutine.
                      003377 |;****************************************************************************
      F300            003378 |ToUpper:
      F300 C9 61      003379 |	cmp #'a'
      F302 30 07      003380 |	bmi ExitToUp
      F304 C9 7B      003381 |	cmp #123d
      F306 10 03      003382 |	bpl ExitToUp
      F308 38         003383 |	sec
      F309 E9 20      003384 |	sbc #32d
      F30B            003385 |ExitToUp:
      F30B 60         003386 |	rts
                      003387 |
                      003388 |
                      003389 |
                      003390 |;****************************************************************************
                      003391 |;                         Print address.
                      003392 |;****************************************************************************
      F30C            003393 |PrntAdd:
      F30C AD 09 00   003394 |	lda PointerA+1d	;
      F30F 20 45 F3   003395 |	jsr OutHex	;
      F312 AD 08 00   003396 |	lda PointerA	;
      F315 20 45 F3   003397 |	jsr OutHex	;
      F318 A9 20      003398 |	lda #32d	;
      F31A 20 FA F3   003399 |	jsr OutChar	;
      F31D A9 20      003400 |	lda #32d	;
      F31F 20 FA F3   003401 |	jsr OutChar	;
                      003402 |	
      F322 60         003403 |	rts
                      003404 |
                      003405 |;****************************************************************************
                      003406 |;                         Ascii to Binary Subroutine.
                      003407 |;****************************************************************************
      F323            003408 |AsToBin:		;X points to digits to be converted using
                      003409 |			; OpFld1 as a base.
                      003410 |
      F323 BD 5F 00   003411 |	lda OpFld1,x	;Convert most significant digit to binary.
      F326 20 79 EA   003412 |	jsr DgtToBin	;
      F329 90 19      003413 |	bcc ExtAs2Bn	;
      F32B 0A         003414 |	asl a		;
      F32C 0A         003415 |	asl a		;
      F32D 0A         003416 |	asl a		;
      F32E 0A         003417 |	asl a		;
      F32F 29 F0      003418 |	and #0f0h	;
      F331 8D 9C 00   003419 |	sta number	;
                      003420 |	
      F334 E8         003421 |	inx		;Convert least significant digit to binary.
      F335 BD 5F 00   003422 |	lda OpFld1,x	;
      F338 20 79 EA   003423 |	jsr DgtToBin	;
      F33B 90 07      003424 |	bcc ExtAs2Bn	;
      F33D 0D 9C 00   003425 |	ora number	;
                      003426 |	
      F340 8D 9C 00   003427 |	sta number	;Store full binary number in number.
      F343 38         003428 |	sec
      F344            003429 |ExtAs2Bn:
      F344 60         003430 |	rts
                      003431 |	
                      003432 |;****************************************************************************
                      003433 |;                     Output a Hex byte to the serial port.
                      003434 |;
                      003435 |;            Enter with the number to be output in the A register.
                      003436 |;****************************************************************************
      F345            003437 |OutHex:
      F345 8D 9C 00   003438 |	sta number
                      003439 |	
      F348 4A         003440 |	lsr a		;Output most significant digit of hex byte to
      F349 4A         003441 |	lsr a		; serial port.
      F34A 4A         003442 |	lsr a		;
      F34B 4A         003443 |	lsr a		;
      F34C 29 0F      003444 |	and #0fh	;
      F34E C9 0A      003445 |	cmp #0ah	;
      F350 10 05      003446 |	bpl Letter1	;
      F352 09 30      003447 |	ora #30h	;
      F354 4C 5C F3   003448 |	jmp Print1st	;
      F357            003449 |Letter1:		;
      F357 38         003450 |	sec
      F358 E9 09      003451 |	sbc #9d		;
      F35A 09 40      003452 |	ora #40h
      F35C            003453 |Print1st:
      F35C 20 FA F3   003454 |	jsr OutChar	;
                      003455 |	
      F35F AD 9C 00   003456 |	lda number	;Output least significant digit of hex byte to
      F362 29 0F      003457 |	and #0fh	; serial port.
      F364 C9 0A      003458 |	cmp #0ah	;
      F366 10 05      003459 |	bpl Letter2	;
      F368 09 30      003460 |	ora #30h	;
      F36A 4C 72 F3   003461 |	jmp Print2nd	;
      F36D            003462 |Letter2:		;
      F36D 38         003463 |	sec
      F36E E9 09      003464 |	sbc #9d		;
      F370 09 40      003465 |	ora #40h	;
      F372            003466 |Print2nd:		;
      F372 20 FA F3   003467 |	jsr OutChar	;
                      003468 |	
      F375 AD 9C 00   003469 |	lda number
      F378 60         003470 |	rts
                      003471 |	
                      003472 |;****************************************************************************
                      003473 |;                     Initialize Variables Subroutine
                      003474 |;****************************************************************************
      F379            003475 |InitVars:
                      003476 |
                      003477 |	;lda #1ah	;Initialize ACIA control register, 2400
                      003478 |	;sta 6551CtR	; Baud.
                      003479 |	
                      003480 |	;lda #0bh	;Initialize ACIA command register.
                      003481 |	;sta 6551CmR	;
                      003482 |		
      F379 A9 04      003483 |	lda #BRK<	;Initialize BRK vector.
      F37B 8D 04 00   003484 |	sta BRKVect	;
      F37E A9 E2      003485 |	lda #BRK>	;
      F380 8D 05 00   003486 |	sta BRKVect+1d	;
                      003487 |	
      F383 A9 00      003488 |	lda #0d		;Initialize trace break flag.
      F385 8D 39 00   003489 |	sta TrBrkFlg	;
                      003490 |	
      F388 A9 00      003491 |	lda #0d		;Initialize break point status variables.
      F38A 8D 2F 00   003492 |	sta BrkPt1St	;
      F38D 8D 30 00   003493 |	sta BrkPt2St	;
      F390 8D 31 00   003494 |	sta BrkPt3St	;
      F393 8D 32 00   003495 |	sta BrkPt4St	;
                      003496 |	
      F396 A9 00      003497 |	lda #0d		;Set the output port to all zeros (turn
                      003498 |	;sta OutPort0	; off all of the LEDs).
                      003499 |	
      F398 60         003500 |	rts
                      003501 |
                      003502 |;****************************************************************************
                      003503 |;                          Print Message Subroutine.
                      003504 |;
                      003505 |; X holds the message pointer's low byte (< means less than) and Y holds its 
                      003506 |; high byte (> means greater than).  The message must have a NULL (0) after 
                      003507 |; the last character in the  Message so the PrntMess subroutine knows when to 
                      003508 |; stop printing.
                      003509 |;****************************************************************************
      F399            003510 |PrntMess:
      F399 48         003511 |	pha
                      003512 |	
      F39A 8E 06 00   003513 |	stx MessPtr	;Initialize pointer that will point to each
      F39D 8C 07 00   003514 |	sty MessPtr+1h	; character of message.
                      003515 |	
      F3A0 A0 00      003516 |	ldy #0h
                      003517 |	
      F3A2            003518 |OutMess:		;
      F3A2 B1 06      003519 |	lda (MessPtr),y	;Get a character from the message and if it is
      F3A4 F0 0E      003520 |	beq ExitMess	; a NULL (0) then exit this subroutine.
                      003521 |	
      F3A6 20 FA F3   003522 |	jsr OutChar	;Output the character to the serial port.
                      003523 |	
      F3A9 EE 06 00   003524 |	inc MessPtr	;Increment the message pointer to point to the
      F3AC D0 03      003525 |	bne PrNoOvf	; next character in the message.
      F3AE EE 07 00   003526 |	inc MessPtr+1d	;
                      003527 |	
      F3B1            003528 |PrNoOvf:
      F3B1 4C A2 F3   003529 |	jmp OutMess
                      003530 |		
      F3B4            003531 |ExitMess:
      F3B4 68         003532 |	pla
                      003533 |	
      F3B5 60         003534 |	rts
                      003535 |
                      003536 |;****************************************************************************
                      003537 |;           Get Character (Don't Wait) From Serial Channel Subroutine
                      003538 |;****************************************************************************
      F3B6            003539 |GetChar:
      F3B6 08         003540 |	php		;Save the registers on the stack.
      F3B7 8A         003541 |	txa		;
      F3B8 48         003542 |	pha		;
      F3B9 98         003543 |	tya		;
      F3BA 48         003544 |	pha		;
                      003545 |	
      F3BB AD 01 A0   003546 |	lda 6551StR	;Check ACIA to see if a character has been
      F3BE 29 08      003547 |	and #00001000b	; received and return with a NULL if no
      F3C0 F0 09      003548 |	beq NoChar	; character was present.
                      003549 |	
      F3C2 AD 00 A0   003550 |	lda 6551TRR	;Get the received character from the ACIA's 
      F3C5 8D CE 00   003551 |	sta RegTemp	; receive register.
      F3C8 4C D0 F3   003552 |	jmp ExitGtCh	;
                      003553 |	
      F3CB            003554 |NoChar:
      F3CB A9 00      003555 |	lda #0d
      F3CD 8D CE 00   003556 |	sta RegTemp
                      003557 |	
      F3D0            003558 |ExitGtCh:
      F3D0 68         003559 |	pla		;Restore the registers.
      F3D1 A8         003560 |	tay		;
      F3D2 68         003561 |	pla		;
      F3D3 AA         003562 |	tax		;
      F3D4 28         003563 |	plp		;
      F3D5 AD CE 00   003564 |	lda RegTemp	;
                      003565 |	
      F3D8 60         003566 |	rts
                      003567 |	
                      003568 |;****************************************************************************
                      003569 |;             Get Character (Wait) From Serial Channel Subroutine
                      003570 |;****************************************************************************
      F3D9            003571 |GetCharW:
      F3D9 08         003572 |	php		;Save the registers on the stack.
      F3DA 8A         003573 |	txa		;
      F3DB 48         003574 |	pha		;
      F3DC 98         003575 |	tya		;
      F3DD 48         003576 |	pha		;
                      003577 |	
      F3DE            003578 |GtCkAgn:	
      F3DE AD 01 A0   003579 |	lda 6551StR	;Check the ACIA's receiver buffer full register
      F3E1 29 08      003580 |	and #00001000b	; and wait until a character is received.
      F3E3 D0 06      003581 |	bne CharRec	;
                      003582 |	
      F3E5 AD 02 A0   003583 |	lda 6551Sleep ;Allow the emulator to be put to sleep.
      F3E8 4C DE F3   003584 |	jmp GtCkAgn
                      003585 |	
      F3EB            003586 |CharRec:
      F3EB AD 00 A0   003587 |	lda 6551TRR	;Get the received character from the ACIA's 
      F3EE 8D CE 00   003588 |	sta RegTemp	; receive register.
                      003589 |	
      F3F1 68         003590 |	pla		;Restore the registers.
      F3F2 A8         003591 |	tay		;
      F3F3 68         003592 |	pla		;
      F3F4 AA         003593 |	tax		;
      F3F5 28         003594 |	plp		;
      F3F6 AD CE 00   003595 |	lda RegTemp	;
                      003596 |	
      F3F9 60         003597 |	rts
                      003598 |	
                      003599 |;****************************************************************************
                      003600 |;                 Output Character to Serial Channel Subroutine 
                      003601 |;                   Character to print is in register 'A'
                      003602 |;****************************************************************************
      F3FA            003603 |OutChar:
                      003604 |	
      F3FA 8D CE 00   003605 |	sta RegTemp	;Save registers.
      F3FD 08         003606 |	php		;
      F3FE 98         003607 |	tya		;
      F3FF 48         003608 |	pha		;
      F400 8A         003609 |	txa		;
      F401 48         003610 |	pha		;
                      003611 |	
      F402            003612 |OtCkAgn:
      F402 AD 01 A0   003613 |	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
      F405 29 10      003614 |	and #00010000b	; register and wait until the buffer is empty.
      F407 F0 F9      003615 |	beq OtCkAgn	;
                      003616 |	
      F409 AD CE 00   003617 |	lda RegTemp	;Output a character to the ACIA's Transmitt
      F40C 8D 00 A0   003618 |	sta 6551TRR	; register.
                      003619 |	
      F40F 68         003620 |	pla		;Restore registers.
      F410 AA         003621 |	tax		;
      F411 68         003622 |	pla		;
      F412 A8         003623 |	tay		;
      F413 28         003624 |	plp		;
      F414 AD CE 00   003625 |	lda RegTemp	;
                      003626 |		
      F417 60         003627 |	rts
                      003628 |
                      003629 |
                      003630 |;****************************************************************************
                      003631 |;                          Delay Subroutine
                      003632 |;****************************************************************************
      F418            003633 |delay:
      F418 48         003634 |	pha
      F419 8A         003635 |	txa
      F41A 48         003636 |	pha
      F41B 98         003637 |	tya
      F41C 48         003638 |	pha
                      003639 |	
      F41D A9 00      003640 |	lda #0h
      F41F 8D A2 00   003641 |	sta wait0
      F422 A9 10      003642 |	lda #10h
      F424 8D A3 00   003643 |	sta wait1
                      003644 |	
                      003645 |	
      F427            003646 |dw0:
      F427 CE A2 00   003647 |	dec wait0
      F42A D0 FB      003648 |	bne dw0
      F42C CE A3 00   003649 |	dec wait1
      F42F D0 F6      003650 |	bne dw0
                      003651 |	
      F431 68         003652 |	pla
      F432 A8         003653 |	tay
      F433 68         003654 |	pla                                                                        
      F434 AA         003655 |	tax
      F435 68         003656 |	pla
      F436 60         003657 |	rts
                      003658 |
                      003659 |
                      003660 |;****************************************************************************
                      003661 |;                Constants
                      003662 |;****************************************************************************
                      003663 |
      F437 16         003664 |UARTval:	dbt 16h,0bh
      F438 0B               
      F439 30         003665 |DgtTblUC:	dbt "0123456789ABCDEF"
      F43A 31 32 33         
      F43D 34 35 36         
      F440 37 38 39         
      F443 41 42 43         
      F446 44 45 46         
      F449 00         003666 |			dbt 0h
      F44A 30         003667 |DgtTblLC:	dbt "0123456789abcdef"
      F44B 31 32 33         
      F44E 34 35 36         
      F451 37 38 39         
      F454 61 62 63         
      F457 64 65 66         
      F45A 00         003668 |			dbt 0h
      F45B 0A         003669 |OpenMess:	dbt 10d,13d,10d
      F45C 0D               
      F45D 0A               
      F45E 55         003670 |			dbt "UMON65 V1.19 - Understandable Monitor for the 6500 series microprocessors."
      F45F 4D 4F 4E         
      F462 36 35 20         
      F465 56 31 2E         
      F468 31 39 20         
      F46B 2D 20 55         
      F46E 6E 64 65         
      F471 72 73 74         
      F474 61 6E 64         
      F477 61 62 6C         
      F47A 65 20 4D         
      F47D 6F 6E 69         
      F480 74 6F 72         
      F483 20 66 6F         
      F486 72 20 74         
      F489 68 65 20         
      F48C 36 35 30         
      F48F 30 20 73         
      F492 65 72 69         
      F495 65 73 20         
      F498 6D 69 63         
      F49B 72 6F 70         
      F49E 72 6F 63         
      F4A1 65 73 73         
      F4A4 6F 72 73         
      F4A7 2E               
      F4A8 0A         003671 |			dbt 10d,13d
      F4A9 0D               
      F4AA 00         003672 |			dbt 0h
      F4AB 0A         003673 |prompt:		dbt 10d,13d
      F4AC 0D               
      F4AD 2D         003674 |			dbt "-"
      F4AE 00         003675 |			dbt 0h
      F4AF 0A         003676 |CRLF:		dbt 10d,13d,0d
      F4B0 0D               
      F4B1 00               
      F4B2 0A         003677 |SRecStMs:	dbt 10d,13d
      F4B3 0D               
      F4B4 53         003678 |			dbt "Send S records when you are ready..."
      F4B5 65 6E 64         
      F4B8 20 53 20         
      F4BB 72 65 63         
      F4BE 6F 72 64         
      F4C1 73 20 77         
      F4C4 68 65 6E         
      F4C7 20 79 6F         
      F4CA 75 20 61         
      F4CD 72 65 20         
      F4D0 72 65 61         
      F4D3 64 79 2E         
      F4D6 2E 2E            
      F4D8 0A         003679 |			dbt 10d,13d,0d
      F4D9 0D               
      F4DA 00               
      F4DB 0A         003680 |SRecErMe:	dbt 10d,13d,7d
      F4DC 0D               
      F4DD 07               
      F4DE 45         003681 |			dbt "Error Loading S Records..."
      F4DF 72 72 6F         
      F4E2 72 20 4C         
      F4E5 6F 61 64         
      F4E8 69 6E 67         
      F4EB 20 53 20         
      F4EE 52 65 63         
      F4F1 6F 72 64         
      F4F4 73 2E 2E         
      F4F7 2E               
      F4F8 0A         003682 |			dbt 10d,13d,0d
      F4F9 0D               
      F4FA 00               
      F4FB 0A         003683 |SRecEnMs:	dbt 10d,13d,7d
      F4FC 0D               
      F4FD 07               
      F4FE 53         003684 |			dbt "S records successfully loaded (press <enter> to continue)."
      F4FF 20 72 65         
      F502 63 6F 72         
      F505 64 73 20         
      F508 73 75 63         
      F50B 63 65 73         
      F50E 73 66 75         
      F511 6C 6C 79         
      F514 20 6C 6F         
      F517 61 64 65         
      F51A 64 20 28         
      F51D 70 72 65         
      F520 73 73 20         
      F523 3C 65 6E         
      F526 74 65 72         
      F529 3E 20 74         
      F52C 6F 20 63         
      F52F 6F 6E 74         
      F532 69 6E 75         
      F535 65 29 2E         
      F538 00         003685 |			dbt 0d
      F539 0A         003686 |RegMess:		dbt 10d,13d,10d
      F53A 0D               
      F53B 0A               
      F53C 50         003687 |			dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
      F53D 67 6D 43         
      F540 6E 74 72         
      F543 28 50 43         
      F546 29 20 20         
      F549 41 63 63         
      F54C 75 6D 28         
      F54F 41 43 29         
      F552 20 20 58         
      F555 52 65 67         
      F558 28 58 52         
      F55B 29 20 20         
      F55E 59 52 65         
      F561 67 28 59         
      F564 52 29 20         
      F567 20 53 74         
      F56A 6B 50 74         
      F56D 72 28 53         
      F570 50 29 20         
      F573 20 4E 56         
      F576 2D 42 44         
      F579 49 5A 43         
      F57C 28 53 52         
      F57F 29               
      F580 0A         003688 |			dbt 10d,13d,0d
      F581 0D               
      F582 00               
      F583 0A         003689 |ColnPrmt:	dbt 10d,13d
      F584 0D               
      F585 20         003690 |			dbt " :"
      F586 3A               
      F587 00         003691 |			dbt 0d
      F588 20         003692 |BadOpMes:	dbt "        ???"
      F589 20 20 20         
      F58C 20 20 20         
      F58F 20 3F 3F         
      F592 3F               
      F593 00         003693 |			dbt 0d
      F594 0A         003694 |BPFulMes:	dbt 10d,13d
      F595 0D               
      F596 41         003695 |			dbt "All breakpoints are currently in use."
      F597 6C 6C 20         
      F59A 62 72 65         
      F59D 61 6B 70         
      F5A0 6F 69 6E         
      F5A3 74 73 20         
      F5A6 61 72 65         
      F5A9 20 63 75         
      F5AC 72 72 65         
      F5AF 6E 74 6C         
      F5B2 79 20 69         
      F5B5 6E 20 75         
      F5B8 73 65 2E         
      F5BB 00         003696 |			dbt 0d
      F5BC 0A         003697 |NoBPMess:	dbt 10d,13d
      F5BD 0D               
      F5BE 4E         003698 |			dbt "No breakpoint exists at this address."
      F5BF 6F 20 62         
      F5C2 72 65 61         
      F5C5 6B 70 6F         
      F5C8 69 6E 74         
      F5CB 20 65 78         
      F5CE 69 73 74         
      F5D1 73 20 61         
      F5D4 74 20 74         
      F5D7 68 69 73         
      F5DA 20 61 64         
      F5DD 64 72 65         
      F5E0 73 73 2E         
      F5E3 00         003699 |			dbt 0d
      F5E4 0A         003700 |GoBPErrM:	dbt 10d,13d
      F5E5 0D               
      F5E6 59         003701 |			dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
      F5E7 6F 75 20         
      F5EA 63 61 6E         
      F5ED 6E 6F 74         
      F5F0 20 47 4F         
      F5F3 20 61 74         
      F5F6 20 61 20         
      F5F9 62 72 65         
      F5FC 61 6B 70         
      F5FF 6F 69 6E         
      F602 74 65 64         
      F605 20 61 64         
      F608 64 72 65         
      F60B 73 73 2C         
      F60E 20 54 52         
      F611 41 43 45         
      F614 20 70 61         
      F617 73 74 20         
      F61A 69 74 20         
      F61D 74 68 65         
      F620 6E 20 47         
      F623 4F 2E            
      F625 00         003702 |			dbt 0d
      F626 0A         003703 |CmdErMes:	dbt 10d,13d
      F627 0D               
      F628 3F         003704 |			dbt "?"
      F629 00         003705 |			dbt 0d
      F62A 0A         003706 |HelpMess:	dbt 10d,13d,10d
      F62B 0D               
      F62C 0A               
      F62D 41         003707 |			dbt "Assemble       A start_address"
      F62E 73 73 65         
      F631 6D 62 6C         
      F634 65 20 20         
      F637 20 20 20         
      F63A 20 20 41         
      F63D 20 73 74         
      F640 61 72 74         
      F643 5F 61 64         
      F646 64 72 65         
      F649 73 73            
      F64B 0A         003708 |			dbt 10d,13d
      F64C 0D               
      F64D 42         003709 |			dbt "Breakpoint     B (+,-,?) address"
      F64E 72 65 61         
      F651 6B 70 6F         
      F654 69 6E 74         
      F657 20 20 20         
      F65A 20 20 42         
      F65D 20 28 2B         
      F660 2C 2D 2C         
      F663 3F 29 20         
      F666 61 64 64         
      F669 72 65 73         
      F66C 73               
      F66D 0A         003710 |			dbt 10d,13d
      F66E 0D               
      F66F 44         003711 |			dbt "Dump           D [start_address [end_address]]"
      F670 75 6D 70         
      F673 20 20 20         
      F676 20 20 20         
      F679 20 20 20         
      F67C 20 20 44         
      F67F 20 5B 73         
      F682 74 61 72         
      F685 74 5F 61         
      F688 64 64 72         
      F68B 65 73 73         
      F68E 20 5B 65         
      F691 6E 64 5F         
      F694 61 64 64         
      F697 72 65 73         
      F69A 73 5D 5D         
      F69D 0A         003712 |			dbt 10d,13d
      F69E 0D               
      F69F 45         003713 |			dbt "Enter          E address list"
      F6A0 6E 74 65         
      F6A3 72 20 20         
      F6A6 20 20 20         
      F6A9 20 20 20         
      F6AC 20 20 45         
      F6AF 20 61 64         
      F6B2 64 72 65         
      F6B5 73 73 20         
      F6B8 6C 69 73         
      F6BB 74               
      F6BC 0A         003714 |			dbt 10d,13d
      F6BD 0D               
      F6BE 46         003715 |			dbt "Fill           F start_address end_address list"
      F6BF 69 6C 6C         
      F6C2 20 20 20         
      F6C5 20 20 20         
      F6C8 20 20 20         
      F6CB 20 20 46         
      F6CE 20 73 74         
      F6D1 61 72 74         
      F6D4 5F 61 64         
      F6D7 64 72 65         
      F6DA 73 73 20         
      F6DD 65 6E 64         
      F6E0 5F 61 64         
      F6E3 64 72 65         
      F6E6 73 73 20         
      F6E9 6C 69 73         
      F6EC 74               
      F6ED 0A         003716 |			dbt 10d,13d
      F6EE 0D               
      F6EF 47         003717 |			dbt "Go             G [start_address]"
      F6F0 6F 20 20         
      F6F3 20 20 20         
      F6F6 20 20 20         
      F6F9 20 20 20         
      F6FC 20 20 47         
      F6FF 20 5B 73         
      F702 74 61 72         
      F705 74 5F 61         
      F708 64 64 72         
      F70B 65 73 73         
      F70E 5D               
      F70F 0A         003718 |			dbt 10d,13d
      F710 0D               
      F711 48         003719 |			dbt "Help           H or ?"
      F712 65 6C 70         
      F715 20 20 20         
      F718 20 20 20         
      F71B 20 20 20         
      F71E 20 20 48         
      F721 20 6F 72         
      F724 20 3F            
      F726 0A         003720 |			dbt 10d,13d
      F727 0D               
      F728 4C         003721 |			dbt "Load           L"
      F729 6F 61 64         
      F72C 20 20 20         
      F72F 20 20 20         
      F732 20 20 20         
      F735 20 20 4C         
      F738 0A         003722 |			dbt 10d,13d
      F739 0D               
      F73A 4D         003723 |			dbt "Move           M start_address end_address destination_address"
      F73B 6F 76 65         
      F73E 20 20 20         
      F741 20 20 20         
      F744 20 20 20         
      F747 20 20 4D         
      F74A 20 73 74         
      F74D 61 72 74         
      F750 5F 61 64         
      F753 64 72 65         
      F756 73 73 20         
      F759 65 6E 64         
      F75C 5F 61 64         
      F75F 64 72 65         
      F762 73 73 20         
      F765 64 65 73         
      F768 74 69 6E         
      F76B 61 74 69         
      F76E 6F 6E 5F         
      F771 61 64 64         
      F774 72 65 73         
      F777 73               
      F778 0A         003724 |			dbt 10d,13d
      F779 0D               
      F77A 52         003725 |			dbt "Register       R [PC,AC,XR,YR,SP,SR]"
      F77B 65 67 69         
      F77E 73 74 65         
      F781 72 20 20         
      F784 20 20 20         
      F787 20 20 52         
      F78A 20 5B 50         
      F78D 43 2C 41         
      F790 43 2C 58         
      F793 52 2C 59         
      F796 52 2C 53         
      F799 50 2C 53         
      F79C 52 5D            
      F79E 0A         003726 |			dbt 10d,13d
      F79F 0D               
      F7A0 53         003727 |			dbt "Search         S start_address end_address list"
      F7A1 65 61 72         
      F7A4 63 68 20         
      F7A7 20 20 20         
      F7AA 20 20 20         
      F7AD 20 20 53         
      F7B0 20 73 74         
      F7B3 61 72 74         
      F7B6 5F 61 64         
      F7B9 64 72 65         
      F7BC 73 73 20         
      F7BF 65 6E 64         
      F7C2 5F 61 64         
      F7C5 64 72 65         
      F7C8 73 73 20         
      F7CB 6C 69 73         
      F7CE 74               
      F7CF 0A         003728 |			dbt 10d,13d
      F7D0 0D               
      F7D1 54         003729 |			dbt "Trace          T [start_address [value]]"
      F7D2 72 61 63         
      F7D5 65 20 20         
      F7D8 20 20 20         
      F7DB 20 20 20         
      F7DE 20 20 54         
      F7E1 20 5B 73         
      F7E4 74 61 72         
      F7E7 74 5F 61         
      F7EA 64 64 72         
      F7ED 65 73 73         
      F7F0 20 5B 76         
      F7F3 61 6C 75         
      F7F6 65 5D 5D         
      F7F9 0A         003730 |			dbt 10d,13d
      F7FA 0D               
      F7FB 55         003731 |			dbt "Unassemble     U [start_address [end_address]]"
      F7FC 6E 61 73         
      F7FF 73 65 6D         
      F802 62 6C 65         
      F805 20 20 20         
      F808 20 20 55         
      F80B 20 5B 73         
      F80E 74 61 72         
      F811 74 5F 61         
      F814 64 64 72         
      F817 65 73 73         
      F81A 20 5B 65         
      F81D 6E 64 5F         
      F820 61 64 64         
      F823 72 65 73         
      F826 73 5D 5D         
      F829 0A         003732 |			dbt 10d,13d,0d
      F82A 0D               
      F82B 00               
                      003733 |	
                      003734 |
      F82C 41         003735 |OpTable:		dbt "ADC IMM"
      F82D 44 43 20         
      F830 49 4D 4D         
      F833 69         003736 |			dbt 069h,2h,2h
      F834 02               
      F835 02               
      F836 41         003737 |			dbt "ADC ABS"
      F837 44 43 20         
      F83A 41 42 53         
      F83D 6D         003738 |			dbt 06Dh,3h,4h
      F83E 03               
      F83F 04               
      F840 41         003739 |			dbt "ADC ABX"
      F841 44 43 20         
      F844 41 42 58         
      F847 7D         003740 |			dbt 07Dh,3h,4h
      F848 03               
      F849 04               
      F84A 41         003741 |			dbt "ADC ABY"
      F84B 44 43 20         
      F84E 41 42 59         
      F851 79         003742 |			dbt 079h,3h,4h
      F852 03               
      F853 04               
      F854 41         003743 |			dbt "ADC IIR"
      F855 44 43 20         
      F858 49 49 52         
      F85B 61         003744 |			dbt 061h,2h,6h
      F85C 02               
      F85D 06               
      F85E 41         003745 |			dbt "ADC IRI"
      F85F 44 43 20         
      F862 49 52 49         
      F865 71         003746 |			dbt 071h,2h,5h
      F866 02               
      F867 05               
      F868 41         003747 |			dbt "AND IMM"
      F869 4E 44 20         
      F86C 49 4D 4D         
      F86F 29         003748 |			dbt 029h,2h,2h
      F870 02               
      F871 02               
      F872 41         003749 |			dbt "AND ABS"
      F873 4E 44 20         
      F876 41 42 53         
      F879 2D         003750 |			dbt 02Dh,3h,4h
      F87A 03               
      F87B 04               
      F87C 41         003751 |			dbt "AND ABX"
      F87D 4E 44 20         
      F880 41 42 58         
      F883 3D         003752 |			dbt 03Dh,3h,4h
      F884 03               
      F885 04               
      F886 41         003753 |			dbt "AND ABY"
      F887 4E 44 20         
      F88A 41 42 59         
      F88D 39         003754 |			dbt 039h,3h,4h
      F88E 03               
      F88F 04               
      F890 41         003755 |			dbt "AND IIR"
      F891 4E 44 20         
      F894 49 49 52         
      F897 21         003756 |			dbt 021h,2h,6h
      F898 02               
      F899 06               
      F89A 41         003757 |			dbt "AND IRI"
      F89B 4E 44 20         
      F89E 49 52 49         
      F8A1 31         003758 |			dbt 031h,2h,5h
      F8A2 02               
      F8A3 05               
      F8A4 41         003759 |			dbt "ASL ACC"
      F8A5 53 4C 20         
      F8A8 41 43 43         
      F8AB 0A         003760 |			dbt 00Ah,1h,2h
      F8AC 01               
      F8AD 02               
      F8AE 41         003761 |			dbt "ASL ABS"
      F8AF 53 4C 20         
      F8B2 41 42 53         
      F8B5 0E         003762 |			dbt 00Eh,3h,6h
      F8B6 03               
      F8B7 06               
      F8B8 41         003763 |			dbt "ASL ABX"
      F8B9 53 4C 20         
      F8BC 41 42 58         
      F8BF 1E         003764 |			dbt 01Eh,3h,7h
      F8C0 03               
      F8C1 07               
      F8C2 42         003765 |			dbt "BCC REL"
      F8C3 43 43 20         
      F8C6 52 45 4C         
      F8C9 90         003766 |			dbt 090h,2h,2h
      F8CA 02               
      F8CB 02               
      F8CC 42         003767 |			dbt "BCS REL"
      F8CD 43 53 20         
      F8D0 52 45 4C         
      F8D3 B0         003768 |			dbt 0B0h,2h,2h
      F8D4 02               
      F8D5 02               
      F8D6 42         003769 |			dbt "BEQ REL"
      F8D7 45 51 20         
      F8DA 52 45 4C         
      F8DD F0         003770 |			dbt 0F0h,2h,2h
      F8DE 02               
      F8DF 02               
      F8E0 42         003771 |			dbt "BIT ABS"
      F8E1 49 54 20         
      F8E4 41 42 53         
      F8E7 2C         003772 |			dbt 02Ch,3h,4h
      F8E8 03               
      F8E9 04               
      F8EA 42         003773 |			dbt "BMI REL"
      F8EB 4D 49 20         
      F8EE 52 45 4C         
      F8F1 30         003774 |			dbt 030h,2h,2h
      F8F2 02               
      F8F3 02               
      F8F4 42         003775 |			dbt "BNE REL"
      F8F5 4E 45 20         
      F8F8 52 45 4C         
      F8FB D0         003776 |			dbt 0D0h,2h,2h
      F8FC 02               
      F8FD 02               
      F8FE 42         003777 |			dbt "BPL REL"
      F8FF 50 4C 20         
      F902 52 45 4C         
      F905 10         003778 |			dbt 010h,2h,2h
      F906 02               
      F907 02               
      F908 42         003779 |			dbt "BRK IMP"
      F909 52 4B 20         
      F90C 49 4D 50         
      F90F 00         003780 |			dbt 000h,1h,7h
      F910 01               
      F911 07               
      F912 42         003781 |			dbt "BVC REL"
      F913 56 43 20         
      F916 52 45 4C         
      F919 50         003782 |			dbt 050h,2h,2h
      F91A 02               
      F91B 02               
      F91C 42         003783 |			dbt "BVS REL"
      F91D 56 53 20         
      F920 52 45 4C         
      F923 70         003784 |			dbt 070h,2h,2h
      F924 02               
      F925 02               
      F926 43         003785 |			dbt "CLC IMP"
      F927 4C 43 20         
      F92A 49 4D 50         
      F92D 18         003786 |			dbt 018h,1h,2h
      F92E 01               
      F92F 02               
      F930 43         003787 |			dbt "CLD IMP"
      F931 4C 44 20         
      F934 49 4D 50         
      F937 D8         003788 |			dbt 0D8h,1h,2h
      F938 01               
      F939 02               
      F93A 43         003789 |			dbt "CLI IMP"
      F93B 4C 49 20         
      F93E 49 4D 50         
      F941 58         003790 |			dbt 058h,1h,2h
      F942 01               
      F943 02               
      F944 43         003791 |			dbt "CLV IMP"
      F945 4C 56 20         
      F948 49 4D 50         
      F94B B8         003792 |			dbt 0B8h,1h,2h
      F94C 01               
      F94D 02               
      F94E 43         003793 |			dbt "CMP IMM"
      F94F 4D 50 20         
      F952 49 4D 4D         
      F955 C9         003794 |			dbt 0C9h,2h,2h
      F956 02               
      F957 02               
      F958 43         003795 |			dbt "CMP ABS"
      F959 4D 50 20         
      F95C 41 42 53         
      F95F CD         003796 |			dbt 0CDh,3h,4h
      F960 03               
      F961 04               
      F962 43         003797 |			dbt "CMP ABX"
      F963 4D 50 20         
      F966 41 42 58         
      F969 DD         003798 |			dbt 0DDh,3h,4h
      F96A 03               
      F96B 04               
      F96C 43         003799 |			dbt "CMP ABY"
      F96D 4D 50 20         
      F970 41 42 59         
      F973 D9         003800 |			dbt 0D9h,3h,4h
      F974 03               
      F975 04               
      F976 43         003801 |			dbt "CMP IIR"
      F977 4D 50 20         
      F97A 49 49 52         
      F97D C1         003802 |			dbt 0C1h,2h,6h
      F97E 02               
      F97F 06               
      F980 43         003803 |			dbt "CMP IRI"
      F981 4D 50 20         
      F984 49 52 49         
      F987 D1         003804 |			dbt 0D1h,2h,5h
      F988 02               
      F989 05               
      F98A 43         003805 |			dbt "CPX IMM"
      F98B 50 58 20         
      F98E 49 4D 4D         
      F991 E0         003806 |			dbt 0E0h,2h,2h
      F992 02               
      F993 02               
      F994 43         003807 |			dbt "CPX ABS"
      F995 50 58 20         
      F998 41 42 53         
      F99B EC         003808 |			dbt 0ECh,3h,4h
      F99C 03               
      F99D 04               
      F99E 43         003809 |			dbt "CPY IMM"
      F99F 50 59 20         
      F9A2 49 4D 4D         
      F9A5 C0         003810 |			dbt 0C0h,2h,2h
      F9A6 02               
      F9A7 02               
      F9A8 43         003811 |			dbt "CPY ABS"
      F9A9 50 59 20         
      F9AC 41 42 53         
      F9AF CC         003812 |			dbt 0CCh,3h,4h
      F9B0 03               
      F9B1 04               
      F9B2 44         003813 |			dbt "DEC ABS"
      F9B3 45 43 20         
      F9B6 41 42 53         
      F9B9 CE         003814 |			dbt 0CEh,3h,6h
      F9BA 03               
      F9BB 06               
      F9BC 44         003815 |			dbt "DEC ABX"
      F9BD 45 43 20         
      F9C0 41 42 58         
      F9C3 DE         003816 |			dbt 0DEh,3h,7h
      F9C4 03               
      F9C5 07               
      F9C6 44         003817 |			dbt "DEX IMP"
      F9C7 45 58 20         
      F9CA 49 4D 50         
      F9CD CA         003818 |			dbt 0CAh,1h,2h
      F9CE 01               
      F9CF 02               
      F9D0 44         003819 |			dbt "DEY IMP"
      F9D1 45 59 20         
      F9D4 49 4D 50         
      F9D7 88         003820 |			dbt 088h,1h,2h
      F9D8 01               
      F9D9 02               
      F9DA 45         003821 |			dbt "EOR IMM"
      F9DB 4F 52 20         
      F9DE 49 4D 4D         
      F9E1 49         003822 |			dbt 049h,2h,2h
      F9E2 02               
      F9E3 02               
      F9E4 45         003823 |			dbt "EOR ABS"
      F9E5 4F 52 20         
      F9E8 41 42 53         
      F9EB 4D         003824 |			dbt 04Dh,3h,4h
      F9EC 03               
      F9ED 04               
      F9EE 45         003825 |			dbt "EOR ABX"
      F9EF 4F 52 20         
      F9F2 41 42 58         
      F9F5 5D         003826 |			dbt 05Dh,3h,4h
      F9F6 03               
      F9F7 04               
      F9F8 45         003827 |			dbt "EOR ABY"
      F9F9 4F 52 20         
      F9FC 41 42 59         
      F9FF 59         003828 |			dbt 059h,3h,4h
      FA00 03               
      FA01 04               
      FA02 45         003829 |			dbt "EOR IIR"
      FA03 4F 52 20         
      FA06 49 49 52         
      FA09 41         003830 |			dbt 041h,2h,6h
      FA0A 02               
      FA0B 06               
      FA0C 45         003831 |			dbt "EOR IRI"
      FA0D 4F 52 20         
      FA10 49 52 49         
      FA13 51         003832 |			dbt 051h,2h,5h
      FA14 02               
      FA15 05               
      FA16 49         003833 |			dbt "INC ABS"
      FA17 4E 43 20         
      FA1A 41 42 53         
      FA1D EE         003834 |			dbt 0EEh,3h,6h
      FA1E 03               
      FA1F 06               
      FA20 49         003835 |			dbt "INC ABX"
      FA21 4E 43 20         
      FA24 41 42 58         
      FA27 FE         003836 |			dbt 0FEh,3h,7h
      FA28 03               
      FA29 07               
      FA2A 49         003837 |			dbt "INX IMP"
      FA2B 4E 58 20         
      FA2E 49 4D 50         
      FA31 E8         003838 |			dbt 0E8h,1h,2h
      FA32 01               
      FA33 02               
      FA34 49         003839 |			dbt "INY IMP"
      FA35 4E 59 20         
      FA38 49 4D 50         
      FA3B C8         003840 |			dbt 0C8h,1h,2h
      FA3C 01               
      FA3D 02               
      FA3E 4A         003841 |			dbt "JMP ABS"
      FA3F 4D 50 20         
      FA42 41 42 53         
      FA45 4C         003842 |			dbt 04Ch,3h,3h
      FA46 03               
      FA47 03               
      FA48 4A         003843 |			dbt "JMP IND"
      FA49 4D 50 20         
      FA4C 49 4E 44         
      FA4F 6C         003844 |			dbt 06Ch,3h,5h
      FA50 03               
      FA51 05               
      FA52 4A         003845 |			dbt "JSR ABS"
      FA53 53 52 20         
      FA56 41 42 53         
      FA59 20         003846 |			dbt 020h,3h,6h
      FA5A 03               
      FA5B 06               
      FA5C 4C         003847 |			dbt "LDA IMM"
      FA5D 44 41 20         
      FA60 49 4D 4D         
      FA63 A9         003848 |			dbt 0A9h,2h,2h
      FA64 02               
      FA65 02               
      FA66 4C         003849 |			dbt "LDA ABS"
      FA67 44 41 20         
      FA6A 41 42 53         
      FA6D AD         003850 |			dbt 0ADh,3h,4h
      FA6E 03               
      FA6F 04               
      FA70 4C         003851 |			dbt "LDA ABX"
      FA71 44 41 20         
      FA74 41 42 58         
      FA77 BD         003852 |			dbt 0BDh,3h,4h
      FA78 03               
      FA79 04               
      FA7A 4C         003853 |			dbt "LDA ABY"
      FA7B 44 41 20         
      FA7E 41 42 59         
      FA81 B9         003854 |			dbt 0B9h,3h,4h
      FA82 03               
      FA83 04               
      FA84 4C         003855 |			dbt "LDA IIR"
      FA85 44 41 20         
      FA88 49 49 52         
      FA8B A1         003856 |			dbt 0A1h,2h,6h
      FA8C 02               
      FA8D 06               
      FA8E 4C         003857 |			dbt "LDA IRI"
      FA8F 44 41 20         
      FA92 49 52 49         
      FA95 B1         003858 |			dbt 0B1h,2h,5h
      FA96 02               
      FA97 05               
      FA98 4C         003859 |			dbt "LDX IMM"
      FA99 44 58 20         
      FA9C 49 4D 4D         
      FA9F A2         003860 |			dbt 0A2h,2h,2h
      FAA0 02               
      FAA1 02               
      FAA2 4C         003861 |			dbt "LDX ABS"
      FAA3 44 58 20         
      FAA6 41 42 53         
      FAA9 AE         003862 |			dbt 0AEh,3h,4h
      FAAA 03               
      FAAB 04               
      FAAC 4C         003863 |			dbt "LDX ABY"
      FAAD 44 58 20         
      FAB0 41 42 59         
      FAB3 BE         003864 |			dbt 0BEh,3h,4h
      FAB4 03               
      FAB5 04               
      FAB6 4C         003865 |			dbt "LDY IMM"
      FAB7 44 59 20         
      FABA 49 4D 4D         
      FABD A0         003866 |			dbt 0A0h,2h,2h
      FABE 02               
      FABF 02               
      FAC0 4C         003867 |			dbt "LDY ABS"
      FAC1 44 59 20         
      FAC4 41 42 53         
      FAC7 AC         003868 |			dbt 0ACh,3h,4h
      FAC8 03               
      FAC9 04               
      FACA 4C         003869 |			dbt "LDY ABX"
      FACB 44 59 20         
      FACE 41 42 58         
      FAD1 BC         003870 |			dbt 0BCh,3h,4h
      FAD2 03               
      FAD3 04               
      FAD4 4C         003871 |			dbt "LSR ACC"
      FAD5 53 52 20         
      FAD8 41 43 43         
      FADB 4A         003872 |			dbt 04Ah,1h,2h
      FADC 01               
      FADD 02               
      FADE 4C         003873 |			dbt "LSR ABS"
      FADF 53 52 20         
      FAE2 41 42 53         
      FAE5 4E         003874 |			dbt 04Eh,3h,6h
      FAE6 03               
      FAE7 06               
      FAE8 4C         003875 |			dbt "LSR ABX"
      FAE9 53 52 20         
      FAEC 41 42 58         
      FAEF 5E         003876 |			dbt 05Eh,3h,7h
      FAF0 03               
      FAF1 07               
      FAF2 4E         003877 |			dbt "NOP IMP"
      FAF3 4F 50 20         
      FAF6 49 4D 50         
      FAF9 EA         003878 |			dbt 0EAh,1h,2h
      FAFA 01               
      FAFB 02               
      FAFC 4F         003879 |			dbt "ORA IMM"
      FAFD 52 41 20         
      FB00 49 4D 4D         
      FB03 09         003880 |			dbt 009h,2h,2h
      FB04 02               
      FB05 02               
      FB06 4F         003881 |			dbt "ORA ABS"
      FB07 52 41 20         
      FB0A 41 42 53         
      FB0D 0D         003882 |			dbt 00Dh,3h,4h
      FB0E 03               
      FB0F 04               
      FB10 4F         003883 |			dbt "ORA ABX"
      FB11 52 41 20         
      FB14 41 42 58         
      FB17 1D         003884 |			dbt 01Dh,3h,4h
      FB18 03               
      FB19 04               
      FB1A 4F         003885 |			dbt "ORA ABY"
      FB1B 52 41 20         
      FB1E 41 42 59         
      FB21 19         003886 |			dbt 019h,3h,4h
      FB22 03               
      FB23 04               
      FB24 4F         003887 |			dbt "ORA IIR"
      FB25 52 41 20         
      FB28 49 49 52         
      FB2B 01         003888 |			dbt 001h,2h,6h
      FB2C 02               
      FB2D 06               
      FB2E 4F         003889 |			dbt "ORA IRI"
      FB2F 52 41 20         
      FB32 49 52 49         
      FB35 11         003890 |			dbt 011h,2h,5h
      FB36 02               
      FB37 05               
      FB38 50         003891 |			dbt "PHA IMP"
      FB39 48 41 20         
      FB3C 49 4D 50         
      FB3F 48         003892 |			dbt 048h,1h,3h
      FB40 01               
      FB41 03               
      FB42 50         003893 |			dbt "PHP IMP"
      FB43 48 50 20         
      FB46 49 4D 50         
      FB49 08         003894 |			dbt 008h,1h,3h
      FB4A 01               
      FB4B 03               
      FB4C 50         003895 |			dbt "PLA IMP"
      FB4D 4C 41 20         
      FB50 49 4D 50         
      FB53 68         003896 |			dbt 068h,1h,4h
      FB54 01               
      FB55 04               
      FB56 50         003897 |			dbt "PLP IMP"
      FB57 4C 50 20         
      FB5A 49 4D 50         
      FB5D 28         003898 |			dbt 028h,1h,4h
      FB5E 01               
      FB5F 04               
      FB60 52         003899 |			dbt "ROL ACC"
      FB61 4F 4C 20         
      FB64 41 43 43         
      FB67 2A         003900 |			dbt 02Ah,1h,2h
      FB68 01               
      FB69 02               
      FB6A 52         003901 |			dbt "ROL ABS"
      FB6B 4F 4C 20         
      FB6E 41 42 53         
      FB71 2E         003902 |			dbt 02Eh,3h,6h
      FB72 03               
      FB73 06               
      FB74 52         003903 |			dbt "ROL ABX"
      FB75 4F 4C 20         
      FB78 41 42 58         
      FB7B 3E         003904 |			dbt 03Eh,3h,7h
      FB7C 03               
      FB7D 07               
      FB7E 52         003905 |			dbt "ROR ACC"
      FB7F 4F 52 20         
      FB82 41 43 43         
      FB85 6A         003906 |			dbt 06Ah,1h,2h
      FB86 01               
      FB87 02               
      FB88 52         003907 |			dbt "ROR ABS"
      FB89 4F 52 20         
      FB8C 41 42 53         
      FB8F 6E         003908 |			dbt 06Eh,3h,6h
      FB90 03               
      FB91 06               
      FB92 52         003909 |			dbt "ROR ABX"
      FB93 4F 52 20         
      FB96 41 42 58         
      FB99 7E         003910 |			dbt 07Eh,3h,7h
      FB9A 03               
      FB9B 07               
      FB9C 52         003911 |			dbt "RTI IMP"
      FB9D 54 49 20         
      FBA0 49 4D 50         
      FBA3 40         003912 |			dbt 040h,1h,6h
      FBA4 01               
      FBA5 06               
      FBA6 52         003913 |			dbt "RTS IMP"
      FBA7 54 53 20         
      FBAA 49 4D 50         
      FBAD 60         003914 |			dbt 060h,1h,6h
      FBAE 01               
      FBAF 06               
      FBB0 53         003915 |			dbt "SBC IMM"
      FBB1 42 43 20         
      FBB4 49 4D 4D         
      FBB7 E9         003916 |			dbt 0E9h,2h,2h
      FBB8 02               
      FBB9 02               
      FBBA 53         003917 |			dbt "SBC ABS"
      FBBB 42 43 20         
      FBBE 41 42 53         
      FBC1 ED         003918 |			dbt 0EDh,3h,4h
      FBC2 03               
      FBC3 04               
      FBC4 53         003919 |			dbt "SBC ABX"
      FBC5 42 43 20         
      FBC8 41 42 58         
      FBCB FD         003920 |			dbt 0FDh,3h,4h
      FBCC 03               
      FBCD 04               
      FBCE 53         003921 |			dbt "SBC ABY"
      FBCF 42 43 20         
      FBD2 41 42 59         
      FBD5 F9         003922 |			dbt 0F9h,3h,4h
      FBD6 03               
      FBD7 04               
      FBD8 53         003923 |			dbt "SBC IIR"
      FBD9 42 43 20         
      FBDC 49 49 52         
      FBDF E1         003924 |			dbt 0E1h,2h,6h
      FBE0 02               
      FBE1 06               
      FBE2 53         003925 |			dbt "SBC IRI"
      FBE3 42 43 20         
      FBE6 49 52 49         
      FBE9 F1         003926 |			dbt 0F1h,2h,5h
      FBEA 02               
      FBEB 05               
      FBEC 53         003927 |			dbt "SEC IMP"
      FBED 45 43 20         
      FBF0 49 4D 50         
      FBF3 38         003928 |			dbt 038h,1h,2h
      FBF4 01               
      FBF5 02               
      FBF6 53         003929 |			dbt "SED IMP"
      FBF7 45 44 20         
      FBFA 49 4D 50         
      FBFD F8         003930 |			dbt 0F8h,1h,2h
      FBFE 01               
      FBFF 02               
      FC00 53         003931 |			dbt "SEI IMP"
      FC01 45 49 20         
      FC04 49 4D 50         
      FC07 78         003932 |			dbt 078h,1h,2h
      FC08 01               
      FC09 02               
      FC0A 53         003933 |			dbt "STA ABS"
      FC0B 54 41 20         
      FC0E 41 42 53         
      FC11 8D         003934 |			dbt 08Dh,3h,4h
      FC12 03               
      FC13 04               
      FC14 53         003935 |			dbt "STA ABX"
      FC15 54 41 20         
      FC18 41 42 58         
      FC1B 9D         003936 |			dbt 09Dh,3h,5h
      FC1C 03               
      FC1D 05               
      FC1E 53         003937 |			dbt "STA ABY"
      FC1F 54 41 20         
      FC22 41 42 59         
      FC25 99         003938 |			dbt 099h,3h,5h
      FC26 03               
      FC27 05               
      FC28 53         003939 |			dbt "STA IIR"
      FC29 54 41 20         
      FC2C 49 49 52         
      FC2F 81         003940 |			dbt 081h,2h,6h
      FC30 02               
      FC31 06               
      FC32 53         003941 |			dbt "STA IRI"
      FC33 54 41 20         
      FC36 49 52 49         
      FC39 91         003942 |			dbt 091h,2h,6h
      FC3A 02               
      FC3B 06               
      FC3C 53         003943 |			dbt "STX ABS"
      FC3D 54 58 20         
      FC40 41 42 53         
      FC43 8E         003944 |			dbt 08Eh,3h,4h
      FC44 03               
      FC45 04               
      FC46 53         003945 |			dbt "STY ABS"
      FC47 54 59 20         
      FC4A 41 42 53         
      FC4D 8C         003946 |			dbt 08Ch,3h,4h
      FC4E 03               
      FC4F 04               
      FC50 54         003947 |			dbt "TAX IMP"
      FC51 41 58 20         
      FC54 49 4D 50         
      FC57 AA         003948 |			dbt 0AAh,1h,2h
      FC58 01               
      FC59 02               
      FC5A 54         003949 |			dbt "TAY IMP"
      FC5B 41 59 20         
      FC5E 49 4D 50         
      FC61 A8         003950 |			dbt 0A8h,1h,2h
      FC62 01               
      FC63 02               
      FC64 54         003951 |			dbt "TSX IMP"
      FC65 53 58 20         
      FC68 49 4D 50         
      FC6B BA         003952 |			dbt 0BAh,1h,2h
      FC6C 01               
      FC6D 02               
      FC6E 54         003953 |			dbt "TXA IMP"
      FC6F 58 41 20         
      FC72 49 4D 50         
      FC75 8A         003954 |			dbt 08Ah,1h,2h
      FC76 01               
      FC77 02               
      FC78 54         003955 |			dbt "TXS IMP"
      FC79 58 53 20         
      FC7C 49 4D 50         
      FC7F 9A         003956 |			dbt 09Ah,1h,2h
      FC80 01               
      FC81 02               
      FC82 54         003957 |			dbt "TYA IMP"
      FC83 59 41 20         
      FC86 49 4D 50         
      FC89 98         003958 |			dbt 098h,1h,2h
      FC8A 01               
      FC8B 02               
      FC8C 5A         003959 |			dbt "ZZZ ZZZ"
      FC8D 5A 5A 20         
      FC90 5A 5A 5A         
      FC93 00         003960 |			dbt 000h,0h,0h
      FC94 00               
      FC95 00               
                      003961 |		
                      003962 |;****************************************************************************
                      003963 |;       Initialize 6502 reset vector and maskable interrupt vector.
                      003964 |;****************************************************************************
      FFFC            003965 |			org 0fffch	;Initialize reset vector.
      FFFC 00         003966 |			dbt 00h,0e0h	;                                                                                         
      FFFD E0               
                      003967 |;	
      FFFE            003968 |			org 0fffeh	;Initialize maskable interrupt vector.
      FFFE F1         003969 |			dbt #MaskInt<	;
      FFFF E1         003970 |			dbt #MaskInt>	;
                      003971 |			end
                      003972 |		
                      003973 |; ,output="array",start_address="E000"
      
      *** Executable code ***
      
      %s19,descrption="Execute this fold to send program to U6502 monitor.",preserve="false",output="array",start_address="E000"
      	S007000055415347C8
      	S11700000000000000000000000000000000000000000000E8
      	S11700140000000000000000000000000000000000000000D4
      	S11700280000000000000000000000000000000000000000C0
      	S117003C0000000000000000000000000000000000000000AC
      	S1170050000000000000000000000000000000000000000098
      	S1170064000000000000000000000000000000000000000084
      	S1170078000000000000000000000000000000000000000070
      	S117008C00000000000000000000000000000000000000005C
      	S11700A0000000000000000000000000000000000000000048
      	S11700B4000000000000000000000000000000000000000034
      	S10B00C800000000000000002C
      	S117E0004C1BE04CFAF34CB6F34CD9F34C99F34CE9F24C45EB
      	S117E014F34C79EA4C8EE0A2FF9AD82079F3AD00AAC900F0E9
      	S117E028034C00C0A25BA0F42099F3A9008D4B00A9008D4796
      	S117E03C008D48008D4900A9FF8D4A004C27E2C902D0132976
      	S117E050F04A4A4A1869C08D0900A9008D08006C08004C65B0
      	S117E064E0A0008C4400A264C8D0FDCAD0FAEE4400AD440002
      	S117E0784C6AE02087E020F9E02051E14C7BE0A2ABA0F42080
      	S117E08C99F3A0008C5E008CCD008C5F008C73008C8700A070
      	S117E0A000A90099A500C8C027D0F8A00020D9F3C900F0F9CC
      	S117E0B4C908D0034CBFE0C97FD01588300DA92020FAF3A954
      	S117E0C80820FAF34CADE0A0004CADE0C90DF00D99A500C800
      	S117E0DCC027D0CDA0274CADE088B9A500C90AF001C8A900ED
      	S117E0F099A50060A0FF4C16E1A000B9A500F050C93F304BD7
      	S117E104C95A100338B008C9613040C97A103C8DCD00C8C0D2
      	S117E11814F034B9A500C900F02EC920F0F0AE5E008A186992
      	S117E12C148D5E00B9A500C920F010C900F00C9D5F00E8C824
      	S117E140C028F00B4C30E1A9009D5F004C16E1606038ADCD2D
      	S117E1540020F4F2C96CD0062070E94CE4E1C964D0062042B3
      	S117E168E74CE4E1C972D0062026EB4CE4E1C967D00620E747
      	S117E17CE84CE4E1C965D0062040E84CE4E1C966D00620A66A
      	S117E190E84CE4E1C975D00620B7EF4CE4E1C974D006207CE4
      	S117E1A4ED4CE4E1C962D00620DAE54CE4E1C973D00620EB57
      	S117E1B8EC4CE4E1C96DD00620BAEA4CE4E1C961D006205100
      	S117E1CCE24CE4E1C968D0062068E94CE4E1C93FD006206859
      	S117E1E0E94CE4E1B009A226A0F62099F318603860788D4411
      	S117E1F40068482910D006AD44006C02006C0400688D4B0045
      	S117E208AD44008D47008E48008C4900BAE8E88E4A0068388C
      	S117E21CE9018D450068E9008D4600A0008C5F002026EBADA1
      	S117E2303900C901D0034C32EFA003A206B92F00C901D005C1
      	S117E244B93300811288CACA10EF4C7BE0A20020CAF2B00350
      	S117E2584C47E38E08008C0900A2AFA0F42099F3200CF3203D
      	S117E26C8EE020F4E0AD5F00C900F004C920D0034C49E3A09B
      	S117E28000B95F002000F3995F00C8C003D0F2204BE3B028F0
      	S117E294200CF3A92020FAF3A25FA0002099F3A92020FAF35A
      	S117E2A8A273A0002099F3A92020FAF3A93F20FAF34C61E2A3
      	S117E2BC2083E3B0034C94E22078E4B0034C94E22098E4B012
      	S117E2D0034C94E2200CF3A000AD1A0091082045F320C1F227
      	S117E2E4A92020FAF3AD1D00F028AD1B0091082045F320C1D0
      	S117E2F8F2A92020FAF3AD1E00F01EAD1C0091082045F32093
      	S117E30CC1F2A92020FAF34C2CE3A92020FAF320FAF320FA18
      	S117E320F3A92020FAF320FAF320FAF3A92020FAF3A25FA08B
      	S117E334002099F3A92020FAF3A273A0002099F34C61E21847
      	S117E348603860A22C8E0A00A2F88E0B00A000B10AD95F0099
      	S117E35CF019AD0A0018690A8D0A009003EE0B00A004B10ADC
      	S117E370C95AF00B4C55E3C8C003F0054C57E318603860A03D
      	S117E38400B97300C900D008A9508D1F004C76E4C923D008A5
      	S117E398A94D8D1F004C76E4C941F007C961F0034CC2E3C84E
      	S117E3ACB97300C900F007C920F0034CC2E3A9438D1F004CBC
      	S117E3C076E4A006B10AC94CD0068D1F004C76E4A000B97381
      	S117E3D400C928D0034C1CE4A000B97300C92CF008C900F0AF
      	S117E3E82BC84CDEE3C8B97300C958F00FC978F00BC959F0BB
      	S117E3FC0FC979F00B4C74E4A9588D1F004C76E4A9598D1F18
      	S117E410004C76E4A9538D1F004C76E4C8B97300C92CF00B1C
      	S117E424C929F01EC00BD0F04C74E4C8B97300C958F007C9DC
      	S117E43878F0034C74E4A9528D1F004C76E4C8B97300C900B3
      	S117E44CF016C92CF0034C74E4C8B97300C959F00FC979F0DF
      	S117E4600B4C74E4A9448D1F004C76E4A9498D1F004C76E472
      	S117E47418603860A006B10ACD1F00F015AD0A0018690A8D5F
      	S117E4880A009003EE0B002055E3B0E418603860A9008D1D97
      	S117E49C008D1E00A007B10A8D1A00AD1F00C950F027C943AC
      	S117E4B0F026C94DF025C953F03CC958F038C959F034C9492A
      	S117E4C4F058C952F054C944F050C94CF0244CB1E54CB3E55D
      	S117E4D84CB3E520B5E5B0034CB1E52023F3B0034CB1E58DA1
      	S117E4EC1B00A9018D1D004CB3E520B5E5B0034CB1E520CA8C
      	S117E500F2B0034CB1E5AD1F00C94CF0488E1B008C1C00A969
      	S117E514018D1D008D1E004CB3E520B5E5B0034CB1E520CA7C
      	S117E528F2B0034CB1E5AD1F00C944F00FC000D0788E1B00CB
      	S117E53CA9018D1D004CB3E58E1B008C1C00A9018D1D008D5D
      	S117E5501E004CB3E58E2B008C2C00AD08008D2D00AD09001B
      	S117E5648D2E00A008B10A186D2D008D2D009003EE2E00382E
      	S117E578AD2B00ED2D008D2B00AD2C00ED2E008D2C00AD2C5B
      	S117E58C00C9FFF00EC900D01CAD2B00C98010154CA6E5AD32
      	S117E5A02B00C980300B8D1B00A9018D1D004CB3E518603824
      	S117E5B460A214A000BD5F00D939F4F017D94AF4F012C8C0CF
      	S117E5C810F0034CBCE5E8E01FF0034CB7E518603860AD5F6D
      	S117E5DC00C92BF00BC92DF00AC93FF0094CFAE64C66E64C37
      	S117E5F022E6A2AFA0F42099F3A0FFA2FFC8E8B912008D082A
      	S117E60400C8B912008D0900BD2F00F003200CF3C007D0E55B
      	S117E618A2AFA0F42099F34CFAE6AD7300C900F00AA2142074
      	S117E62CCAF2B0104CFAE6A003A900992F008810F84CFAE65E
      	S117E6408E2B008C2C00A003A20620FBE6B00F88CACA10F624
      	S117E654A2BCA0F52099F34CFAE6A900992F004CFAE6AD7326
      	S117E66800C900F007A21420CAF2B0034CFAE68E2B008C2CF8
      	S117E67C00A003A206B92F00C900F00520FBE6B0E788CACAE1
      	S117E69010EFA000B92F00C900F00FC8C004D0F4A294A0F508
      	S117E6A42099F34CFAE68C3700A901992F00C000D00FAD2BDA
      	S117E6B8008D1200AD2C008D13004CFAE6C001D00FAD2B008E
      	S117E6CC8D1400AD2C008D15004CFAE6C002D00FAD2B008DE8
      	S117E6E01600AD2C008D17004CFAE6AD2B008D1800AD2C000D
      	S117E6F48D19004CFAE660C000D00BAD2C00CD1300F02C4C20
      	S117E70840E7C001D00BAD2C00CD1500F01D4C40E7C002D069
      	S117E71C0BAD2C00CD1700F00E4C40E7AD2C00CD1900F003FA
      	S117E7304C40E7AD2B00DD1200F0034C40E738601860A2007F
      	S117E744BD5F00C900F03A2023F3B0034C06E88D0900E820ED
      	S117E75823F3B0034C06E88D0800A214BD5F00C900F01A204C
      	S117E76C23F3B0034C06E88D5D00E82023F3B0034C06E88D10
      	S117E7805C004C9CE7AD09008D5D00AD08008D5C0018690F88
      	S117E7948D5C009003EE5D00A90D20FAF3A90A20FAF3A20081
      	S117E7A8A000200CF3B108202AE82045F3E8E010D00320127A
      	S117E7BCE8E008D012A92020FAF3A92D20FAF3A92020FAF304
      	S117E7D04CD8E7A92020FAF3AD0800CD5C00D008AD0900CD17
      	S117E7E45D00F020EE0800D003EE0900E010D00FA90A20FA54
      	S117E7F8F3A90D20FAF3200CF3A2004CADE71860EE0800D074
      	S117E80C03EE09003860A92020FAF3A92020FAF3A200BD4C0B
      	S117E8200020FAF3E8E010D0F56048C920300AC97F10069D70
      	S117E8344C004C3EE8A92E9D4C006860AD5F00C900D0034C92
      	S117E8486EE8AD7300C900D0034C6EE8A20020CAF2B0034C87
      	S117E85C6EE88E08008C0900A2142072E890034C70E8186044
      	S117E8703860A0008CCF00BD5F00F0282023F3B0034CA4E808
      	S117E8849108EE0800D003EE0900EECF00ADCF00C90AF00A1D
      	S117E898E8BD5F00F004E84C77E838601860A20020CAF2B09F
      	S117E8AC034CE3E88E08008C0900A21420CAF2B0034CE3E8B3
      	S117E8C08E5C008C5D00A2282072E89016AD5D00CD0900F0B3
      	S117E8D4034CC6E8AD5C00CD0800F0054CC6E818603860ADA5
      	S117E8E85F00C900F010A20020CAF2B0034C64E98E45008CC7
      	S117E8FC4600AE45008E2B00AC46008C2C00A003A206B92F35
      	S117E91000C900F00520FBE6B00888CACA10EF4C2CE9A2E476
      	S117E924A0F52099F34C66E9A003A206B92F00C901D009A188
      	S117E93812993300A900811288CACA10EB68686868AD5F00EA
      	S117E94CC900F011A2FF9AAD4B0048AD4700AE4800AC49008F
      	S117E960286C450018603860A22AA0F62099F360A2B2A0F460
      	S117E9742099F320D9F3A2AFA0F42099F34C87E920D9F3C9F1
      	S117E98853D0F920FAF320D9F320FAF38DA100C930D0082036
      	S117E99C9CEA90254CC2E9C931D00820A6EA90194CC2E9C946
      	S117E9B039D01220B0EA900DA2FBA0F42099F34CCEE94C842D
      	S117E9C4E9A2DBA0F42099F3386020D9F33860A9008D9F00A4
      	S117E9D88DA0002043EA8D9E00206AEAAACACACA8A8D9B0054
      	S117E9EC2043EA8D0900206AEA2043EA8D0800206AEA60AD59
      	S117EA009B00F00B2043EA206AEACE9B00D0F560AD9B00F0E1
      	S117EA1417A0002043EA206AEA9108EE0800D003EE0900CE4B
      	S117EA289B00D0EB60AD9F0049FF8D9D002043EACD9D00F0BB
      	S117EA3C04184C42EA3860984820D9F32079EA901C0A0A0A7D
      	S117EA500A29F08D9C0020D9F32079EA900B0D9C008D9C0086
      	S117EA6468A8AD9C006048186D9F008D9F009003EEA00068C0
      	S117EA78608ECE00A200DD39F4F013DD4AF4F00EE8E010F03A
      	S117EA8C034C7EEAA900184C9BEA8A38AECE006020D3E9208F
      	S117EAA0FFE9202DEA6020D3E92010EA202DEA6020D3E92056
      	S117EAB4FFE9202DEA60AD5F00C900F007A20020CAF2B003CE
      	S117EAC84C25EB8E08008C0900A21420CAF2B0034C25EB8E80
      	S117EADC5C008C5D00EE5C00D003EE5D00A22820CAF2B0031C
      	S117EAF04C25EB8E0A008C0B00A000B108910AEE0A00D003C4
      	S117EB04EE0B00EE0800D003EE0900AD0800CD5C00F0034C23
      	S117EB18FBEAAD0900CD5D00F0034CFBEA60488A489848089A
      	S117EB2CAD5F00C900F0034C9EEBA239A0F52099F3A0032055
      	S117EB40E9F2AD46002045F3AD45002045F3A00920E9F2ADFC
      	S117EB5447002045F3A00920E9F2AD48002045F3A00820E968
      	S117EB68F2AD49002045F3A00820E9F2AD4A002045F3A007BC
      	S117EB7C20E9F2AD4B00A2082AB00A48A93020FAF3684C9886
      	S117EB90EB48A93120FAF368CAD0E94CE3ECA90D20FAF3A9E1
      	S117EBA40A20FAF3AD5F0020F4F2C970D03CAD46002045F3A0
      	S117EBB8AD45002045F320E1F2208EE020F4E0AD5F00C900B1
      	S117EBCCD0034CE3ECA2002023F3B0034CE3ECA8E82023F3D7
      	S117EBE0B0034CE3EC8D45008C46004CE3ECC961D029AD4779
      	S117EBF4002045F320E1F2208EE020F4E0AD5F00C900D00394
      	S117EC084CE3ECA2002023F3B0034CE3EC8D47004CE3ECC97B
      	S117EC1C78D029AD48002045F320E1F2208EE020F4E0AD5FA1
      	S117EC3000C900D0034CE3ECA2002023F3B0034CE3EC8D489A
      	S117EC44004CE3ECC979D029AD49002045F320E1F2208EE093
      	S117EC5820F4E0AD5F00C900D0034CE3ECA2002023F3B00362
      	S117EC6C4CE3EC8D49004CE3ECC973F0034CDFECAD60002011
      	S117EC80F4F2C970F007C972F02C4CDFECAD4A002045F32089
      	S117EC94E1F2208EE020F4E0AD5F00C900D0034CE3ECA200AE
      	S117ECA82023F3B0034CE3EC8D4A004CE3ECAD4B002045F30E
      	S117ECBC20E1F2208EE020F4E0AD5F00C900D0034CE3ECA266
      	S117ECD0002023F3B0034CE3EC8D4B004CE3EC184CE4EC38C9
      	S117ECE42868A868AA6860AD5F00C900F007A20020CAF2B00C
      	S117ECF8034C7BED8E0A008C0B00A21420CAF2B0034C7BED25
      	S117ED0C8E5C008C5D00EE5C00D003EE5D00A228A9208D088C
      	S117ED2000A9008D09002072E89050ADCF008D2A00AD0A0058
      	S117ED348D0800AD0B008D0900A2AFA0F42099F3A200A00011
      	S117ED48B108DD2000F01920C1F2AD0800CD5C00F0034C44C0
      	S117ED5CEDAD0900CD5D00F0164C44EDC8E8EC2A00F0034C4A
      	S117ED7048ED200CF320C1F24C44ED60AD5F00C900F017A209
      	S117ED840020CAF2B0034C83EF8E45008C4600AD7300C9009C
      	S117ED98D008A0018C3E004CAFEDA2142023F3B0034C83EFDB
      	S117EDAC8D3E0068686868AC45008C0800AC46008C0900A038
      	S117EDC000B1088D43002087EFB0034C83EFA008B10A8D3A81
      	S117EDD400A001AD4300C960D028A9028D3D00688D10006893
      	S117EDE88D110048AD100048EE1000D003EE1100A000B110F7
      	S117EDFC8D3C00A90091104C12EFC94CD01EA9028D3D00B176
      	S117EE10088D1000C8B1088D1100A000B1108D3C00A90091C2
      	S117EE24104C12EFC96CD02BA9028D3D00B1088D0C00C8B109
      	S117EE38088D0D00A000B10C8D1000C8B10C8D1100A000B1B2
      	S117EE4C108D3C00A90091104C12EFC920D01EA9028D3D00F2
      	S117EE60B1088D1000C8B1088D1100A000B1108D3C00A90052
      	S117EE7491104C12EFA000B10AC942D008A001B10AC949D01C
      	S117EE88034CEFEEA9018D3D0018AD08006D3A008D1000AD14
      	S117EE9C090069008D1100A001B1088D38001020CE3800AD4C
      	S117EEB0380049FF8D380038AD1000ED38008D1000AD110090
      	S117EEC4E9008D11004CE1EE18AD10006D38008D1000AD11BF
      	S117EED80069008D11004CE1EEA000B1108D3C00A90091108C
      	S117EEEC4CF4EEA9008D3D00AC3A00B1088D3B0018AD080039
      	S117EF006D3A008D0E00AD090069008D0F00A9009108A90110
      	S117EF148D3900AD5F00C900F003A2FF9AAD4B0048AD4700E8
      	S117EF28AE4800AC4900286C4500A9008D3900A000AD3D0014
      	S117EF3CC900F011C901F008AD3C0091104C56EFAD3C00919C
      	S117EF5010AD3B00910EAC45008C0800AC46008C0900A2AFB5
      	S117EF64A0F42099F3AD08008D5C00AD09008D5D002006F001
      	S117EF78CE3E00F0034CB3ED4C7BE018603860A22C8E0A0079
      	S117EF8CA2F88E0B00A004B10AC95AF01CA007B10ACD43003A
      	S117EFA0F011AD0A0018690A8D0A009003EE0B004C91EF38EF
      	S117EFB4601860AD5F00C900F017A20020CAF2B0034CABF277
      	S117EFC88E08008C0900AD7300C900D021AD08008D5C00ADE1
      	S117EFDC09008D5D0018AD080069148D5C009007AE5D00E86D
      	S117EFF08E5D004C06F0A21420CAF2B0034CABF28E5C008C38
      	S117F0045D00AD5D00CD0900F005900E4C21F0AD5C00CD08E9
      	S117F0180090034C21F04CADF2A000B1088D43002087EFB096
      	S117F02C1DA2AFA0F42099F3200CF3AD43002045F3A288A0ED
      	S117F040F52099F320C1F24C06F0A2AFA0F42099F3200CF352
      	S117F05420C1F2A006B10AC950D0034CA4F0C94DD0034CCBA4
      	S117F068F0C953D0034CFEF0C958D0034CFEF0C959D0034C08
      	S117F07CFEF0C952D0034C1BF2C94CD0034C68F1C943D003DB
      	S117F0904CB5F0C944D0034C5DF2C949D0034CD9F14C2DF098
      	S117F0A4AD43002045F3A00820E9F220AFF24C06F0AD430076
      	S117F0B82045F3A00820E9F220AFF2A94120FAF34C06F0A0AB
      	S117F0CC00AD43002045F3A92020FAF3B1088D41002045F32F
      	S117F0E020C1F2A00520E9F220AFF2A92320FAF3AD410020FD
      	S117F0F445F3A96820FAF34C06F0A000AD43002045F3A920BB
      	S117F10820FAF3B1088D41002045F320C1F2A92020FAF3B1A9
      	S117F11C088D42002045F320C1F2A00220E9F220AFF2AD428C
      	S117F130002045F3AD41002045F3A96820FAF3A006B10AC9E1
      	S117F14458F007C959F0104C06F0A92C20FAF3A95820FAF310
      	S117F1584C06F0A92C20FAF3A95920FAF34C06F0A000AD439A
      	S117F16C002045F3A92020FAF3B1088D41002045F320C1F2AB
      	S117F180A00520E9F220AFF2AD08008D3F00AD09008D400012
      	S117F194AD41003012AD3F00186D41008D3F009020EE4000D7
      	S117F1A84CC5F1CE4100AD410049FF8D4100AD3F0038ED41E8
      	S117F1BC008D3F00B003CE4000AD40002045F3AD3F00204518
      	S117F1D0F3A96820FAF34C06F0A000AD43002045F3A9202003
      	S117F1E4FAF3B1088D41002045F320C1F2A00520E9F220AF05
      	S117F1F8F2A92820FAF3AD41002045F3A96820FAF3A92920D9
      	S117F20CFAF3A92C20FAF3A95920FAF34C06F0A000AD43003A
      	S117F2202045F3A92020FAF3B1088D41002045F320C1F2A056
      	S117F2340520E9F220AFF2A92820FAF3AD41002045F3A968CC
      	S117F24820FAF3A92C20FAF3A95820FAF3A92920FAF34C0680
      	S117F25CF0A000AD43002045F3A92020FAF3B1088D41002045
      	S117F27045F320C1F2A92020FAF3B1088D42002045F320C1E4
      	S117F284F2A00220E9F220AFF2A92820FAF3AD42002045F3FD
      	S117F298AD41002045F3A96820FAF3A92920FAF34C06F018C1
      	S117F2AC603860A000B10A20FAF3C8C003D0F6A92020FAF3C3
      	S117F2C060EE0800D003EE0900602023F3B0034CDFF2A8E820
      	S117F2D42023F3B0034CDFF2AA38601860A283A0F52099F3FC
      	S117F2E86048A92020FAF388D0F86860C9413007C95B100300
      	S117F2FC18692060C9613007C97B100338E92060AD090020CA
      	S117F31045F3AD08002045F3A92020FAF3A92020FAF360BDD7
      	S117F3245F002079EA90190A0A0A0A29F08D9C00E8BD5F00D8
      	S117F3382079EA90070D9C008D9C0038608D9C004A4A4A4AE8
      	S117F34C290FC90A100509304C5CF338E909094020FAF3AD88
      	S117F3609C00290FC90A100509304C72F338E909094020FA62
      	S117F374F3AD9C0060A9048D0400A9E28D0500A9008D39001B
      	S117F388A9008D2F008D30008D31008D3200A90060488E06E9
      	S117F39C008C0700A000B106F00E20FAF3EE0600D003EE07A8
      	S117F3B0004CA2F36860088A489848AD01A02908F009AD00BD
      	S117F3C4A08DCE004CD0F3A9008DCE0068A868AA28ADCE005E
      	S117F3D860088A489848AD01A02908D006AD02A04CDEF3AD95
      	S117F3EC00A08DCE0068A868AA28ADCE00608DCE00089848A6
      	S117F4008A48AD01A02910F0F9ADCE008D00A068AA68A828C0
      	S117F414ADCE0060488A489848A9008DA200A9108DA300CE7C
      	S117F428A200D0FBCEA300D0F668A868AA6860160B3031328A
      	S117F43C33343536373839414243444546003031323334357A
      	S117F45036373839616263646566000A0D0A554D4F4E3635A6
      	S117F4642056312E3139202D20556E6465727374616E64616B
      	S117F478626C65204D6F6E69746F7220666F72207468652059
      	S117F48C3635303020736572696573206D6963726F70726F67
      	S117F4A0636573736F72732E0A0D000A0D2D000A0D000A0D9B
      	S117F4B453656E642053207265636F726473207768656E203F
      	S117F4C8796F75206172652072656164792E2E2E0A0D000A97
      	S117F4DC0D074572726F72204C6F6164696E672053205265D2
      	S117F4F0636F7264732E2E2E0A0D000A0D0753207265636F0E
      	S117F504726473207375636365737366756C6C79206C6F6105
      	S117F51864656420287072657373203C656E7465723E2074ED
      	S117F52C6F20636F6E74696E7565292E000A0D0A50676D43F4
      	S117F5406E7472285043292020416363756D2841432920203D
      	S117F55458526567285852292020595265672859522920203B
      	S117F56853746B5074722853502920204E562D4244495A43B2
      	S117F57C285352290A0D000A0D203A002020202020202020F9
      	S117F5903F3F3F000A0D416C6C20627265616B706F696E7427
      	S117F5A473206172652063757272656E746C7920696E2075F0
      	S117F5B873652E000A0D4E6F20627265616B706F696E7420F2
      	S117F5CC65786973747320617420746869732061646472659A
      	S117F5E073732E000A0D596F752063616E6E6F7420474F2032
      	S117F5F46174206120627265616B706F696E746564206164AC
      	S117F60864726573732C205452414345207061737420697439
      	S117F61C207468656E20474F2E000A0D3F000A0D0A41737385
      	S117F630656D626C6520202020202020412073746172745FEF
      	S117F644616464726573730A0D427265616B706F696E742082
      	S117F658202020204220282B2C2D2C3F2920616464726573E5
      	S117F66C730A0D44756D7020202020202020202020204420A2
      	S117F6805B73746172745F61646472657373205B656E645F93
      	S117F694616464726573735D5D0A0D456E7465722020202029
      	S117F6A8202020202020452061646472657373206C69737463
      	S117F6BC0A0D46696C6C20202020202020202020204620735F
      	S117F6D0746172745F6164647265737320656E645F61646443
      	S117F6E472657373206C6973740A0D476F20202020202020C8
      	S117F6F820202020202047205B73746172745F6164647265EB
      	S117F70C73735D0A0D48656C702020202020202020202020A2
      	S117F72048206F72203F0A0D4C6F6164202020202020202092
      	S117F7342020204C0A0D4D6F76652020202020202020202023
      	S117F748204D2073746172745F6164647265737320656E6452
      	S117F75C5F616464726573732064657374696E6174696F6E8E
      	S117F7705F616464726573730A0D52656769737465722020A0
      	S117F784202020202052205B50432C41432C58522C59522CE4
      	S117F79853502C53525D0A0D5365617263682020202020205B
      	S117F7AC202020532073746172745F6164647265737320657A
      	S117F7C06E645F61646472657373206C6973740A0D54726100
      	S117F7D463652020202020202020202054205B737461727418
      	S117F7E85F61646472657373205B76616C75655D5D0A0D5506
      	S117F7FC6E617373656D626C65202020202055205B73746183
      	S117F81072745F61646472657373205B656E645F6164647209
      	S117F8246573735D5D0A0D0041444320494D4D6902024144F3
      	S117F83843204142536D0304414443204142587D030441443F
      	S117F84C43204142597903044144432049495261020641442B
      	S117F8604320495249710205414E4420494D4D290202414E3F
      	S117F87444204142532D0304414E44204142583D0304414E6D
      	S117F8884420414259390304414E4420494952210206414E59
      	S117F89C442049524931020541534C204143430A010241536C
      	S117F8B04C204142530E030641534C204142581E030742435F
      	S117F8C4432052454C9002024243532052454CB0020242453C
      	S117F8D8512052454CF00202424954204142532C0304424D39
      	S117F8EC492052454C300202424E452052454CD00202425046
      	S117F9004C2052454C10020242524B20494D50000107425607
      	S117F914432052454C5002024256532052454C700202434C50
      	S117F9284320494D50180102434C4420494D50D80102434C20
      	S117F93C4920494D50580102434C5620494D50B80102434DD3
      	S117F9505020494D4DC90202434D5020414253CD0304434D45
      	S117F9645020414258DD0304434D5020414259D90304434D10
      	S117F9785020494952C10206434D5020495249D1020543500B
      	S117F98C5820494D4DE0020243505820414253EC03044350BD
      	S117F9A05920494D4DC0020243505920414253CC03044445F1
      	S117F9B44320414253CE030644454320414258DE03074445F3
      	S117F9C85820494D50CA010244455920494D50880102454FF5
      	S117F9DC5220494D4D490202454F52204142534D0304454FAD
      	S117F9F052204142585D0304454F5220414259590304454F78
      	S117FA045220494952410206454F5220495249510205494E72
      	S117FA184320414253EE0306494E4320414258FE0307494E32
      	S117FA2C5820494D50E80102494E5920494D50C801024A4D21
      	S117FA4050204142534C03034A4D5020494E446C03054A5323
      	S117FA5452204142532003064C444120494D4DA902024C4418
      	S117FA684120414253AD03044C444120414258BD03044C447B
      	S117FA7C4120414259B903044C444120494952A102064C4467
      	S117FA904120495249B102054C445820494D4DA202024C4440
      	S117FAA45820414253AE03044C445820414259BE03044C440E
      	S117FAB85920494D4DA002024C445920414253AC03044C4414
      	S117FACC5920414258BC03044C5352204143434A01024C5347
      	S117FAE052204142534E03064C5352204142585E03074E4F7E
      	S117FAF45020494D50EA01024F524120494D4D0902024F5224
      	S117FB0841204142530D03044F5241204142581D03044F52F8
      	S117FB1C41204142591903044F5241204949520102064F52E4
      	S117FB30412049524911020550484120494D5048010350489D
      	S117FB445020494D50080103504C4120494D50680104504C5B
      	S117FB585020494D50280104524F4C204143432A0102524F70
      	S117FB6C4C204142532E0306524F4C204142583E0307524F37
      	S117FB8052204143436A0102524F52204142536E0306524FC6
      	S117FB9452204142587E030752544920494D504001065254A2
      	S117FBA85320494D5060010653424320494D4DE90202534228
      	S117FBBC4320414253ED030453424320414258FD0304534298
      	S117FBD04320414259F9030453424320494952E10206534284
      	S117FBE44320495249F1020553454320494D50380102534516
      	S117FBF84420494D50F8010253454920494D507801025354A7
      	S117FC0C41204142538D0304535441204142589D03055354E6
      	S117FC204120414259990305535441204949528102065354D2
      	S117FC344120495249910206535458204142538E03045354A9
      	S117FC4859204142538C030454415820494D50AA010254418D
      	S117FC5C5920494D50A8010254535820494D50BA0102545818
      	S117FC704120494D508A010254585320494D509A0102545959
      	S115FC844120494D509801025A5A5A205A5A5A0000004C
      	S105FFFC00E01F
      	S105FFFEF1E12B
      	S9030000FC
      %/s19

          %output,sequence="18",timestamp="2015-02-11 16:07:37.503",preserve="false"
            {76,27,224,76,250,243,76,182,243,76,217,243,76,153,243,76,233,242,76,69,243,76,121,234,76,142,224,162,255,154,216,32,121,243,173,0,170,201,0,240,3,76,0,192,162,91,160,244,32,153,243,169,0,141,75,0,169,0,141,71,0,141,72,0,141,73,0,169,255,141,74,0,76,39,226,201,2,208,19,41,240,74,74,74,24,105,192,141,9,0,169,0,141,8,0,108,8,0,76,101,224,160,0,140,68,0,162,100,200,208,253,202,208,250,238,68,0,173,68,0,76,106,224,32,135,224,32,249,224,32,81,225,76,123,224,162,171,160,244,32,153,243,160,0,140,94,0,140,205,0,140,95,0,140,115,0,140,135,0,160,0,169,0,153,165,0,200,192,39,208,248,160,0,32,217,243,201,0,240,249,201,8,208,3,76,191,224,201,127,208,21,136,48,13,169,32,32,250,243,169,8,32,250,243,76,173,224,160,0,76,173,224,201,13,240,13,153,165,0,200,192,39,208,205,160,39,76,173,224,136,185,165,0,201,10,240,1,200,169,0,153,165,0,96,160,255,76,22,225,160,0,185,165,0,240,80,201,63,48,75,201,90,16,3,56,176,8,201,97,48,64,201,122,16,60,141,205,0,200,192,20,240,52,185,165,0,201,0,240,46,201,32,240,240,174,94,0,138,24,105,20,141,94,0,185,165,0,201,32,240,16,201,0,240,12,157,95,0,232,200,192,40,240,11,76,48,225,169,0,157,95,0,76,22,225,96,96,56,173,205,0,32,244,242,201,108,208,6,32,112,233,76,228,225,201,100,208,6,32,66,231,76,228,225,201,114,208,6,32,38,235,76,228,225,201,103,208,6,32,231,232,76,228,225,201,101,208,6,32,64,232,76,228,225,201,102,208,6,32,166,232,76,228,225,201,117,208,6,32,183,239,76,228,225,201,116,208,6,32,124,237,76,228,225,201,98,208,6,32,218,229,76,228,225,201,115,208,6,32,235,236,76,228,225,201,109,208,6,32,186,234,76,228,225,201,97,208,6,32,81,226,76,228,225,201,104,208,6,32,104,233,76,228,225,201,63,208,6,32,104,233,76,228,225,176,9,162,38,160,246,32,153,243,24,96,56,96,120,141,68,0,104,72,41,16,208,6,173,68,0,108,2,0,108,4,0,104,141,75,0,173,68,0,141,71,0,142,72,0,140,73,0,186,232,232,142,74,0,104,56,233,1,141,69,0,104,233,0,141,70,0,160,0,140,95,0,32,38,235,173,57,0,201,1,208,3,76,50,239,160,3,162,6,185,47,0,201,1,208,5,185,51,0,129,18,136,202,202,16,239,76,123,224,162,0,32,202,242,176,3,76,71,227,142,8,0,140,9,0,162,175,160,244,32,153,243,32,12,243,32,142,224,32,244,224,173,95,0,201,0,240,4,201,32,208,3,76,73,227,160,0,185,95,0,32,0,243,153,95,0,200,192,3,208,242,32,75,227,176,40,32,12,243,169,32,32,250,243,162,95,160,0,32,153,243,169,32,32,250,243,162,115,160,0,32,153,243,169,32,32,250,243,169,63,32,250,243,76,97,226,32,131,227,176,3,76,148,226,32,120,228,176,3,76,148,226,32,152,228,176,3,76,148,226,32,12,243,160,0,173,26,0,145,8,32,69,243,32,193,242,169,32,32,250,243,173,29,0,240,40,173,27,0,145,8,32,69,243,32,193,242,169,32,32,250,243,173,30,0,240,30,173,28,0,145,8,32,69,243,32,193,242,169,32,32,250,243,76,44,227,169,32,32,250,243,32,250,243,32,250,243,169,32,32,250,243,32,250,243,32,250,243,169,32,32,250,243,162,95,160,0,32,153,243,169,32,32,250,243,162,115,160,0,32,153,243,76,97,226,24,96,56,96,162,44,142,10,0,162,248,142,11,0,160,0,177,10,217,95,0,240,25,173,10,0,24,105,10,141,10,0,144,3,238,11,0,160,4,177,10,201,90,240,11,76,85,227,200,192,3,240,5,76,87,227,24,96,56,96,160,0,185,115,0,201,0,208,8,169,80,141,31,0,76,118,228,201,35,208,8,169,77,141,31,0,76,118,228,201,65,240,7,201,97,240,3,76,194,227,200,185,115,0,201,0,240,7,201,32,240,3,76,194,227,169,67,141,31,0,76,118,228,160,6,177,10,201,76,208,6,141,31,0,76,118,228,160,0,185,115,0,201,40,208,3,76,28,228,160,0,185,115,0,201,44,240,8,201,0,240,43,200,76,222,227,200,185,115,0,201,88,240,15,201,120,240,11,201,89,240,15,201,121,240,11,76,116,228,169,88,141,31,0,76,118,228,169,89,141,31,0,76,118,228,169,83,141,31,0,76,118,228,200,185,115,0,201,44,240,11,201,41,240,30,192,11,208,240,76,116,228,200,185,115,0,201,88,240,7,201,120,240,3,76,116,228,169,82,141,31,0,76,118,228,200,185,115,0,201,0,240,22,201,44,240,3,76,116,228,200,185,115,0,201,89,240,15,201,121,240,11,76,116,228,169,68,141,31,0,76,118,228,169,73,141,31,0,76,118,228,24,96,56,96,160,6,177,10,205,31,0,240,21,173,10,0,24,105,10,141,10,0,144,3,238,11,0,32,85,227,176,228,24,96,56,96,169,0,141,29,0,141,30,0,160,7,177,10,141,26,0,173,31,0,201,80,240,39,201,67,240,38,201,77,240,37,201,83,240,60,201,88,240,56,201,89,240,52,201,73,240,88,201,82,240,84,201,68,240,80,201,76,240,36,76,177,229,76,179,229,76,179,229,32,181,229,176,3,76,177,229,32,35,243,176,3,76,177,229,141,27,0,169,1,141,29,0,76,179,229,32,181,229,176,3,76,177,229,32,202,242,176,3,76,177,229,173,31,0,201,76,240,72,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,179,229,32,181,229,176,3,76,177,229,32,202,242,176,3,76,177,229,173,31,0,201,68,240,15,192,0,208,120,142,27,0,169,1,141,29,0,76,179,229,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,179,229,142,43,0,140,44,0,173,8,0,141,45,0,173,9,0,141,46,0,160,8,177,10,24,109,45,0,141,45,0,144,3,238,46,0,56,173,43,0,237,45,0,141,43,0,173,44,0,237,46,0,141,44,0,173,44,0,201,255,240,14,201,0,208,28,173,43,0,201,128,16,21,76,166,229,173,43,0,201,128,48,11,141,27,0,169,1,141,29,0,76,179,229,24,96,56,96,162,20,160,0,189,95,0,217,57,244,240,23,217,74,244,240,18,200,192,16,240,3,76,188,229,232,224,31,240,3,76,183,229,24,96,56,96,173,95,0,201,43,240,11,201,45,240,10,201,63,240,9,76,250,230,76,102,230,76,34,230,162,175,160,244,32,153,243,160,255,162,255,200,232,185,18,0,141,8,0,200,185,18,0,141,9,0,189,47,0,240,3,32,12,243,192,7,208,229,162,175,160,244,32,153,243,76,250,230,173,115,0,201,0,240,10,162,20,32,202,242,176,16,76,250,230,160,3,169,0,153,47,0,136,16,248,76,250,230,142,43,0,140,44,0,160,3,162,6,32,251,230,176,15,136,202,202,16,246,162,188,160,245,32,153,243,76,250,230,169,0,153,47,0,76,250,230,173,115,0,201,0,240,7,162,20,32,202,242,176,3,76,250,230,142,43,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,251,230,176,231,136,202,202,16,239,160,0,185,47,0,201,0,240,15,200,192,4,208,244,162,148,160,245,32,153,243,76,250,230,140,55,0,169,1,153,47,0,192,0,208,15,173,43,0,141,18,0,173,44,0,141,19,0,76,250,230,192,1,208,15,173,43,0,141,20,0,173,44,0,141,21,0,76,250,230,192,2,208,15,173,43,0,141,22,0,173,44,0,141,23,0,76,250,230,173,43,0,141,24,0,173,44,0,141,25,0,76,250,230,96,192,0,208,11,173,44,0,205,19,0,240,44,76,64,231,192,1,208,11,173,44,0,205,21,0,240,29,76,64,231,192,2,208,11,173,44,0,205,23,0,240,14,76,64,231,173,44,0,205,25,0,240,3,76,64,231,173,43,0,221,18,0,240,3,76,64,231,56,96,24,96,162,0,189,95,0,201,0,240,58,32,35,243,176,3,76,6,232,141,9,0,232,32,35,243,176,3,76,6,232,141,8,0,162,20,189,95,0,201,0,240,26,32,35,243,176,3,76,6,232,141,93,0,232,32,35,243,176,3,76,6,232,141,92,0,76,156,231,173,9,0,141,93,0,173,8,0,141,92,0,24,105,15,141,92,0,144,3,238,93,0,169,13,32,250,243,169,10,32,250,243,162,0,160,0,32,12,243,177,8,32,42,232,32,69,243,232,224,16,208,3,32,18,232,224,8,208,18,169,32,32,250,243,169,45,32,250,243,169,32,32,250,243,76,216,231,169,32,32,250,243,173,8,0,205,92,0,208,8,173,9,0,205,93,0,240,32,238,8,0,208,3,238,9,0,224,16,208,15,169,10,32,250,243,169,13,32,250,243,32,12,243,162,0,76,173,231,24,96,238,8,0,208,3,238,9,0,56,96,169,32,32,250,243,169,32,32,250,243,162,0,189,76,0,32,250,243,232,224,16,208,245,96,72,201,32,48,10,201,127,16,6,157,76,0,76,62,232,169,46,157,76,0,104,96,173,95,0,201,0,208,3,76,110,232,173,115,0,201,0,208,3,76,110,232,162,0,32,202,242,176,3,76,110,232,142,8,0,140,9,0,162,20,32,114,232,144,3,76,112,232,24,96,56,96,160,0,140,207,0,189,95,0,240,40,32,35,243,176,3,76,164,232,145,8,238,8,0,208,3,238,9,0,238,207,0,173,207,0,201,10,240,10,232,189,95,0,240,4,232,76,119,232,56,96,24,96,162,0,32,202,242,176,3,76,227,232,142,8,0,140,9,0,162,20,32,202,242,176,3,76,227,232,142,92,0,140,93,0,162,40,32,114,232,144,22,173,93,0,205,9,0,240,3,76,198,232,173,92,0,205,8,0,240,5,76,198,232,24,96,56,96,173,95,0,201,0,240,16,162,0,32,202,242,176,3,76,100,233,142,69,0,140,70,0,174,69,0,142,43,0,172,70,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,251,230,176,8,136,202,202,16,239,76,44,233,162,228,160,245,32,153,243,76,102,233,160,3,162,6,185,47,0,201,1,208,9,161,18,153,51,0,169,0,129,18,136,202,202,16,235,104,104,104,104,173,95,0,201,0,240,17,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,24,96,56,96,162,42,160,246,32,153,243,96,162,178,160,244,32,153,243,32,217,243,162,175,160,244,32,153,243,76,135,233,32,217,243,201,83,208,249,32,250,243,32,217,243,32,250,243,141,161,0,201,48,208,8,32,156,234,144,37,76,194,233,201,49,208,8,32,166,234,144,25,76,194,233,201,57,208,18,32,176,234,144,13,162,251,160,244,32,153,243,76,206,233,76,132,233,162,219,160,244,32,153,243,56,96,32,217,243,56,96,169,0,141,159,0,141,160,0,32,67,234,141,158,0,32,106,234,170,202,202,202,138,141,155,0,32,67,234,141,9,0,32,106,234,32,67,234,141,8,0,32,106,234,96,173,155,0,240,11,32,67,234,32,106,234,206,155,0,208,245,96,173,155,0,240,23,160,0,32,67,234,32,106,234,145,8,238,8,0,208,3,238,9,0,206,155,0,208,235,96,173,159,0,73,255,141,157,0,32,67,234,205,157,0,240,4,24,76,66,234,56,96,152,72,32,217,243,32,121,234,144,28,10,10,10,10,41,240,141,156,0,32,217,243,32,121,234,144,11,13,156,0,141,156,0,104,168,173,156,0,96,72,24,109,159,0,141,159,0,144,3,238,160,0,104,96,142,206,0,162,0,221,57,244,240,19,221,74,244,240,14,232,224,16,240,3,76,126,234,169,0,24,76,155,234,138,56,174,206,0,96,32,211,233,32,255,233,32,45,234,96,32,211,233,32,16,234,32,45,234,96,32,211,233,32,255,233,32,45,234,96,173,95,0,201,0,240,7,162,0,32,202,242,176,3,76,37,235,142,8,0,140,9,0,162,20,32,202,242,176,3,76,37,235,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,32,202,242,176,3,76,37,235,142,10,0,140,11,0,160,0,177,8,145,10,238,10,0,208,3,238,11,0,238,8,0,208,3,238,9,0,173,8,0,205,92,0,240,3,76,251,234,173,9,0,205,93,0,240,3,76,251,234,96,72,138,72,152,72,8,173,95,0,201,0,240,3,76,158,235,162,57,160,245,32,153,243,160,3,32,233,242,173,70,0,32,69,243,173,69,0,32,69,243,160,9,32,233,242,173,71,0,32,69,243,160,9,32,233,242,173,72,0,32,69,243,160,8,32,233,242,173,73,0,32,69,243,160,8,32,233,242,173,74,0,32,69,243,160,7,32,233,242,173,75,0,162,8,42,176,10,72,169,48,32,250,243,104,76,152,235,72,169,49,32,250,243,104,202,208,233,76,227,236,169,13,32,250,243,169,10,32,250,243,173,95,0,32,244,242,201,112,208,60,173,70,0,32,69,243,173,69,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,168,232,32,35,243,176,3,76,227,236,141,69,0,140,70,0,76,227,236,201,97,208,41,173,71,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,141,71,0,76,227,236,201,120,208,41,173,72,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,141,72,0,76,227,236,201,121,208,41,173,73,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,141,73,0,76,227,236,201,115,240,3,76,223,236,173,96,0,32,244,242,201,112,240,7,201,114,240,44,76,223,236,173,74,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,141,74,0,76,227,236,173,75,0,32,69,243,32,225,242,32,142,224,32,244,224,173,95,0,201,0,208,3,76,227,236,162,0,32,35,243,176,3,76,227,236,141,75,0,76,227,236,24,76,228,236,56,40,104,168,104,170,104,96,173,95,0,201,0,240,7,162,0,32,202,242,176,3,76,123,237,142,10,0,140,11,0,162,20,32,202,242,176,3,76,123,237,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,169,32,141,8,0,169,0,141,9,0,32,114,232,144,80,173,207,0,141,42,0,173,10,0,141,8,0,173,11,0,141,9,0,162,175,160,244,32,153,243,162,0,160,0,177,8,221,32,0,240,25,32,193,242,173,8,0,205,92,0,240,3,76,68,237,173,9,0,205,93,0,240,22,76,68,237,200,232,236,42,0,240,3,76,72,237,32,12,243,32,193,242,76,68,237,96,173,95,0,201,0,240,23,162,0,32,202,242,176,3,76,131,239,142,69,0,140,70,0,173,115,0,201,0,208,8,160,1,140,62,0,76,175,237,162,20,32,35,243,176,3,76,131,239,141,62,0,104,104,104,104,172,69,0,140,8,0,172,70,0,140,9,0,160,0,177,8,141,67,0,32,135,239,176,3,76,131,239,160,8,177,10,141,58,0,160,1,173,67,0,201,96,208,40,169,2,141,61,0,104,141,16,0,104,141,17,0,72,173,16,0,72,238,16,0,208,3,238,17,0,160,0,177,16,141,60,0,169,0,145,16,76,18,239,201,76,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,18,239,201,108,208,43,169,2,141,61,0,177,8,141,12,0,200,177,8,141,13,0,160,0,177,12,141,16,0,200,177,12,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,18,239,201,32,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,18,239,160,0,177,10,201,66,208,8,160,1,177,10,201,73,208,3,76,239,238,169,1,141,61,0,24,173,8,0,109,58,0,141,16,0,173,9,0,105,0,141,17,0,160,1,177,8,141,56,0,16,32,206,56,0,173,56,0,73,255,141,56,0,56,173,16,0,237,56,0,141,16,0,173,17,0,233,0,141,17,0,76,225,238,24,173,16,0,109,56,0,141,16,0,173,17,0,105,0,141,17,0,76,225,238,160,0,177,16,141,60,0,169,0,145,16,76,244,238,169,0,141,61,0,172,58,0,177,8,141,59,0,24,173,8,0,109,58,0,141,14,0,173,9,0,105,0,141,15,0,169,0,145,8,169,1,141,57,0,173,95,0,201,0,240,3,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,169,0,141,57,0,160,0,173,61,0,201,0,240,17,201,1,240,8,173,60,0,145,16,76,86,239,173,60,0,145,16,173,59,0,145,14,172,69,0,140,8,0,172,70,0,140,9,0,162,175,160,244,32,153,243,173,8,0,141,92,0,173,9,0,141,93,0,32,6,240,206,62,0,240,3,76,179,237,76,123,224,24,96,56,96,162,44,142,10,0,162,248,142,11,0,160,4,177,10,201,90,240,28,160,7,177,10,205,67,0,240,17,173,10,0,24,105,10,141,10,0,144,3,238,11,0,76,145,239,56,96,24,96,173,95,0,201,0,240,23,162,0,32,202,242,176,3,76,171,242,142,8,0,140,9,0,173,115,0,201,0,208,33,173,8,0,141,92,0,173,9,0,141,93,0,24,173,8,0,105,20,141,92,0,144,7,174,93,0,232,142,93,0,76,6,240,162,20,32,202,242,176,3,76,171,242,142,92,0,140,93,0,173,93,0,205,9,0,240,5,144,14,76,33,240,173,92,0,205,8,0,144,3,76,33,240,76,173,242,160,0,177,8,141,67,0,32,135,239,176,29,162,175,160,244,32,153,243,32,12,243,173,67,0,32,69,243,162,136,160,245,32,153,243,32,193,242,76,6,240,162,175,160,244,32,153,243,32,12,243,32,193,242,160,6,177,10,201,80,208,3,76,164,240,201,77,208,3,76,203,240,201,83,208,3,76,254,240,201,88,208,3,76,254,240,201,89,208,3,76,254,240,201,82,208,3,76,27,242,201,76,208,3,76,104,241,201,67,208,3,76,181,240,201,68,208,3,76,93,242,201,73,208,3,76,217,241,76,45,240,173,67,0,32,69,243,160,8,32,233,242,32,175,242,76,6,240,173,67,0,32,69,243,160,8,32,233,242,32,175,242,169,65,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,160,5,32,233,242,32,175,242,169,35,32,250,243,173,65,0,32,69,243,169,104,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,169,32,32,250,243,177,8,141,66,0,32,69,243,32,193,242,160,2,32,233,242,32,175,242,173,66,0,32,69,243,173,65,0,32,69,243,169,104,32,250,243,160,6,177,10,201,88,240,7,201,89,240,16,76,6,240,169,44,32,250,243,169,88,32,250,243,76,6,240,169,44,32,250,243,169,89,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,160,5,32,233,242,32,175,242,173,8,0,141,63,0,173,9,0,141,64,0,173,65,0,48,18,173,63,0,24,109,65,0,141,63,0,144,32,238,64,0,76,197,241,206,65,0,173,65,0,73,255,141,65,0,173,63,0,56,237,65,0,141,63,0,176,3,206,64,0,173,64,0,32,69,243,173,63,0,32,69,243,169,104,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,160,5,32,233,242,32,175,242,169,40,32,250,243,173,65,0,32,69,243,169,104,32,250,243,169,41,32,250,243,169,44,32,250,243,169,89,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,160,5,32,233,242,32,175,242,169,40,32,250,243,173,65,0,32,69,243,169,104,32,250,243,169,44,32,250,243,169,88,32,250,243,169,41,32,250,243,76,6,240,160,0,173,67,0,32,69,243,169,32,32,250,243,177,8,141,65,0,32,69,243,32,193,242,169,32,32,250,243,177,8,141,66,0,32,69,243,32,193,242,160,2,32,233,242,32,175,242,169,40,32,250,243,173,66,0,32,69,243,173,65,0,32,69,243,169,104,32,250,243,169,41,32,250,243,76,6,240,24,96,56,96,160,0,177,10,32,250,243,200,192,3,208,246,169,32,32,250,243,96,238,8,0,208,3,238,9,0,96,32,35,243,176,3,76,223,242,168,232,32,35,243,176,3,76,223,242,170,56,96,24,96,162,131,160,245,32,153,243,96,72,169,32,32,250,243,136,208,248,104,96,201,65,48,7,201,91,16,3,24,105,32,96,201,97,48,7,201,123,16,3,56,233,32,96,173,9,0,32,69,243,173,8,0,32,69,243,169,32,32,250,243,169,32,32,250,243,96,189,95,0,32,121,234,144,25,10,10,10,10,41,240,141,156,0,232,189,95,0,32,121,234,144,7,13,156,0,141,156,0,56,96,141,156,0,74,74,74,74,41,15,201,10,16,5,9,48,76,92,243,56,233,9,9,64,32,250,243,173,156,0,41,15,201,10,16,5,9,48,76,114,243,56,233,9,9,64,32,250,243,173,156,0,96,169,4,141,4,0,169,226,141,5,0,169,0,141,57,0,169,0,141,47,0,141,48,0,141,49,0,141,50,0,169,0,96,72,142,6,0,140,7,0,160,0,177,6,240,14,32,250,243,238,6,0,208,3,238,7,0,76,162,243,104,96,8,138,72,152,72,173,1,160,41,8,240,9,173,0,160,141,206,0,76,208,243,169,0,141,206,0,104,168,104,170,40,173,206,0,96,8,138,72,152,72,173,1,160,41,8,208,6,173,2,160,76,222,243,173,0,160,141,206,0,104,168,104,170,40,173,206,0,96,141,206,0,8,152,72,138,72,173,1,160,41,16,240,249,173,206,0,141,0,160,104,170,104,168,40,173,206,0,96,72,138,72,152,72,169,0,141,162,0,169,16,141,163,0,206,162,0,208,251,206,163,0,208,246,104,168,104,170,104,96,22,11,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,0,48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,0,10,13,10,85,77,79,78,54,53,32,86,49,46,49,57,32,45,32,85,110,100,101,114,115,116,97,110,100,97,98,108,101,32,77,111,110,105,116,111,114,32,102,111,114,32,116,104,101,32,54,53,48,48,32,115,101,114,105,101,115,32,109,105,99,114,111,112,114,111,99,101,115,115,111,114,115,46,10,13,0,10,13,45,0,10,13,0,10,13,83,101,110,100,32,83,32,114,101,99,111,114,100,115,32,119,104,101,110,32,121,111,117,32,97,114,101,32,114,101,97,100,121,46,46,46,10,13,0,10,13,7,69,114,114,111,114,32,76,111,97,100,105,110,103,32,83,32,82,101,99,111,114,100,115,46,46,46,10,13,0,10,13,7,83,32,114,101,99,111,114,100,115,32,115,117,99,99,101,115,115,102,117,108,108,121,32,108,111,97,100,101,100,32,40,112,114,101,115,115,32,60,101,110,116,101,114,62,32,116,111,32,99,111,110,116,105,110,117,101,41,46,0,10,13,10,80,103,109,67,110,116,114,40,80,67,41,32,32,65,99,99,117,109,40,65,67,41,32,32,88,82,101,103,40,88,82,41,32,32,89,82,101,103,40,89,82,41,32,32,83,116,107,80,116,114,40,83,80,41,32,32,78,86,45,66,68,73,90,67,40,83,82,41,10,13,0,10,13,32,58,0,32,32,32,32,32,32,32,32,63,63,63,0,10,13,65,108,108,32,98,114,101,97,107,112,111,105,110,116,115,32,97,114,101,32,99,117,114,114,101,110,116,108,121,32,105,110,32,117,115,101,46,0,10,13,78,111,32,98,114,101,97,107,112,111,105,110,116,32,101,120,105,115,116,115,32,97,116,32,116,104,105,115,32,97,100,100,114,101,115,115,46,0,10,13,89,111,117,32,99,97,110,110,111,116,32,71,79,32,97,116,32,97,32,98,114,101,97,107,112,111,105,110,116,101,100,32,97,100,100,114,101,115,115,44,32,84,82,65,67,69,32,112,97,115,116,32,105,116,32,116,104,101,110,32,71,79,46,0,10,13,63,0,10,13,10,65,115,115,101,109,98,108,101,32,32,32,32,32,32,32,65,32,115,116,97,114,116,95,97,100,100,114,101,115,115,10,13,66,114,101,97,107,112,111,105,110,116,32,32,32,32,32,66,32,40,43,44,45,44,63,41,32,97,100,100,114,101,115,115,10,13,68,117,109,112,32,32,32,32,32,32,32,32,32,32,32,68,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,69,110,116,101,114,32,32,32,32,32,32,32,32,32,32,69,32,97,100,100,114,101,115,115,32,108,105,115,116,10,13,70,105,108,108,32,32,32,32,32,32,32,32,32,32,32,70,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,71,111,32,32,32,32,32,32,32,32,32,32,32,32,32,71,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,93,10,13,72,101,108,112,32,32,32,32,32,32,32,32,32,32,32,72,32,111,114,32,63,10,13,76,111,97,100,32,32,32,32,32,32,32,32,32,32,32,76,10,13,77,111,118,101,32,32,32,32,32,32,32,32,32,32,32,77,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,100,101,115,116,105,110,97,116,105,111,110,95,97,100,100,114,101,115,115,10,13,82,101,103,105,115,116,101,114,32,32,32,32,32,32,32,82,32,91,80,67,44,65,67,44,88,82,44,89,82,44,83,80,44,83,82,93,10,13,83,101,97,114,99,104,32,32,32,32,32,32,32,32,32,83,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,84,114,97,99,101,32,32,32,32,32,32,32,32,32,32,84,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,118,97,108,117,101,93,93,10,13,85,110,97,115,115,101,109,98,108,101,32,32,32,32,32,85,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,0,65,68,67,32,73,77,77,105,2,2,65,68,67,32,65,66,83,109,3,4,65,68,67,32,65,66,88,125,3,4,65,68,67,32,65,66,89,121,3,4,65,68,67,32,73,73,82,97,2,6,65,68,67,32,73,82,73,113,2,5,65,78,68,32,73,77,77,41,2,2,65,78,68,32,65,66,83,45,3,4,65,78,68,32,65,66,88,61,3,4,65,78,68,32,65,66,89,57,3,4,65,78,68,32,73,73,82,33,2,6,65,78,68,32,73,82,73,49,2,5,65,83,76,32,65,67,67,10,1,2,65,83,76,32,65,66,83,14,3,6,65,83,76,32,65,66,88,30,3,7,66,67,67,32,82,69,76,144,2,2,66,67,83,32,82,69,76,176,2,2,66,69,81,32,82,69,76,240,2,2,66,73,84,32,65,66,83,44,3,4,66,77,73,32,82,69,76,48,2,2,66,78,69,32,82,69,76,208,2,2,66,80,76,32,82,69,76,16,2,2,66,82,75,32,73,77,80,0,1,7,66,86,67,32,82,69,76,80,2,2,66,86,83,32,82,69,76,112,2,2,67,76,67,32,73,77,80,24,1,2,67,76,68,32,73,77,80,216,1,2,67,76,73,32,73,77,80,88,1,2,67,76,86,32,73,77,80,184,1,2,67,77,80,32,73,77,77,201,2,2,67,77,80,32,65,66,83,205,3,4,67,77,80,32,65,66,88,221,3,4,67,77,80,32,65,66,89,217,3,4,67,77,80,32,73,73,82,193,2,6,67,77,80,32,73,82,73,209,2,5,67,80,88,32,73,77,77,224,2,2,67,80,88,32,65,66,83,236,3,4,67,80,89,32,73,77,77,192,2,2,67,80,89,32,65,66,83,204,3,4,68,69,67,32,65,66,83,206,3,6,68,69,67,32,65,66,88,222,3,7,68,69,88,32,73,77,80,202,1,2,68,69,89,32,73,77,80,136,1,2,69,79,82,32,73,77,77,73,2,2,69,79,82,32,65,66,83,77,3,4,69,79,82,32,65,66,88,93,3,4,69,79,82,32,65,66,89,89,3,4,69,79,82,32,73,73,82,65,2,6,69,79,82,32,73,82,73,81,2,5,73,78,67,32,65,66,83,238,3,6,73,78,67,32,65,66,88,254,3,7,73,78,88,32,73,77,80,232,1,2,73,78,89,32,73,77,80,200,1,2,74,77,80,32,65,66,83,76,3,3,74,77,80,32,73,78,68,108,3,5,74,83,82,32,65,66,83,32,3,6,76,68,65,32,73,77,77,169,2,2,76,68,65,32,65,66,83,173,3,4,76,68,65,32,65,66,88,189,3,4,76,68,65,32,65,66,89,185,3,4,76,68,65,32,73,73,82,161,2,6,76,68,65,32,73,82,73,177,2,5,76,68,88,32,73,77,77,162,2,2,76,68,88,32,65,66,83,174,3,4,76,68,88,32,65,66,89,190,3,4,76,68,89,32,73,77,77,160,2,2,76,68,89,32,65,66,83,172,3,4,76,68,89,32,65,66,88,188,3,4,76,83,82,32,65,67,67,74,1,2,76,83,82,32,65,66,83,78,3,6,76,83,82,32,65,66,88,94,3,7,78,79,80,32,73,77,80,234,1,2,79,82,65,32,73,77,77,9,2,2,79,82,65,32,65,66,83,13,3,4,79,82,65,32,65,66,88,29,3,4,79,82,65,32,65,66,89,25,3,4,79,82,65,32,73,73,82,1,2,6,79,82,65,32,73,82,73,17,2,5,80,72,65,32,73,77,80,72,1,3,80,72,80,32,73,77,80,8,1,3,80,76,65,32,73,77,80,104,1,4,80,76,80,32,73,77,80,40,1,4,82,79,76,32,65,67,67,42,1,2,82,79,76,32,65,66,83,46,3,6,82,79,76,32,65,66,88,62,3,7,82,79,82,32,65,67,67,106,1,2,82,79,82,32,65,66,83,110,3,6,82,79,82,32,65,66,88,126,3,7,82,84,73,32,73,77,80,64,1,6,82,84,83,32,73,77,80,96,1,6,83,66,67,32,73,77,77,233,2,2,83,66,67,32,65,66,83,237,3,4,83,66,67,32,65,66,88,253,3,4,83,66,67,32,65,66,89,249,3,4,83,66,67,32,73,73,82,225,2,6,83,66,67,32,73,82,73,241,2,5,83,69,67,32,73,77,80,56,1,2,83,69,68,32,73,77,80,248,1,2,83,69,73,32,73,77,80,120,1,2,83,84,65,32,65,66,83,141,3,4,83,84,65,32,65,66,88,157,3,5,83,84,65,32,65,66,89,153,3,5,83,84,65,32,73,73,82,129,2,6,83,84,65,32,73,82,73,145,2,6,83,84,88,32,65,66,83,142,3,4,83,84,89,32,65,66,83,140,3,4,84,65,88,32,73,77,80,170,1,2,84,65,89,32,73,77,80,168,1,2,84,83,88,32,73,77,80,186,1,2,84,88,65,32,73,77,80,138,1,2,84,88,83,32,73,77,80,154,1,2,84,89,65,32,73,77,80,152,1,2,90,90,90,32,90,90,90,0,0,0,0,224,241,225};
.         %/output

.   %/output







