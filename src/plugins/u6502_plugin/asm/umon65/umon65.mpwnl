%uasm65,title=""
;****************************************************************************
;  UMON65 Understandable Monitor for the 6500 series microprocessors.
;  Copyright 2015 by Ted Kosan.
;
;
;****************************************************************************


;****************************************************************************
;                                Equates Area.
;****************************************************************************   


;
;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
;
;Transmitt Receive Register.
6551TRR:	equ A000h ;400ah


;Status Register.  
;		    Status			          cleared by
;	b0	Parity error * (1: error)       self clearing **
;	b1	Framing error * (1: error)      self clearing **
;	b2	Overrun * (1: error)            self clearing **
;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
;                                                                                                            
;	note: * no interrupt generated for these conditions
;	      ** cleared automatically after a read of RDR and the next 
;		error free receipt of data
6551StR:	equ A001h ;400bh 

6551Sleep: equ A002h	; When an lda to this address is performed the emulator
			;can be put to sleep.


;Comand Register  
;	b0	Data Terminal Ready
;			0 : disable receiver and all interrupts (DTR high)
;			1 : enable receiver and all interrupts (DTR low)
;	b1	Receiver Interrupt Enable
;			0 : IRQ interrupt enabled from bit 3 of status register
;			1 : IRQ interrupt disabled
;	b3,b2	Transmitter Control
;				Transmit Interrupt    RTS level    Transmitter
;			00	   disabled		high		off
;			01	   enabled		low		on
;			10	   disabled		low		on
;			11	   disabled		low	   Transmit BRK
;	b4	Normal/Echo Mode for Receiver
;			0 : normal
;			1 : echo (bits 2 and 3 must be 0)
;	b5	Parity Enable
;			0 : parity disabled, no parity bit generated or received
;			1 : parity enabled
;	b7,b6	Parity
;			00 : odd parity receiver and transmitter
;			01 : even parity receiver and transmitter
;			10 : mark parity bit transmitted, parity check disabled
;			11 : space parity bit transmitted, parity check disabled


;6551CmR	equ 0b202h  

;Control Register
;
;	b3-b0	baud rate generator:
;			0000 : 16x external clock
;			0001 : 50 baud
;			0010 : 75
;			0011 : 110
;			0100 : 134.5
;			0101 : 150
;			0110 : 300
;			0111 : 600
;			1000 : 1200
;			1001 : 1800
;			1010 : 2400
;			1011 : 3600
;			1100 : 4800
;			1101 : 7200
;			1110 : 9600
;			1111 : 19,200
;	b4	receiver clock source
;			0 : external receiver clock
;			1 : baud rate generator
;	b6,b5	word length                                                                  
;			00 : 8 bits
;			01 : 7
;			10 : 6
;			11 : 5
;	b7	stop bits
;			0 : 1 stop bit
;			1 : 2 stop bits
;			    (1 stop bit if parity and word length = 8)
;			    (1 1/2 stop bits if word length = 5 and no parity)
;6551CtR	equ 0b203h  




;InPort0 Equate.
InPort0:	equ 0a000h

;OutPort0 Equate.
OutPort0:	equ 0a100h

;****************************************************************************
;                       General Purpose Pointer Area.
;****************************************************************************
	org 0000h
	
GenPoint:	dwd ?
IRQVect:	dwd ?		;
BRKVect:	dwd ?		;Break command indirect vector.
MessPtr:	dwd ?		;
PointerA:	dwd ?		;
PointerB:	dwd ?		;
PointerC:	dwd ?		;
NOpAdPtr:	dwd ?		;
BOpAdPtr:	dwd ?		;
BrkPt1Ad:	dwd ?		;
BrkPt2Ad:	dwd ?		;
BrkPt3Ad:	dwd ?		;                                                                                       
BrkPt4Ad:	dwd ?		;


	
;****************************************************************************
;                   General Purpose Variable Storage Area.
;****************************************************************************
;	org 0200h 

		  
Obj1:		dbt ?
Obj2:		dbt ?
Obj3:		dbt ?
Obj2Flg:	dbt ?
Obj3Flg:	dbt ?
AddMode:	dbt ?
SrchTabl:	dbt 10d(?)
SrchBtCt:	dbt ?
TempAdd:	dwd ?
TempAdd2:	dwd ?
BrkPt1St:	dbt ?
BrkPt2St:	dbt ?
BrkPt3St:	dbt ?
BrkPt4St:	dbt ?
BP1OpHld:	dbt ?
BP2OpHld:	dbt ?
BP3OpHld:	dbt ?
BP4OpHld:	dbt ?
BPNumHld:	dbt ?
BrValHld:	dbt ?
TrBrkFlg:	dbt ?
CurInsLn:	dbt ?
NOpCdHld:	dbt ?
BOpCdHld:	dbt ?
BrnchFlg:	dbt ?
TracCnt:	dbt ?
AddHold:	dwd ?
ObCdHld1:	dbt ?
ObCdHld2:	dbt ?
OpCdHold:	dbt ?
TempA:		dbt ?
UPgmCntr:	dwd ?
UAccum:		dbt ?
UXReg:		dbt ?
UYReg:		dbt ?
UStkPtr:	dbt ?
UStatReg:	dbt ?
ASCIIbuf:	dbt 16d(?)
EndAdd:		dwd ?
OpOffSet:	dbt ?
OpFld1:		dbt 20d(?)
OpFld2:		dbt 20d(?)
OpFld3:		dbt 20d(?)	
CodeCntr:	dbt ?
Number:		dbt ?
ChkSum:		dbt ?
RecLen:		dbt ?
CkSumAc:	dwd ?
RecType: 	dbt ?
wait0:		dbt ?
wait1:		dbt ?
			dbt ?
InptBufr:	dbt 40d(?)
Command:	dbt ?
RegTemp:	dbt ?
DataTemp:	dbt ?

;****************************************************************************
;                        Monitor Eprom Entry Point.
;****************************************************************************
	org 0e000h Note
	;org 1000h
	jmp Start

;****************************************************************************
;                  Monitor Utility Subroutine Jump Table.
;****************************************************************************
	jmp OutChar	;Output byte in A register to serial port.
	
	jmp GetChar	;Get a byte from the serial port.
	
	jmp GetCharW	;Wait and get a byte from the serial port.
	
	jmp PrntMess	;Print a message to the serial port.
	
	jmp OutSpace	;Output spaces to the serial port.
	
	jmp OutHex	;Output a HEX number to the serial port.
	
	jmp DgtToBin	;Convert an ASCII digit into binary.
	
	jmp GetLine	;Input a line from the serial port.
	

; Beginning of UMON65.
;****************************************************************************
;                       Start of UMON65 Main Routine.
;
;
;****************************************************************************
start:
	sei
	ldx #0ffh	;Initialize stack pointer and
	txs		; clear decimal mode.
;	cli		;
	cld		;
	
	jsr InitVars	;Initialize variables.
	
    lda #00000100b	 ;Initialize user's status register.
	sta UStatReg	;

	lda #0d	    ;Initialize user's accumulator.
	sta UAccum	;
	
	sta UXReg	;Initialize user's X register.
	
	sta UYReg	;Initialize user's Y register.
	
	lda #0ffh    ;Initialize user's stack pointer
	sta UStkPtr	 ;.
	
	lda 0aa00h		; If ESC has been pressed, enter the monitor.
	cmp #0d			;
	beq EnterMon	;
	
	lda 0c000h		; If the byte at 0c000h is not zero, there is a program
	beq EnterMon    ; in the EEPROM that has been copied to 0200h by the emulator.
	jmp 0200h		; Run this program.

;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
		
;****************************************************************************
;                     Check Computer's Configuration.
;****************************************************************************
CkConfig:
	;lda InPort0	;Get the switch settings and mask out the 
	;and #00001111b	; switch's high nibble.

;CkMon:
	
	;cmp #1d	;If the switch is set to a 1 then print the
	;bne CkEEPROM		; UMON65 monitor startup messages and enter the
EnterMon:				; monitor through the maskable interrupt vector.
	ldx #0d
CopyVersion:
	lda EmuVersionFrom,x
	sta EmuVersionTo,x
	inx
	cpx #8d
	bne CopyVersion
	ldx #EmulatorMess<  ;
	ldy #EmulatorMess>  ;
	jsr PrntMess        ;
	                    ;
	ldx #OpenMess<		; 
	ldy #OpenMess>		;
	jsr PrntMess		;
	;brk		    	;
   
    jmp ResetEntryPoint

CkEEPROM:
	cmp #2d		;If the switch is set to a 2 then get the
	bne DoLgtSho	; switch's high nibble and jump to a program
	;lda InPort0	; present in the EEPROM which is indicated by
	and #11110000b	; the high nibble's value.  The program can be
	lsr a		; located at 1 of the following 16 locations:
	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
	clc
	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
	sta PointerA+1d	; 15-DE00.
	lda #0d		;
	sta PointerA	;
	jmp (PointerA)	;
			
DoLgtSho:
	jmp LghtShow
	
;****************************************************************************
;                            Light Show Subroutine.
;****************************************************************************
LghtShow:
	ldy #0h		;Make the Y register count from 0 to 255 and
	sty TempA	; output each number in the count to the
	;sty OutPort0	; light register.
LSOtLoop:		;
	ldx #100d	;
LSInLoop:		;
	iny		;
	bne LSInLoop	;
	dex		;
	bne LSInLoop	;
	inc TempA	;
	lda TempA	;
	;sta OutPort0	;
	jmp LSOtLoop	;

;****************************************************************************
;                            Monitor's Main Loop.
;****************************************************************************
MainLoop:	

	jsr GetLineP	;Get a typed line from the serial port.

	jsr ParsLine	;Break line into fields.
	
	jsr CkValCmd	;Check to see if a valid monitor command was
			; entered and if so execute that command's code.
	jmp MainLoop

	
;****************************************************************************
;                    Get Line From Serial Port Subroutine.
;****************************************************************************
GetLineP:
	ldx #Prompt<	;Print Prompt.
	ldy #Prompt>	;
	jsr PrntMess	;

GetLine:	
	ldy #0d		;Initialize Y index register.
	sty OpOffSet	;Initialize opcode holder offset pointer.
	sty command	;Initialize command holder.
	sty OpFld1	;Initialize operand field 1 buffer.
	sty OpFld2	;Initialize operand field 2 buffer.
	sty OpFld3	;Initialize operand field 3 buffer.
	
	ldy #0d		;Clear input buffer.
	lda #0d		;
ClrInpBf:		;
	sta InptBufr,y	;
	iny		;
	cpy #39d	;
	bne ClrInpBf	;
	
	ldy #0h		;Use Y register as buffer pointer.
	
GtAnChar:
	jsr GetCharW
;	jsr OutChar	;Echo character.  ;Note: remove for muvium.

	cmp #0h		;If no character is entered then try again.
	beq GtAnChar	;
	
	cmp #8d		;Check to see if the user entered a Delete or
	bne CkDel	; a Backspace.  If so then erase the character
	jmp DoDelete	; to the left of the cursor.
CkDel:			;
	cmp #127d	;
	bne GtCkChar	;
DoDelete:		;
	dey		;
	bmi AtStart	;
	lda #32d	;
	jsr OutChar	;
	lda #8d		;
	jsr OutChar	;
	jmp GtAnChar	;

AtStart:
	ldy #0d
	jmp GtAnChar
	
GtCkChar:
	cmp #13d	;If a CR was entered then accept line and exit,
	beq GtLnDone	; if not then accept the next character and
	sta InptBufr,y	; place it into the input buffer.
	iny		;
	
	cpy #39d	;Do not let buffer expand past 40 characters.
	bne GtAnChar
	ldy #39d	;Set buffer at 40 characters if over 40 characters.

	jmp GtAnChar	;
	
GtLnDone:
	;If a NL is in the input buffer then remove it.
	dey
	lda InptBufr,y
	cmp #10d
	beq PutNull
	iny
PutNull:
	lda #0h		;Put a NULL at end of the input buffer.
	sta InptBufr,y	;
		
	rts
	
;****************************************************************************
;                       Parse Input Buffer Subroutine.
;****************************************************************************
ParseOpr:	;Entry point if parsing for a UASM command is not
	ldy #0ffh	; desired.
	jmp GtAnoOpr	;
	
ParsLine:
	ldy #0d

	lda InptBufr,y
	beq ExtPrsLn	;If NULL or CR encountered then return.
	
	cmp #63d	;Check for upper case letter.
	bmi ParError	;
	cmp #90d	;	
	bpl CkSmCase	;
	
	sec
	bcs GetCmd	;
	
CkSmCase:
	cmp #97d	;Check for lower case letter.
	bmi ParError	;
	cmp #122d	;
	bpl ParError	;
	                
GetCmd:
	sta command	;Store command in command buffer.
                        
GtAnoOpr:       
	iny		;Point Y to the next operand field and check to
	cpy #20d	;make sure that the input line is not too long.
	beq ParError	;
	                
	lda InptBufr,y	;Check for the end of the input line.
	cmp #0d		;
	beq ExtPrsLn	;
	                
	cmp #32d	;Check for a space between operand fields.
	beq GtAnoOpr	;
	                
ScanOprn:              
	ldx OpOffSet	;Point X to the beginning of the current operand
	txa		; field holder and point OpOffSet to the beginning
	clc             
	adc #20d	; of the next operand field holder.
	sta OpOffSet	;
	
TranDgt:
	lda InptBufr,y	;
	                
	cmp #32d	;If a space is encountered then stop scanning.
	beq DoneScan	;
	                
	Cmp #0d		;If a CR is encountered then stop scanning.
	beq doneScan	;
	                
	sta OpFld1,x	;Transfer current operand from input buffer into
	inx		; current operand field holder.
	iny		;
	cpy #40d
	beq ParError
	
	jmp TranDgt	
	
DoneScan:
	lda #0h		;Put a NULL at the end of the current operand field
	sta OpFld1,x	; holder.
	
	jmp GtAnoOpr

ParError:
	rts
ExtPrsLn:
	rts

;****************************************************************************
;                     Check for Valid Command Subroutine.
;****************************************************************************
CkValCmd:
	sec
	
	lda command
	jsr ToLower

	cmp #108d	;Check for Load command.
	bne NxtCmd1	;
	jsr LdSRecs	;
	jmp ExitCmd	;
                        
NxtCmd1:
	cmp #100d	;Check for Dump command.
	bne NxtCmd2	;
	jsr Dump	;
	jmp ExitCmd	;
                        
NxtCmd2:
	cmp #114d	;Check for Register command.
	bne NxtCmd3	;
	jsr Register	;
	jmp ExitCmd	;
		
NxtCmd3:
	cmp #103d	;Check for Go command.
	bne NxtCmd4	;
	jsr Go		;
	jmp ExitCmd	;
	
NxtCmd4:
	cmp #101d	;Check for Enter command.
	bne NxtCmd5	;
	jsr Enter	;
	jmp ExitCmd	;
	
NxtCmd5:
	cmp #102d	;Check for Fill command.
	bne NxtCmd6	;
	jsr Fill	;
	jmp ExitCmd	;

NxtCmd6:
	cmp #117d	;Check for Unassemble command.
	bne NxtCmd7	;
	jsr UnAssem	;
	jmp ExitCmd	;

NxtCmd7:
	cmp #116d	;Check for Trace command.
	bne NxtCmd8	;
	jsr Trace	;
	jmp ExitCmd	;

NxtCmd8:
	cmp #98d	;Check for Breakpoint command.
	bne NxtCmd9	;
	jsr BreakPnt	;
	jmp ExitCmd	;
	
NxtCmd9:
	cmp #115d	;Check for Search command.
	bne NxtCmd10	;
	jsr Search	;
	jmp ExitCmd	;

NxtCmd10:
	cmp #109d	;Check for Move command.
	bne NxtCmd11	;
	jsr Move	;
	jmp ExitCmd	;
	
NxtCmd11:
	cmp #'a'	;Check for Assemble command.
	bne NxtCmd12	;
	jsr Assemble	;
	jmp ExitCmd	;

NxtCmd12:
	cmp #104d	;Check for Help command.
	bne NxtCmd13	;
	jsr Help	;
	jmp ExitCmd	;
NxtCmd13:                 
	cmp #63d	;
	bne ExitCmd	;
	jsr Help	;
	jmp ExitCmd	;

ExitCmd:
	bcs CmdOk
	
CmdError:		;If there was an error with a command then
	ldx #CmdErMes<	; print a question mark.
	ldy #CmdErMes>	;
	jsr PrntMess	;
	clc		;
	rts		;
	
CmdOk:
	sec
	rts

;****************************************************************************
;                     Maskable Interrupt Service Subroutine.
;****************************************************************************
MaskInt:
	sei		;Disable interrupts.

	sta TempA	;Save accumulator.
			
	pla		;Check to see if BRK command was executed.
	pha		;
	and #10h	;
	bne DoBRK	;
	
	lda TempA	;Restore accumulator.

IRQ:	
	jmp (IRQVect)
	
DoBRK:
	jmp (BRKVect)

	
;****************************************************************************
;                          Break Service Subroutine.
;****************************************************************************
	
BRK:
	pla		;Save user's status register.
	sta UStatReg	;

	
	lda TempA	;Save user's accumulator.
	sta UAccum	;
	
	stx UXReg	;Save user's X register.
	
	sty UYReg	;Save user's Y register.
	
	tsx
    
    inx ;Remove the remaining 2 bytes that were pushed on the
    inx ; stack by the brk command.
    
	stx UStkPtr	;Save user's stack pointer.
	
	pla		;Save program counter of break instruction
	sec		; that caused execution of this code.
	sbc #1d		;
	sta UPgmCntr	;
	pla		; 
	sbc #0d		;
	sta UPgmCntr+1d	;
;	cli

ResetEntryPoint:
	ldy #0d		;Print user's registers.
	sty OpFld1	;
	jsr Register	;

	lda TrBrkFlg	;If this break was placed by the trace command
	cmp #1d		; then go back to the trace subroutine.
	bne RepBPOp	;
	jmp Tr2ndEnt	;
	
RepBPOp:
	ldy #3d		;Replace the opcodes of all breakpointed
	ldx #6d		; addresses.
CkBPStBr:              ;
	lda BrkPt1St,y	;
	cmp #1d		;
	bne NxtBPStB	;
	lda BP1OpHld,y	;
	sta (BrkPt1Ad,x);
NxtBPStB:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPStBr	;
	
GoMain:
	jmp MainLoop	;Enter monitor.


;****************************************************************************
;                       Assemble Command Subroutine.
;****************************************************************************
Assemble:

	ldx #0d		;Get address to start assembling at and store
	jsr GetAdd	; in pointer A.
	bcs AAddOk	;
	jmp ErrAsem	;
AAddOk:		;
	stx PointerA	;
	sty PointerA+1d	;

AsemTop:		;On new line print current address being
	ldx #CRLF<	; assembled at and get next instruction to be
	ldy #CRLF>	; assembled from user.
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr GetLine	;
	jsr ParseOpr	;
	
	lda OpFld1	;Check for operator to be assembled. If no
	cmp #0d		; operator is found then exit Assemble 
	beq AsemDone	; subroutine.
	cmp #32d	;
	bne ACont	;
AsemDone:              ;
	jmp ExitAsem	;
	
ACont:			;Convert operator in input buffer to upper case,
	ldy #0d		; check to see if it is in the operator table and
ConvAno:		;
	lda OpFld1,y	; output a question mark if operator was not found.
	jsr ToUpper	;
	sta OpFld1,y	;
	iny		;
	cpy #3d		;
	bne ConvAno	;
	jsr OptrScan	;
	bcs AOptrOk	;
	
PrntQues:
	jsr PrntAdd	;If there was an error assembling the instruction
	lda #32d	; input from the user into object code then re-
	jsr OutChar	; output the line and print a question mark.
	ldx #OpFld1<	;
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;
	lda #32d	;
	jsr OutChar	;
	lda #63d	;
	jsr OutChar	;
	jmp AsemTop	;
	
AOptrOk:		;Check address mode of operand and print a quesion
	jsr AdMdScan	; mark if error occures while scanning operand.
	bcs AOpndOk	;
	jmp PrntQues
		
AOpndOk:		;Check to see if address mode of operand is a
	jsr AdMdTbSc	; valid address mode for instruction.
	bcs AOpTbFnd	;
	jmp PrntQues
		
AOpTbFnd:		;Extract object code from operand.
	jsr OpndScan	;
	bcs PrntAssm	;
	jmp PrntQues	;
	
PrntAssm:
	jsr PrntAdd	;Re-output current address.
	
	ldy #0d		;
	
	lda Obj1	;Output opcode, store it in memory, point to next
	sta (PointerA),y; byte, and print one space.
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj2Flg	;Output second object code byte if present, store it in
	beq NoObjCd	; it in memory, point to next byte, and print one
	lda Obj2	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	
	lda Obj3Flg	;Output third object code byte if present, store
	beq NoObjCd3	; it in memory, point to next byte, and print one
	lda Obj3	; space.
	sta (PointerA),y;
	jsr OutHex	;
	jsr IncPntrA	;
	lda #32d	;
	jsr OutChar	;
	jmp NoExSpcs

NoObjCd:		;If fewer then 3 bytes of object code are output
	lda #32d	; then output spaces instead.
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
NoObjCd3:
	lda #32d	;
	jsr OutChar	;
	jsr OutChar	;
	jsr OutChar
	
NoExSpcs:
	lda #32d	;
	jsr OutChar	;
	ldx #OpFld1<	;Re-output instruction that user had entered in.
	ldy #OpFld1>	;
	jsr PrntMess	;
	lda #32d  	;
	jsr OutChar	;
	ldx #OpFld2<	;
	ldy #OpFld2>	;
	jsr PrntMess	;

	jmp AsemTop
	
	
ErrAsem:
	clc
	rts
	
ExitAsem:
	sec
	rts
	

;****************************************************************************
;                       Operator Scan Subroutine.
;****************************************************************************
OptrScan:

	ldx #OpTable<	;Point pointer B to beginning of the operator
	stx PointerB	; table.
	ldx #Optable>	;
	stx PointerB+1d	;
	
OSCkAno:
	ldy #0d		;Compare a digit of the operator that the user
OSCkAnCM:		;
	lda (PointerB),y; entered with the analogous digit of the
	cmp OpFld1,y	; operator in the operator table.
	beq CharMtch	;
	
OptScan2:
	lda PointerB	;Point pointer B to the beginning of the next
	clc		; operator in the operator table.
	adc #10d	;
	sta PointerB	;
	bcc OSNoCary	;
	inc PointerB+1d	;
	
OSNoCary:
	ldy #4d		;Check for the end of the operator table.
	lda (PointerB),y;
	cmp #'Z'	;
	beq OSNoMtch	;
	jmp OSCkAno	;
	
CharMtch:		;Check for an operator match in the operator
	iny		; table.
	cpy #3d		;
	beq OSMatch	;
	jmp OSCkAnCM	;
	
OSNoMtch:
	clc
	rts
	
OSMatch:
	sec
	rts


;****************************************************************************
;                     Address Mode Scan Subroutine.
;****************************************************************************
AdMdScan:

AMSCkIMP:
	ldy #0d		;Check for implied addressing mode.
	lda OpFld2,y	;
	cmp #0d		;
	bne AMSCkIMM	;
	lda #'P'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkIMM:		;Check for immediate addressing mode.
	cmp #'#'	;
	bne AMSCkACC	;
	lda #'M'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkACC:		;Check for accumulator addressing mode.
	cmp #'A'	;
	beq CkSpNull	;
	cmp #'a'	;
	beq CkSpNull	;
	jmp AMSCkREL	;
CkSpNull:		;
	iny		;
	lda OpFld2,y	;
	Cmp #0d		;
	beq IsAcc	;
	cmp #32d	;
	beq IsAcc	;
	jmp AMSCkREL	;
IsAcc:			;
	lda #'C'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkREL:		;Check for relative addressing mode.
	ldy #6d		;
	lda (PointerB),y;
	cmp #'L'	;
	bne AMSCkA_I	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkA_I:		;Dispatch to absolute or indexed check code.
	ldy #0d		;
	lda OpFld2,y	;
	cmp #'('	;
	bne AMSCkAB?	;
	jmp AMSCkId?	;
	
AMSCkAB?:		;Check to see if operand is absolute addressing
	ldy #0d		; mode or absolute indexed addressing mode.
AMSScnAB:		;
	lda OpFld2,y	;
	cmp #','	;
	beq CkXorY	;
	cmp #0d		;
	beq IsABS	;
	iny		;
	jmp AMSScnAB	;
	
CkXorY:		;Check for absolute X or absolute Y addressing
	iny		; mode.
	lda OpFld2,y	;                                                                        
	cmp #'X'	;
	beq IsABX	;
	cmp #'x'	;
	beq IsABX	;
	cmp #'Y'	;
	beq IsABY	;
	cmp #'y'	;
	beq IsABY	;
	jmp ErrAMS	;
	
IsABX:			;Save ABS, ABX or ABY mode in the variable to be
	lda #'X'	; returned.
	sta AddMode	;
	jmp ExitAMS	;
IsABY:			;
	lda #'Y'	;
	sta AddMode	;
	jmp ExitAMS	;
IsABS:			;
	lda #'S'	;
	sta AddMode	;
	jmp ExitAMS	;
	
AMSCkId?:		;Dispatch to code that checks for IIR, IRI or
	iny		; IND addressing modes.
	lda OpFld2,y	;
	cmp #','	;
	beq CkIIR	;
	cmp #')'	;
	beq CkIRIIND	;
	cpy #11d	;
	bne AMSCkId?	;
	jmp ErrAMS	;

CkIIR:			;Check for IIR addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'X'	;
	beq IsIIR	;
	cmp #'x'	;
	beq IsIIR	;
	jmp ErrAMS	;
	
IsIIR:
	lda #'R'	;Save IIR addressing mode code in variable to be
	sta AddMode	; returned.
	jmp ExitAMS	;
	
CkIRIIND:		;Check for IND addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #0d		;
	beq IsIND	;
	cmp #','	;
	beq CkIRI	;
	jmp ErrAMS	;
	
CkIRI:			;Check for IRI addressing mode.
	iny		;
	lda OpFld2,y	;
	cmp #'Y'	;
	beq IsIRI	;
	cmp #'y'	;
	beq IsIRI	;
	jmp ErrAMS	;
	
IsIND:			;Save IND or IRI addressing mode code in variable
	lda #'D'	; to be returned.
	sta AddMode	;
	jmp ExitAMS	;
IsIRI:			;
	lda #'I'	;
	sta AddMode	;
	jmp ExitAMS	;
	
ErrAMS:
	clc
	rts
	
ExitAMS:
	sec
	rts
	
	
;****************************************************************************
;                   Address Mode Table Search Subroutine.
;****************************************************************************
AdMdTbSc:		
	ldy #6d		;Check for address mode match between contents
	lda (PointerB),y; of variable AddMode & OpTable.
	cmp AddMode	;
	beq ExitAdMd	;
	
	lda PointerB	;Pointer Pointer B to next operator in
	clc		; operator table.
	adc #10d	;
	sta PointerB	;
	bcc AdMdNoCy	;
	inc PointerB+1d	;
	
AdMdNoCy:		;Check to see if next operator is the same type
	jsr OSCkANO	; that we are currently trying to assemble.
	bcs AdMdTbSc	;
	
ErrAdMd:
	clc
	rts
	
ExitAdMd:
	sec
	rts

;****************************************************************************
;                       Operand Scan Subroutine.
;****************************************************************************
OpndScan:

	lda #0d		;Initialize the flags that indicate whether or
	sta Obj2Flg	; not there are object bytes in addition to
	sta Obj3Flg	; the opcode object byte.
	
	ldy #7d		;Get the opcode of the instruction being 
	lda (PointerB),y; currently assembled from the opcode table
	sta Obj1	; and put it in Obj1.
	
	lda AddMode	;Check to see what address mode the instruction
	cmp #'P'	; currently being assembled is.
	beq OpndIMP	;
	cmp #'C'	;
	beq OpndACC	;
	cmp #'M'	;
	beq OpndIMM	;
	cmp #'S'	;
	beq OpndAB??	;
	cmp #'X'	;
	beq OpndAB??	;
	cmp #'Y'	;
	beq OpndAB??	;
	cmp #'I'	;
	beq OpndIN??	;
	cmp #'R'	;
	beq OpndIN??	;
	cmp #'D'	;
	beq OpndIN??	;
	cmp #'L'	;
	beq OpndAB??	;
	jmp ErrOpndS	;

OpndIMP:		;Process implied addressing mode.
	jmp ExtOpndS	;
	
OpndACC:		;Process accumulator addressing mode.
	jmp ExtOpndS	;
	
OpndIMM:		;Process immediate addressing mode.
	jsr ScnForHex	;
	bcs OpnMHFnd	;
	jmp ErrOpndS	;
OpnMHFnd:		;
	jsr AsToBin	;
	bcs OpndCvOk	;
	jmp ErrOpndS	;
OpndCvOk:		;
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;


OpndAB??:		;Process absolute, absolute X, absolute Y.
	jsr ScnForHex	; Check for relative addressing mode and send
	bcs OpnAHFnd	; to appropriate code if found.
	jmp ErrOpndS	;
OpnAHFnd:		;
	jsr GetAdd	;
	bcs OpndAdOk	;
	jmp ErrOpndS	;
OpndAdOk:		;
	lda AddMode	;
	cmp #'L'	;
	beq OpndDoBr	;
DoAdd:			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;

OpndIN??:		;Process indirect indexed, indexed indirect and
	jsr ScnForHex	; indirect addressing modes.
	bcs OpnINFnd	;
	jmp ErrOpndS	;
OpnINFnd:		;
	jsr GetAdd	;
	bcs OpINAdOk	;
	jmp ErrOpndS	;
OpINAdOk:		;
	lda AddMode	;
	cmp #'D'	;
	beq DoIND	;
	cpy #0d		;
	bne ErrOpndS	;
	stx Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
DoIND:			;
	stx Obj2	;
	sty Obj3	;
	lda #1d		;
	sta Obj2Flg	;
	sta Obj3Flg	;
	jmp ExtOpndS	;
	
OpndDoBr:		;Put address to be branched to in TempAdd and
	stx TempAdd	; the address of the first byte of the next
	sty TempAdd+1d	; instruction in TempAdd2.
	lda PointerA	;
	sta TempAdd2	;
	lda PointerA+1d	;
	sta TempAdd2+1d	;
	ldy #8d		;
	lda (PointerB),y;
	clc		;
	adc TempAdd2	;
	sta TempAdd2	;
	bcc OpBrNoOv	;
	inc TempAdd2+1d	;
OpBrNoOv:
	sec		;Subtract the address of the first byte of the
	lda TempAdd	; next instruction from the address to be branched
	sbc TempAdd2	; to in order to get the branch offset.
	sta TempAdd	;
	lda TempAdd+1d	;
	sbc TempAdd2+1d	;
	sta TempAdd+1d	;
	
	lda TempAdd+1d	;Check to make sure that MSB of the offset does
	cmp #0ffh	; not indicate a number greater than 127 or less
	beq OpCkNOff	; than 128.
	cmp #0d		;
	bne ErrOpndS	;
	
OpCkPOff:		;Check to make sure that LSB of the offset does
	lda TempAdd	; not contain a number greater than 127 or less
	cmp #128d	; than 128.
	bpl ErrOpndS	;
	jmp OffOk	;
OpCkNOff:		;
	lda TempAdd	;
	cmp #128d	;
	bmi ErrOpndS	;
	
OffOk:			;If offset is OK then put it in Obj2 and return.
	sta Obj2	;
	lda #1d		;
	sta Obj2Flg	;
	jmp ExtOpndS	;
	
ErrOpndS:
	clc
	rts
	
ExtOpndS:
	sec
	rts


;****************************************************************************
;                     Scan For Hex Digit Subroutine.
;****************************************************************************
ScnForHex:
	ldx #20d		
	
SFHNxtDg:
	ldy #0d		;Scan until either an upper case or a lower case
	lda OpFld1,x	; hex digit is encountered in the input buffer.
SFHCkDgt:		;
	cmp DgtTblUC,y	;
	beq ExitSFH	;
	cmp DgtTblLC,y	;
	beq ExitSFH	;
	iny		;
	cpy #16d	;
	beq IncBfPtr	;
	jmp SFHCkDgt	;

IncBfPtr:		;Point to the next digit in the input buffer.
	inx		;
	cpx #31d	;
	beq ErrSFH	;
	jmp SFHNxtDg	;

ErrSFH:
	clc
	rts
	
ExitSFH:
	sec
	rts
	
	
;****************************************************************************
;                       Breakpoint Command Subroutine.
;****************************************************************************
BreakPnt:
	lda OpFld1	;Check for a +, - or a ? in operand field #1.
	cmp #43d	;
	beq DoPlus	;
	cmp #45d	;
	beq DoMinus	;
	cmp #63d	;
	beq DmpBPAdd	;
	jmp ExitBP	;
DoPlus:		;
	jmp Plus	;
DoMinus:		;
	jmp Minus	;
	
DmpBPAdd:
	ldx #CRLF<	;If question mark was entered then dump current
	ldy #CRLF>	; breakpoints.
	jsr PrntMess	;
	ldy #0ffh	;
	ldx #0ffh	;
OtAdAgin:		;
	iny		;
	inx		;
	lda BrkPt1Ad,y	;
	sta PointerA	;
	iny		;
	lda BrkPt1Ad,y	;
	sta PointerA+1d	;
	lda BrkPt1St,x	;
	beq AdEmpty	;
	jsr PrntAdd	;
AdEmpty:		;
	cpy #7d		;
	bne OtAdAgin	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp ExitBP	;
	
Minus:
	lda OpFld2	;If minus was found in operand field #1 check for
	cmp #0d		; an address in operand field #2.  If no address
	beq ClrAllBP	; was found then clear all breakpoints, if an
	ldx #20d	; address was found then clear that one breakpoint.
	jsr GetAdd	;
	bcs Clr1BP	;
	jmp ExitBP	;
	
ClrAllBP:
	ldy #3d		;Clear all breakpoints.
ZeroBP:		;
	lda #0d		;
	sta BrkPt1St,y	;
	dey		;
	bpl ZeroBP	;
	jmp ExitBP	;
	
Clr1BP:
	stx TempAdd	;Search for a match between a breakpoint address
	sty TempAdd+1d	; in the breakpoint address table and the address
	ldy #3d		; that was entered.
	ldx #6d		;
CkBPAdd:		;
	jsr CmpBPAdd	;
	bcs FoundBP	;
	dey		;
	dex		;
	dex		;
	bpl CkBPAdd	;
	
BPNtFnd:		
	ldx #NoBPMess<	;If no match was found then print an error message
	ldy #NoBPMess>	; and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
FoundBP:
	lda #0d		;If match was found then zero out that breakpoint's
	sta BrkPt1St,y	; status indicator and exit.
	jmp ExitBP	;

Plus:
	lda OpFld2	;If a plus was entered then check operand field
	cmp #0d		; #2 for the address of the new breakpoint.
	beq OutBP2	;
	ldx #20d	;
	jsr GetAdd	;
	bcs BPAdOk	;
OutBP2:		;
	jmp ExitBP	;


BPAdOk:
	stx TempAdd	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddP:		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmp	;
	jsr CmpBPAdd	;
	bcs OutBP2	;
NoCmp:			;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddP	;
	

	ldy #0d		;If a plus was entered then search breakpoint
CkNxtBP:		;
	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
	cmp #0d		;
	beq EmptyBP	;
	iny		;
	cpy #4d		;
	bne CkNxtBP	;
	
AllBPFull:
	ldx #BPFulMes<	;If all breakpoints are full then print an error
	ldy #BPFulMes>	; message and exit.
	jsr PrntMess	;
	jmp ExitBP	;
	
EmptyBP:
	sty BPNumHld	;
	lda #1d		;
	sta BrkPt1St,y	;
	
	
NxtBPSlt0:
	cpy #0d		;Store new address in first position of
	bne NxtBPSlt1	; breakpoint table.
	lda TempAdd	;
	sta BrkPt1Ad	;
	lda TempAdd+1d	;
	sta BrkPt1Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt1:		;
	cpy #1d		;Store new address in second position of
	bne NxtBPSlt2	; breakpoint table.
	lda TempAdd	;
	sta BrkPt2Ad	;
	lda TempAdd+1d	;
	sta BrkPt2Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt2:		;
	cpy #2d		;Store new address in third position of
	bne NxtBPSlt3	; breakpoint table.
	lda TempAdd	;
	sta BrkPt3Ad	;
	lda TempAdd+1d	;
	sta BrkPt3Ad+1d	;
	jmp ExitBP	;
	
NxtBPSlt3:		;
	lda TempAdd	;Store new address in forth position of
	sta BrkPt4Ad	; breakpoint table.
	lda TempAdd+1d	;
	sta BrkPt4Ad+1d	;
	jmp ExitBP	;

ExitBP:
	rts


;****************************************************************************
;                   Compare Breakpoint Address Subroutine.
;****************************************************************************
CmpBPAdd:
	cpy #0d		;Compare LSB of first breakpoint address.
	bne CmpNxt1	;
	lda TempAdd+1d	;
	cmp BrkPt1Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt1:		;
	cpy #1d		;Compare MSB of second breakpoint address.
	bne CmpNxt2	;
	lda TempAdd+1d	;
	cmp BrkPt2Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt2:		;
	cpy #2d		;Compare MSB of third breakpoint address.
	bne CmpNxt3	;
	lda TempAdd+1d	;
	cmp BrkPt3Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CmpNxt3:		;
	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
	cmp BrkPt4Ad+1d	;
	beq CChkFLSB	;
	jmp NoMatch 	;
	
CChkFLSB:
	lda TempAdd	;Compare LSB of breakpoint address.
	cmp BrkPt1Ad,x	;
	beq BPMatch	;
	jmp NoMatch	;
	
BPMatch:		;Return with carry set if addresses match.
	sec		;
	rts		;
	
NoMatch:		;Return with carry cleared if addresses
	clc		; do not match.
	rts		;


;****************************************************************************
;                     Dump command Subroutine
;****************************************************************************
Dump:
	
	ldx #0h
	
	lda OpFld1,x	;If no operands then do a standard dump.
	cmp #0h		;
	beq DoStdDmp	;

	jsr AsToBin	;Get start address from operand field #1 and place
	bcs DgtOk1	; in zero page pointer.
	jmp ErrDump	;
DgtOk1:		;
	sta PointerA+1d	;
	inx		;
	jsr AsToBin	;
	bcs DgtOk2	;
	jmp ErrDump	;
DgtOk2:		;
	sta PointerA	;
	
	ldx #20d	;If no end address was entered then perform a
	lda OpFld1,x	; standard dump.
	cmp #0h		;
	beq DoStdDmp	;
	
	Jsr AsToBin	;Get end address from operand field #2 and place
	bcs OpFldOk1	; in the variable EndAdd.
	jmp ErrDump	;
OpFldOk1:		;
	sta EndAdd+1d	;
	inx 		;
	jsr AsToBin	;
	bcs OpFldOk2	;
	jmp ErrDump	;
OpFldOk2:		;
	sta EndAdd	;
	
	jmp DoDump	
	
DoStdDmp:
	lda PointerA+1d	;Adjust end address so that it will only dump the
	sta EndAdd+1d	; contents of 16 memory locations.
	lda PointerA	;
	sta EndAdd	;
	clc   		;Note: check to make sure this is correct.
	adc #15d	;
	sta EndAdd	;
	bcc DoDump	;
	inc EndAdd+1d	;
	
DoDump:
	lda #13d	;Output a CRLF.
	jsr OutChar	;
	lda #10d	;
	jsr OutChar	;

	ldx #0d		;
	ldy #0d		;

	jsr PrntAdd	;Output address of first dump memory location.
	
DumpAgin:
	lda (PointerA),y;Get byte from memory location.

	jsr PutASCBf	;Put character in ASCII buffer.
	
	jsr OutHex	;Convert to ASCII/Hex and print.
	
	inx
	cpx #16d	;
	bne Chk8	;
	jsr DumpASC	;Output ASCII interpretion of dumped line.
	
Chk8:			;
	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
	bne OutSpc	; the dump screen.
	lda #32d	;
	jsr OutChar	;
	lda #45d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	jmp ChkEndAd	;
	
OutSpc:
	lda #32d	;Print a space between hex characters on dump screen.
	jsr OutChar	;
	
ChkEndAd:
	lda PointerA	;Check pointer against end address holder.  Exit
	cmp EndAdd	; subroutine if the end address has been reached,
	bne PointNxt	; increment pointer and dump the contents of 
	lda PointerA+1d	; another memory location if not.
	cmp EndAdd+1d	;
	beq ExitDump	;
PointNxt:
	inc PointerA	;
	bne NoCary2	;
	inc PointerA+1d	;
NoCary2:		;

ChkCR:			;Perform end of dump line functions.
	cpx #16d	;
	bne NotEnd	;
	
	lda #10d	;Print a CRLF and reset X register to point to
	jsr OutChar	; beginning of new dump line.
	lda #13d	;
	jsr Outchar	;
	jsr PrntAdd	;
	ldx #0d		;
NotEnd:
	
	jmp DumpAgin	;

ErrDump:
	clc
	rts

ExitDump:
	inc PointerA	;Point to next location in memory to be dumped
	bne NoCary3	;
	inc PointerA+1d	;
NoCary3:		;
	sec
	rts

;****************************************************************************
;                 Output the ASCII interpretation of the dumped line.
;****************************************************************************
DumpASC:
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	ldx #0d		;
OutAsc:
	lda ASCIIbuf,x	;
	jsr OutChar	;
	inx		;
	cpx #16d	;
	bne OutAsc	;
	rts


;****************************************************************************
;         Put byte from memory into ASCII buffer from Dump command.
;****************************************************************************
PutASCBf:
	pha
	cmp #32d
	bmi Period
	cmp #127d
	bpl Period
	sta ASCIIbuf,x
	jmp ExitPut
Period:
	lda #46d
	sta ASCIIbuf,x
ExitPut:
	pla
	rts
	
;****************************************************************************
;                        Enter Command Subroutine.
;****************************************************************************
Enter:
	lda OpFld1	;Check for operand in operand field #1.
	cmp #0d		;
	bne ChkOp2	;
	jmp ErrEntr	;
	
ChkOp2:
	lda OpFld2	;Check for operand in operand field #2.
	cmp #0d		;
	bne ProcEntr	;
	jmp ErrEntr	;
	
ProcEntr:
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs EnAddOk	;
	jmp ErrEntr	;

EnAddOk:
	stx PointerA	;Put address from operand field #1 into
	sty PointerA+1d	; zero page variable Pointer.
	
	ldx #20d	;Get list of bytes to be entered into memory
	jsr GetList	; from operand field #2 and put them in memory
	bcc ErrEntr	; starting at Pointer.
	jmp ExitEntr	;
	
ErrEntr:
	clc
	rts	

ExitEntr:
	sec
	rts


;****************************************************************************
;                        Get List Subroutine
;
;	Zero page variable Pointer points to location in memory where
;	 list members will be placed.
;****************************************************************************
GetList:
	ldy #0d
	
	sty DataTemp	;Use this variable to count bytes in list.	
	
GLNxtByt:
	lda OpFld1,x	;Check for NULL that terminates current
	beq ListErr	; operand field.
	
	jsr AsToBin	;Convert byte in list to binary form and place
	bcs StInMem	; in memory.
	jmp ListErr	;
StInMem:		;
	sta (PointerA),y;
	inc PointerA	;
	bne LstNoOv	;
	inc PointerA+1d	;
LstNoOv:		;
	inc DataTemp	;
	lda DataTemp	;
	cmp #10d	;
	beq ExtGtLst	;
	
	inx		;Point to comma between bytes.

	lda OpFld1,x	;Check for NULL that terminates current
	beq ExtGtLst	; operand field.
	
	inx		;Point to next byte in list.
	
	jmp GLNxtByt	;
	
ExtGtLst:
	sec
	rts

ListErr:
	clc
	rts

;****************************************************************************
;                        Fill Command Subroutine.
;****************************************************************************
Fill:

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs FAdd1ok	;
	jmp ErrFill	;
FAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs FAdd2ok	;
	jmp ErrFill	;
FAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
FillAgin:
	ldx #40d	;Get list and place in memory.
	jsr GetList	;
	bcc ErrFill	;

	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq ChkFLSB	;
;	bmi ExitFill 	;
	jmp FillAgin 	;
ChkFLSB:
	lda EndAdd	; 
	cmp PointerA	;
	beq ExitFill	;
	
	jmp  FillAgin	;
	

ErrFill:
	clc
	rts

ExitFill:
	sec
	rts

;****************************************************************************
;                        Go Command Subroutine
;****************************************************************************
Go:

	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq CurentPC	;
			
	ldx #0d		;Get address from operand field #1.
	jsr GetAdd	;
	bcs GAddOk	;
	jmp ErrGo	;
	
GAddOk:		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;

CurentPC:
	ldx UPgmCntr	;
	stx TempAdd	;
	ldy UPgmCntr+1d	;
	sty TempAdd+1d	;
	ldy #3d		;Check to make sure that breakpoint address has
	ldx #6d		; not already been entered into table.
CkBPAddG:		;
	lda BrkPt1St,y	;
	cmp #0d		;
	beq NoCmpG	;
	jsr CmpBPAdd	;
	bcs MaError	;
NoCmpG:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPAddG	;
	jmp NoMatchG	;

MaError:
	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
	ldy #GoBPErrM>	; error message and exit.
	jsr PrntMess	;
	jmp ExitGo	;

NoMatchG:
	ldy #3d		;Check all active breakpoints in table, save
	ldx #6d		; the opcodes of the breakpointed addresses, 
CkBPSt:		;
	lda BrkPt1St,y	; and replace them with BRKs.
	cmp #1d		;
	bne NxtBPSt	;
	lda (BrkPt1Ad,x);
	sta BP1OpHld,y	;
	lda #0d		;
	sta (BrkPt1Ad,x);
NxtBPSt:		;
	dey		;
	dex		;
	dex		;
	bpl CkBPSt	;

	pla		;Remove Go command's return address and the check
	pla		; command's return address from the stack.
	pla		;
	pla		;
    
    lda OpFld1	;Check for operand.
	cmp #0d		;
	beq DoNotRestoreRegistersGo
 
    ldx #0ffh    ;Restore user's registers.
    txs          ;
    lda UStatReg ;
	pha          ;
	lda UAccum	 ;
	ldx UXReg	 ;
	ldy UYReg	 ;
    plp          ;
   
DoNotRestoreRegistersGo:
	
	jmp (UPgmCntr)	;Start executing at address being pointed to by
			; UPGmCntr.	

ErrGo:
	clc
	rts
	
ExitGo:
	sec
	rts

;****************************************************************************
;                       Help Command Subroutine.
;****************************************************************************
Help:
	ldx #HelpMess<
	ldy #HelpMess>
	jsr PrntMess
	rts

;****************************************************************************
;                     Load Command Subroutine
;****************************************************************************
LdSRecs:
	ldx #SRecStMs<
	ldy #SRecStMs>	
	jsr PrntMess
	
	jsr GetCharW	;Wait for first character of record.
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	jmp CkS		;
	
GtAnCh:		;
	jsr GetCharW	;Check for an S.
CkS:			;
	cmp #83d	;
	bne GtAnCh	;
	
	jsr OutChar	;Print an S to the user.
	
	jsr GetCharW	;Get record type ECHO it and store it.
	jsr OutChar	;
	sta RecType	;
	
	cmp #48d	;Check for header record and process.
	bne NtHdr	;
	jsr ProcHdr	;
	bcc SError	;
	jmp NextLine	;
	
NtHdr:			;
	cmp #49d	;Check for code record and process.
	bne NtCd	;
	jsr ProcCode	;
	bcc SError	;
	jmp NextLine	;
	
NtCd:			;
	cmp #57d	;Check for termination record process, and print
	bne SError	; records loaded message.
	jsr ProcTerm	;
	bcc SError	;
	ldx #SRecEnMs<	;
	ldy #SRecEnMs>	;
	jsr PrntMess	;
	jmp ExitSRec	;
	
NextLine:
	jmp GtAnCh

SError:
	ldx #SRecErMe<
	ldy #SRecErMe>	
	jsr PrntMess
	sec
	rts
	
ExitSRec:
	jsr GetCharW
	sec
	rts
	
;****************************************************************************
;                Process Record Length and Address Subroutine
;****************************************************************************
PrRLeAdd:	
	
	lda #0h		;Zero out Checksum accumulator.
	sta CkSumAc	;
	sta CkSumAc+1h	;
	
	jsr Getnum	;Fetch record length and update checksum
	sta RecLen	; accumulator.
	jsr AccCkSum	;
	
	tax		;Adjust code byte counter and store it.
	dex		;
	dex		;
	dex		;
	txa		;
	sta CodeCntr	;
	
	jsr GetNum	;Get most significant byte of address and
	sta PointerA+1h	; store it.
	jsr AccCkSum	;
	
	jsr GetNum	;Get least significant byte of address and
	sta PointerA	; store it.
	jsr AccCkSum	;
	
	rts
	
;****************************************************************************
;        Get Code Byte Without Loading into Memory Subroutine.
;****************************************************************************
GtCodNld:
	
	lda CodeCntr
	beq ExitNld
	
GetOneNl:
	jsr GetNum
	jsr AccCkSum
	dec CodeCntr
	Bne GetOneNl
	
ExitNld:
	rts

;****************************************************************************
;        Get Code Byte and Load it into Memory Subroutine.
;****************************************************************************
GtCodLd:

	lda CodeCntr
	beq ExitLd
	
	ldy #0h
GtOneLd:
	jsr GetNum
	jsr AccCkSum
	sta (PointerA),y	
	inc PointerA
	bne NxtCode
	inc PointerA+1h
NxtCode:
	dec CodeCntr
	bne GtOneld
	
ExitLd:
	rts

;****************************************************************************
;                      Check Checksum Subroutine.
;****************************************************************************
ChkChkSm:

	lda CkSumAc	;Invert lowest byte of the checksum accumulator
	eor #0ffh	; and store it in CkhSum.
	sta ChkSum	;
	
	jsr GetNum	;Compare calculated checksum against S record	
	cmp ChkSum	; checksum.
	beq CkSumOK	;
	clc
	jmp Chkexit
CkSumOK:
	sec
Chkexit:
	rts

;****************************************************************************
;                       Get Number Subroutine.
;****************************************************************************
GetNum:
	tya
	pha

	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in most significat nibble
	bcc ExtGtNum	;
	asl a		; of number.
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	jsr GetCharW	;Get ASCII character, convert to hex digit,
	jsr DgtToBin	; and position hex digit in least significant
	bcc ExtGtNum	;
	ora number	; nibble of number.
	sta number	;
	
	pla
	tay
	lda number
ExtGtNum:
	rts

;****************************************************************************
;                    Accumulate Checksum Subroutine.
;****************************************************************************
AccCkSum:
	pha
	clc
	adc CkSumAc
	sta CkSumAc
	bcc NoOvrFlo
	inc CkSumAc+1h
NoOvrFlo:
	pla
	rts

;****************************************************************************
;                ASCII Digit to Binary Number Subroutine.
;
;        Enter with register 'A' containing the number to convert.
;        If the number was valid return its binary conversion in the
;        A register.  If the number is not convertable then clear the
;        carry flag and return.
;****************************************************************************
DgtToBin:
	
	stx RegTemp	;Save the character to convert.
	
	ldx #0h		
	
AnothDgt:
	cmp DgtTblUC,x	;Search through character table and try to find
	beq Match	; a match for the character present in the X
	cmp DgtTblLC,x	; register.
	beq Match	;
	
	inx		;If a match was not found then increment the
	cpx #16d	; table index register and check the next
	beq DgtError	; character.  If all the characters have been 
	jmp AnothDgt	; checked then return with an error.
	
DgtError:
	lda #0h
	clc
	jmp DgtExit

Match:
	txa
	sec
	
	ldx RegTemp
DgtExit:	rts
	
;****************************************************************************
;                    Process Header Record Subroutine.
;****************************************************************************

ProcHdr:

	jsr PrRLeAdd
	jsr GtCodNld		
	jsr ChkChkSm
	
	rts

;****************************************************************************
;                     Process Code Record Subroutine
;****************************************************************************
ProcCode:

	jsr PrRLeAdd
	jsr GtCodLd
	jsr ChkChksm
	
	rts

;****************************************************************************
;                     Process Termination Record Subroutine
;****************************************************************************
ProcTerm:

	jsr PrRLeAdd
	jsr GtCodNld	
	jsr ChkChkSm

	rts

;****************************************************************************
;                       Move Command Subroutine.
;****************************************************************************
Move:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq MOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs MAdd1ok	;
MOut:			;
	jmp ExitMove	;
MAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs MAdd2ok	;
	jmp ExitMove	;
MAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne MNOvFlo	;
	inc EndAdd+1d	;
	
MNOvFlo:		;
	ldx #40d	;Get destination address.
	jsr GetAdd	;
	bcs MAdd3ok	;
	jmp ExitMove	;
MAdd3ok:		;
	stx PointerB	;
	sty PointerB+1d	;

	ldy #0d		;Move bytes between start address and end address
MCont:			;to memory starting at destination address.
	lda (PointerA),y; 
	sta (PointerB),y;
	inc PointerB	;
	bne MNoOvf1	;
	inc PointerB+1d	;
MNoOvf1:		;
	inc PointerA	;
	bne MNoOvf2	;
	inc PointerA+1d	;
MNoOvf2:		;
	lda PointerA	;
	cmp EndAdd	;
	beq MCkMSB	;
	jmp MCont	;
MCkMSB:		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitMove	;
	jmp MCont	;
	
ExitMove:
	rts


;****************************************************************************
;                     Register Command Subroutine
;****************************************************************************
Register:
	pha
	txa
	pha
	tya
	pha
	php
	
	lda OpFld1	;Check for operand.
	cmp #0d		;
	beq GenReg	;
	jmp SpecReg	;
	
GenReg:		;
	ldx #RegMess<	;Output register headings.
	ldy #RegMess>	;
	jsr PrntMess	;
	
	ldy #3d		;Output contents of user's program counter.
	jsr OutSpace	;
	lda UPgmCntr+1d	;
	jsr OutHex	;
	lda UPgmCntr	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's accumulator.
	jsr OutSpace	;
	lda UAccum	;
	jsr OutHex	;
	
	ldy #9d		;Output contents of user's X register.
	jsr OutSpace	;
	lda UXreg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Y register.
	jsr OutSpace	;
	lda UYReg	;
	jsr OutHex	;
	
	ldy #8d		;Output contents of user's Stack Pointer.
	jsr OutSpace	;
	lda UStkPtr	;
	jsr OutHex	;
	
	ldy #7d		;Output contents of user's Status register.
	jsr OutSpace	;
	lda UStatReg	;
	ldx #8d		;
NextFlag:		;
	rol a		;
	bcs OutOne	;
OutZero:		;
	pha		;
	lda #30h	;
	jsr OutChar	;
	pla		;
	jmp CkBtPos	;
OutOne:		;
	pha		;
	lda #31h	;
	jsr OutChar	;
	pla		;
CkBtPos:		;
	dex		;
	bne NextFlag	;
	jmp ExitReg	;
	
	
SpecReg:
	lda #13d
	jsr OutChar
	lda #10d
	jsr OutChar
	lda OpFld1
	jsr ToLower

CkPCReg:		;
	cmp #112d	;Get value for Program Counter from user.
	bne CkAReg	;
	lda UpgmCntr+1d	;
	jsr OutHex	;
	lda UpgmCntr	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetPC	;
	jmp ExitReg	;
GetPC:	ldx #0d		;
	jsr AsToBin	;
	bcs PCMSBOK	;
	jmp ExitReg	;
PCMSBOK:	tay		;
	inx		;
	jsr AsToBin	;
	bcs PCLSBOK	;
	jmp ExitReg	;
PCLSBOK:	sta UPgmCntr	;
	sty UPgmCntr+1d	;
	jmp ExitReg	;
	
CkAReg:		;Get value for Accumulator from user.
	cmp #97d	;
	bne CkXReg	;
	lda UAccum	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetA	;
	jmp ExitReg	;
GetA:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs AOK		;
	jmp ExitReg	;
AOK:			;
	sta UAccum	;
	jmp ExitReg	;
	
CkXReg:		;Get value for X register from user.
	cmp #120d	;
	bne CkYReg	;
	lda UXreg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetX	;
	jmp ExitReg	;
GetX:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs XOK		;
	jmp ExitReg	;
XOK:			;
	sta UXReg	;
	jmp ExitReg	;
	
CkYReg:		;Get value for Y register from user.
	cmp #121d	;
	bne CkForS	;
	lda UYReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetY	;
	jmp ExitReg	;
GetY:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs YOK		;
	jmp ExitReg	;
YOK:			;
	sta UYReg	;
	jmp ExitReg	;
	
CkForS:		;Check if user is accessing the Stack Pointer or
	cmp #115d	; the Status Register.
	beq CkPorR	;
	jmp RegInErr	;
CkPorR:		;
	lda OpFld1+1d	;
	jsr ToLower	;
	cmp #112d	;
	beq CkSpReg	;
	cmp #114d	;
	beq CkSRReg	;
	jmp RegInErr	;

CkSpReg:		;
	lda UStkPtr	;Get value for Stack Pointer from user.
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSP	;
	jmp ExitReg	;
GetSP:			;
	ldx #0d		;
	jsr AsToBin	;
	bcs SPOK	;
	jmp ExitReg	;
SPOK:			;
	sta UStkPtr	;
	jmp ExitReg	;
	
CkSRReg:		;Get value for Status Register from user.
	lda UStatReg	;
	jsr OutHex	;
	jsr OutColn	;
	jsr GetLine	;
	jsr ParseOpr	;
	lda OpFld1	;
	cmp #0d		;
	bne GetSR	;
	jmp ExitReg	;
GetSR:	ldx #0d		;
	jsr AsToBin	;
	bcs SROK	;
	jmp ExitReg	;
SROK:	sta UStatReg	;
	jmp ExitReg	;

RegInErr:
	clc
	jmp ErrRegOt
	
ExitReg:
	sec
ErrRegOt:
	plp
	pla
	tay
	pla
	tax
	pla
	rts

;****************************************************************************
;                       Search Command Subroutine.
;****************************************************************************
Search:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq SOut	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs SAdd1ok	;
SOut:			;
	jmp ExitSrch	;
SAdd1ok:		;
	stx PointerB	;
	sty PointerB+1d	;
	
	ldx #20d	;Get end address and increment by 1.
	jsr GetAdd	;
	bcs SAdd2ok	;
	jmp ExitSrch	;
SAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	inc EndAdd	;
	bne SNOvFlo	;
	inc EndAdd+1d	;
	
SNOvFlo:		;
	ldx #40d	;Get search list from operand field #3 and store
	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
	sta PointerA	; SrchBtCt.
	lda #SrchTabl>	;
	sta PointerA+1d	;
	jsr GetList	;
	bcc ExitSrch	;
	lda DataTemp	;
	sta SrchBtCt	;
	
	lda PointerB	;Transfer start address from pointer A to 
	sta PointerA	; pointer B.  Output a CRLF.
	lda PointerB+1d	;
	sta PointerA+1d	;
	ldx #CRLF<	;
	ldy #CRLF>	;
	jsr PrntMess	;
	
SCkByte1:		;Compare list with memory.
	ldx #0d		;
	ldy #0d		;
SCkByte2:		;
	lda (PointerA),y;
	cmp SrchTabl,x	;
	beq SMatch	;
	
IncScPtr:
	jsr IncPntrA	;Increment memory pointer and check to see if
	lda PointerA	; the end address has been reached.
	cmp EndAdd	;
	beq SckMSB	;
	jmp SCkByte1	;
SCkMSB:		;
	lda PointerA+1d	;
	cmp EndAdd+1d	;
	beq ExitSrch	;
	jmp SCkByte1	;
	
SMatch:		;
	iny		;Check to see if all bytes in search list match
	inx		; bytes in memory.
	cpx SrchBtCt	;
	beq SFulMtch	;
	jmp SCkByte2	;

SFulMtch:		;
	jsr PrntAdd	;Output address where match was found.
	jsr IncPntrA	;
	jmp SCkByte1	;

ExitSrch:
	rts



;****************************************************************************
;                       Trace Command Subroutine.
;****************************************************************************
Trace:

	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq TNoOper	;
	
	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs TAdd1ok	;
	jmp ErrTrce	;
TAdd1ok:		;
	stx UPgmCntr	;
	sty UPgmCntr+1d	;
	
	lda OpFld2	;Check to see if a trace count has been 
	cmp #0d		; specified.
	bne GtTrcCnt	;

TNoOper:
	ldy #1d		;Set trace count to 1.
	sty TracCnt	;
	jmp StartTrc	;

GtTrcCnt:	
	ldx #20d	;Get trace count from user.
	jsr AsToBin	;
	bcs TrValOK	;
	jmp ErrTrce	;
TrValOK:		;
	sta TracCnt	;
	
StartTrc:
	pla		;Remove trace command's return address and
	pla		; the check command routine's return address from
	pla		; the stack.
	pla		;

ContTrc:	
	ldy UPgmCntr	;Transfer user's program counter to pointer A.
	sty PointerA	;
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;

	ldy #0d		;Get opcode of current instruction.
	lda (PointerA),y;
	sta OpCdHold	;
	
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs TOpCdFnd	; an opcode.
	jmp ErrTrce

TOpCdFnd:
	ldy #8d		;Get number of bytes in the current instruction
	lda (PointerB),y; information from opcode table.
	sta CurInsLn	;
	
	ldy #1d		;Get opcode of current instruction.
	lda OpCdHold	;

TrRTS:			;If the opcode is an RTS then copy the return
	cmp #60h	; address from the stack, save the opcode to
	bne TNxtOp0	; be returned to, and place a BRK at the return
	lda #2d		; address.
	sta BrnchFlg	;
	pla		;
	sta BOpAdPtr	;
	pla		;
	sta BOpAdPtr+1d	;
	pha		;
	lda BOpAdPtr	;
	pha		;
	inc BOpAdPtr	;
	bne NNOvflo	;
	inc BOpAdPtr+1d	;
NNOvflo:		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp0:		;
	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
	bne TNxtOp1	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp1:
	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
	bne TNxtOp2	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta PointerC	;
	iny		;
	lda (PointerA),y;
	sta PointerC+1d	;
	ldy #0d		;
	lda (PointerC),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerC),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
		
	
TNxtOp2:
	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
	bne TNxtOp3	; then save the opcode of the instruction that
	lda #2d		; will be jumped to and replace it with a BRK.
	sta BrnchFlg	;
	lda (PointerA),y;
	sta BOpAdPtr	;
	iny		;
	lda (PointerA),y;
	sta BOpAdPtr+1d	;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp ChBkVect	;
	
TNxtOp3:
	ldy #0d		;Check to see if the current instruction is an
	lda (PointerB),y; actual branch.
	cmp #'B'	;
	bne NoBrnch2	;
	ldy #1d		;
	lda (PointerB),y;
	cmp #'I'	;
	bne Branch	;
NoBrnch2:		;
	jmp NoBranch	;
	
Branch:		;If the opcode is a branch, Bxx aaaa,
	lda #1d		; then save the opcode of the instruction that
	sta BrnchFlg	; will be branched to and replace it with a BRK.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta BOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
			;
	ldy #1d		;
	lda (PointerA),y;
	sta BrValHld	;
	bpl AddAdd	;
SubAdd:		;
	dec BrValHld	;
	lda BrValHld	;
	eor #0ffh	;
	sta BrValHld	;
	sec		;
	lda BOpAdPtr	;
	sbc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	sbc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
AddAdd:		;
	clc		;
	lda BOpAdPtr	;
	adc BrValHld	;
	sta BOpAdPtr	;
	lda BOpAdPtr+1d	;
	adc #0d		;
	sta BOpAdPtr+1d	;
	jmp GtBrOpCd	;
GtBrOpCd:		;
	ldy #0d		;
	lda (BOpAdPtr),y;
	sta BOpCdHld	;
	lda #0d		;
	sta (BOpAdPtr),y;
	jmp Both	;
	
NoBranch:
	lda #0d		;Set branch flag to 0 to indicate the current
	sta BrnchFlg	; instruction is not a branch instruction.

Both:
	ldy CurInsLn	;
	lda (PointerA),y;Save the opcode of the next instruction to be
	sta NOpCdHld	; executed if no branch is taken and replace it
			; with a BRK command.
	clc		;
	lda PointerA	;
	adc CurInsLn	;
	sta NOpAdPtr	;
	lda PointerA+1d	;
	adc #0d		;
	sta NOpAdPtr+1d	;
	lda #0d		;
	sta (PointerA),y;
	
ChBkVect:
	lda #1d		    ;Make BRK jump here instead of main.
	sta TrBrkFlg	;
	
    lda OpFld1	;Check to see if user entered address.
	cmp #0d		;
	beq DoNotRestoreStackPointer
    ldx #0ffh    
    txs          ;
DoNotRestoreStackPointer:

	lda UStatReg	;Restore user's registers.
	pha		        ;
	lda UAccum	    ;
	ldx UXreg	    ;
	ldy UYReg	    ;
	plp		        ;
    
	jmp (UPgmCntr)	;Jump to user's code.
	
Tr2ndEnt:
	lda #0d		;Reset trace break flag.
	sta TrBrkFlg	;
	
CkBrnch:		;
	ldy #0d		;Check to see which opcodes need to be restored.
	lda BrnchFlg	;
	cmp #0d		;
	beq NoBrnch	;
	cmp #1d		;
	beq Brnch	;
	
DoJmp:
	lda BOpCdHld	;Restore opcode to be jumped to.
	sta (BOpAdPtr),y;
	jmp UpDtPtrA	;

Brnch:
	lda BOpCdHld	;Restore opcode to be branched to.
	sta (BOpAdPtr),y;
	
NoBrnch:
	lda NOpCdHld	;Restore opcode that will be executed next in
	sta (NOpAdPtr),y; the instruction stream.

UpDtPtrA:
	ldy UPgmCntr	;Set pointer A to point to the next instruction
	sty PointerA	; to be executed for unassemble.
	ldy UPgmCntr+1d	;
	sty PointerA+1d	;
	
	ldx #CRLF<	;Unassemble next instruction in memory.
	ldy #CRLF>	;
	jsr PrntMess	;
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	jsr StartUnA	;
	
NxtIn:
	dec TracCnt	;Decrement trace count and trace again if it
	beq OutTrce	; is not zero.
	jmp ContTrc	;

OutTrce:
	jmp MainLoop	;Enter the main monitor loop using a jump
			; because the trace command's return address
			; and the check command routine's return address
			; were removed when a trace was initiated.
ErrTrce:
	clc
	rts	

ExitTrce:
	sec
	rts	

;****************************************************************************
;                       Scan for Valid Opcode Subroutine.
;****************************************************************************
ScanOpCd:
	
	ldx #OpTable<	;Point pointer B to beginning of opcode table.
	stx PointerB	;
	ldx #OpTable>	;
	stx PointerB+1d	;
	
CkTblEnd:
	ldy #4d		;Check for end of opcode table.
	lda (PointerB),y;
	cmp #90d	;
	beq OpCdNtFd	;
	
CkNxtOp:		;
	ldy #7d		;Check for an opcode match in the opcode table.
	lda (PointerB),y;
	cmp OpCdHold	;
	beq OpCdFndS	;
	
	lda PointerB	;Point pointer B to next entry in opcode table.
	clc		;
	adc #10d	;
	sta PointerB	;
	bcc ScNoCary	;
	inc PointerB+1d	;
		
ScNoCary:
	jmp CkTblEnd
	
	
OpCdFndS:
	sec
	rts
	
OpCdNtFd:
	clc
	rts
	
;****************************************************************************
;                       Unassemble Command Subroutine.
;****************************************************************************
UnAssem:
	lda OpFld1	;Check for operands.
	cmp #0d		;
	beq UNoOper	;

	ldx #0d		;Get start address.
	jsr GetAdd	;
	bcs UAdd1ok	;
	jmp ErrUnAs	;
UAdd1ok:		;
	stx PointerA	;
	sty PointerA+1d	;
	
	lda OpFld2	;Check to see if an end address has been 
	cmp #0d		; specified.
	bne GtUEndAd	;
	
UNoOper:
	lda PointerA	;
	sta EndAdd	;
	lda PointerA+1d	;
	sta EndAdd+1d	;
	clc		;If no end address has been specified by the
	lda PointerA	; user then set the end address to start address
	adc #20d	; + 20d.
	sta EndAdd	;
	bcc UNoCary	;
	ldx EndAdd+1d	;
	inx		;
	stx EndAdd+1d	;
UNoCary:		;
	jmp StartUnA	;
	
GtUEndAd:
	ldx #20d	;Get end address.
	jsr GetAdd	;
	bcs UAdd2ok	;
	jmp ErrUnAs	;
UAdd2ok:		;
	stx EndAdd	;
	sty EndAdd+1d	;
	
StartUnA:
	lda EndAdd+1d	;Check to see if end address has been reached.
	cmp PointerA+1d	;
	beq UChkFLSB	;
	bcc UOut	;
	jmp UNotFin 	;
UChkFLSB:
	lda EndAdd	; 
	cmp PointerA	;
	bcc UOut	;
	jmp UNotFin	;
UOut:			;
	jmp ExitUnAs	;

UNotFin:		;
	ldy #0d		;Get opcode byte from memory and save.
	lda (PointerA),y;
	sta OpCdHold	;
	jsr ScanOpCd	;Check to see if byte from memory location was
	bcs OpCdFnd	; an opcode.

NtOpCode:
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;

	lda OpCdHold	;Print the bad opcode.
	jsr OutHex	;
	
	ldx #BadOpMes<	;If byte was not an opcode then print question
	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
	jsr PrntMess	;
	jsr IncPntrA	;
	jmp StartUnA	;

OpCdFnd:
	ldx #CRLF<	;Print start address of current instruction.
	ldy #CRLF>	;
	jsr PrntMess	;
	jsr PrntAdd	;
	jsr IncPntrA	;

CkAdMode:
	ldy #6d		;Get addressing mode indicator from table.
	lda (PointerB),y;
	
NxAdMo1:		;
	cmp #'P'	;Check for implied addressing mode.
	bne NxAdMo2	;
	jmp ImpAdMo	;
	
NxAdMo2:		;
	cmp #'M'	;Check for immediate addressing mode.
	bne NxAdMo3	;
	jmp ImmAdMo	;	

NxAdMo3:		;
	cmp #'S'	;Check for absolute addressing mode.
	bne NxAdMo4	;
	jmp AbsxyAdM	;	

NxAdMo4:		;
	cmp #'X'	;Check for absolute x addressing mode.
	bne NxAdMo5	;
	jmp AbsxyAdM	;

NxAdMo5:		;
	cmp #'Y'	;Check for absolute y addressing mode.
	bne NxAdMo6	;
	jmp AbsxyAdM	;

NxAdMo6:		;
	cmp #'R'	;Check for indexed indirect addressing mode.
	bne NxAdMo7	;
	jmp IIRAdMo	;

NxAdMo7:		;
	cmp #'L'	;Check for relative addressing mode.
	bne NxAdMo8 	;
	jmp RelAdMo	;

NxAdMo8:		;
	cmp #'C'	;Check for accumulator addressing mode.
	bne NxAdMo9 	;
	jmp AccAdMo	;

NxAdMo9:		;
	cmp #'D'	;Check for indirect addressing mode.
	bne NxAdMo10 	;
	jmp IndAdMo	;

NxAdMo10:
	cmp #'I'	;Check for indirect indexed addressing mode.
	bne BdOpCd	;
	jmp IRIAdMo	;

BdOpCd:		;
	jmp NtOpCode	;


ImpAdMo:
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	jmp StartUnA

AccAdMo:
	lda OpCdHold	;Print the opcode.
	jsr OutHex	;
	
	ldy #8d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
		
	jsr PrntMnem	;Print the operator.
	
	lda #65d	;Print a capital A for accumulator addressing.
	jsr OutChar	;
	
	jmp StartUnA


ImmAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #35d	;Print a pound sign.
	jsr OutChar	;
	
	lda ObCdHld1	;Print immediate operand value.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	jmp StartUnA


AbsxyAdM:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	ldy #6d		;Check to see if address mode is abs, abx or
	lda (PointerB),y; aby.
	cmp #'X'	;
	beq AbxAdMo	;
	cmp #'Y'	;
	beq AbyAdMo	;
	
AbsAM:
	jmp StartUnA

AbxAdMo:
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	jmp StartUna
	
AbyAdMo:
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;

	jmp StartUnA


RelAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda PointerA	;Store a copy of the next instruction's start
	sta AddHold	; address.
	lda PointerA+1d	;
	sta AddHold+1d	;
	
	lda ObCdHld1	;Check to see if branch is positive or negative.
	bmi NegBrnch	;
	
PosBrnch:		;If branch is positive then find address being
	lda AddHold	; branched to by adding offset to start address
	clc		; of next instruction in memory.
	adc ObCdHld1	;
	sta AddHold	;
	bcc OutBrAdd	;
	inc AddHold+1d	;
	jmp OutBrAdd	;
		
NegBrnch:
	dec ObCdHld1	;If branch is negative then find address being
	lda ObCdHld1	; branched to by subtracting offset from start
	eor #0ffh	; address of next instruction in memory.
	sta ObCdHld1	;
	lda AddHold	;
	sec		;
	sbc ObCdHld1	;
	sta AddHold	;
	bcs OutBrAdd	;
	dec AddHold+1d	;
	
OutBrAdd:
	lda AddHold+1d	;Print address being branched to.
	jsr OutHex	;
	lda AddHold	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;

	jmp StartUnA


IRIAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	lda #44d	;Print comma and y.
	jsr OutChar	;
	lda #89d	;
	jsr OutChar	;
	
	jmp StartUnA
	
IIRAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer.
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #5d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.
	
	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld1	;Print offset into zero page.
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex.
	jsr OutChar	;
	
	lda #44d	;Print comma and x.
	jsr OutChar	;
	lda #88d	;
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA

IndAdMo:
	ldy #0d

	lda OpCdHold	;Print the opcode and a space.
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	
	lda (PointerA),y;Print the second byte of the instruction and
	sta ObCdHld1	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	lda #32d	;Print a space between obj codes.
	jsr OutChar	;
	
	lda (PointerA),y;Print the third byte of the instruction and
	sta ObCdHld2	; increment the memory pointer
	jsr OutHex	;
	jsr IncPntrA	;
	
	ldy #2d		;Print spaces between object code field and
	jsr OutSpace	; operator field.
	
	jsr PrntMnem	;Print the operator.

	lda #40d	;Print (.
	jsr OutChar	;
	
	lda ObCdHld2	;Print absolute address in msb, lsb order.
	jsr OutHex	;
	lda ObCdHld1	;
	jsr OutHex	;
	
	lda #104d	;Print lower case h to indicate hex number.
	jsr OutChar	;
	
	lda #41d	;Print ).
	jsr OutChar	;
	
	jmp StartUnA
	
ErrUnAs:
	clc
	rts

ExitUnAs:
	sec
	rts


;****************************************************************************
;                       Print Mnemonic Subroutine.
;****************************************************************************
PrntMnem:

	ldy #0d		;Use loop to print all three characters of
PrntMore:
	lda (PointerB),y; mnemonic.
	jsr OutChar	;
	iny		;
	cpy #3d		;
	bne PrntMore	;
	
	lda #32d	;Print a space after the mnemonic.
	jsr OutChar	;
	
	rts

;****************************************************************************
;                       Increment Pointer A Subroutine.
;****************************************************************************
IncPntrA:
	inc PointerA
	bne NoOvFl1
	inc PointerA+1d
NoOvFl1:
	rts



;****************************************************************************
;                        Get Address Subroutine
;
;	X returns LSB of address.  Y returns MSB of address.
;****************************************************************************
GetAdd:		;Convert address found in operand field #x
	jsr AsToBin	; into binary.
	bcs AdMSBOK	;
	jmp ErrGtAd	;
AdMSBOK:		;
	tay		;
	inx		;
	jsr AsToBin	;
	bcs AdLSBOK	;
	jmp ErrGtAd	;
AdLSBOK:		;
	tax

	sec		;If conversion OK then set carry flag and
	rts		; return.
	
ErrGtAd:		;
	clc		;If error then clear carry and return.
	rts		;


;****************************************************************************
;                     Output a Colon Prompt Subroutine.
;****************************************************************************
OutColn:
	ldx #ColnPrmt<
	ldy #ColnPrmt>
	jsr PrntMess
	rts

;****************************************************************************
;                     Out Spaces Subroutine
;
;       Enter with the Y register indicating the number of spaces to output.
;****************************************************************************
OutSpace:		;Output the number of spaces indicated by
	pha		; the Y register.
OtAnoSpc:
	lda #32d
	jsr OutChar
	dey
	bne OtAnoSpc
	pla
	rts


;****************************************************************************
;              Covert ASCII character to lower case Subroutine.
;****************************************************************************
ToLower:
	cmp #65d
	bmi ExitToLo
	cmp #91d
	bpl ExitToLo
	clc
	adc #32d
ExitTolo:
	rts


;****************************************************************************
;              Covert ASCII character to upper case Subroutine.
;****************************************************************************
ToUpper:
	cmp #'a'
	bmi ExitToUp
	cmp #123d
	bpl ExitToUp
	sec
	sbc #32d
ExitToUp:
	rts



;****************************************************************************
;                         Print address.
;****************************************************************************
PrntAdd:
	lda PointerA+1d	;
	jsr OutHex	;
	lda PointerA	;
	jsr OutHex	;
	lda #32d	;
	jsr OutChar	;
	lda #32d	;
	jsr OutChar	;
	
	rts

;****************************************************************************
;                         Ascii to Binary Subroutine.
;****************************************************************************
AsToBin:		;X points to digits to be converted using
			; OpFld1 as a base.

	lda OpFld1,x	;Convert most significant digit to binary.
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	asl a		;
	asl a		;
	asl a		;
	asl a		;
	and #0f0h	;
	sta number	;
	
	inx		;Convert least significant digit to binary.
	lda OpFld1,x	;
	jsr DgtToBin	;
	bcc ExtAs2Bn	;
	ora number	;
	
	sta number	;Store full binary number in number.
	sec
ExtAs2Bn:
	rts
	
;****************************************************************************
;                     Output a Hex byte to the serial port.
;
;            Enter with the number to be output in the A register.
;****************************************************************************
OutHex:
	sta number
	
	lsr a		;Output most significant digit of hex byte to
	lsr a		; serial port.
	lsr a		;
	lsr a		;
	and #0fh	;
	cmp #0ah	;
	bpl Letter1	;
	ora #30h	;
	jmp Print1st	;
Letter1:		;
	sec
	sbc #9d		;
	ora #40h
Print1st:
	jsr OutChar	;
	
	lda number	;Output least significant digit of hex byte to
	and #0fh	; serial port.
	cmp #0ah	;
	bpl Letter2	;
	ora #30h	;
	jmp Print2nd	;
Letter2:		;
	sec
	sbc #9d		;
	ora #40h	;
Print2nd:		;
	jsr OutChar	;
	
	lda number
	rts
	
;****************************************************************************
;                     Initialize Variables Subroutine
;****************************************************************************
InitVars:

	;lda #1ah	;Initialize ACIA control register, 2400
	;sta 6551CtR	; Baud.
	
	;lda #0bh	;Initialize ACIA command register.
	;sta 6551CmR	;
		
	lda #BRK<	;Initialize BRK vector.
	sta BRKVect	;
	lda #BRK>	;
	sta BRKVect+1d	;
	
	lda #0d		;Initialize trace break flag.
	sta TrBrkFlg	;
	
	lda #0d		;Initialize break point status variables.
	sta BrkPt1St	;
	sta BrkPt2St	;
	sta BrkPt3St	;
	sta BrkPt4St	;
	
	lda #0d		;Set the output port to all zeros (turn
	;sta OutPort0	; off all of the LEDs).
	
	rts

;****************************************************************************
;                          Print Message Subroutine.
;
; X holds the message pointer's low byte (< means less than) and Y holds its 
; high byte (> means greater than).  The message must have a NULL (0) after 
; the last character in the  Message so the PrntMess subroutine knows when to 
; stop printing.
;****************************************************************************
PrntMess:
	pha
	
	stx MessPtr	;Initialize pointer that will point to each
	sty MessPtr+1h	; character of message.
	
	ldy #0h
	
OutMess:		;
	lda (MessPtr),y	;Get a character from the message and if it is
	beq ExitMess	; a NULL (0) then exit this subroutine.
	
	jsr OutChar	;Output the character to the serial port.
	
	inc MessPtr	;Increment the message pointer to point to the
	bne PrNoOvf	; next character in the message.
	inc MessPtr+1d	;
	
PrNoOvf:
	jmp OutMess
		
ExitMess:
	pla
	
	rts

;****************************************************************************
;           Get Character (Don't Wait) From Serial Channel Subroutine
;****************************************************************************
GetChar:
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
	lda 6551StR	;Check ACIA to see if a character has been
	and #00001000b	; received and return with a NULL if no
	beq NoChar	; character was present.
	
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	jmp ExitGtCh	;
	
NoChar:
	lda #0d
	sta RegTemp
	
ExitGtCh:
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;             Get Character (Wait) From Serial Channel Subroutine
;****************************************************************************
GetCharW:
	php		;Save the registers on the stack.
	txa		;
	pha		;
	tya		;
	pha		;
	
GtCkAgn:	
	lda 6551StR	;Check the ACIA's receiver buffer full register
	and #00001000b	; and wait until a character is received.
	bne CharRec	;
	
	lda 6551Sleep ;Allow the emulator to be put to sleep.
	jmp GtCkAgn
	
CharRec:
	lda 6551TRR	;Get the received character from the ACIA's 
	sta RegTemp	; receive register.
	
	pla		;Restore the registers.
	tay		;
	pla		;
	tax		;
	plp		;
	lda RegTemp	;
	
	rts
	
;****************************************************************************
;                 Output Character to Serial Channel Subroutine 
;                   Character to print is in register 'A'
;****************************************************************************
OutChar:
	
	sta RegTemp	;Save registers.
	php		;
	tya		;
	pha		;
	txa		;
	pha		;
	
OtCkAgn:
	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
	and #00010000b	; register and wait until the buffer is empty.
	beq OtCkAgn	;
	
	lda RegTemp	;Output a character to the ACIA's Transmitt
	sta 6551TRR	; register.
	
	pla		;Restore registers.
	tax		;
	pla		;
	tay		;
	plp		;
	lda RegTemp	;
		
	rts


;****************************************************************************
;                          Delay Subroutine
;****************************************************************************
delay:
	pha
	txa
	pha
	tya
	pha
	
	lda #0h
	sta wait0
	lda #10h
	sta wait1
	
	
dw0:
	dec wait0
	bne dw0
	dec wait1
	bne dw0
	
	pla
	tay
	pla                                                                        
	tax
	pla
	rts


;****************************************************************************
;                Constants
;****************************************************************************

UARTval:		dbt 16h,0bh
DgtTblUC:		dbt "0123456789ABCDEF"
				dbt 0h
DgtTblLC:		dbt "0123456789abcdef"
				dbt 0h
EmulatorMess:	dbt 10d,13d
				dbt "Emulator v"
EmuVersionTo:	dbt "        " ;8 characters.
				dbt 10d,13d
				dbt 0h
OpenMess:		dbt "UMON65 v1.22 - Understandable Monitor for the 6500 series microprocessors."
				dbt 10d,13d
				dbt 0h
prompt:			dbt 10d,13d
				dbt "-"
				dbt 0h
CRLF:			dbt 10d,13d,0d
SRecStMs:		dbt 10d,13d
				dbt "Send S records when you are ready..."
				dbt 10d,13d,0d
SRecErMe:		dbt 10d,13d,7d
				dbt "Error Loading S Records..."
				dbt 10d,13d,0d
SRecEnMs:		dbt 10d,13d,7d
				dbt "S records successfully loaded (press <enter> to continue)."
				dbt 10d,13d,0d
RegMess:		dbt 10d,13d,10d
				dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
				dbt 10d,13d,0d
ColnPrmt:		dbt 10d,13d
				dbt " :"
				dbt 0d
BadOpMes:		dbt "        ???"
				dbt 0d
BPFulMes:		dbt 10d,13d
				dbt "All breakpoints are currently in use."
				dbt 0d
NoBPMess:		dbt 10d,13d
				dbt "No breakpoint exists at this address."
				dbt 0d
GoBPErrM:		dbt 10d,13d
				dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
				dbt 0d
CmdErMes:		dbt 10d,13d
				dbt "?"
				dbt 0d
HelpMess:		dbt 10d,13d,10d
				dbt "Assemble       A start_address"
				dbt 10d,13d
				dbt "Breakpoint     B (+,-,?) address"
				dbt 10d,13d
				dbt "Dump           D [start_address [end_address]]"
				dbt 10d,13d
				dbt "Enter          E address list"
				dbt 10d,13d
				dbt "Fill           F start_address end_address list"
				dbt 10d,13d
				dbt "Go             G [start_address]"
				dbt 10d,13d
				dbt "Help           H or ?"
				dbt 10d,13d
				dbt "Load           L"
				dbt 10d,13d
				dbt "Move           M start_address end_address destination_address"
				dbt 10d,13d
				dbt "Register       R [PC,AC,XR,YR,SP,SR]"
				dbt 10d,13d
				dbt "Search         S start_address end_address list"
				dbt 10d,13d
				dbt "Trace          T [start_address [value]]"
				dbt 10d,13d
				dbt "Unassemble     U [start_address [end_address]]"
				dbt 10d,13d,0d
	        	
            	
OpTable:		dbt "ADC IMM"
				dbt 069h,2h,2h
				dbt "ADC ABS"
				dbt 06Dh,3h,4h
				dbt "ADC ABX"
				dbt 07Dh,3h,4h
				dbt "ADC ABY"
				dbt 079h,3h,4h
				dbt "ADC IIR"
				dbt 061h,2h,6h
				dbt "ADC IRI"
				dbt 071h,2h,5h
				dbt "AND IMM"
				dbt 029h,2h,2h
				dbt "AND ABS"
				dbt 02Dh,3h,4h
				dbt "AND ABX"
				dbt 03Dh,3h,4h
				dbt "AND ABY"
				dbt 039h,3h,4h
				dbt "AND IIR"
				dbt 021h,2h,6h
				dbt "AND IRI"
				dbt 031h,2h,5h
				dbt "ASL ACC"
				dbt 00Ah,1h,2h
				dbt "ASL ABS"
				dbt 00Eh,3h,6h
				dbt "ASL ABX"
				dbt 01Eh,3h,7h
				dbt "BCC REL"
				dbt 090h,2h,2h
				dbt "BCS REL"
				dbt 0B0h,2h,2h
				dbt "BEQ REL"
				dbt 0F0h,2h,2h
				dbt "BIT ABS"
				dbt 02Ch,3h,4h
				dbt "BMI REL"
				dbt 030h,2h,2h
				dbt "BNE REL"
				dbt 0D0h,2h,2h
				dbt "BPL REL"
				dbt 010h,2h,2h
				dbt "BRK IMP"
				dbt 000h,1h,7h
				dbt "BVC REL"
				dbt 050h,2h,2h
				dbt "BVS REL"
				dbt 070h,2h,2h
				dbt "CLC IMP"
				dbt 018h,1h,2h
				dbt "CLD IMP"
				dbt 0D8h,1h,2h
				dbt "CLI IMP"
				dbt 058h,1h,2h
				dbt "CLV IMP"
				dbt 0B8h,1h,2h
				dbt "CMP IMM"
				dbt 0C9h,2h,2h
				dbt "CMP ABS"
				dbt 0CDh,3h,4h
				dbt "CMP ABX"
				dbt 0DDh,3h,4h
				dbt "CMP ABY"
				dbt 0D9h,3h,4h
				dbt "CMP IIR"
				dbt 0C1h,2h,6h
				dbt "CMP IRI"
				dbt 0D1h,2h,5h
				dbt "CPX IMM"
				dbt 0E0h,2h,2h
				dbt "CPX ABS"
				dbt 0ECh,3h,4h
				dbt "CPY IMM"
				dbt 0C0h,2h,2h
				dbt "CPY ABS"
				dbt 0CCh,3h,4h
				dbt "DEC ABS"
				dbt 0CEh,3h,6h
				dbt "DEC ABX"
				dbt 0DEh,3h,7h
				dbt "DEX IMP"
				dbt 0CAh,1h,2h
				dbt "DEY IMP"
				dbt 088h,1h,2h
				dbt "EOR IMM"
				dbt 049h,2h,2h
				dbt "EOR ABS"
				dbt 04Dh,3h,4h
				dbt "EOR ABX"
				dbt 05Dh,3h,4h
				dbt "EOR ABY"
				dbt 059h,3h,4h
				dbt "EOR IIR"
				dbt 041h,2h,6h
				dbt "EOR IRI"
				dbt 051h,2h,5h
				dbt "INC ABS"
				dbt 0EEh,3h,6h
				dbt "INC ABX"
				dbt 0FEh,3h,7h
				dbt "INX IMP"
				dbt 0E8h,1h,2h
				dbt "INY IMP"
				dbt 0C8h,1h,2h
				dbt "JMP ABS"
				dbt 04Ch,3h,3h
				dbt "JMP IND"
				dbt 06Ch,3h,5h
				dbt "JSR ABS"
				dbt 020h,3h,6h
				dbt "LDA IMM"
				dbt 0A9h,2h,2h
				dbt "LDA ABS"
				dbt 0ADh,3h,4h
				dbt "LDA ABX"
				dbt 0BDh,3h,4h
				dbt "LDA ABY"
				dbt 0B9h,3h,4h
				dbt "LDA IIR"
				dbt 0A1h,2h,6h
				dbt "LDA IRI"
				dbt 0B1h,2h,5h
				dbt "LDX IMM"
				dbt 0A2h,2h,2h
				dbt "LDX ABS"
				dbt 0AEh,3h,4h
				dbt "LDX ABY"
				dbt 0BEh,3h,4h
				dbt "LDY IMM"
				dbt 0A0h,2h,2h
				dbt "LDY ABS"
				dbt 0ACh,3h,4h
				dbt "LDY ABX"
				dbt 0BCh,3h,4h
				dbt "LSR ACC"
				dbt 04Ah,1h,2h
				dbt "LSR ABS"
				dbt 04Eh,3h,6h
				dbt "LSR ABX"
				dbt 05Eh,3h,7h
				dbt "NOP IMP"
				dbt 0EAh,1h,2h
				dbt "ORA IMM"
				dbt 009h,2h,2h
				dbt "ORA ABS"
				dbt 00Dh,3h,4h
				dbt "ORA ABX"
				dbt 01Dh,3h,4h
				dbt "ORA ABY"
				dbt 019h,3h,4h
				dbt "ORA IIR"
				dbt 001h,2h,6h
				dbt "ORA IRI"
				dbt 011h,2h,5h
				dbt "PHA IMP"
				dbt 048h,1h,3h
				dbt "PHP IMP"
				dbt 008h,1h,3h
				dbt "PLA IMP"
				dbt 068h,1h,4h
				dbt "PLP IMP"
				dbt 028h,1h,4h
				dbt "ROL ACC"
				dbt 02Ah,1h,2h
				dbt "ROL ABS"
				dbt 02Eh,3h,6h
				dbt "ROL ABX"
				dbt 03Eh,3h,7h
				dbt "ROR ACC"
				dbt 06Ah,1h,2h
				dbt "ROR ABS"
				dbt 06Eh,3h,6h
				dbt "ROR ABX"
				dbt 07Eh,3h,7h
				dbt "RTI IMP"
				dbt 040h,1h,6h
				dbt "RTS IMP"
				dbt 060h,1h,6h
				dbt "SBC IMM"
				dbt 0E9h,2h,2h
				dbt "SBC ABS"
				dbt 0EDh,3h,4h
				dbt "SBC ABX"
				dbt 0FDh,3h,4h
				dbt "SBC ABY"
				dbt 0F9h,3h,4h
				dbt "SBC IIR"
				dbt 0E1h,2h,6h
				dbt "SBC IRI"
				dbt 0F1h,2h,5h
				dbt "SEC IMP"
				dbt 038h,1h,2h
				dbt "SED IMP"
				dbt 0F8h,1h,2h
				dbt "SEI IMP"
				dbt 078h,1h,2h
				dbt "STA ABS"
				dbt 08Dh,3h,4h
				dbt "STA ABX"
				dbt 09Dh,3h,5h
				dbt "STA ABY"
				dbt 099h,3h,5h
				dbt "STA IIR"
				dbt 081h,2h,6h
				dbt "STA IRI"
				dbt 091h,2h,6h
				dbt "STX ABS"
				dbt 08Eh,3h,4h
				dbt "STY ABS"
				dbt 08Ch,3h,4h
				dbt "TAX IMP"
				dbt 0AAh,1h,2h
				dbt "TAY IMP"
				dbt 0A8h,1h,2h
				dbt "TSX IMP"
				dbt 0BAh,1h,2h
				dbt "TXA IMP"
				dbt 08Ah,1h,2h
				dbt "TXS IMP"
				dbt 09Ah,1h,2h
				dbt "TYA IMP"
				dbt 098h,1h,2h
				dbt "ZZZ ZZZ"
				dbt 000h,0h,0h
				
	
;****************************************************************************
;       Emulator version number (to be set by the emulator).
;****************************************************************************
EmuVersionFrom:
				org 0fff0h
				dbt "J0.01   "

;****************************************************************************
;       Initialize 6502 reset vector and maskable interrupt vector.
;****************************************************************************
			org 0fffch	    ;Initialize reset vector.
			dbt 00h,0e0h	;                                                                                         
;	
			org 0fffeh	    ;Initialize maskable
			dbt #MaskInt<	; interrupt vector.
			dbt #MaskInt>	;
			
			end
		
; ,output="array",start_address="E000"
%/uasm65

    %output,sequence="6",timestamp="2015-05-05 14:45:38.157",preserve="false"
      *** Executable Code ***
      
      %s19,description="Execute this fold to send program to U6502 monitor.",preserve="false",output="array",start_address="E000"
      	S007000055415347C8
      	S11700000000000000000000000000000000000000000000E8
      	S11700140000000000000000000000000000000000000000D4
      	S11700280000000000000000000000000000000000000000C0
      	S117003C0000000000000000000000000000000000000000AC
      	S1170050000000000000000000000000000000000000000098
      	S1170064000000000000000000000000000000000000000084
      	S1170078000000000000000000000000000000000000000070
      	S117008C00000000000000000000000000000000000000005C
      	S11700A0000000000000000000000000000000000000000048
      	S11700B4000000000000000000000000000000000000000034
      	S10B00C800000000000000002C
      	S117E0004C1BE04C14F44CD0F34CF3F34CB3F34C03F34C5F4D
      	S117E014F34C93EA4CA8E078A2FF9AD82093F3A9048D4B00AE
      	S117E028A9008D47008D48008D4900A9FF8D4A00AD00AAC919
      	S117E03C00F008AD00C0F0034C0002A200BDC6FC9D81F4E80B
      	S117E050E008D0F5A275A0F420B3F3A28CA0F420B3F34C4185
      	S117E064E2C902D01329F04A4A4A1869C08D0900A9008D0808
      	S117E078006C08004C7FE0A0008C4400A264C8D0FDCAD0FAD2
      	S117E08CEE4400AD44004C84E020A1E02013E1206BE14C95A7
      	S117E0A0E0A2D9A0F420B3F3A0008C5E008CCD008C5F008C59
      	S117E0B473008C8700A000A90099A500C8C027D0F8A0002010
      	S117E0C8F3F3C900F0F9C908D0034CD9E0C97FD01588300D0D
      	S117E0DCA9202014F4A9082014F44CC7E0A0004CC7E0C90D06
      	S117E0F0F00D99A500C8C027D0CDA0274CC7E088B9A500C928
      	S117E1040AF001C8A90099A50060A0FF4C30E1A000B9A500FF
      	S117E118F050C93F304BC95A100338B008C9613040C97A1019
      	S117E12C3C8DCD00C8C014F034B9A500C900F02EC920F0F077
      	S117E140AE5E008A1869148D5E00B9A500C920F010C900F0B1
      	S117E1540C9D5F00E8C8C028F00B4C4AE1A9009D5F004C3080
      	S117E168E1606038ADCD00200EF3C96CD006208AE94CFEE162
      	S117E17CC964D006205CE74CFEE1C972D0062040EB4CFEE173
      	S117E190C967D0062001E94CFEE1C965D006205AE84CFEE1AB
      	S117E1A4C966D00620C0E84CFEE1C975D00620D1EF4CFEE14C
      	S117E1B8C974D0062096ED4CFEE1C962D00620F4E54CFEE149
      	S117E1CCC973D0062005ED4CFEE1C96DD00620D4EA4CFEE1D7
      	S117E1E0C961D006206BE24CFEE1C968D0062082E94CFEE1D2
      	S117E1F4C93FD0062082E94CFEE1B009A256A0F620B3F3185A
      	S117E208603860788D440068482910D006AD44006C02006C33
      	S117E21C0400688D4B00AD44008D47008E48008C4900BAE894
      	S117E230E88E4A006838E9018D450068E9008D4600A0008C6A
      	S117E2445F002040EBAD3900C901D0034C4CEFA003A206B90A
      	S117E2582F00C901D005B93300811288CACA10EF4C95E0A2E3
      	S117E26C0020E4F2B0034C61E38E08008C0900A2DDA0F42003
      	S117E280B3F32026F320A8E0200EE1AD5F00C900F004C9203E
      	S117E294D0034C63E3A000B95F00201AF3995F00C8C003D0D5
      	S117E2A8F22065E3B0282026F3A9202014F4A25FA00020B38E
      	S117E2BCF3A9202014F4A273A00020B3F3A9202014F4A93F12
      	S117E2D02014F44C7BE2209DE3B0034CAEE22092E4B0034CA1
      	S117E2E4AEE220B2E4B0034CAEE22026F3A000AD1A00910814
      	S117E2F8205FF320DBF2A9202014F4AD1D00F028AD1B009183
      	S117E30C08205FF320DBF2A9202014F4AD1E00F01EAD1C00FF
      	S117E3209108205FF320DBF2A9202014F44C46E3A92020148A
      	S117E334F42014F42014F4A9202014F42014F42014F4A92083
      	S117E3482014F4A25FA00020B3F3A9202014F4A273A0002068
      	S117E35CB3F34C7BE218603860A25C8E0A00A2F88E0B00A0E1
      	S117E37000B10AD95F00F019AD0A0018690A8D0A009003EE3F
      	S117E3840B00A004B10AC95AF00B4C6FE3C8C003F0054C711E
      	S117E398E318603860A000B97300C900D008A9508D1F004C1C
      	S117E3AC90E4C923D008A94D8D1F004C90E4C941F007C96194
      	S117E3C0F0034CDCE3C8B97300C900F007C920F0034CDCE3AC
      	S117E3D4A9438D1F004C90E4A006B10AC94CD0068D1F004C95
      	S117E3E890E4A000B97300C928D0034C36E4A000B97300C91E
      	S117E3FC2CF008C900F02BC84CF8E3C8B97300C958F00FC935
      	S117E41078F00BC959F00FC979F00B4C8EE4A9588D1F004C6C
      	S117E42490E4A9598D1F004C90E4A9538D1F004C90E4C8B915
      	S117E4387300C92CF00BC929F01EC00BD0F04C8EE4C8B9732C
      	S117E44C00C958F007C978F0034C8EE4A9528D1F004C90E447
      	S117E460C8B97300C900F016C92CF0034C8EE4C8B97300C97E
      	S117E47459F00FC979F00B4C8EE4A9448D1F004C90E4A949F2
      	S117E4888D1F004C90E418603860A006B10ACD1F00F015AD01
      	S117E49C0A0018690A8D0A009003EE0B00206FE3B0E4186032
      	S117E4B03860A9008D1D008D1E00A007B10A8D1A00AD1F00E9
      	S117E4C4C950F027C943F026C94DF025C953F03CC958F03832
      	S117E4D8C959F034C949F058C952F054C944F050C94CF024B7
      	S117E4EC4CCBE54CCDE54CCDE520CFE5B0034CCBE5203DF34D
      	S117E500B0034CCBE58D1B00A9018D1D004CCDE520CFE5B0D6
      	S117E514034CCBE520E4F2B0034CCBE5AD1F00C94CF0488EA4
      	S117E5281B008C1C00A9018D1D008D1E004CCDE520CFE5B097
      	S117E53C034CCBE520E4F2B0034CCBE5AD1F00C944F00FC08B
      	S117E55000D0788E1B00A9018D1D004CCDE58E1B008C1C001F
      	S117E564A9018D1D008D1E004CCDE58E2B008C2C00AD08007C
      	S117E5788D2D00AD09008D2E00A008B10A186D2D008D2D0091
      	S117E58C9003EE2E0038AD2B00ED2D008D2B00AD2C00ED2EF2
      	S117E5A0008D2C00AD2C00C9FFF00EC900D01CAD2B00C98035
      	S117E5B410154CC0E5AD2B00C980300B8D1B00A9018D1D00E1
      	S117E5C84CCDE518603860A214A000BD5F00D953F4F017D9BB
      	S117E5DC64F4F012C8C010F0034CD6E5E8E01FF0034CD1E55F
      	S117E5F018603860AD5F00C92BF00BC92DF00AC93FF0094CCB
      	S117E60414E74C80E64C3CE6A2DDA0F420B3F3A0FFA2FFC802
      	S117E618E8B912008D0800C8B912008D0900BD2F00F003207A
      	S117E62C26F3C007D0E5A2DDA0F420B3F34C14E7AD7300C938
      	S117E64000F00AA21420E4F2B0104C14E7A003A900992F0001
      	S117E6548810F84C14E78E2B008C2C00A003A2062015E7B04F
      	S117E6680F88CACA10F6A2ECA0F520B3F34C14E7A900992FC8
      	S117E67C004C14E7AD7300C900F007A21420E4F2B0034C14A0
      	S117E690E78E2B008C2C00A003A206B92F00C900F0052015F4
      	S117E6A4E7B0E788CACA10EFA000B92F00C900F00FC8C004E9
      	S117E6B8D0F4A2C4A0F520B3F34C14E78C3700A901992F0049
      	S117E6CCC000D00FAD2B008D1200AD2C008D13004C14E7C0A0
      	S117E6E001D00FAD2B008D1400AD2C008D15004C14E7C00245
      	S117E6F4D00FAD2B008D1600AD2C008D17004C14E7AD2B0018
      	S117E7088D1800AD2C008D19004C14E760C000D00BAD2C00BA
      	S117E71CCD1300F02C4C5AE7C001D00BAD2C00CD1500F01DF8
      	S117E7304C5AE7C002D00BAD2C00CD1700F00E4C5AE7AD2C86
      	S117E74400CD1900F0034C5AE7AD2B00DD1200F0034C5AE710
      	S117E75838601860A200BD5F00C900F03A203DF3B0034C2079
      	S117E76CE88D0900E8203DF3B0034C20E88D0800A214BD5F71
      	S117E78000C900F01A203DF3B0034C20E88D5D00E8203DF335
      	S117E794B0034C20E88D5C004CB6E7AD09008D5D00AD08003F
      	S117E7A88D5C0018690F8D5C009003EE5D00A90D2014F4A992
      	S117E7BC0A2014F4A200A0002026F3B1082044E8205FF3E839
      	S117E7D0E010D003202CE8E008D012A9202014F4A92D201475
      	S117E7E4F4A9202014F44CF2E7A9202014F4AD0800CD5C0044
      	S117E7F8D008AD0900CD5D00F020EE0800D003EE0900E01091
      	S117E80CD00FA90A2014F4A90D2014F42026F3A2004CC7E787
      	S117E8201860EE0800D003EE09003860A9202014F4A9202036
      	S117E83414F4A200BD4C002014F4E8E010D0F56048C9203093
      	S117E8480AC97F10069D4C004C58E8A92E9D4C006860AD5F47
      	S117E85C00C900D0034C88E8AD7300C900D0034C88E8A20032
      	S117E87020E4F2B0034C88E88E08008C0900A214208CE89026
      	S117E884034C8AE818603860A0008CCF00BD5F00F028203D1F
      	S117E898F3B0034CBEE89108EE0800D003EE0900EECF00AD0D
      	S117E8ACCF00C90AF00AE8BD5F00F004E84C91E83860186003
      	S117E8C0A20020E4F2B0034CFDE88E08008C0900A21420E4DF
      	S117E8D4F2B0034CFDE88E5C008C5D00A228208CE89016ADD2
      	S117E8E85D00CD0900F0034CE0E8AD5C00CD0800F0054CE0DF
      	S117E8FCE818603860AD5F00C900F010A20020E4F2B0034CA0
      	S117E9107EE98E45008C4600AE45008E2B00AC46008C2C008D
      	S117E924A003A206B92F00C900F0052015E7B00888CACA10EA
      	S117E938EF4C46E9A214A0F620B3F34C80E9A003A206B92F63
      	S117E94C00C901D009A112993300A900811288CACA10EB68D6
      	S117E960686868AD5F00C900F011A2FF9AAD4B0048AD470022
      	S117E974AE4800AC4900286C450018603860A25AA0F620B352
      	S117E988F360A2E0A0F420B3F320F3F3A2DDA0F420B3F34C1D
      	S117E99CA1E920F3F3C953D0F92014F420F3F32014F48DA16A
      	S117E9B000C930D00820B6EA90254CDCE9C931D00820C0EA5C
      	S117E9C490194CDCE9C939D01220CAEA900DA229A0F520B3F9
      	S117E9D8F34CE8E94C9EE9A209A0F520B3F3386020F3F33868
      	S117E9EC60A9008D9F008DA000205DEA8D9E002084EAAACA1D
      	S117EA00CACA8A8D9B00205DEA8D09002084EA205DEA8D0831
      	S117EA14002084EA60AD9B00F00B205DEA2084EACE9B00D08B
      	S117EA28F560AD9B00F017A000205DEA2084EA9108EE08000E
      	S117EA3CD003EE0900CE9B00D0EB60AD9F0049FF8D9D002096
      	S117EA505DEACD9D00F004184C5CEA3860984820F3F320932E
      	S117EA64EA901C0A0A0A0A29F08D9C0020F3F32093EA900B5C
      	S117EA780D9C008D9C0068A8AD9C006048186D9F008D9F0063
      	S117EA8C9003EEA00068608ECE00A200DD53F4F013DD64F42F
      	S117EAA0F00EE8E010F0034C98EAA900184CB5EA8A38AECEDD
      	S117EAB4006020EDE92019EA2047EA6020EDE9202AEA20478F
      	S117EAC8EA6020EDE92019EA2047EA60AD5F00C900F007A2B4
      	S117EADC0020E4F2B0034C3FEB8E08008C0900A21420E4F22C
      	S117EAF0B0034C3FEB8E5C008C5D00EE5C00D003EE5D00A208
      	S117EB042820E4F2B0034C3FEB8E0A008C0B00A000B1089199
      	S117EB180AEE0A00D003EE0B00EE0800D003EE0900AD0800A2
      	S117EB2CCD5C00F0034C15EBAD0900CD5D00F0034C15EB60EA
      	S117EB40488A48984808AD5F00C900F0034CB8EBA269A0F564
      	S117EB5420B3F3A0032003F3AD4600205FF3AD4500205FF361
      	S117EB68A0092003F3AD4700205FF3A0092003F3AD4800209C
      	S117EB7C5FF3A0082003F3AD4900205FF3A0082003F3AD4A54
      	S117EB9000205FF3A0072003F3AD4B00A2082AB00A48A93097
      	S117EBA42014F4684CB2EB48A9312014F468CAD0E94CFDEC76
      	S117EBB8A90D2014F4A90A2014F4AD5F00200EF3C970D03C1A
      	S117EBCCAD4600205FF3AD4500205FF320FBF220A8E0200E85
      	S117EBE0E1AD5F00C900D0034CFDECA200203DF3B0034CFD71
      	S117EBF4ECA8E8203DF3B0034CFDEC8D45008C46004CFDEC7C
      	S117EC08C961D029AD4700205FF320FBF220A8E0200EE1ADFA
      	S117EC1C5F00C900D0034CFDECA200203DF3B0034CFDEC8D49
      	S117EC3047004CFDECC978D029AD4800205FF320FBF220A8DA
      	S117EC44E0200EE1AD5F00C900D0034CFDECA200203DF3B04A
      	S117EC58034CFDEC8D48004CFDECC979D029AD4900205FF3BF
      	S117EC6C20FBF220A8E0200EE1AD5F00C900D0034CFDECA24D
      	S117EC8000203DF3B0034CFDEC8D49004CFDECC973F0034CBE
      	S117EC94F9ECAD6000200EF3C970F007C972F02C4CF9ECADF0
      	S117ECA84A00205FF320FBF220A8E0200EE1AD5F00C900D02F
      	S117ECBC034CFDECA200203DF3B0034CFDEC8D4A004CFDEC22
      	S117ECD0AD4B00205FF320FBF220A8E0200EE1AD5F00C90029
      	S117ECE4D0034CFDECA200203DF3B0034CFDEC8D4B004CFD15
      	S117ECF8EC184CFEEC382868A868AA6860AD5F00C900F007B4
      	S117ED0CA20020E4F2B0034C95ED8E0A008C0B00A21420E4ED
      	S117ED20F2B0034C95ED8E5C008C5D00EE5C00D003EE5D002D
      	S117ED34A228A9208D0800A9008D0900208CE89050ADCF0070
      	S117ED488D2A00AD0A008D0800AD0B008D0900A2DDA0F4202F
      	S117ED5CB3F3A200A000B108DD2000F01920DBF2AD0800CD89
      	S117ED705C00F0034C5EEDAD0900CD5D00F0164C5EEDC8E878
      	S117ED84EC2A00F0034C62ED2026F320DBF24C5EED60AD5FAA
      	S117ED9800C900F017A20020E4F2B0034C9DEF8E45008C46CB
      	S117EDAC00AD7300C900D008A0018C3E004CC9EDA214203D0E
      	S117EDC0F3B0034C9DEF8D3E0068686868AC45008C0800AC21
      	S117EDD446008C0900A000B1088D430020A1EFB0034C9DEFE8
      	S117EDE8A008B10A8D3A00A001AD4300C960D028A9028D3DC2
      	S117EDFC00688D1000688D110048AD100048EE1000D003EEE8
      	S117EE101100A000B1108D3C00A90091104C2CEFC94CD01EFB
      	S117EE24A9028D3D00B1088D1000C8B1088D1100A000B1108B
      	S117EE388D3C00A90091104C2CEFC96CD02BA9028D3D00B1F2
      	S117EE4C088D0C00C8B1088D0D00A000B10C8D1000C8B10C73
      	S117EE608D1100A000B1108D3C00A90091104C2CEFC920D068
      	S117EE741EA9028D3D00B1088D1000C8B1088D1100A000B12D
      	S117EE88108D3C00A90091104C2CEFA000B10AC942D008A00A
      	S117EE9C01B10AC949D0034C09EFA9018D3D0018AD08006DCB
      	S117EEB03A008D1000AD090069008D1100A001B1088D380097
      	S117EEC41020CE3800AD380049FF8D380038AD1000ED3800F4
      	S117EED88D1000AD1100E9008D11004CFBEE18AD10006D3891
      	S117EEEC008D1000AD110069008D11004CFBEEA000B1108D89
      	S117EF003C00A90091104C0EEFA9008D3D00AC3A00B1088D8B
      	S117EF143B0018AD08006D3A008D0E00AD090069008D0F00E0
      	S117EF28A9009108A9018D3900AD5F00C900F003A2FF9AAD6F
      	S117EF3C4B0048AD4700AE4800AC4900286C4500A9008D3903
      	S117EF5000A000AD3D00C900F011C901F008AD3C0091104CBD
      	S117EF6470EFAD3C009110AD3B00910EAC45008C0800AC46AE
      	S117EF78008C0900A2DDA0F420B3F3AD08008D5C00AD0900BF
      	S117EF8C8D5D002020F0CE3E00F0034CCDED4C95E0186038DD
      	S117EFA060A25C8E0A00A2F88E0B00A004B10AC95AF01CA002
      	S117EFB407B10ACD4300F011AD0A0018690A8D0A009003EE18
      	S117EFC80B004CABEF38601860AD5F00C900F017A20020E4AE
      	S117EFDCF2B0034CC5F28E08008C0900AD7300C900D021ADC3
      	S117EFF008008D5C00AD09008D5D0018AD080069148D5C0045
      	S117F0049007AE5D00E88E5D004C20F0A21420E4F2B0034C78
      	S117F018C5F28E5C008C5D00AD5D00CD0900F005900E4C3B5C
      	S117F02CF0AD5C00CD080090034C3BF04CC7F2A000B1088D09
      	S117F040430020A1EFB01DA2DDA0F420B3F32026F3AD4300F6
      	S117F054205FF3A2B8A0F520B3F320DBF24C20F0A2DDA0F421
      	S117F06820B3F32026F320DBF2A006B10AC950D0034CBEF05D
      	S117F07CC94DD0034CE5F0C953D0034C18F1C958D0034C18D6
      	S117F090F1C959D0034C18F1C952D0034C35F2C94CD0034C98
      	S117F0A482F1C943D0034CCFF0C944D0034C77F2C949D0037D
      	S117F0B84CF3F14C47F0AD4300205FF3A0082003F320C9F292
      	S117F0CC4C20F0AD4300205FF3A0082003F320C9F2A94120CB
      	S117F0E014F44C20F0A000AD4300205FF3A9202014F4B10808
      	S117F0F48D4100205FF320DBF2A0052003F320C9F2A9232055
      	S117F10814F4AD4100205FF3A9682014F44C20F0A000AD4362
      	S117F11C00205FF3A9202014F4B1088D4100205FF320DBF292
      	S117F130A9202014F4B1088D4200205FF320DBF2A00220032A
      	S117F144F320C9F2AD4200205FF3AD4100205FF3A9682014DF
      	S117F158F4A006B10AC958F007C959F0104C20F0A92C2014AB
      	S117F16CF4A9582014F44C20F0A92C2014F4A9592014F44C9F
      	S117F18020F0A000AD4300205FF3A9202014F4B1088D4100ED
      	S117F194205FF320DBF2A0052003F320C9F2AD08008D3F00ED
      	S117F1A8AD09008D4000AD41003012AD3F00186D41008D3F1E
      	S117F1BC009020EE40004CDFF1CE4100AD410049FF8D41002E
      	S117F1D0AD3F0038ED41008D3F00B003CE4000AD4000205FDC
      	S117F1E4F3AD3F00205FF3A9682014F44C20F0A000AD43009D
      	S117F1F8205FF3A9202014F4B1088D4100205FF320DBF2A016
      	S117F20C052003F320C9F2A9282014F4AD4100205FF3A9688A
      	S117F2202014F4A9292014F4A92C2014F4A9592014F44C2021
      	S117F234F0A000AD4300205FF3A9202014F4B1088D41002038
      	S117F2485FF320DBF2A0052003F320C9F2A9282014F4AD41F2
      	S117F25C00205FF3A9682014F4A92C2014F4A9582014F4A920
      	S117F270292014F44C20F0A000AD4300205FF3A9202014F4E6
      	S117F284B1088D4100205FF320DBF2A9202014F4B1088D4213
      	S117F29800205FF320DBF2A0022003F320C9F2A9282014F473
      	S117F2ACAD4200205FF3AD4100205FF3A9682014F4A929205E
      	S117F2C014F44C20F018603860A000B10A2014F4C8C003D0E4
      	S117F2D4F6A9202014F460EE0800D003EE090060203DF3B0BB
      	S117F2E8034CF9F2A8E8203DF3B0034CF9F2AA38601860A2AE
      	S117F2FCB3A0F520B3F36048A9202014F488D0F86860C94131
      	S117F3103007C95B100318692060C9613007C97B100338E99D
      	S117F3242060AD0900205FF3AD0800205FF3A9202014F4A968
      	S117F338202014F460BD5F002093EA90190A0A0A0A29F08DE5
      	S117F34C9C00E8BD5F002093EA90070D9C008D9C0038608DDE
      	S117F3609C004A4A4A4A290FC90A100509304C76F338E90999
      	S117F37409402014F4AD9C00290FC90A100509304C8CF3386B
      	S117F388E90909402014F4AD9C0060A91E8D0400A9E28D05EC
      	S117F39C00A9008D3900A9008D2F008D30008D31008D32004B
      	S117F3B0A90060488E06008C0700A000B106F00E2014F4EE62
      	S117F3C40600D003EE07004CBCF36860088A489848AD01A098
      	S117F3D82908F009AD00A08DCE004CEAF3A9008DCE0068A80E
      	S117F3EC68AA28ADCE0060088A489848AD01A02908D006AD38
      	S117F40002A04CF8F3AD00A08DCE0068A868AA28ADCE00604E
      	S117F4148DCE000898488A48AD01A02910F0F9ADCE008D0053
      	S117F428A068AA68A828ADCE0060488A489848A9008DA20035
      	S117F43CA9108DA300CEA200D0FBCEA300D0F668A868AA68D3
      	S117F45060160B303132333435363738394142434445460081
      	S117F46430313233343536373839616263646566000A0D45D2
      	S117F4786D756C61746F72207620202020202020200A0D00CB
      	S117F48C554D4F4E36352076312E3232202D20556E646572FA
      	S117F4A07374616E6461626C65204D6F6E69746F7220666FA9
      	S117F4B47220746865203635303020736572696573206D69E1
      	S117F4C863726F70726F636573736F72732E0A0D000A0D2D0C
      	S117F4DC000A0D000A0D53656E642053207265636F726473DB
      	S117F4F0207768656E20796F75206172652072656164792EFA
      	S117F5042E2E0A0D000A0D074572726F72204C6F6164696EDD
      	S117F518672053205265636F7264732E2E2E0A0D000A0D0750
      	S117F52C53207265636F726473207375636365737366756C02
      	S117F5406C79206C6F6164656420287072657373203C656EA1
      	S117F5547465723E20746F20636F6E74696E7565292E0A0D20
      	S117F568000A0D0A50676D436E747228504329202041636384
      	S117F57C756D28414329202058526567285852292020595224
      	S117F590656728595229202053746B507472285350292020BF
      	S117F5A44E562D4244495A43285352290A0D000A0D203A0094
      	S117F5B820202020202020203F3F3F000A0D416C6C2062725A
      	S117F5CC65616B706F696E7473206172652063757272656E52
      	S117F5E0746C7920696E207573652E000A0D4E6F20627265FB
      	S117F5F4616B706F696E742065786973747320617420746858
      	S117F608697320616464726573732E000A0D596F75206361A2
      	S117F61C6E6E6F7420474F206174206120627265616B706FE7
      	S117F630696E74656420616464726573732C205452414345ED
      	S117F6442070617374206974207468656E20474F2E000A0D0F
      	S117F6583F000A0D0A417373656D626C65202020202020202E
      	S117F66C412073746172745F616464726573730A0D42726582
      	S117F680616B706F696E7420202020204220282B2C2D2C3F63
      	S117F6942920616464726573730A0D44756D702020202020E2
      	S117F6A820202020202044205B73746172745F61646472653E
      	S117F6BC7373205B656E645F616464726573735D5D0A0D4543
      	S117F6D06E7465722020202020202020202045206164647229
      	S117F6E4657373206C6973740A0D46696C6C20202020202089
      	S117F6F82020202020462073746172745F6164647265737381
      	S117F70C20656E645F61646472657373206C6973740A0D470F
      	S117F7206F2020202020202020202020202047205B737461B8
      	S117F73472745F616464726573735D0A0D48656C7020202035
      	S117F748202020202020202048206F72203F0A0D4C6F61646A
      	S117F75C20202020202020202020204C0A0D4D6F76652020FB
      	S117F7702020202020202020204D2073746172745F6164643E
      	S117F7847265737320656E645F6164647265737320646573B8
      	S117F79874696E6174696F6E5F616464726573730A0D5265E0
      	S117F7AC6769737465722020202020202052205B50432C410A
      	S117F7C0432C58522C59522C53502C53525D0A0D53656172A2
      	S117F7D46368202020202020202020532073746172745F61D1
      	S117F7E864647265737320656E645F61646472657373206C5C
      	S117F7FC6973740A0D5472616365202020202020202020205F
      	S117F81054205B73746172745F61646472657373205B76614C
      	S117F8246C75655D5D0A0D556E617373656D626C6520202046
      	S117F838202055205B73746172745F61646472657373205BBA
      	S117F84C656E645F616464726573735D5D0A0D00414443206F
      	S117F860494D4D690202414443204142536D03044144432026
      	S117F8744142587D03044144432041425979030441444320F1
      	S117F88849495261020641444320495249710205414E4420E4
      	S117F89C494D4D290202414E44204142532D0304414E442054
      	S117F8B04142583D0304414E4420414259390304414E44201F
      	S117F8C4494952210206414E442049524931020541534C2010
      	S117F8D84143430A010241534C204142530E030641534C2057
      	S117F8EC4142581E03074243432052454C90020242435320AA
      	S117F90052454CB002024245512052454CF00202424954208A
      	S117F9144142532C0304424D492052454C300202424E4520CE
      	S117F92852454CD0020242504C2052454C10020242524B201C
      	S117F93C494D500001074256432052454C5002024256532088
      	S117F95052454C700202434C4320494D50180102434C442062
      	S117F964494D50D80102434C4920494D50580102434C56208C
      	S117F978494D50B80102434D5020494D4DC90202434D502026
      	S117F98C414253CD0304434D5020414258DD0304434D5020FA
      	S117F9A0414259D90304434D5020494952C10206434D5020E6
      	S117F9B4495249D1020543505820494D4DE0020243505820A2
      	S117F9C8414253EC030443505920494D4DC00202435059209F
      	S117F9DC414253CC030444454320414253CE030644454320E5
      	S117F9F0414258DE030744455820494D50CA01024445592086
      	S117FA04494D50880102454F5220494D4D490202454F52203D
      	S117FA184142534D0304454F52204142585D0304454F522061
      	S117FA2C414259590304454F5220494952410206454F52204D
      	S117FA40495249510205494E4320414253EE0306494E4320B1
      	S117FA54414258FE0307494E5820494D50E80102494E5920C7
      	S117FA68494D50C801024A4D50204142534C03034A4D50209F
      	S117FA7C494E446C03054A5352204142532003064C44412024
      	S117FA90494D4DA902024C444120414253AD03044C44412062
      	S117FAA4414258BD03044C444120414259B903044C4441202D
      	S117FAB8494952A102064C444120495249B102054C44582014
      	S117FACC494D4DA202024C445820414253AE03044C445820FE
      	S117FAE0414259BE03044C445920494D4DA002024C445920D4
      	S117FAF4414253AC03044C445920414258BC03044C535220B9
      	S117FB084143434A01024C5352204142534E03064C53522082
      	S117FB1C4142585E03074E4F5020494D50EA01024F524120AC
      	S117FB30494D4D0902024F5241204142530D03044F524120DF
      	S117FB444142581D03044F5241204142591903044F524120AA
      	S117FB584949520102064F52412049524911020550484120B1
      	S117FB6C494D5048010350485020494D50080103504C412058
      	S117FB80494D50680104504C5020494D50280104524F4C20EE
      	S117FB944143432A0102524F4C204142532E0306524F4C203E
      	S117FBA84142583E0307524F52204143436A0102524F5220C8
      	S117FBBC4142536E0306524F52204142587E0307525449205F
      	S117FBD0494D5040010652545320494D506001065342432092
      	S117FBE4494D4DE9020253424320414253ED0304534243207F
      	S117FBF8414258FD030453424320414259F90304534243204A
      	S117FC0C494952E1020653424320495249F102055345432044
      	S117FC20494D5038010253454420494D50F8010253454920CD
      	S117FC34494D50780102535441204142538D030453544120DD
      	S117FC484142589D0305535441204142599903055354412097
      	S117FC5C49495281020653544120495249910206535458207F
      	S117FC704142538E0304535459204142538C0304544158207B
      	S117FC84494D50AA010254415920494D50A801025453582017
      	S117FC98494D50BA010254584120494D508A01025458532012
      	S117FCAC494D509A010254594120494D509801025A5A5A2000
      	S109FCC05A5A5A0000002C
      	S10BFFF04A302E30312020209C
      	S105FFFC00E01F
      	S105FFFE0BE210
      	S9030000FC
      %/s19

          %output,sequence="7",timestamp="2015-05-05 14:45:45.719",preserve="false"
            {76,27,224,76,20,244,76,208,243,76,243,243,76,179,243,76,3,243,76,95,243,76,147,234,76,168,224,120,162,255,154,216,32,147,243,169,4,141,75,0,169,0,141,71,0,141,72,0,141,73,0,169,255,141,74,0,173,0,170,201,0,240,8,173,0,192,240,3,76,0,2,162,0,189,198,252,157,129,244,232,224,8,208,245,162,117,160,244,32,179,243,162,140,160,244,32,179,243,76,65,226,201,2,208,19,41,240,74,74,74,24,105,192,141,9,0,169,0,141,8,0,108,8,0,76,127,224,160,0,140,68,0,162,100,200,208,253,202,208,250,238,68,0,173,68,0,76,132,224,32,161,224,32,19,225,32,107,225,76,149,224,162,217,160,244,32,179,243,160,0,140,94,0,140,205,0,140,95,0,140,115,0,140,135,0,160,0,169,0,153,165,0,200,192,39,208,248,160,0,32,243,243,201,0,240,249,201,8,208,3,76,217,224,201,127,208,21,136,48,13,169,32,32,20,244,169,8,32,20,244,76,199,224,160,0,76,199,224,201,13,240,13,153,165,0,200,192,39,208,205,160,39,76,199,224,136,185,165,0,201,10,240,1,200,169,0,153,165,0,96,160,255,76,48,225,160,0,185,165,0,240,80,201,63,48,75,201,90,16,3,56,176,8,201,97,48,64,201,122,16,60,141,205,0,200,192,20,240,52,185,165,0,201,0,240,46,201,32,240,240,174,94,0,138,24,105,20,141,94,0,185,165,0,201,32,240,16,201,0,240,12,157,95,0,232,200,192,40,240,11,76,74,225,169,0,157,95,0,76,48,225,96,96,56,173,205,0,32,14,243,201,108,208,6,32,138,233,76,254,225,201,100,208,6,32,92,231,76,254,225,201,114,208,6,32,64,235,76,254,225,201,103,208,6,32,1,233,76,254,225,201,101,208,6,32,90,232,76,254,225,201,102,208,6,32,192,232,76,254,225,201,117,208,6,32,209,239,76,254,225,201,116,208,6,32,150,237,76,254,225,201,98,208,6,32,244,229,76,254,225,201,115,208,6,32,5,237,76,254,225,201,109,208,6,32,212,234,76,254,225,201,97,208,6,32,107,226,76,254,225,201,104,208,6,32,130,233,76,254,225,201,63,208,6,32,130,233,76,254,225,176,9,162,86,160,246,32,179,243,24,96,56,96,120,141,68,0,104,72,41,16,208,6,173,68,0,108,2,0,108,4,0,104,141,75,0,173,68,0,141,71,0,142,72,0,140,73,0,186,232,232,142,74,0,104,56,233,1,141,69,0,104,233,0,141,70,0,160,0,140,95,0,32,64,235,173,57,0,201,1,208,3,76,76,239,160,3,162,6,185,47,0,201,1,208,5,185,51,0,129,18,136,202,202,16,239,76,149,224,162,0,32,228,242,176,3,76,97,227,142,8,0,140,9,0,162,221,160,244,32,179,243,32,38,243,32,168,224,32,14,225,173,95,0,201,0,240,4,201,32,208,3,76,99,227,160,0,185,95,0,32,26,243,153,95,0,200,192,3,208,242,32,101,227,176,40,32,38,243,169,32,32,20,244,162,95,160,0,32,179,243,169,32,32,20,244,162,115,160,0,32,179,243,169,32,32,20,244,169,63,32,20,244,76,123,226,32,157,227,176,3,76,174,226,32,146,228,176,3,76,174,226,32,178,228,176,3,76,174,226,32,38,243,160,0,173,26,0,145,8,32,95,243,32,219,242,169,32,32,20,244,173,29,0,240,40,173,27,0,145,8,32,95,243,32,219,242,169,32,32,20,244,173,30,0,240,30,173,28,0,145,8,32,95,243,32,219,242,169,32,32,20,244,76,70,227,169,32,32,20,244,32,20,244,32,20,244,169,32,32,20,244,32,20,244,32,20,244,169,32,32,20,244,162,95,160,0,32,179,243,169,32,32,20,244,162,115,160,0,32,179,243,76,123,226,24,96,56,96,162,92,142,10,0,162,248,142,11,0,160,0,177,10,217,95,0,240,25,173,10,0,24,105,10,141,10,0,144,3,238,11,0,160,4,177,10,201,90,240,11,76,111,227,200,192,3,240,5,76,113,227,24,96,56,96,160,0,185,115,0,201,0,208,8,169,80,141,31,0,76,144,228,201,35,208,8,169,77,141,31,0,76,144,228,201,65,240,7,201,97,240,3,76,220,227,200,185,115,0,201,0,240,7,201,32,240,3,76,220,227,169,67,141,31,0,76,144,228,160,6,177,10,201,76,208,6,141,31,0,76,144,228,160,0,185,115,0,201,40,208,3,76,54,228,160,0,185,115,0,201,44,240,8,201,0,240,43,200,76,248,227,200,185,115,0,201,88,240,15,201,120,240,11,201,89,240,15,201,121,240,11,76,142,228,169,88,141,31,0,76,144,228,169,89,141,31,0,76,144,228,169,83,141,31,0,76,144,228,200,185,115,0,201,44,240,11,201,41,240,30,192,11,208,240,76,142,228,200,185,115,0,201,88,240,7,201,120,240,3,76,142,228,169,82,141,31,0,76,144,228,200,185,115,0,201,0,240,22,201,44,240,3,76,142,228,200,185,115,0,201,89,240,15,201,121,240,11,76,142,228,169,68,141,31,0,76,144,228,169,73,141,31,0,76,144,228,24,96,56,96,160,6,177,10,205,31,0,240,21,173,10,0,24,105,10,141,10,0,144,3,238,11,0,32,111,227,176,228,24,96,56,96,169,0,141,29,0,141,30,0,160,7,177,10,141,26,0,173,31,0,201,80,240,39,201,67,240,38,201,77,240,37,201,83,240,60,201,88,240,56,201,89,240,52,201,73,240,88,201,82,240,84,201,68,240,80,201,76,240,36,76,203,229,76,205,229,76,205,229,32,207,229,176,3,76,203,229,32,61,243,176,3,76,203,229,141,27,0,169,1,141,29,0,76,205,229,32,207,229,176,3,76,203,229,32,228,242,176,3,76,203,229,173,31,0,201,76,240,72,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,205,229,32,207,229,176,3,76,203,229,32,228,242,176,3,76,203,229,173,31,0,201,68,240,15,192,0,208,120,142,27,0,169,1,141,29,0,76,205,229,142,27,0,140,28,0,169,1,141,29,0,141,30,0,76,205,229,142,43,0,140,44,0,173,8,0,141,45,0,173,9,0,141,46,0,160,8,177,10,24,109,45,0,141,45,0,144,3,238,46,0,56,173,43,0,237,45,0,141,43,0,173,44,0,237,46,0,141,44,0,173,44,0,201,255,240,14,201,0,208,28,173,43,0,201,128,16,21,76,192,229,173,43,0,201,128,48,11,141,27,0,169,1,141,29,0,76,205,229,24,96,56,96,162,20,160,0,189,95,0,217,83,244,240,23,217,100,244,240,18,200,192,16,240,3,76,214,229,232,224,31,240,3,76,209,229,24,96,56,96,173,95,0,201,43,240,11,201,45,240,10,201,63,240,9,76,20,231,76,128,230,76,60,230,162,221,160,244,32,179,243,160,255,162,255,200,232,185,18,0,141,8,0,200,185,18,0,141,9,0,189,47,0,240,3,32,38,243,192,7,208,229,162,221,160,244,32,179,243,76,20,231,173,115,0,201,0,240,10,162,20,32,228,242,176,16,76,20,231,160,3,169,0,153,47,0,136,16,248,76,20,231,142,43,0,140,44,0,160,3,162,6,32,21,231,176,15,136,202,202,16,246,162,236,160,245,32,179,243,76,20,231,169,0,153,47,0,76,20,231,173,115,0,201,0,240,7,162,20,32,228,242,176,3,76,20,231,142,43,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,21,231,176,231,136,202,202,16,239,160,0,185,47,0,201,0,240,15,200,192,4,208,244,162,196,160,245,32,179,243,76,20,231,140,55,0,169,1,153,47,0,192,0,208,15,173,43,0,141,18,0,173,44,0,141,19,0,76,20,231,192,1,208,15,173,43,0,141,20,0,173,44,0,141,21,0,76,20,231,192,2,208,15,173,43,0,141,22,0,173,44,0,141,23,0,76,20,231,173,43,0,141,24,0,173,44,0,141,25,0,76,20,231,96,192,0,208,11,173,44,0,205,19,0,240,44,76,90,231,192,1,208,11,173,44,0,205,21,0,240,29,76,90,231,192,2,208,11,173,44,0,205,23,0,240,14,76,90,231,173,44,0,205,25,0,240,3,76,90,231,173,43,0,221,18,0,240,3,76,90,231,56,96,24,96,162,0,189,95,0,201,0,240,58,32,61,243,176,3,76,32,232,141,9,0,232,32,61,243,176,3,76,32,232,141,8,0,162,20,189,95,0,201,0,240,26,32,61,243,176,3,76,32,232,141,93,0,232,32,61,243,176,3,76,32,232,141,92,0,76,182,231,173,9,0,141,93,0,173,8,0,141,92,0,24,105,15,141,92,0,144,3,238,93,0,169,13,32,20,244,169,10,32,20,244,162,0,160,0,32,38,243,177,8,32,68,232,32,95,243,232,224,16,208,3,32,44,232,224,8,208,18,169,32,32,20,244,169,45,32,20,244,169,32,32,20,244,76,242,231,169,32,32,20,244,173,8,0,205,92,0,208,8,173,9,0,205,93,0,240,32,238,8,0,208,3,238,9,0,224,16,208,15,169,10,32,20,244,169,13,32,20,244,32,38,243,162,0,76,199,231,24,96,238,8,0,208,3,238,9,0,56,96,169,32,32,20,244,169,32,32,20,244,162,0,189,76,0,32,20,244,232,224,16,208,245,96,72,201,32,48,10,201,127,16,6,157,76,0,76,88,232,169,46,157,76,0,104,96,173,95,0,201,0,208,3,76,136,232,173,115,0,201,0,208,3,76,136,232,162,0,32,228,242,176,3,76,136,232,142,8,0,140,9,0,162,20,32,140,232,144,3,76,138,232,24,96,56,96,160,0,140,207,0,189,95,0,240,40,32,61,243,176,3,76,190,232,145,8,238,8,0,208,3,238,9,0,238,207,0,173,207,0,201,10,240,10,232,189,95,0,240,4,232,76,145,232,56,96,24,96,162,0,32,228,242,176,3,76,253,232,142,8,0,140,9,0,162,20,32,228,242,176,3,76,253,232,142,92,0,140,93,0,162,40,32,140,232,144,22,173,93,0,205,9,0,240,3,76,224,232,173,92,0,205,8,0,240,5,76,224,232,24,96,56,96,173,95,0,201,0,240,16,162,0,32,228,242,176,3,76,126,233,142,69,0,140,70,0,174,69,0,142,43,0,172,70,0,140,44,0,160,3,162,6,185,47,0,201,0,240,5,32,21,231,176,8,136,202,202,16,239,76,70,233,162,20,160,246,32,179,243,76,128,233,160,3,162,6,185,47,0,201,1,208,9,161,18,153,51,0,169,0,129,18,136,202,202,16,235,104,104,104,104,173,95,0,201,0,240,17,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,24,96,56,96,162,90,160,246,32,179,243,96,162,224,160,244,32,179,243,32,243,243,162,221,160,244,32,179,243,76,161,233,32,243,243,201,83,208,249,32,20,244,32,243,243,32,20,244,141,161,0,201,48,208,8,32,182,234,144,37,76,220,233,201,49,208,8,32,192,234,144,25,76,220,233,201,57,208,18,32,202,234,144,13,162,41,160,245,32,179,243,76,232,233,76,158,233,162,9,160,245,32,179,243,56,96,32,243,243,56,96,169,0,141,159,0,141,160,0,32,93,234,141,158,0,32,132,234,170,202,202,202,138,141,155,0,32,93,234,141,9,0,32,132,234,32,93,234,141,8,0,32,132,234,96,173,155,0,240,11,32,93,234,32,132,234,206,155,0,208,245,96,173,155,0,240,23,160,0,32,93,234,32,132,234,145,8,238,8,0,208,3,238,9,0,206,155,0,208,235,96,173,159,0,73,255,141,157,0,32,93,234,205,157,0,240,4,24,76,92,234,56,96,152,72,32,243,243,32,147,234,144,28,10,10,10,10,41,240,141,156,0,32,243,243,32,147,234,144,11,13,156,0,141,156,0,104,168,173,156,0,96,72,24,109,159,0,141,159,0,144,3,238,160,0,104,96,142,206,0,162,0,221,83,244,240,19,221,100,244,240,14,232,224,16,240,3,76,152,234,169,0,24,76,181,234,138,56,174,206,0,96,32,237,233,32,25,234,32,71,234,96,32,237,233,32,42,234,32,71,234,96,32,237,233,32,25,234,32,71,234,96,173,95,0,201,0,240,7,162,0,32,228,242,176,3,76,63,235,142,8,0,140,9,0,162,20,32,228,242,176,3,76,63,235,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,32,228,242,176,3,76,63,235,142,10,0,140,11,0,160,0,177,8,145,10,238,10,0,208,3,238,11,0,238,8,0,208,3,238,9,0,173,8,0,205,92,0,240,3,76,21,235,173,9,0,205,93,0,240,3,76,21,235,96,72,138,72,152,72,8,173,95,0,201,0,240,3,76,184,235,162,105,160,245,32,179,243,160,3,32,3,243,173,70,0,32,95,243,173,69,0,32,95,243,160,9,32,3,243,173,71,0,32,95,243,160,9,32,3,243,173,72,0,32,95,243,160,8,32,3,243,173,73,0,32,95,243,160,8,32,3,243,173,74,0,32,95,243,160,7,32,3,243,173,75,0,162,8,42,176,10,72,169,48,32,20,244,104,76,178,235,72,169,49,32,20,244,104,202,208,233,76,253,236,169,13,32,20,244,169,10,32,20,244,173,95,0,32,14,243,201,112,208,60,173,70,0,32,95,243,173,69,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,168,232,32,61,243,176,3,76,253,236,141,69,0,140,70,0,76,253,236,201,97,208,41,173,71,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,141,71,0,76,253,236,201,120,208,41,173,72,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,141,72,0,76,253,236,201,121,208,41,173,73,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,141,73,0,76,253,236,201,115,240,3,76,249,236,173,96,0,32,14,243,201,112,240,7,201,114,240,44,76,249,236,173,74,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,141,74,0,76,253,236,173,75,0,32,95,243,32,251,242,32,168,224,32,14,225,173,95,0,201,0,208,3,76,253,236,162,0,32,61,243,176,3,76,253,236,141,75,0,76,253,236,24,76,254,236,56,40,104,168,104,170,104,96,173,95,0,201,0,240,7,162,0,32,228,242,176,3,76,149,237,142,10,0,140,11,0,162,20,32,228,242,176,3,76,149,237,142,92,0,140,93,0,238,92,0,208,3,238,93,0,162,40,169,32,141,8,0,169,0,141,9,0,32,140,232,144,80,173,207,0,141,42,0,173,10,0,141,8,0,173,11,0,141,9,0,162,221,160,244,32,179,243,162,0,160,0,177,8,221,32,0,240,25,32,219,242,173,8,0,205,92,0,240,3,76,94,237,173,9,0,205,93,0,240,22,76,94,237,200,232,236,42,0,240,3,76,98,237,32,38,243,32,219,242,76,94,237,96,173,95,0,201,0,240,23,162,0,32,228,242,176,3,76,157,239,142,69,0,140,70,0,173,115,0,201,0,208,8,160,1,140,62,0,76,201,237,162,20,32,61,243,176,3,76,157,239,141,62,0,104,104,104,104,172,69,0,140,8,0,172,70,0,140,9,0,160,0,177,8,141,67,0,32,161,239,176,3,76,157,239,160,8,177,10,141,58,0,160,1,173,67,0,201,96,208,40,169,2,141,61,0,104,141,16,0,104,141,17,0,72,173,16,0,72,238,16,0,208,3,238,17,0,160,0,177,16,141,60,0,169,0,145,16,76,44,239,201,76,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,44,239,201,108,208,43,169,2,141,61,0,177,8,141,12,0,200,177,8,141,13,0,160,0,177,12,141,16,0,200,177,12,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,44,239,201,32,208,30,169,2,141,61,0,177,8,141,16,0,200,177,8,141,17,0,160,0,177,16,141,60,0,169,0,145,16,76,44,239,160,0,177,10,201,66,208,8,160,1,177,10,201,73,208,3,76,9,239,169,1,141,61,0,24,173,8,0,109,58,0,141,16,0,173,9,0,105,0,141,17,0,160,1,177,8,141,56,0,16,32,206,56,0,173,56,0,73,255,141,56,0,56,173,16,0,237,56,0,141,16,0,173,17,0,233,0,141,17,0,76,251,238,24,173,16,0,109,56,0,141,16,0,173,17,0,105,0,141,17,0,76,251,238,160,0,177,16,141,60,0,169,0,145,16,76,14,239,169,0,141,61,0,172,58,0,177,8,141,59,0,24,173,8,0,109,58,0,141,14,0,173,9,0,105,0,141,15,0,169,0,145,8,169,1,141,57,0,173,95,0,201,0,240,3,162,255,154,173,75,0,72,173,71,0,174,72,0,172,73,0,40,108,69,0,169,0,141,57,0,160,0,173,61,0,201,0,240,17,201,1,240,8,173,60,0,145,16,76,112,239,173,60,0,145,16,173,59,0,145,14,172,69,0,140,8,0,172,70,0,140,9,0,162,221,160,244,32,179,243,173,8,0,141,92,0,173,9,0,141,93,0,32,32,240,206,62,0,240,3,76,205,237,76,149,224,24,96,56,96,162,92,142,10,0,162,248,142,11,0,160,4,177,10,201,90,240,28,160,7,177,10,205,67,0,240,17,173,10,0,24,105,10,141,10,0,144,3,238,11,0,76,171,239,56,96,24,96,173,95,0,201,0,240,23,162,0,32,228,242,176,3,76,197,242,142,8,0,140,9,0,173,115,0,201,0,208,33,173,8,0,141,92,0,173,9,0,141,93,0,24,173,8,0,105,20,141,92,0,144,7,174,93,0,232,142,93,0,76,32,240,162,20,32,228,242,176,3,76,197,242,142,92,0,140,93,0,173,93,0,205,9,0,240,5,144,14,76,59,240,173,92,0,205,8,0,144,3,76,59,240,76,199,242,160,0,177,8,141,67,0,32,161,239,176,29,162,221,160,244,32,179,243,32,38,243,173,67,0,32,95,243,162,184,160,245,32,179,243,32,219,242,76,32,240,162,221,160,244,32,179,243,32,38,243,32,219,242,160,6,177,10,201,80,208,3,76,190,240,201,77,208,3,76,229,240,201,83,208,3,76,24,241,201,88,208,3,76,24,241,201,89,208,3,76,24,241,201,82,208,3,76,53,242,201,76,208,3,76,130,241,201,67,208,3,76,207,240,201,68,208,3,76,119,242,201,73,208,3,76,243,241,76,71,240,173,67,0,32,95,243,160,8,32,3,243,32,201,242,76,32,240,173,67,0,32,95,243,160,8,32,3,243,32,201,242,169,65,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,160,5,32,3,243,32,201,242,169,35,32,20,244,173,65,0,32,95,243,169,104,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,169,32,32,20,244,177,8,141,66,0,32,95,243,32,219,242,160,2,32,3,243,32,201,242,173,66,0,32,95,243,173,65,0,32,95,243,169,104,32,20,244,160,6,177,10,201,88,240,7,201,89,240,16,76,32,240,169,44,32,20,244,169,88,32,20,244,76,32,240,169,44,32,20,244,169,89,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,160,5,32,3,243,32,201,242,173,8,0,141,63,0,173,9,0,141,64,0,173,65,0,48,18,173,63,0,24,109,65,0,141,63,0,144,32,238,64,0,76,223,241,206,65,0,173,65,0,73,255,141,65,0,173,63,0,56,237,65,0,141,63,0,176,3,206,64,0,173,64,0,32,95,243,173,63,0,32,95,243,169,104,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,160,5,32,3,243,32,201,242,169,40,32,20,244,173,65,0,32,95,243,169,104,32,20,244,169,41,32,20,244,169,44,32,20,244,169,89,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,160,5,32,3,243,32,201,242,169,40,32,20,244,173,65,0,32,95,243,169,104,32,20,244,169,44,32,20,244,169,88,32,20,244,169,41,32,20,244,76,32,240,160,0,173,67,0,32,95,243,169,32,32,20,244,177,8,141,65,0,32,95,243,32,219,242,169,32,32,20,244,177,8,141,66,0,32,95,243,32,219,242,160,2,32,3,243,32,201,242,169,40,32,20,244,173,66,0,32,95,243,173,65,0,32,95,243,169,104,32,20,244,169,41,32,20,244,76,32,240,24,96,56,96,160,0,177,10,32,20,244,200,192,3,208,246,169,32,32,20,244,96,238,8,0,208,3,238,9,0,96,32,61,243,176,3,76,249,242,168,232,32,61,243,176,3,76,249,242,170,56,96,24,96,162,179,160,245,32,179,243,96,72,169,32,32,20,244,136,208,248,104,96,201,65,48,7,201,91,16,3,24,105,32,96,201,97,48,7,201,123,16,3,56,233,32,96,173,9,0,32,95,243,173,8,0,32,95,243,169,32,32,20,244,169,32,32,20,244,96,189,95,0,32,147,234,144,25,10,10,10,10,41,240,141,156,0,232,189,95,0,32,147,234,144,7,13,156,0,141,156,0,56,96,141,156,0,74,74,74,74,41,15,201,10,16,5,9,48,76,118,243,56,233,9,9,64,32,20,244,173,156,0,41,15,201,10,16,5,9,48,76,140,243,56,233,9,9,64,32,20,244,173,156,0,96,169,30,141,4,0,169,226,141,5,0,169,0,141,57,0,169,0,141,47,0,141,48,0,141,49,0,141,50,0,169,0,96,72,142,6,0,140,7,0,160,0,177,6,240,14,32,20,244,238,6,0,208,3,238,7,0,76,188,243,104,96,8,138,72,152,72,173,1,160,41,8,240,9,173,0,160,141,206,0,76,234,243,169,0,141,206,0,104,168,104,170,40,173,206,0,96,8,138,72,152,72,173,1,160,41,8,208,6,173,2,160,76,248,243,173,0,160,141,206,0,104,168,104,170,40,173,206,0,96,141,206,0,8,152,72,138,72,173,1,160,41,16,240,249,173,206,0,141,0,160,104,170,104,168,40,173,206,0,96,72,138,72,152,72,169,0,141,162,0,169,16,141,163,0,206,162,0,208,251,206,163,0,208,246,104,168,104,170,104,96,22,11,48,49,50,51,52,53,54,55,56,57,65,66,67,68,69,70,0,48,49,50,51,52,53,54,55,56,57,97,98,99,100,101,102,0,10,13,69,109,117,108,97,116,111,114,32,118,32,32,32,32,32,32,32,32,10,13,0,85,77,79,78,54,53,32,118,49,46,50,50,32,45,32,85,110,100,101,114,115,116,97,110,100,97,98,108,101,32,77,111,110,105,116,111,114,32,102,111,114,32,116,104,101,32,54,53,48,48,32,115,101,114,105,101,115,32,109,105,99,114,111,112,114,111,99,101,115,115,111,114,115,46,10,13,0,10,13,45,0,10,13,0,10,13,83,101,110,100,32,83,32,114,101,99,111,114,100,115,32,119,104,101,110,32,121,111,117,32,97,114,101,32,114,101,97,100,121,46,46,46,10,13,0,10,13,7,69,114,114,111,114,32,76,111,97,100,105,110,103,32,83,32,82,101,99,111,114,100,115,46,46,46,10,13,0,10,13,7,83,32,114,101,99,111,114,100,115,32,115,117,99,99,101,115,115,102,117,108,108,121,32,108,111,97,100,101,100,32,40,112,114,101,115,115,32,60,101,110,116,101,114,62,32,116,111,32,99,111,110,116,105,110,117,101,41,46,10,13,0,10,13,10,80,103,109,67,110,116,114,40,80,67,41,32,32,65,99,99,117,109,40,65,67,41,32,32,88,82,101,103,40,88,82,41,32,32,89,82,101,103,40,89,82,41,32,32,83,116,107,80,116,114,40,83,80,41,32,32,78,86,45,66,68,73,90,67,40,83,82,41,10,13,0,10,13,32,58,0,32,32,32,32,32,32,32,32,63,63,63,0,10,13,65,108,108,32,98,114,101,97,107,112,111,105,110,116,115,32,97,114,101,32,99,117,114,114,101,110,116,108,121,32,105,110,32,117,115,101,46,0,10,13,78,111,32,98,114,101,97,107,112,111,105,110,116,32,101,120,105,115,116,115,32,97,116,32,116,104,105,115,32,97,100,100,114,101,115,115,46,0,10,13,89,111,117,32,99,97,110,110,111,116,32,71,79,32,97,116,32,97,32,98,114,101,97,107,112,111,105,110,116,101,100,32,97,100,100,114,101,115,115,44,32,84,82,65,67,69,32,112,97,115,116,32,105,116,32,116,104,101,110,32,71,79,46,0,10,13,63,0,10,13,10,65,115,115,101,109,98,108,101,32,32,32,32,32,32,32,65,32,115,116,97,114,116,95,97,100,100,114,101,115,115,10,13,66,114,101,97,107,112,111,105,110,116,32,32,32,32,32,66,32,40,43,44,45,44,63,41,32,97,100,100,114,101,115,115,10,13,68,117,109,112,32,32,32,32,32,32,32,32,32,32,32,68,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,69,110,116,101,114,32,32,32,32,32,32,32,32,32,32,69,32,97,100,100,114,101,115,115,32,108,105,115,116,10,13,70,105,108,108,32,32,32,32,32,32,32,32,32,32,32,70,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,71,111,32,32,32,32,32,32,32,32,32,32,32,32,32,71,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,93,10,13,72,101,108,112,32,32,32,32,32,32,32,32,32,32,32,72,32,111,114,32,63,10,13,76,111,97,100,32,32,32,32,32,32,32,32,32,32,32,76,10,13,77,111,118,101,32,32,32,32,32,32,32,32,32,32,32,77,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,100,101,115,116,105,110,97,116,105,111,110,95,97,100,100,114,101,115,115,10,13,82,101,103,105,115,116,101,114,32,32,32,32,32,32,32,82,32,91,80,67,44,65,67,44,88,82,44,89,82,44,83,80,44,83,82,93,10,13,83,101,97,114,99,104,32,32,32,32,32,32,32,32,32,83,32,115,116,97,114,116,95,97,100,100,114,101,115,115,32,101,110,100,95,97,100,100,114,101,115,115,32,108,105,115,116,10,13,84,114,97,99,101,32,32,32,32,32,32,32,32,32,32,84,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,118,97,108,117,101,93,93,10,13,85,110,97,115,115,101,109,98,108,101,32,32,32,32,32,85,32,91,115,116,97,114,116,95,97,100,100,114,101,115,115,32,91,101,110,100,95,97,100,100,114,101,115,115,93,93,10,13,0,65,68,67,32,73,77,77,105,2,2,65,68,67,32,65,66,83,109,3,4,65,68,67,32,65,66,88,125,3,4,65,68,67,32,65,66,89,121,3,4,65,68,67,32,73,73,82,97,2,6,65,68,67,32,73,82,73,113,2,5,65,78,68,32,73,77,77,41,2,2,65,78,68,32,65,66,83,45,3,4,65,78,68,32,65,66,88,61,3,4,65,78,68,32,65,66,89,57,3,4,65,78,68,32,73,73,82,33,2,6,65,78,68,32,73,82,73,49,2,5,65,83,76,32,65,67,67,10,1,2,65,83,76,32,65,66,83,14,3,6,65,83,76,32,65,66,88,30,3,7,66,67,67,32,82,69,76,144,2,2,66,67,83,32,82,69,76,176,2,2,66,69,81,32,82,69,76,240,2,2,66,73,84,32,65,66,83,44,3,4,66,77,73,32,82,69,76,48,2,2,66,78,69,32,82,69,76,208,2,2,66,80,76,32,82,69,76,16,2,2,66,82,75,32,73,77,80,0,1,7,66,86,67,32,82,69,76,80,2,2,66,86,83,32,82,69,76,112,2,2,67,76,67,32,73,77,80,24,1,2,67,76,68,32,73,77,80,216,1,2,67,76,73,32,73,77,80,88,1,2,67,76,86,32,73,77,80,184,1,2,67,77,80,32,73,77,77,201,2,2,67,77,80,32,65,66,83,205,3,4,67,77,80,32,65,66,88,221,3,4,67,77,80,32,65,66,89,217,3,4,67,77,80,32,73,73,82,193,2,6,67,77,80,32,73,82,73,209,2,5,67,80,88,32,73,77,77,224,2,2,67,80,88,32,65,66,83,236,3,4,67,80,89,32,73,77,77,192,2,2,67,80,89,32,65,66,83,204,3,4,68,69,67,32,65,66,83,206,3,6,68,69,67,32,65,66,88,222,3,7,68,69,88,32,73,77,80,202,1,2,68,69,89,32,73,77,80,136,1,2,69,79,82,32,73,77,77,73,2,2,69,79,82,32,65,66,83,77,3,4,69,79,82,32,65,66,88,93,3,4,69,79,82,32,65,66,89,89,3,4,69,79,82,32,73,73,82,65,2,6,69,79,82,32,73,82,73,81,2,5,73,78,67,32,65,66,83,238,3,6,73,78,67,32,65,66,88,254,3,7,73,78,88,32,73,77,80,232,1,2,73,78,89,32,73,77,80,200,1,2,74,77,80,32,65,66,83,76,3,3,74,77,80,32,73,78,68,108,3,5,74,83,82,32,65,66,83,32,3,6,76,68,65,32,73,77,77,169,2,2,76,68,65,32,65,66,83,173,3,4,76,68,65,32,65,66,88,189,3,4,76,68,65,32,65,66,89,185,3,4,76,68,65,32,73,73,82,161,2,6,76,68,65,32,73,82,73,177,2,5,76,68,88,32,73,77,77,162,2,2,76,68,88,32,65,66,83,174,3,4,76,68,88,32,65,66,89,190,3,4,76,68,89,32,73,77,77,160,2,2,76,68,89,32,65,66,83,172,3,4,76,68,89,32,65,66,88,188,3,4,76,83,82,32,65,67,67,74,1,2,76,83,82,32,65,66,83,78,3,6,76,83,82,32,65,66,88,94,3,7,78,79,80,32,73,77,80,234,1,2,79,82,65,32,73,77,77,9,2,2,79,82,65,32,65,66,83,13,3,4,79,82,65,32,65,66,88,29,3,4,79,82,65,32,65,66,89,25,3,4,79,82,65,32,73,73,82,1,2,6,79,82,65,32,73,82,73,17,2,5,80,72,65,32,73,77,80,72,1,3,80,72,80,32,73,77,80,8,1,3,80,76,65,32,73,77,80,104,1,4,80,76,80,32,73,77,80,40,1,4,82,79,76,32,65,67,67,42,1,2,82,79,76,32,65,66,83,46,3,6,82,79,76,32,65,66,88,62,3,7,82,79,82,32,65,67,67,106,1,2,82,79,82,32,65,66,83,110,3,6,82,79,82,32,65,66,88,126,3,7,82,84,73,32,73,77,80,64,1,6,82,84,83,32,73,77,80,96,1,6,83,66,67,32,73,77,77,233,2,2,83,66,67,32,65,66,83,237,3,4,83,66,67,32,65,66,88,253,3,4,83,66,67,32,65,66,89,249,3,4,83,66,67,32,73,73,82,225,2,6,83,66,67,32,73,82,73,241,2,5,83,69,67,32,73,77,80,56,1,2,83,69,68,32,73,77,80,248,1,2,83,69,73,32,73,77,80,120,1,2,83,84,65,32,65,66,83,141,3,4,83,84,65,32,65,66,88,157,3,5,83,84,65,32,65,66,89,153,3,5,83,84,65,32,73,73,82,129,2,6,83,84,65,32,73,82,73,145,2,6,83,84,88,32,65,66,83,142,3,4,83,84,89,32,65,66,83,140,3,4,84,65,88,32,73,77,80,170,1,2,84,65,89,32,73,77,80,168,1,2,84,83,88,32,73,77,80,186,1,2,84,88,65,32,73,77,80,138,1,2,84,88,83,32,73,77,80,154,1,2,84,89,65,32,73,77,80,152,1,2,90,90,90,32,90,90,90,0,0,0,74,48,46,48,49,32,32,32,0,224,11,226};
            bytes = 7378
.         %/output

      
      *** List File ***
      
                      000001 |;****************************************************************************
                      000002 |;  UMON65 Understandable Monitor for the 6500 series microprocessors.
                      000003 |;  Copyright 2015 by Ted Kosan.
                      000004 |;
                      000005 |;
                      000006 |;****************************************************************************
                      000007 |
                      000008 |
                      000009 |;****************************************************************************
                      000010 |;                                Equates Area.
                      000011 |;****************************************************************************   
                      000012 |
                      000013 |
                      000014 |;
                      000015 |;6551 ACIA Register Equates. A200 old ACIA address, B200 new ACIA address.  
                      000016 |;
                      000017 |;Transmitt Receive Register.
      0000            000018 |6551TRR:	equ A000h ;400ah
                      000019 |
                      000020 |
                      000021 |;Status Register.  
                      000022 |;		    Status			          cleared by
                      000023 |;	b0	Parity error * (1: error)       self clearing **
                      000024 |;	b1	Framing error * (1: error)      self clearing **
                      000025 |;	b2	Overrun * (1: error)            self clearing **
                      000026 |;	b3	Receive Data Register Full (1: full)  Read Receive Data Register
                      000027 |;	b4	Transmit Data Reg Empty (1: empty) Write Transmit Data Register
                      000028 |;	b5	DCD (0: DCD low, 1: DCD high) Not resettable, reflects DCD state
                      000029 |;	b6	DSR (0: DSR low, 1: DCD high) Not resettable, reflects DSR state
                      000030 |;	b7	IRQ (0: no int., 1: interrupt)  Read Status Register
                      000031 |;                                                                                                            
                      000032 |;	note: * no interrupt generated for these conditions
                      000033 |;	      ** cleared automatically after a read of RDR and the next 
                      000034 |;		error free receipt of data
      0000            000035 |6551StR:	equ A001h ;400bh 
                      000036 |
      0000            000037 |6551Sleep: equ A002h	; When an lda to this address is performed the emulator
                      000038 |			;can be put to sleep.
                      000039 |
                      000040 |
                      000041 |;Comand Register  
                      000042 |;	b0	Data Terminal Ready
                      000043 |;			0 : disable receiver and all interrupts (DTR high)
                      000044 |;			1 : enable receiver and all interrupts (DTR low)
                      000045 |;	b1	Receiver Interrupt Enable
                      000046 |;			0 : IRQ interrupt enabled from bit 3 of status register
                      000047 |;			1 : IRQ interrupt disabled
                      000048 |;	b3,b2	Transmitter Control
                      000049 |;				Transmit Interrupt    RTS level    Transmitter
                      000050 |;			00	   disabled		high		off
                      000051 |;			01	   enabled		low		on
                      000052 |;			10	   disabled		low		on
                      000053 |;			11	   disabled		low	   Transmit BRK
                      000054 |;	b4	Normal/Echo Mode for Receiver
                      000055 |;			0 : normal
                      000056 |;			1 : echo (bits 2 and 3 must be 0)
                      000057 |;	b5	Parity Enable
                      000058 |;			0 : parity disabled, no parity bit generated or received
                      000059 |;			1 : parity enabled
                      000060 |;	b7,b6	Parity
                      000061 |;			00 : odd parity receiver and transmitter
                      000062 |;			01 : even parity receiver and transmitter
                      000063 |;			10 : mark parity bit transmitted, parity check disabled
                      000064 |;			11 : space parity bit transmitted, parity check disabled
                      000065 |
                      000066 |
                      000067 |;6551CmR	equ 0b202h  
                      000068 |
                      000069 |;Control Register
                      000070 |;
                      000071 |;	b3-b0	baud rate generator:
                      000072 |;			0000 : 16x external clock
                      000073 |;			0001 : 50 baud
                      000074 |;			0010 : 75
                      000075 |;			0011 : 110
                      000076 |;			0100 : 134.5
                      000077 |;			0101 : 150
                      000078 |;			0110 : 300
                      000079 |;			0111 : 600
                      000080 |;			1000 : 1200
                      000081 |;			1001 : 1800
                      000082 |;			1010 : 2400
                      000083 |;			1011 : 3600
                      000084 |;			1100 : 4800
                      000085 |;			1101 : 7200
                      000086 |;			1110 : 9600
                      000087 |;			1111 : 19,200
                      000088 |;	b4	receiver clock source
                      000089 |;			0 : external receiver clock
                      000090 |;			1 : baud rate generator
                      000091 |;	b6,b5	word length                                                                  
                      000092 |;			00 : 8 bits
                      000093 |;			01 : 7
                      000094 |;			10 : 6
                      000095 |;			11 : 5
                      000096 |;	b7	stop bits
                      000097 |;			0 : 1 stop bit
                      000098 |;			1 : 2 stop bits
                      000099 |;			    (1 stop bit if parity and word length = 8)
                      000100 |;			    (1 1/2 stop bits if word length = 5 and no parity)
                      000101 |;6551CtR	equ 0b203h  
                      000102 |
                      000103 |
                      000104 |
                      000105 |
                      000106 |;InPort0 Equate.
      0000            000107 |InPort0:	equ 0a000h
                      000108 |
                      000109 |;OutPort0 Equate.
      0000            000110 |OutPort0:	equ 0a100h
                      000111 |
                      000112 |;****************************************************************************
                      000113 |;                       General Purpose Pointer Area.
                      000114 |;****************************************************************************
      0000            000115 |	org 0000h
                      000116 |	
      0000 00 00      000117 |GenPoint:	dwd ?
      0002 00 00      000118 |IRQVect:	dwd ?		;
      0004 00 00      000119 |BRKVect:	dwd ?		;Break command indirect vector.
      0006 00 00      000120 |MessPtr:	dwd ?		;
      0008 00 00      000121 |PointerA:	dwd ?		;
      000A 00 00      000122 |PointerB:	dwd ?		;
      000C 00 00      000123 |PointerC:	dwd ?		;
      000E 00 00      000124 |NOpAdPtr:	dwd ?		;
      0010 00 00      000125 |BOpAdPtr:	dwd ?		;
      0012 00 00      000126 |BrkPt1Ad:	dwd ?		;
      0014 00 00      000127 |BrkPt2Ad:	dwd ?		;
      0016 00 00      000128 |BrkPt3Ad:	dwd ?		;                                                                                       
      0018 00 00      000129 |BrkPt4Ad:	dwd ?		;
                      000130 |
                      000131 |
                      000132 |	
                      000133 |;****************************************************************************
                      000134 |;                   General Purpose Variable Storage Area.
                      000135 |;****************************************************************************
                      000136 |;	org 0200h 
                      000137 |
                      000138 |		  
      001A 00         000139 |Obj1:		dbt ?
      001B 00         000140 |Obj2:		dbt ?
      001C 00         000141 |Obj3:		dbt ?
      001D 00         000142 |Obj2Flg:	dbt ?
      001E 00         000143 |Obj3Flg:	dbt ?
      001F 00         000144 |AddMode:	dbt ?
      0020 00         000145 |SrchTabl:	dbt 10d(?)
      0021 00 00 00         
      0024 00 00 00         
      0027 00 00 00         
      002A 00         000146 |SrchBtCt:	dbt ?
      002B 00 00      000147 |TempAdd:	dwd ?
      002D 00 00      000148 |TempAdd2:	dwd ?
      002F 00         000149 |BrkPt1St:	dbt ?
      0030 00         000150 |BrkPt2St:	dbt ?
      0031 00         000151 |BrkPt3St:	dbt ?
      0032 00         000152 |BrkPt4St:	dbt ?
      0033 00         000153 |BP1OpHld:	dbt ?
      0034 00         000154 |BP2OpHld:	dbt ?
      0035 00         000155 |BP3OpHld:	dbt ?
      0036 00         000156 |BP4OpHld:	dbt ?
      0037 00         000157 |BPNumHld:	dbt ?
      0038 00         000158 |BrValHld:	dbt ?
      0039 00         000159 |TrBrkFlg:	dbt ?
      003A 00         000160 |CurInsLn:	dbt ?
      003B 00         000161 |NOpCdHld:	dbt ?
      003C 00         000162 |BOpCdHld:	dbt ?
      003D 00         000163 |BrnchFlg:	dbt ?
      003E 00         000164 |TracCnt:	dbt ?
      003F 00 00      000165 |AddHold:	dwd ?
      0041 00         000166 |ObCdHld1:	dbt ?
      0042 00         000167 |ObCdHld2:	dbt ?
      0043 00         000168 |OpCdHold:	dbt ?
      0044 00         000169 |TempA:		dbt ?
      0045 00 00      000170 |UPgmCntr:	dwd ?
      0047 00         000171 |UAccum:		dbt ?
      0048 00         000172 |UXReg:		dbt ?
      0049 00         000173 |UYReg:		dbt ?
      004A 00         000174 |UStkPtr:	dbt ?
      004B 00         000175 |UStatReg:	dbt ?
      004C 00         000176 |ASCIIbuf:	dbt 16d(?)
      004D 00 00 00         
      0050 00 00 00         
      0053 00 00 00         
      0056 00 00 00         
      0059 00 00 00         
      005C 00 00      000177 |EndAdd:		dwd ?
      005E 00         000178 |OpOffSet:	dbt ?
      005F 00         000179 |OpFld1:		dbt 20d(?)
      0060 00 00 00         
      0063 00 00 00         
      0066 00 00 00         
      0069 00 00 00         
      006C 00 00 00         
      006F 00 00 00         
      0072 00               
      0073 00         000180 |OpFld2:		dbt 20d(?)
      0074 00 00 00         
      0077 00 00 00         
      007A 00 00 00         
      007D 00 00 00         
      0080 00 00 00         
      0083 00 00 00         
      0086 00               
      0087 00         000181 |OpFld3:		dbt 20d(?)	
      0088 00 00 00         
      008B 00 00 00         
      008E 00 00 00         
      0091 00 00 00         
      0094 00 00 00         
      0097 00 00 00         
      009A 00               
      009B 00         000182 |CodeCntr:	dbt ?
      009C 00         000183 |Number:		dbt ?
      009D 00         000184 |ChkSum:		dbt ?
      009E 00         000185 |RecLen:		dbt ?
      009F 00 00      000186 |CkSumAc:	dwd ?
      00A1 00         000187 |RecType: 	dbt ?
      00A2 00         000188 |wait0:		dbt ?
      00A3 00         000189 |wait1:		dbt ?
      00A4 00         000190 |			dbt ?
      00A5 00         000191 |InptBufr:	dbt 40d(?)
      00A6 00 00 00         
      00A9 00 00 00         
      00AC 00 00 00         
      00AF 00 00 00         
      00B2 00 00 00         
      00B5 00 00 00         
      00B8 00 00 00         
      00BB 00 00 00         
      00BE 00 00 00         
      00C1 00 00 00         
      00C4 00 00 00         
      00C7 00 00 00         
      00CA 00 00 00         
      00CD 00         000192 |Command:	dbt ?
      00CE 00         000193 |RegTemp:	dbt ?
      00CF 00         000194 |DataTemp:	dbt ?
                      000195 |
                      000196 |;****************************************************************************
                      000197 |;                        Monitor Eprom Entry Point.
                      000198 |;****************************************************************************
      E000            000199 |	org 0e000h Note
                      000200 |	;org 1000h
      E000 4C 1B E0   000201 |	jmp Start
                      000202 |
                      000203 |;****************************************************************************
                      000204 |;                  Monitor Utility Subroutine Jump Table.
                      000205 |;****************************************************************************
      E003 4C 14 F4   000206 |	jmp OutChar	;Output byte in A register to serial port.
                      000207 |	
      E006 4C D0 F3   000208 |	jmp GetChar	;Get a byte from the serial port.
                      000209 |	
      E009 4C F3 F3   000210 |	jmp GetCharW	;Wait and get a byte from the serial port.
                      000211 |	
      E00C 4C B3 F3   000212 |	jmp PrntMess	;Print a message to the serial port.
                      000213 |	
      E00F 4C 03 F3   000214 |	jmp OutSpace	;Output spaces to the serial port.
                      000215 |	
      E012 4C 5F F3   000216 |	jmp OutHex	;Output a HEX number to the serial port.
                      000217 |	
      E015 4C 93 EA   000218 |	jmp DgtToBin	;Convert an ASCII digit into binary.
                      000219 |	
      E018 4C A8 E0   000220 |	jmp GetLine	;Input a line from the serial port.
                      000221 |	
                      000222 |
                      000223 |; Beginning of UMON65.
                      000224 |;****************************************************************************
                      000225 |;                       Start of UMON65 Main Routine.
                      000226 |;
                      000227 |;
                      000228 |;****************************************************************************
      E01B            000229 |start:
      E01B 78         000230 |	sei
      E01C A2 FF      000231 |	ldx #0ffh	;Initialize stack pointer and
      E01E 9A         000232 |	txs		; clear decimal mode.
                      000233 |;	cli		;
      E01F D8         000234 |	cld		;
                      000235 |	
      E020 20 93 F3   000236 |	jsr InitVars	;Initialize variables.
                      000237 |	
      E023 A9 04      000238 |    lda #00000100b	 ;Initialize user's status register.
      E025 8D 4B 00   000239 |	sta UStatReg	;
                      000240 |
      E028 A9 00      000241 |	lda #0d	    ;Initialize user's accumulator.
      E02A 8D 47 00   000242 |	sta UAccum	;
                      000243 |	
      E02D 8D 48 00   000244 |	sta UXReg	;Initialize user's X register.
                      000245 |	
      E030 8D 49 00   000246 |	sta UYReg	;Initialize user's Y register.
                      000247 |	
      E033 A9 FF      000248 |	lda #0ffh    ;Initialize user's stack pointer
      E035 8D 4A 00   000249 |	sta UStkPtr	 ;.
                      000250 |	
      E038 AD 00 AA   000251 |	lda 0aa00h		; If ESC has been pressed, enter the monitor.
      E03B C9 00      000252 |	cmp #0d			;
      E03D F0 08      000253 |	beq EnterMon	;
                      000254 |	
      E03F AD 00 C0   000255 |	lda 0c000h		; If the byte at 0c000h is not zero, there is a program
      E042 F0 03      000256 |	beq EnterMon    ; in the EEPROM that has been copied to 0200h by the emulator.
      E044 4C 00 02   000257 |	jmp 0200h		; Run this program.
                      000258 |
                      000259 |;	jmp EnterMon	;Enter the monitor. (Fix, until boards are updated).
                      000260 |		
                      000261 |;****************************************************************************
                      000262 |;                     Check Computer's Configuration.
                      000263 |;****************************************************************************
      E047            000264 |CkConfig:
                      000265 |	;lda InPort0	;Get the switch settings and mask out the 
                      000266 |	;and #00001111b	; switch's high nibble.
                      000267 |
                      000268 |;CkMon:
                      000269 |	
                      000270 |	;cmp #1d	;If the switch is set to a 1 then print the
                      000271 |	;bne CkEEPROM		; UMON65 monitor startup messages and enter the
      E047            000272 |EnterMon:				; monitor through the maskable interrupt vector.
      E047 A2 00      000273 |	ldx #0d
      E049            000274 |CopyVersion:
      E049 BD C6 FC   000275 |	lda EmuVersionFrom,x
      E04C 9D 81 F4   000276 |	sta EmuVersionTo,x
      E04F E8         000277 |	inx
      E050 E0 08      000278 |	cpx #8d
      E052 D0 F5      000279 |	bne CopyVersion
      E054 A2 75      000280 |	ldx #EmulatorMess<  ;
      E056 A0 F4      000281 |	ldy #EmulatorMess>  ;
      E058 20 B3 F3   000282 |	jsr PrntMess        ;
                      000283 |	                    ;
      E05B A2 8C      000284 |	ldx #OpenMess<		; 
      E05D A0 F4      000285 |	ldy #OpenMess>		;
      E05F 20 B3 F3   000286 |	jsr PrntMess		;
                      000287 |	;brk		    	;
                      000288 |   
      E062 4C 41 E2   000289 |    jmp ResetEntryPoint
                      000290 |
      E065            000291 |CkEEPROM:
      E065 C9 02      000292 |	cmp #2d		;If the switch is set to a 2 then get the
      E067 D0 13      000293 |	bne DoLgtSho	; switch's high nibble and jump to a program
                      000294 |	;lda InPort0	; present in the EEPROM which is indicated by
      E069 29 F0      000295 |	and #11110000b	; the high nibble's value.  The program can be
      E06B 4A         000296 |	lsr a		; located at 1 of the following 16 locations:
      E06C 4A         000297 |	lsr a		; 0-C000, 1-C200, 2-C400, 3-C600, 4-C800,
      E06D 4A         000298 |	lsr a		; 5-CA00, 6-CC00, 7-CE00, 8-D000, 9-D200,
      E06E 18         000299 |	clc
      E06F 69 C0      000300 |	adc #0c0h	; 10-D400, 11-D600, 12-D800, 13-DA00, 14-DC00,
      E071 8D 09 00   000301 |	sta PointerA+1d	; 15-DE00.
      E074 A9 00      000302 |	lda #0d		;
      E076 8D 08 00   000303 |	sta PointerA	;
      E079 6C 08 00   000304 |	jmp (PointerA)	;
                      000305 |			
      E07C            000306 |DoLgtSho:
      E07C 4C 7F E0   000307 |	jmp LghtShow
                      000308 |	
                      000309 |;****************************************************************************
                      000310 |;                            Light Show Subroutine.
                      000311 |;****************************************************************************
      E07F            000312 |LghtShow:
      E07F A0 00      000313 |	ldy #0h		;Make the Y register count from 0 to 255 and
      E081 8C 44 00   000314 |	sty TempA	; output each number in the count to the
                      000315 |	;sty OutPort0	; light register.
      E084            000316 |LSOtLoop:		;
      E084 A2 64      000317 |	ldx #100d	;
      E086            000318 |LSInLoop:		;
      E086 C8         000319 |	iny		;
      E087 D0 FD      000320 |	bne LSInLoop	;
      E089 CA         000321 |	dex		;
      E08A D0 FA      000322 |	bne LSInLoop	;
      E08C EE 44 00   000323 |	inc TempA	;
      E08F AD 44 00   000324 |	lda TempA	;
                      000325 |	;sta OutPort0	;
      E092 4C 84 E0   000326 |	jmp LSOtLoop	;
                      000327 |
                      000328 |;****************************************************************************
                      000329 |;                            Monitor's Main Loop.
                      000330 |;****************************************************************************
      E095            000331 |MainLoop:	
                      000332 |
      E095 20 A1 E0   000333 |	jsr GetLineP	;Get a typed line from the serial port.
                      000334 |
      E098 20 13 E1   000335 |	jsr ParsLine	;Break line into fields.
                      000336 |	
      E09B 20 6B E1   000337 |	jsr CkValCmd	;Check to see if a valid monitor command was
                      000338 |			; entered and if so execute that command's code.
      E09E 4C 95 E0   000339 |	jmp MainLoop
                      000340 |
                      000341 |	
                      000342 |;****************************************************************************
                      000343 |;                    Get Line From Serial Port Subroutine.
                      000344 |;****************************************************************************
      E0A1            000345 |GetLineP:
      E0A1 A2 D9      000346 |	ldx #Prompt<	;Print Prompt.
      E0A3 A0 F4      000347 |	ldy #Prompt>	;
      E0A5 20 B3 F3   000348 |	jsr PrntMess	;
                      000349 |
      E0A8            000350 |GetLine:	
      E0A8 A0 00      000351 |	ldy #0d		;Initialize Y index register.
      E0AA 8C 5E 00   000352 |	sty OpOffSet	;Initialize opcode holder offset pointer.
      E0AD 8C CD 00   000353 |	sty command	;Initialize command holder.
      E0B0 8C 5F 00   000354 |	sty OpFld1	;Initialize operand field 1 buffer.
      E0B3 8C 73 00   000355 |	sty OpFld2	;Initialize operand field 2 buffer.
      E0B6 8C 87 00   000356 |	sty OpFld3	;Initialize operand field 3 buffer.
                      000357 |	
      E0B9 A0 00      000358 |	ldy #0d		;Clear input buffer.
      E0BB A9 00      000359 |	lda #0d		;
      E0BD            000360 |ClrInpBf:		;
      E0BD 99 A5 00   000361 |	sta InptBufr,y	;
      E0C0 C8         000362 |	iny		;
      E0C1 C0 27      000363 |	cpy #39d	;
      E0C3 D0 F8      000364 |	bne ClrInpBf	;
                      000365 |	
      E0C5 A0 00      000366 |	ldy #0h		;Use Y register as buffer pointer.
                      000367 |	
      E0C7            000368 |GtAnChar:
      E0C7 20 F3 F3   000369 |	jsr GetCharW
                      000370 |;	jsr OutChar	;Echo character.  ;Note: remove for muvium.
                      000371 |
      E0CA C9 00      000372 |	cmp #0h		;If no character is entered then try again.
      E0CC F0 F9      000373 |	beq GtAnChar	;
                      000374 |	
      E0CE C9 08      000375 |	cmp #8d		;Check to see if the user entered a Delete or
      E0D0 D0 03      000376 |	bne CkDel	; a Backspace.  If so then erase the character
      E0D2 4C D9 E0   000377 |	jmp DoDelete	; to the left of the cursor.
      E0D5            000378 |CkDel:			;
      E0D5 C9 7F      000379 |	cmp #127d	;
      E0D7 D0 15      000380 |	bne GtCkChar	;
      E0D9            000381 |DoDelete:		;
      E0D9 88         000382 |	dey		;
      E0DA 30 0D      000383 |	bmi AtStart	;
      E0DC A9 20      000384 |	lda #32d	;
      E0DE 20 14 F4   000385 |	jsr OutChar	;
      E0E1 A9 08      000386 |	lda #8d		;
      E0E3 20 14 F4   000387 |	jsr OutChar	;
      E0E6 4C C7 E0   000388 |	jmp GtAnChar	;
                      000389 |
      E0E9            000390 |AtStart:
      E0E9 A0 00      000391 |	ldy #0d
      E0EB 4C C7 E0   000392 |	jmp GtAnChar
                      000393 |	
      E0EE            000394 |GtCkChar:
      E0EE C9 0D      000395 |	cmp #13d	;If a CR was entered then accept line and exit,
      E0F0 F0 0D      000396 |	beq GtLnDone	; if not then accept the next character and
      E0F2 99 A5 00   000397 |	sta InptBufr,y	; place it into the input buffer.
      E0F5 C8         000398 |	iny		;
                      000399 |	
      E0F6 C0 27      000400 |	cpy #39d	;Do not let buffer expand past 40 characters.
      E0F8 D0 CD      000401 |	bne GtAnChar
      E0FA A0 27      000402 |	ldy #39d	;Set buffer at 40 characters if over 40 characters.
                      000403 |
      E0FC 4C C7 E0   000404 |	jmp GtAnChar	;
                      000405 |	
      E0FF            000406 |GtLnDone:
                      000407 |	;If a NL is in the input buffer then remove it.
      E0FF 88         000408 |	dey
      E100 B9 A5 00   000409 |	lda InptBufr,y
      E103 C9 0A      000410 |	cmp #10d
      E105 F0 01      000411 |	beq PutNull
      E107 C8         000412 |	iny
      E108            000413 |PutNull:
      E108 A9 00      000414 |	lda #0h		;Put a NULL at end of the input buffer.
      E10A 99 A5 00   000415 |	sta InptBufr,y	;
                      000416 |		
      E10D 60         000417 |	rts
                      000418 |	
                      000419 |;****************************************************************************
                      000420 |;                       Parse Input Buffer Subroutine.
                      000421 |;****************************************************************************
      E10E            000422 |ParseOpr:	;Entry point if parsing for a UASM command is not
      E10E A0 FF      000423 |	ldy #0ffh	; desired.
      E110 4C 30 E1   000424 |	jmp GtAnoOpr	;
                      000425 |	
      E113            000426 |ParsLine:
      E113 A0 00      000427 |	ldy #0d
                      000428 |
      E115 B9 A5 00   000429 |	lda InptBufr,y
      E118 F0 50      000430 |	beq ExtPrsLn	;If NULL or CR encountered then return.
                      000431 |	
      E11A C9 3F      000432 |	cmp #63d	;Check for upper case letter.
      E11C 30 4B      000433 |	bmi ParError	;
      E11E C9 5A      000434 |	cmp #90d	;	
      E120 10 03      000435 |	bpl CkSmCase	;
                      000436 |	
      E122 38         000437 |	sec
      E123 B0 08      000438 |	bcs GetCmd	;
                      000439 |	
      E125            000440 |CkSmCase:
      E125 C9 61      000441 |	cmp #97d	;Check for lower case letter.
      E127 30 40      000442 |	bmi ParError	;
      E129 C9 7A      000443 |	cmp #122d	;
      E12B 10 3C      000444 |	bpl ParError	;
                      000445 |	                
      E12D            000446 |GetCmd:
      E12D 8D CD 00   000447 |	sta command	;Store command in command buffer.
                      000448 |                        
      E130            000449 |GtAnoOpr:       
      E130 C8         000450 |	iny		;Point Y to the next operand field and check to
      E131 C0 14      000451 |	cpy #20d	;make sure that the input line is not too long.
      E133 F0 34      000452 |	beq ParError	;
                      000453 |	                
      E135 B9 A5 00   000454 |	lda InptBufr,y	;Check for the end of the input line.
      E138 C9 00      000455 |	cmp #0d		;
      E13A F0 2E      000456 |	beq ExtPrsLn	;
                      000457 |	                
      E13C C9 20      000458 |	cmp #32d	;Check for a space between operand fields.
      E13E F0 F0      000459 |	beq GtAnoOpr	;
                      000460 |	                
      E140            000461 |ScanOprn:              
      E140 AE 5E 00   000462 |	ldx OpOffSet	;Point X to the beginning of the current operand
      E143 8A         000463 |	txa		; field holder and point OpOffSet to the beginning
      E144 18         000464 |	clc             
      E145 69 14      000465 |	adc #20d	; of the next operand field holder.
      E147 8D 5E 00   000466 |	sta OpOffSet	;
                      000467 |	
      E14A            000468 |TranDgt:
      E14A B9 A5 00   000469 |	lda InptBufr,y	;
                      000470 |	                
      E14D C9 20      000471 |	cmp #32d	;If a space is encountered then stop scanning.
      E14F F0 10      000472 |	beq DoneScan	;
                      000473 |	                
      E151 C9 00      000474 |	Cmp #0d		;If a CR is encountered then stop scanning.
      E153 F0 0C      000475 |	beq doneScan	;
                      000476 |	                
      E155 9D 5F 00   000477 |	sta OpFld1,x	;Transfer current operand from input buffer into
      E158 E8         000478 |	inx		; current operand field holder.
      E159 C8         000479 |	iny		;
      E15A C0 28      000480 |	cpy #40d
      E15C F0 0B      000481 |	beq ParError
                      000482 |	
      E15E 4C 4A E1   000483 |	jmp TranDgt	
                      000484 |	
      E161            000485 |DoneScan:
      E161 A9 00      000486 |	lda #0h		;Put a NULL at the end of the current operand field
      E163 9D 5F 00   000487 |	sta OpFld1,x	; holder.
                      000488 |	
      E166 4C 30 E1   000489 |	jmp GtAnoOpr
                      000490 |
      E169            000491 |ParError:
      E169 60         000492 |	rts
      E16A            000493 |ExtPrsLn:
      E16A 60         000494 |	rts
                      000495 |
                      000496 |;****************************************************************************
                      000497 |;                     Check for Valid Command Subroutine.
                      000498 |;****************************************************************************
      E16B            000499 |CkValCmd:
      E16B 38         000500 |	sec
                      000501 |	
      E16C AD CD 00   000502 |	lda command
      E16F 20 0E F3   000503 |	jsr ToLower
                      000504 |
      E172 C9 6C      000505 |	cmp #108d	;Check for Load command.
      E174 D0 06      000506 |	bne NxtCmd1	;
      E176 20 8A E9   000507 |	jsr LdSRecs	;
      E179 4C FE E1   000508 |	jmp ExitCmd	;
                      000509 |                        
      E17C            000510 |NxtCmd1:
      E17C C9 64      000511 |	cmp #100d	;Check for Dump command.
      E17E D0 06      000512 |	bne NxtCmd2	;
      E180 20 5C E7   000513 |	jsr Dump	;
      E183 4C FE E1   000514 |	jmp ExitCmd	;
                      000515 |                        
      E186            000516 |NxtCmd2:
      E186 C9 72      000517 |	cmp #114d	;Check for Register command.
      E188 D0 06      000518 |	bne NxtCmd3	;
      E18A 20 40 EB   000519 |	jsr Register	;
      E18D 4C FE E1   000520 |	jmp ExitCmd	;
                      000521 |		
      E190            000522 |NxtCmd3:
      E190 C9 67      000523 |	cmp #103d	;Check for Go command.
      E192 D0 06      000524 |	bne NxtCmd4	;
      E194 20 01 E9   000525 |	jsr Go		;
      E197 4C FE E1   000526 |	jmp ExitCmd	;
                      000527 |	
      E19A            000528 |NxtCmd4:
      E19A C9 65      000529 |	cmp #101d	;Check for Enter command.
      E19C D0 06      000530 |	bne NxtCmd5	;
      E19E 20 5A E8   000531 |	jsr Enter	;
      E1A1 4C FE E1   000532 |	jmp ExitCmd	;
                      000533 |	
      E1A4            000534 |NxtCmd5:
      E1A4 C9 66      000535 |	cmp #102d	;Check for Fill command.
      E1A6 D0 06      000536 |	bne NxtCmd6	;
      E1A8 20 C0 E8   000537 |	jsr Fill	;
      E1AB 4C FE E1   000538 |	jmp ExitCmd	;
                      000539 |
      E1AE            000540 |NxtCmd6:
      E1AE C9 75      000541 |	cmp #117d	;Check for Unassemble command.
      E1B0 D0 06      000542 |	bne NxtCmd7	;
      E1B2 20 D1 EF   000543 |	jsr UnAssem	;
      E1B5 4C FE E1   000544 |	jmp ExitCmd	;
                      000545 |
      E1B8            000546 |NxtCmd7:
      E1B8 C9 74      000547 |	cmp #116d	;Check for Trace command.
      E1BA D0 06      000548 |	bne NxtCmd8	;
      E1BC 20 96 ED   000549 |	jsr Trace	;
      E1BF 4C FE E1   000550 |	jmp ExitCmd	;
                      000551 |
      E1C2            000552 |NxtCmd8:
      E1C2 C9 62      000553 |	cmp #98d	;Check for Breakpoint command.
      E1C4 D0 06      000554 |	bne NxtCmd9	;
      E1C6 20 F4 E5   000555 |	jsr BreakPnt	;
      E1C9 4C FE E1   000556 |	jmp ExitCmd	;
                      000557 |	
      E1CC            000558 |NxtCmd9:
      E1CC C9 73      000559 |	cmp #115d	;Check for Search command.
      E1CE D0 06      000560 |	bne NxtCmd10	;
      E1D0 20 05 ED   000561 |	jsr Search	;
      E1D3 4C FE E1   000562 |	jmp ExitCmd	;
                      000563 |
      E1D6            000564 |NxtCmd10:
      E1D6 C9 6D      000565 |	cmp #109d	;Check for Move command.
      E1D8 D0 06      000566 |	bne NxtCmd11	;
      E1DA 20 D4 EA   000567 |	jsr Move	;
      E1DD 4C FE E1   000568 |	jmp ExitCmd	;
                      000569 |	
      E1E0            000570 |NxtCmd11:
      E1E0 C9 61      000571 |	cmp #'a'	;Check for Assemble command.
      E1E2 D0 06      000572 |	bne NxtCmd12	;
      E1E4 20 6B E2   000573 |	jsr Assemble	;
      E1E7 4C FE E1   000574 |	jmp ExitCmd	;
                      000575 |
      E1EA            000576 |NxtCmd12:
      E1EA C9 68      000577 |	cmp #104d	;Check for Help command.
      E1EC D0 06      000578 |	bne NxtCmd13	;
      E1EE 20 82 E9   000579 |	jsr Help	;
      E1F1 4C FE E1   000580 |	jmp ExitCmd	;
      E1F4            000581 |NxtCmd13:                 
      E1F4 C9 3F      000582 |	cmp #63d	;
      E1F6 D0 06      000583 |	bne ExitCmd	;
      E1F8 20 82 E9   000584 |	jsr Help	;
      E1FB 4C FE E1   000585 |	jmp ExitCmd	;
                      000586 |
      E1FE            000587 |ExitCmd:
      E1FE B0 09      000588 |	bcs CmdOk
                      000589 |	
      E200            000590 |CmdError:		;If there was an error with a command then
      E200 A2 56      000591 |	ldx #CmdErMes<	; print a question mark.
      E202 A0 F6      000592 |	ldy #CmdErMes>	;
      E204 20 B3 F3   000593 |	jsr PrntMess	;
      E207 18         000594 |	clc		;
      E208 60         000595 |	rts		;
                      000596 |	
      E209            000597 |CmdOk:
      E209 38         000598 |	sec
      E20A 60         000599 |	rts
                      000600 |
                      000601 |;****************************************************************************
                      000602 |;                     Maskable Interrupt Service Subroutine.
                      000603 |;****************************************************************************
      E20B            000604 |MaskInt:
      E20B 78         000605 |	sei		;Disable interrupts.
                      000606 |
      E20C 8D 44 00   000607 |	sta TempA	;Save accumulator.
                      000608 |			
      E20F 68         000609 |	pla		;Check to see if BRK command was executed.
      E210 48         000610 |	pha		;
      E211 29 10      000611 |	and #10h	;
      E213 D0 06      000612 |	bne DoBRK	;
                      000613 |	
      E215 AD 44 00   000614 |	lda TempA	;Restore accumulator.
                      000615 |
      E218            000616 |IRQ:	
      E218 6C 02 00   000617 |	jmp (IRQVect)
                      000618 |	
      E21B            000619 |DoBRK:
      E21B 6C 04 00   000620 |	jmp (BRKVect)
                      000621 |
                      000622 |	
                      000623 |;****************************************************************************
                      000624 |;                          Break Service Subroutine.
                      000625 |;****************************************************************************
                      000626 |	
      E21E            000627 |BRK:
      E21E 68         000628 |	pla		;Save user's status register.
      E21F 8D 4B 00   000629 |	sta UStatReg	;
                      000630 |
                      000631 |	
      E222 AD 44 00   000632 |	lda TempA	;Save user's accumulator.
      E225 8D 47 00   000633 |	sta UAccum	;
                      000634 |	
      E228 8E 48 00   000635 |	stx UXReg	;Save user's X register.
                      000636 |	
      E22B 8C 49 00   000637 |	sty UYReg	;Save user's Y register.
                      000638 |	
      E22E BA         000639 |	tsx
                      000640 |    
      E22F E8         000641 |    inx ;Remove the remaining 2 bytes that were pushed on the
      E230 E8         000642 |    inx ; stack by the brk command.
                      000643 |    
      E231 8E 4A 00   000644 |	stx UStkPtr	;Save user's stack pointer.
                      000645 |	
      E234 68         000646 |	pla		;Save program counter of break instruction
      E235 38         000647 |	sec		; that caused execution of this code.
      E236 E9 01      000648 |	sbc #1d		;
      E238 8D 45 00   000649 |	sta UPgmCntr	;
      E23B 68         000650 |	pla		; 
      E23C E9 00      000651 |	sbc #0d		;
      E23E 8D 46 00   000652 |	sta UPgmCntr+1d	;
                      000653 |;	cli
                      000654 |
      E241            000655 |ResetEntryPoint:
      E241 A0 00      000656 |	ldy #0d		;Print user's registers.
      E243 8C 5F 00   000657 |	sty OpFld1	;
      E246 20 40 EB   000658 |	jsr Register	;
                      000659 |
      E249 AD 39 00   000660 |	lda TrBrkFlg	;If this break was placed by the trace command
      E24C C9 01      000661 |	cmp #1d		; then go back to the trace subroutine.
      E24E D0 03      000662 |	bne RepBPOp	;
      E250 4C 4C EF   000663 |	jmp Tr2ndEnt	;
                      000664 |	
      E253            000665 |RepBPOp:
      E253 A0 03      000666 |	ldy #3d		;Replace the opcodes of all breakpointed
      E255 A2 06      000667 |	ldx #6d		; addresses.
      E257            000668 |CkBPStBr:              ;
      E257 B9 2F 00   000669 |	lda BrkPt1St,y	;
      E25A C9 01      000670 |	cmp #1d		;
      E25C D0 05      000671 |	bne NxtBPStB	;
      E25E B9 33 00   000672 |	lda BP1OpHld,y	;
      E261 81 12      000673 |	sta (BrkPt1Ad,x);
      E263            000674 |NxtBPStB:		;
      E263 88         000675 |	dey		;
      E264 CA         000676 |	dex		;
      E265 CA         000677 |	dex		;
      E266 10 EF      000678 |	bpl CkBPStBr	;
                      000679 |	
      E268            000680 |GoMain:
      E268 4C 95 E0   000681 |	jmp MainLoop	;Enter monitor.
                      000682 |
                      000683 |
                      000684 |;****************************************************************************
                      000685 |;                       Assemble Command Subroutine.
                      000686 |;****************************************************************************
      E26B            000687 |Assemble:
                      000688 |
      E26B A2 00      000689 |	ldx #0d		;Get address to start assembling at and store
      E26D 20 E4 F2   000690 |	jsr GetAdd	; in pointer A.
      E270 B0 03      000691 |	bcs AAddOk	;
      E272 4C 61 E3   000692 |	jmp ErrAsem	;
      E275            000693 |AAddOk:		;
      E275 8E 08 00   000694 |	stx PointerA	;
      E278 8C 09 00   000695 |	sty PointerA+1d	;
                      000696 |
      E27B            000697 |AsemTop:		;On new line print current address being
      E27B A2 DD      000698 |	ldx #CRLF<	; assembled at and get next instruction to be
      E27D A0 F4      000699 |	ldy #CRLF>	; assembled from user.
      E27F 20 B3 F3   000700 |	jsr PrntMess	;
      E282 20 26 F3   000701 |	jsr PrntAdd	;
      E285 20 A8 E0   000702 |	jsr GetLine	;
      E288 20 0E E1   000703 |	jsr ParseOpr	;
                      000704 |	
      E28B AD 5F 00   000705 |	lda OpFld1	;Check for operator to be assembled. If no
      E28E C9 00      000706 |	cmp #0d		; operator is found then exit Assemble 
      E290 F0 04      000707 |	beq AsemDone	; subroutine.
      E292 C9 20      000708 |	cmp #32d	;
      E294 D0 03      000709 |	bne ACont	;
      E296            000710 |AsemDone:              ;
      E296 4C 63 E3   000711 |	jmp ExitAsem	;
                      000712 |	
      E299            000713 |ACont:			;Convert operator in input buffer to upper case,
      E299 A0 00      000714 |	ldy #0d		; check to see if it is in the operator table and
      E29B            000715 |ConvAno:		;
      E29B B9 5F 00   000716 |	lda OpFld1,y	; output a question mark if operator was not found.
      E29E 20 1A F3   000717 |	jsr ToUpper	;
      E2A1 99 5F 00   000718 |	sta OpFld1,y	;
      E2A4 C8         000719 |	iny		;
      E2A5 C0 03      000720 |	cpy #3d		;
      E2A7 D0 F2      000721 |	bne ConvAno	;
      E2A9 20 65 E3   000722 |	jsr OptrScan	;
      E2AC B0 28      000723 |	bcs AOptrOk	;
                      000724 |	
      E2AE            000725 |PrntQues:
      E2AE 20 26 F3   000726 |	jsr PrntAdd	;If there was an error assembling the instruction
      E2B1 A9 20      000727 |	lda #32d	; input from the user into object code then re-
      E2B3 20 14 F4   000728 |	jsr OutChar	; output the line and print a question mark.
      E2B6 A2 5F      000729 |	ldx #OpFld1<	;
      E2B8 A0 00      000730 |	ldy #OpFld1>	;
      E2BA 20 B3 F3   000731 |	jsr PrntMess	;
      E2BD A9 20      000732 |	lda #32d  	;
      E2BF 20 14 F4   000733 |	jsr OutChar	;
      E2C2 A2 73      000734 |	ldx #OpFld2<	;
      E2C4 A0 00      000735 |	ldy #OpFld2>	;
      E2C6 20 B3 F3   000736 |	jsr PrntMess	;
      E2C9 A9 20      000737 |	lda #32d	;
      E2CB 20 14 F4   000738 |	jsr OutChar	;
      E2CE A9 3F      000739 |	lda #63d	;
      E2D0 20 14 F4   000740 |	jsr OutChar	;
      E2D3 4C 7B E2   000741 |	jmp AsemTop	;
                      000742 |	
      E2D6            000743 |AOptrOk:		;Check address mode of operand and print a quesion
      E2D6 20 9D E3   000744 |	jsr AdMdScan	; mark if error occures while scanning operand.
      E2D9 B0 03      000745 |	bcs AOpndOk	;
      E2DB 4C AE E2   000746 |	jmp PrntQues
                      000747 |		
      E2DE            000748 |AOpndOk:		;Check to see if address mode of operand is a
      E2DE 20 92 E4   000749 |	jsr AdMdTbSc	; valid address mode for instruction.
      E2E1 B0 03      000750 |	bcs AOpTbFnd	;
      E2E3 4C AE E2   000751 |	jmp PrntQues
                      000752 |		
      E2E6            000753 |AOpTbFnd:		;Extract object code from operand.
      E2E6 20 B2 E4   000754 |	jsr OpndScan	;
      E2E9 B0 03      000755 |	bcs PrntAssm	;
      E2EB 4C AE E2   000756 |	jmp PrntQues	;
                      000757 |	
      E2EE            000758 |PrntAssm:
      E2EE 20 26 F3   000759 |	jsr PrntAdd	;Re-output current address.
                      000760 |	
      E2F1 A0 00      000761 |	ldy #0d		;
                      000762 |	
      E2F3 AD 1A 00   000763 |	lda Obj1	;Output opcode, store it in memory, point to next
      E2F6 91 08      000764 |	sta (PointerA),y; byte, and print one space.
      E2F8 20 5F F3   000765 |	jsr OutHex	;
      E2FB 20 DB F2   000766 |	jsr IncPntrA	;
      E2FE A9 20      000767 |	lda #32d	;
      E300 20 14 F4   000768 |	jsr OutChar	;
                      000769 |	
      E303 AD 1D 00   000770 |	lda Obj2Flg	;Output second object code byte if present, store it in
      E306 F0 28      000771 |	beq NoObjCd	; it in memory, point to next byte, and print one
      E308 AD 1B 00   000772 |	lda Obj2	; space.
      E30B 91 08      000773 |	sta (PointerA),y;
      E30D 20 5F F3   000774 |	jsr OutHex	;
      E310 20 DB F2   000775 |	jsr IncPntrA	;
      E313 A9 20      000776 |	lda #32d	;
      E315 20 14 F4   000777 |	jsr OutChar	;
                      000778 |	
      E318 AD 1E 00   000779 |	lda Obj3Flg	;Output third object code byte if present, store
      E31B F0 1E      000780 |	beq NoObjCd3	; it in memory, point to next byte, and print one
      E31D AD 1C 00   000781 |	lda Obj3	; space.
      E320 91 08      000782 |	sta (PointerA),y;
      E322 20 5F F3   000783 |	jsr OutHex	;
      E325 20 DB F2   000784 |	jsr IncPntrA	;
      E328 A9 20      000785 |	lda #32d	;
      E32A 20 14 F4   000786 |	jsr OutChar	;
      E32D 4C 46 E3   000787 |	jmp NoExSpcs
                      000788 |
      E330            000789 |NoObjCd:		;If fewer then 3 bytes of object code are output
      E330 A9 20      000790 |	lda #32d	; then output spaces instead.
      E332 20 14 F4   000791 |	jsr OutChar	;
      E335 20 14 F4   000792 |	jsr OutChar	;
      E338 20 14 F4   000793 |	jsr OutChar
      E33B            000794 |NoObjCd3:
      E33B A9 20      000795 |	lda #32d	;
      E33D 20 14 F4   000796 |	jsr OutChar	;
      E340 20 14 F4   000797 |	jsr OutChar	;
      E343 20 14 F4   000798 |	jsr OutChar
                      000799 |	
      E346            000800 |NoExSpcs:
      E346 A9 20      000801 |	lda #32d	;
      E348 20 14 F4   000802 |	jsr OutChar	;
      E34B A2 5F      000803 |	ldx #OpFld1<	;Re-output instruction that user had entered in.
      E34D A0 00      000804 |	ldy #OpFld1>	;
      E34F 20 B3 F3   000805 |	jsr PrntMess	;
      E352 A9 20      000806 |	lda #32d  	;
      E354 20 14 F4   000807 |	jsr OutChar	;
      E357 A2 73      000808 |	ldx #OpFld2<	;
      E359 A0 00      000809 |	ldy #OpFld2>	;
      E35B 20 B3 F3   000810 |	jsr PrntMess	;
                      000811 |
      E35E 4C 7B E2   000812 |	jmp AsemTop
                      000813 |	
                      000814 |	
      E361            000815 |ErrAsem:
      E361 18         000816 |	clc
      E362 60         000817 |	rts
                      000818 |	
      E363            000819 |ExitAsem:
      E363 38         000820 |	sec
      E364 60         000821 |	rts
                      000822 |	
                      000823 |
                      000824 |;****************************************************************************
                      000825 |;                       Operator Scan Subroutine.
                      000826 |;****************************************************************************
      E365            000827 |OptrScan:
                      000828 |
      E365 A2 5C      000829 |	ldx #OpTable<	;Point pointer B to beginning of the operator
      E367 8E 0A 00   000830 |	stx PointerB	; table.
      E36A A2 F8      000831 |	ldx #Optable>	;
      E36C 8E 0B 00   000832 |	stx PointerB+1d	;
                      000833 |	
      E36F            000834 |OSCkAno:
      E36F A0 00      000835 |	ldy #0d		;Compare a digit of the operator that the user
      E371            000836 |OSCkAnCM:		;
      E371 B1 0A      000837 |	lda (PointerB),y; entered with the analogous digit of the
      E373 D9 5F 00   000838 |	cmp OpFld1,y	; operator in the operator table.
      E376 F0 19      000839 |	beq CharMtch	;
                      000840 |	
      E378            000841 |OptScan2:
      E378 AD 0A 00   000842 |	lda PointerB	;Point pointer B to the beginning of the next
      E37B 18         000843 |	clc		; operator in the operator table.
      E37C 69 0A      000844 |	adc #10d	;
      E37E 8D 0A 00   000845 |	sta PointerB	;
      E381 90 03      000846 |	bcc OSNoCary	;
      E383 EE 0B 00   000847 |	inc PointerB+1d	;
                      000848 |	
      E386            000849 |OSNoCary:
      E386 A0 04      000850 |	ldy #4d		;Check for the end of the operator table.
      E388 B1 0A      000851 |	lda (PointerB),y;
      E38A C9 5A      000852 |	cmp #'Z'	;
      E38C F0 0B      000853 |	beq OSNoMtch	;
      E38E 4C 6F E3   000854 |	jmp OSCkAno	;
                      000855 |	
      E391            000856 |CharMtch:		;Check for an operator match in the operator
      E391 C8         000857 |	iny		; table.
      E392 C0 03      000858 |	cpy #3d		;
      E394 F0 05      000859 |	beq OSMatch	;
      E396 4C 71 E3   000860 |	jmp OSCkAnCM	;
                      000861 |	
      E399            000862 |OSNoMtch:
      E399 18         000863 |	clc
      E39A 60         000864 |	rts
                      000865 |	
      E39B            000866 |OSMatch:
      E39B 38         000867 |	sec
      E39C 60         000868 |	rts
                      000869 |
                      000870 |
                      000871 |;****************************************************************************
                      000872 |;                     Address Mode Scan Subroutine.
                      000873 |;****************************************************************************
      E39D            000874 |AdMdScan:
                      000875 |
      E39D            000876 |AMSCkIMP:
      E39D A0 00      000877 |	ldy #0d		;Check for implied addressing mode.
      E39F B9 73 00   000878 |	lda OpFld2,y	;
      E3A2 C9 00      000879 |	cmp #0d		;
      E3A4 D0 08      000880 |	bne AMSCkIMM	;
      E3A6 A9 50      000881 |	lda #'P'	;
      E3A8 8D 1F 00   000882 |	sta AddMode	;
      E3AB 4C 90 E4   000883 |	jmp ExitAMS	;
                      000884 |	
      E3AE            000885 |AMSCkIMM:		;Check for immediate addressing mode.
      E3AE C9 23      000886 |	cmp #'#'	;
      E3B0 D0 08      000887 |	bne AMSCkACC	;
      E3B2 A9 4D      000888 |	lda #'M'	;
      E3B4 8D 1F 00   000889 |	sta AddMode	;
      E3B7 4C 90 E4   000890 |	jmp ExitAMS	;
                      000891 |	
      E3BA            000892 |AMSCkACC:		;Check for accumulator addressing mode.
      E3BA C9 41      000893 |	cmp #'A'	;
      E3BC F0 07      000894 |	beq CkSpNull	;
      E3BE C9 61      000895 |	cmp #'a'	;
      E3C0 F0 03      000896 |	beq CkSpNull	;
      E3C2 4C DC E3   000897 |	jmp AMSCkREL	;
      E3C5            000898 |CkSpNull:		;
      E3C5 C8         000899 |	iny		;
      E3C6 B9 73 00   000900 |	lda OpFld2,y	;
      E3C9 C9 00      000901 |	Cmp #0d		;
      E3CB F0 07      000902 |	beq IsAcc	;
      E3CD C9 20      000903 |	cmp #32d	;
      E3CF F0 03      000904 |	beq IsAcc	;
      E3D1 4C DC E3   000905 |	jmp AMSCkREL	;
      E3D4            000906 |IsAcc:			;
      E3D4 A9 43      000907 |	lda #'C'	;
      E3D6 8D 1F 00   000908 |	sta AddMode	;
      E3D9 4C 90 E4   000909 |	jmp ExitAMS	;
                      000910 |	
      E3DC            000911 |AMSCkREL:		;Check for relative addressing mode.
      E3DC A0 06      000912 |	ldy #6d		;
      E3DE B1 0A      000913 |	lda (PointerB),y;
      E3E0 C9 4C      000914 |	cmp #'L'	;
      E3E2 D0 06      000915 |	bne AMSCkA_I	;
      E3E4 8D 1F 00   000916 |	sta AddMode	;
      E3E7 4C 90 E4   000917 |	jmp ExitAMS	;
                      000918 |	
      E3EA            000919 |AMSCkA_I:		;Dispatch to absolute or indexed check code.
      E3EA A0 00      000920 |	ldy #0d		;
      E3EC B9 73 00   000921 |	lda OpFld2,y	;
      E3EF C9 28      000922 |	cmp #'('	;
      E3F1 D0 03      000923 |	bne AMSCkAB?	;
      E3F3 4C 36 E4   000924 |	jmp AMSCkId?	;
                      000925 |	
      E3F6            000926 |AMSCkAB?:		;Check to see if operand is absolute addressing
      E3F6 A0 00      000927 |	ldy #0d		; mode or absolute indexed addressing mode.
      E3F8            000928 |AMSScnAB:		;
      E3F8 B9 73 00   000929 |	lda OpFld2,y	;
      E3FB C9 2C      000930 |	cmp #','	;
      E3FD F0 08      000931 |	beq CkXorY	;
      E3FF C9 00      000932 |	cmp #0d		;
      E401 F0 2B      000933 |	beq IsABS	;
      E403 C8         000934 |	iny		;
      E404 4C F8 E3   000935 |	jmp AMSScnAB	;
                      000936 |	
      E407            000937 |CkXorY:		;Check for absolute X or absolute Y addressing
      E407 C8         000938 |	iny		; mode.
      E408 B9 73 00   000939 |	lda OpFld2,y	;                                                                        
      E40B C9 58      000940 |	cmp #'X'	;
      E40D F0 0F      000941 |	beq IsABX	;
      E40F C9 78      000942 |	cmp #'x'	;
      E411 F0 0B      000943 |	beq IsABX	;
      E413 C9 59      000944 |	cmp #'Y'	;
      E415 F0 0F      000945 |	beq IsABY	;
      E417 C9 79      000946 |	cmp #'y'	;
      E419 F0 0B      000947 |	beq IsABY	;
      E41B 4C 8E E4   000948 |	jmp ErrAMS	;
                      000949 |	
      E41E            000950 |IsABX:			;Save ABS, ABX or ABY mode in the variable to be
      E41E A9 58      000951 |	lda #'X'	; returned.
      E420 8D 1F 00   000952 |	sta AddMode	;
      E423 4C 90 E4   000953 |	jmp ExitAMS	;
      E426            000954 |IsABY:			;
      E426 A9 59      000955 |	lda #'Y'	;
      E428 8D 1F 00   000956 |	sta AddMode	;
      E42B 4C 90 E4   000957 |	jmp ExitAMS	;
      E42E            000958 |IsABS:			;
      E42E A9 53      000959 |	lda #'S'	;
      E430 8D 1F 00   000960 |	sta AddMode	;
      E433 4C 90 E4   000961 |	jmp ExitAMS	;
                      000962 |	
      E436            000963 |AMSCkId?:		;Dispatch to code that checks for IIR, IRI or
      E436 C8         000964 |	iny		; IND addressing modes.
      E437 B9 73 00   000965 |	lda OpFld2,y	;
      E43A C9 2C      000966 |	cmp #','	;
      E43C F0 0B      000967 |	beq CkIIR	;
      E43E C9 29      000968 |	cmp #')'	;
      E440 F0 1E      000969 |	beq CkIRIIND	;
      E442 C0 0B      000970 |	cpy #11d	;
      E444 D0 F0      000971 |	bne AMSCkId?	;
      E446 4C 8E E4   000972 |	jmp ErrAMS	;
                      000973 |
      E449            000974 |CkIIR:			;Check for IIR addressing mode.
      E449 C8         000975 |	iny		;
      E44A B9 73 00   000976 |	lda OpFld2,y	;
      E44D C9 58      000977 |	cmp #'X'	;
      E44F F0 07      000978 |	beq IsIIR	;
      E451 C9 78      000979 |	cmp #'x'	;
      E453 F0 03      000980 |	beq IsIIR	;
      E455 4C 8E E4   000981 |	jmp ErrAMS	;
                      000982 |	
      E458            000983 |IsIIR:
      E458 A9 52      000984 |	lda #'R'	;Save IIR addressing mode code in variable to be
      E45A 8D 1F 00   000985 |	sta AddMode	; returned.
      E45D 4C 90 E4   000986 |	jmp ExitAMS	;
                      000987 |	
      E460            000988 |CkIRIIND:		;Check for IND addressing mode.
      E460 C8         000989 |	iny		;
      E461 B9 73 00   000990 |	lda OpFld2,y	;
      E464 C9 00      000991 |	cmp #0d		;
      E466 F0 16      000992 |	beq IsIND	;
      E468 C9 2C      000993 |	cmp #','	;
      E46A F0 03      000994 |	beq CkIRI	;
      E46C 4C 8E E4   000995 |	jmp ErrAMS	;
                      000996 |	
      E46F            000997 |CkIRI:			;Check for IRI addressing mode.
      E46F C8         000998 |	iny		;
      E470 B9 73 00   000999 |	lda OpFld2,y	;
      E473 C9 59      001000 |	cmp #'Y'	;
      E475 F0 0F      001001 |	beq IsIRI	;
      E477 C9 79      001002 |	cmp #'y'	;
      E479 F0 0B      001003 |	beq IsIRI	;
      E47B 4C 8E E4   001004 |	jmp ErrAMS	;
                      001005 |	
      E47E            001006 |IsIND:			;Save IND or IRI addressing mode code in variable
      E47E A9 44      001007 |	lda #'D'	; to be returned.
      E480 8D 1F 00   001008 |	sta AddMode	;
      E483 4C 90 E4   001009 |	jmp ExitAMS	;
      E486            001010 |IsIRI:			;
      E486 A9 49      001011 |	lda #'I'	;
      E488 8D 1F 00   001012 |	sta AddMode	;
      E48B 4C 90 E4   001013 |	jmp ExitAMS	;
                      001014 |	
      E48E            001015 |ErrAMS:
      E48E 18         001016 |	clc
      E48F 60         001017 |	rts
                      001018 |	
      E490            001019 |ExitAMS:
      E490 38         001020 |	sec
      E491 60         001021 |	rts
                      001022 |	
                      001023 |	
                      001024 |;****************************************************************************
                      001025 |;                   Address Mode Table Search Subroutine.
                      001026 |;****************************************************************************
      E492            001027 |AdMdTbSc:		
      E492 A0 06      001028 |	ldy #6d		;Check for address mode match between contents
      E494 B1 0A      001029 |	lda (PointerB),y; of variable AddMode & OpTable.
      E496 CD 1F 00   001030 |	cmp AddMode	;
      E499 F0 15      001031 |	beq ExitAdMd	;
                      001032 |	
      E49B AD 0A 00   001033 |	lda PointerB	;Pointer Pointer B to next operator in
      E49E 18         001034 |	clc		; operator table.
      E49F 69 0A      001035 |	adc #10d	;
      E4A1 8D 0A 00   001036 |	sta PointerB	;
      E4A4 90 03      001037 |	bcc AdMdNoCy	;
      E4A6 EE 0B 00   001038 |	inc PointerB+1d	;
                      001039 |	
      E4A9            001040 |AdMdNoCy:		;Check to see if next operator is the same type
      E4A9 20 6F E3   001041 |	jsr OSCkANO	; that we are currently trying to assemble.
      E4AC B0 E4      001042 |	bcs AdMdTbSc	;
                      001043 |	
      E4AE            001044 |ErrAdMd:
      E4AE 18         001045 |	clc
      E4AF 60         001046 |	rts
                      001047 |	
      E4B0            001048 |ExitAdMd:
      E4B0 38         001049 |	sec
      E4B1 60         001050 |	rts
                      001051 |
                      001052 |;****************************************************************************
                      001053 |;                       Operand Scan Subroutine.
                      001054 |;****************************************************************************
      E4B2            001055 |OpndScan:
                      001056 |
      E4B2 A9 00      001057 |	lda #0d		;Initialize the flags that indicate whether or
      E4B4 8D 1D 00   001058 |	sta Obj2Flg	; not there are object bytes in addition to
      E4B7 8D 1E 00   001059 |	sta Obj3Flg	; the opcode object byte.
                      001060 |	
      E4BA A0 07      001061 |	ldy #7d		;Get the opcode of the instruction being 
      E4BC B1 0A      001062 |	lda (PointerB),y; currently assembled from the opcode table
      E4BE 8D 1A 00   001063 |	sta Obj1	; and put it in Obj1.
                      001064 |	
      E4C1 AD 1F 00   001065 |	lda AddMode	;Check to see what address mode the instruction
      E4C4 C9 50      001066 |	cmp #'P'	; currently being assembled is.
      E4C6 F0 27      001067 |	beq OpndIMP	;
      E4C8 C9 43      001068 |	cmp #'C'	;
      E4CA F0 26      001069 |	beq OpndACC	;
      E4CC C9 4D      001070 |	cmp #'M'	;
      E4CE F0 25      001071 |	beq OpndIMM	;
      E4D0 C9 53      001072 |	cmp #'S'	;
      E4D2 F0 3C      001073 |	beq OpndAB??	;
      E4D4 C9 58      001074 |	cmp #'X'	;
      E4D6 F0 38      001075 |	beq OpndAB??	;
      E4D8 C9 59      001076 |	cmp #'Y'	;
      E4DA F0 34      001077 |	beq OpndAB??	;
      E4DC C9 49      001078 |	cmp #'I'	;
      E4DE F0 58      001079 |	beq OpndIN??	;
      E4E0 C9 52      001080 |	cmp #'R'	;
      E4E2 F0 54      001081 |	beq OpndIN??	;
      E4E4 C9 44      001082 |	cmp #'D'	;
      E4E6 F0 50      001083 |	beq OpndIN??	;
      E4E8 C9 4C      001084 |	cmp #'L'	;
      E4EA F0 24      001085 |	beq OpndAB??	;
      E4EC 4C CB E5   001086 |	jmp ErrOpndS	;
                      001087 |
      E4EF            001088 |OpndIMP:		;Process implied addressing mode.
      E4EF 4C CD E5   001089 |	jmp ExtOpndS	;
                      001090 |	
      E4F2            001091 |OpndACC:		;Process accumulator addressing mode.
      E4F2 4C CD E5   001092 |	jmp ExtOpndS	;
                      001093 |	
      E4F5            001094 |OpndIMM:		;Process immediate addressing mode.
      E4F5 20 CF E5   001095 |	jsr ScnForHex	;
      E4F8 B0 03      001096 |	bcs OpnMHFnd	;
      E4FA 4C CB E5   001097 |	jmp ErrOpndS	;
      E4FD            001098 |OpnMHFnd:		;
      E4FD 20 3D F3   001099 |	jsr AsToBin	;
      E500 B0 03      001100 |	bcs OpndCvOk	;
      E502 4C CB E5   001101 |	jmp ErrOpndS	;
      E505            001102 |OpndCvOk:		;
      E505 8D 1B 00   001103 |	sta Obj2	;
      E508 A9 01      001104 |	lda #1d		;
      E50A 8D 1D 00   001105 |	sta Obj2Flg	;
      E50D 4C CD E5   001106 |	jmp ExtOpndS	;
                      001107 |
                      001108 |
      E510            001109 |OpndAB??:		;Process absolute, absolute X, absolute Y.
      E510 20 CF E5   001110 |	jsr ScnForHex	; Check for relative addressing mode and send
      E513 B0 03      001111 |	bcs OpnAHFnd	; to appropriate code if found.
      E515 4C CB E5   001112 |	jmp ErrOpndS	;
      E518            001113 |OpnAHFnd:		;
      E518 20 E4 F2   001114 |	jsr GetAdd	;
      E51B B0 03      001115 |	bcs OpndAdOk	;
      E51D 4C CB E5   001116 |	jmp ErrOpndS	;
      E520            001117 |OpndAdOk:		;
      E520 AD 1F 00   001118 |	lda AddMode	;
      E523 C9 4C      001119 |	cmp #'L'	;
      E525 F0 48      001120 |	beq OpndDoBr	;
      E527            001121 |DoAdd:			;
      E527 8E 1B 00   001122 |	stx Obj2	;
      E52A 8C 1C 00   001123 |	sty Obj3	;
      E52D A9 01      001124 |	lda #1d		;
      E52F 8D 1D 00   001125 |	sta Obj2Flg	;
      E532 8D 1E 00   001126 |	sta Obj3Flg	;
      E535 4C CD E5   001127 |	jmp ExtOpndS	;
                      001128 |
      E538            001129 |OpndIN??:		;Process indirect indexed, indexed indirect and
      E538 20 CF E5   001130 |	jsr ScnForHex	; indirect addressing modes.
      E53B B0 03      001131 |	bcs OpnINFnd	;
      E53D 4C CB E5   001132 |	jmp ErrOpndS	;
      E540            001133 |OpnINFnd:		;
      E540 20 E4 F2   001134 |	jsr GetAdd	;
      E543 B0 03      001135 |	bcs OpINAdOk	;
      E545 4C CB E5   001136 |	jmp ErrOpndS	;
      E548            001137 |OpINAdOk:		;
      E548 AD 1F 00   001138 |	lda AddMode	;
      E54B C9 44      001139 |	cmp #'D'	;
      E54D F0 0F      001140 |	beq DoIND	;
      E54F C0 00      001141 |	cpy #0d		;
      E551 D0 78      001142 |	bne ErrOpndS	;
      E553 8E 1B 00   001143 |	stx Obj2	;
      E556 A9 01      001144 |	lda #1d		;
      E558 8D 1D 00   001145 |	sta Obj2Flg	;
      E55B 4C CD E5   001146 |	jmp ExtOpndS	;
      E55E            001147 |DoIND:			;
      E55E 8E 1B 00   001148 |	stx Obj2	;
      E561 8C 1C 00   001149 |	sty Obj3	;
      E564 A9 01      001150 |	lda #1d		;
      E566 8D 1D 00   001151 |	sta Obj2Flg	;
      E569 8D 1E 00   001152 |	sta Obj3Flg	;
      E56C 4C CD E5   001153 |	jmp ExtOpndS	;
                      001154 |	
      E56F            001155 |OpndDoBr:		;Put address to be branched to in TempAdd and
      E56F 8E 2B 00   001156 |	stx TempAdd	; the address of the first byte of the next
      E572 8C 2C 00   001157 |	sty TempAdd+1d	; instruction in TempAdd2.
      E575 AD 08 00   001158 |	lda PointerA	;
      E578 8D 2D 00   001159 |	sta TempAdd2	;
      E57B AD 09 00   001160 |	lda PointerA+1d	;
      E57E 8D 2E 00   001161 |	sta TempAdd2+1d	;
      E581 A0 08      001162 |	ldy #8d		;
      E583 B1 0A      001163 |	lda (PointerB),y;
      E585 18         001164 |	clc		;
      E586 6D 2D 00   001165 |	adc TempAdd2	;
      E589 8D 2D 00   001166 |	sta TempAdd2	;
      E58C 90 03      001167 |	bcc OpBrNoOv	;
      E58E EE 2E 00   001168 |	inc TempAdd2+1d	;
      E591            001169 |OpBrNoOv:
      E591 38         001170 |	sec		;Subtract the address of the first byte of the
      E592 AD 2B 00   001171 |	lda TempAdd	; next instruction from the address to be branched
      E595 ED 2D 00   001172 |	sbc TempAdd2	; to in order to get the branch offset.
      E598 8D 2B 00   001173 |	sta TempAdd	;
      E59B AD 2C 00   001174 |	lda TempAdd+1d	;
      E59E ED 2E 00   001175 |	sbc TempAdd2+1d	;
      E5A1 8D 2C 00   001176 |	sta TempAdd+1d	;
                      001177 |	
      E5A4 AD 2C 00   001178 |	lda TempAdd+1d	;Check to make sure that MSB of the offset does
      E5A7 C9 FF      001179 |	cmp #0ffh	; not indicate a number greater than 127 or less
      E5A9 F0 0E      001180 |	beq OpCkNOff	; than 128.
      E5AB C9 00      001181 |	cmp #0d		;
      E5AD D0 1C      001182 |	bne ErrOpndS	;
                      001183 |	
      E5AF            001184 |OpCkPOff:		;Check to make sure that LSB of the offset does
      E5AF AD 2B 00   001185 |	lda TempAdd	; not contain a number greater than 127 or less
      E5B2 C9 80      001186 |	cmp #128d	; than 128.
      E5B4 10 15      001187 |	bpl ErrOpndS	;
      E5B6 4C C0 E5   001188 |	jmp OffOk	;
      E5B9            001189 |OpCkNOff:		;
      E5B9 AD 2B 00   001190 |	lda TempAdd	;
      E5BC C9 80      001191 |	cmp #128d	;
      E5BE 30 0B      001192 |	bmi ErrOpndS	;
                      001193 |	
      E5C0            001194 |OffOk:			;If offset is OK then put it in Obj2 and return.
      E5C0 8D 1B 00   001195 |	sta Obj2	;
      E5C3 A9 01      001196 |	lda #1d		;
      E5C5 8D 1D 00   001197 |	sta Obj2Flg	;
      E5C8 4C CD E5   001198 |	jmp ExtOpndS	;
                      001199 |	
      E5CB            001200 |ErrOpndS:
      E5CB 18         001201 |	clc
      E5CC 60         001202 |	rts
                      001203 |	
      E5CD            001204 |ExtOpndS:
      E5CD 38         001205 |	sec
      E5CE 60         001206 |	rts
                      001207 |
                      001208 |
                      001209 |;****************************************************************************
                      001210 |;                     Scan For Hex Digit Subroutine.
                      001211 |;****************************************************************************
      E5CF            001212 |ScnForHex:
      E5CF A2 14      001213 |	ldx #20d		
                      001214 |	
      E5D1            001215 |SFHNxtDg:
      E5D1 A0 00      001216 |	ldy #0d		;Scan until either an upper case or a lower case
      E5D3 BD 5F 00   001217 |	lda OpFld1,x	; hex digit is encountered in the input buffer.
      E5D6            001218 |SFHCkDgt:		;
      E5D6 D9 53 F4   001219 |	cmp DgtTblUC,y	;
      E5D9 F0 17      001220 |	beq ExitSFH	;
      E5DB D9 64 F4   001221 |	cmp DgtTblLC,y	;
      E5DE F0 12      001222 |	beq ExitSFH	;
      E5E0 C8         001223 |	iny		;
      E5E1 C0 10      001224 |	cpy #16d	;
      E5E3 F0 03      001225 |	beq IncBfPtr	;
      E5E5 4C D6 E5   001226 |	jmp SFHCkDgt	;
                      001227 |
      E5E8            001228 |IncBfPtr:		;Point to the next digit in the input buffer.
      E5E8 E8         001229 |	inx		;
      E5E9 E0 1F      001230 |	cpx #31d	;
      E5EB F0 03      001231 |	beq ErrSFH	;
      E5ED 4C D1 E5   001232 |	jmp SFHNxtDg	;
                      001233 |
      E5F0            001234 |ErrSFH:
      E5F0 18         001235 |	clc
      E5F1 60         001236 |	rts
                      001237 |	
      E5F2            001238 |ExitSFH:
      E5F2 38         001239 |	sec
      E5F3 60         001240 |	rts
                      001241 |	
                      001242 |	
                      001243 |;****************************************************************************
                      001244 |;                       Breakpoint Command Subroutine.
                      001245 |;****************************************************************************
      E5F4            001246 |BreakPnt:
      E5F4 AD 5F 00   001247 |	lda OpFld1	;Check for a +, - or a ? in operand field #1.
      E5F7 C9 2B      001248 |	cmp #43d	;
      E5F9 F0 0B      001249 |	beq DoPlus	;
      E5FB C9 2D      001250 |	cmp #45d	;
      E5FD F0 0A      001251 |	beq DoMinus	;
      E5FF C9 3F      001252 |	cmp #63d	;
      E601 F0 09      001253 |	beq DmpBPAdd	;
      E603 4C 14 E7   001254 |	jmp ExitBP	;
      E606            001255 |DoPlus:		;
      E606 4C 80 E6   001256 |	jmp Plus	;
      E609            001257 |DoMinus:		;
      E609 4C 3C E6   001258 |	jmp Minus	;
                      001259 |	
      E60C            001260 |DmpBPAdd:
      E60C A2 DD      001261 |	ldx #CRLF<	;If question mark was entered then dump current
      E60E A0 F4      001262 |	ldy #CRLF>	; breakpoints.
      E610 20 B3 F3   001263 |	jsr PrntMess	;
      E613 A0 FF      001264 |	ldy #0ffh	;
      E615 A2 FF      001265 |	ldx #0ffh	;
      E617            001266 |OtAdAgin:		;
      E617 C8         001267 |	iny		;
      E618 E8         001268 |	inx		;
      E619 B9 12 00   001269 |	lda BrkPt1Ad,y	;
      E61C 8D 08 00   001270 |	sta PointerA	;
      E61F C8         001271 |	iny		;
      E620 B9 12 00   001272 |	lda BrkPt1Ad,y	;
      E623 8D 09 00   001273 |	sta PointerA+1d	;
      E626 BD 2F 00   001274 |	lda BrkPt1St,x	;
      E629 F0 03      001275 |	beq AdEmpty	;
      E62B 20 26 F3   001276 |	jsr PrntAdd	;
      E62E            001277 |AdEmpty:		;
      E62E C0 07      001278 |	cpy #7d		;
      E630 D0 E5      001279 |	bne OtAdAgin	;
      E632 A2 DD      001280 |	ldx #CRLF<	;
      E634 A0 F4      001281 |	ldy #CRLF>	;
      E636 20 B3 F3   001282 |	jsr PrntMess	;
      E639 4C 14 E7   001283 |	jmp ExitBP	;
                      001284 |	
      E63C            001285 |Minus:
      E63C AD 73 00   001286 |	lda OpFld2	;If minus was found in operand field #1 check for
      E63F C9 00      001287 |	cmp #0d		; an address in operand field #2.  If no address
      E641 F0 0A      001288 |	beq ClrAllBP	; was found then clear all breakpoints, if an
      E643 A2 14      001289 |	ldx #20d	; address was found then clear that one breakpoint.
      E645 20 E4 F2   001290 |	jsr GetAdd	;
      E648 B0 10      001291 |	bcs Clr1BP	;
      E64A 4C 14 E7   001292 |	jmp ExitBP	;
                      001293 |	
      E64D            001294 |ClrAllBP:
      E64D A0 03      001295 |	ldy #3d		;Clear all breakpoints.
      E64F            001296 |ZeroBP:		;
      E64F A9 00      001297 |	lda #0d		;
      E651 99 2F 00   001298 |	sta BrkPt1St,y	;
      E654 88         001299 |	dey		;
      E655 10 F8      001300 |	bpl ZeroBP	;
      E657 4C 14 E7   001301 |	jmp ExitBP	;
                      001302 |	
      E65A            001303 |Clr1BP:
      E65A 8E 2B 00   001304 |	stx TempAdd	;Search for a match between a breakpoint address
      E65D 8C 2C 00   001305 |	sty TempAdd+1d	; in the breakpoint address table and the address
      E660 A0 03      001306 |	ldy #3d		; that was entered.
      E662 A2 06      001307 |	ldx #6d		;
      E664            001308 |CkBPAdd:		;
      E664 20 15 E7   001309 |	jsr CmpBPAdd	;
      E667 B0 0F      001310 |	bcs FoundBP	;
      E669 88         001311 |	dey		;
      E66A CA         001312 |	dex		;
      E66B CA         001313 |	dex		;
      E66C 10 F6      001314 |	bpl CkBPAdd	;
                      001315 |	
      E66E            001316 |BPNtFnd:		
      E66E A2 EC      001317 |	ldx #NoBPMess<	;If no match was found then print an error message
      E670 A0 F5      001318 |	ldy #NoBPMess>	; and exit.
      E672 20 B3 F3   001319 |	jsr PrntMess	;
      E675 4C 14 E7   001320 |	jmp ExitBP	;
                      001321 |	
      E678            001322 |FoundBP:
      E678 A9 00      001323 |	lda #0d		;If match was found then zero out that breakpoint's
      E67A 99 2F 00   001324 |	sta BrkPt1St,y	; status indicator and exit.
      E67D 4C 14 E7   001325 |	jmp ExitBP	;
                      001326 |
      E680            001327 |Plus:
      E680 AD 73 00   001328 |	lda OpFld2	;If a plus was entered then check operand field
      E683 C9 00      001329 |	cmp #0d		; #2 for the address of the new breakpoint.
      E685 F0 07      001330 |	beq OutBP2	;
      E687 A2 14      001331 |	ldx #20d	;
      E689 20 E4 F2   001332 |	jsr GetAdd	;
      E68C B0 03      001333 |	bcs BPAdOk	;
      E68E            001334 |OutBP2:		;
      E68E 4C 14 E7   001335 |	jmp ExitBP	;
                      001336 |
                      001337 |
      E691            001338 |BPAdOk:
      E691 8E 2B 00   001339 |	stx TempAdd	;
      E694 8C 2C 00   001340 |	sty TempAdd+1d	;
      E697 A0 03      001341 |	ldy #3d		;Check to make sure that breakpoint address has
      E699 A2 06      001342 |	ldx #6d		; not already been entered into table.
      E69B            001343 |CkBPAddP:		;
      E69B B9 2F 00   001344 |	lda BrkPt1St,y	;
      E69E C9 00      001345 |	cmp #0d		;
      E6A0 F0 05      001346 |	beq NoCmp	;
      E6A2 20 15 E7   001347 |	jsr CmpBPAdd	;
      E6A5 B0 E7      001348 |	bcs OutBP2	;
      E6A7            001349 |NoCmp:			;
      E6A7 88         001350 |	dey		;
      E6A8 CA         001351 |	dex		;
      E6A9 CA         001352 |	dex		;
      E6AA 10 EF      001353 |	bpl CkBPAddP	;
                      001354 |	
                      001355 |
      E6AC A0 00      001356 |	ldy #0d		;If a plus was entered then search breakpoint
      E6AE            001357 |CkNxtBP:		;
      E6AE B9 2F 00   001358 |	lda BrkPt1St,y	; status indicators for an empty breakpoint slot.
      E6B1 C9 00      001359 |	cmp #0d		;
      E6B3 F0 0F      001360 |	beq EmptyBP	;
      E6B5 C8         001361 |	iny		;
      E6B6 C0 04      001362 |	cpy #4d		;
      E6B8 D0 F4      001363 |	bne CkNxtBP	;
                      001364 |	
      E6BA            001365 |AllBPFull:
      E6BA A2 C4      001366 |	ldx #BPFulMes<	;If all breakpoints are full then print an error
      E6BC A0 F5      001367 |	ldy #BPFulMes>	; message and exit.
      E6BE 20 B3 F3   001368 |	jsr PrntMess	;
      E6C1 4C 14 E7   001369 |	jmp ExitBP	;
                      001370 |	
      E6C4            001371 |EmptyBP:
      E6C4 8C 37 00   001372 |	sty BPNumHld	;
      E6C7 A9 01      001373 |	lda #1d		;
      E6C9 99 2F 00   001374 |	sta BrkPt1St,y	;
                      001375 |	
                      001376 |	
      E6CC            001377 |NxtBPSlt0:
      E6CC C0 00      001378 |	cpy #0d		;Store new address in first position of
      E6CE D0 0F      001379 |	bne NxtBPSlt1	; breakpoint table.
      E6D0 AD 2B 00   001380 |	lda TempAdd	;
      E6D3 8D 12 00   001381 |	sta BrkPt1Ad	;
      E6D6 AD 2C 00   001382 |	lda TempAdd+1d	;
      E6D9 8D 13 00   001383 |	sta BrkPt1Ad+1d	;
      E6DC 4C 14 E7   001384 |	jmp ExitBP	;
                      001385 |	
      E6DF            001386 |NxtBPSlt1:		;
      E6DF C0 01      001387 |	cpy #1d		;Store new address in second position of
      E6E1 D0 0F      001388 |	bne NxtBPSlt2	; breakpoint table.
      E6E3 AD 2B 00   001389 |	lda TempAdd	;
      E6E6 8D 14 00   001390 |	sta BrkPt2Ad	;
      E6E9 AD 2C 00   001391 |	lda TempAdd+1d	;
      E6EC 8D 15 00   001392 |	sta BrkPt2Ad+1d	;
      E6EF 4C 14 E7   001393 |	jmp ExitBP	;
                      001394 |	
      E6F2            001395 |NxtBPSlt2:		;
      E6F2 C0 02      001396 |	cpy #2d		;Store new address in third position of
      E6F4 D0 0F      001397 |	bne NxtBPSlt3	; breakpoint table.
      E6F6 AD 2B 00   001398 |	lda TempAdd	;
      E6F9 8D 16 00   001399 |	sta BrkPt3Ad	;
      E6FC AD 2C 00   001400 |	lda TempAdd+1d	;
      E6FF 8D 17 00   001401 |	sta BrkPt3Ad+1d	;
      E702 4C 14 E7   001402 |	jmp ExitBP	;
                      001403 |	
      E705            001404 |NxtBPSlt3:		;
      E705 AD 2B 00   001405 |	lda TempAdd	;Store new address in forth position of
      E708 8D 18 00   001406 |	sta BrkPt4Ad	; breakpoint table.
      E70B AD 2C 00   001407 |	lda TempAdd+1d	;
      E70E 8D 19 00   001408 |	sta BrkPt4Ad+1d	;
      E711 4C 14 E7   001409 |	jmp ExitBP	;
                      001410 |
      E714            001411 |ExitBP:
      E714 60         001412 |	rts
                      001413 |
                      001414 |
                      001415 |;****************************************************************************
                      001416 |;                   Compare Breakpoint Address Subroutine.
                      001417 |;****************************************************************************
      E715            001418 |CmpBPAdd:
      E715 C0 00      001419 |	cpy #0d		;Compare LSB of first breakpoint address.
      E717 D0 0B      001420 |	bne CmpNxt1	;
      E719 AD 2C 00   001421 |	lda TempAdd+1d	;
      E71C CD 13 00   001422 |	cmp BrkPt1Ad+1d	;
      E71F F0 2C      001423 |	beq CChkFLSB	;
      E721 4C 5A E7   001424 |	jmp NoMatch 	;
                      001425 |	
      E724            001426 |CmpNxt1:		;
      E724 C0 01      001427 |	cpy #1d		;Compare MSB of second breakpoint address.
      E726 D0 0B      001428 |	bne CmpNxt2	;
      E728 AD 2C 00   001429 |	lda TempAdd+1d	;
      E72B CD 15 00   001430 |	cmp BrkPt2Ad+1d	;
      E72E F0 1D      001431 |	beq CChkFLSB	;
      E730 4C 5A E7   001432 |	jmp NoMatch 	;
                      001433 |	
      E733            001434 |CmpNxt2:		;
      E733 C0 02      001435 |	cpy #2d		;Compare MSB of third breakpoint address.
      E735 D0 0B      001436 |	bne CmpNxt3	;
      E737 AD 2C 00   001437 |	lda TempAdd+1d	;
      E73A CD 17 00   001438 |	cmp BrkPt3Ad+1d	;
      E73D F0 0E      001439 |	beq CChkFLSB	;
      E73F 4C 5A E7   001440 |	jmp NoMatch 	;
                      001441 |	
      E742            001442 |CmpNxt3:		;
      E742 AD 2C 00   001443 |	lda TempAdd+1d	;Compare MSB of forth breakpoint address.
      E745 CD 19 00   001444 |	cmp BrkPt4Ad+1d	;
      E748 F0 03      001445 |	beq CChkFLSB	;
      E74A 4C 5A E7   001446 |	jmp NoMatch 	;
                      001447 |	
      E74D            001448 |CChkFLSB:
      E74D AD 2B 00   001449 |	lda TempAdd	;Compare LSB of breakpoint address.
      E750 DD 12 00   001450 |	cmp BrkPt1Ad,x	;
      E753 F0 03      001451 |	beq BPMatch	;
      E755 4C 5A E7   001452 |	jmp NoMatch	;
                      001453 |	
      E758            001454 |BPMatch:		;Return with carry set if addresses match.
      E758 38         001455 |	sec		;
      E759 60         001456 |	rts		;
                      001457 |	
      E75A            001458 |NoMatch:		;Return with carry cleared if addresses
      E75A 18         001459 |	clc		; do not match.
      E75B 60         001460 |	rts		;
                      001461 |
                      001462 |
                      001463 |;****************************************************************************
                      001464 |;                     Dump command Subroutine
                      001465 |;****************************************************************************
      E75C            001466 |Dump:
                      001467 |	
      E75C A2 00      001468 |	ldx #0h
                      001469 |	
      E75E BD 5F 00   001470 |	lda OpFld1,x	;If no operands then do a standard dump.
      E761 C9 00      001471 |	cmp #0h		;
      E763 F0 3A      001472 |	beq DoStdDmp	;
                      001473 |
      E765 20 3D F3   001474 |	jsr AsToBin	;Get start address from operand field #1 and place
      E768 B0 03      001475 |	bcs DgtOk1	; in zero page pointer.
      E76A 4C 20 E8   001476 |	jmp ErrDump	;
      E76D            001477 |DgtOk1:		;
      E76D 8D 09 00   001478 |	sta PointerA+1d	;
      E770 E8         001479 |	inx		;
      E771 20 3D F3   001480 |	jsr AsToBin	;
      E774 B0 03      001481 |	bcs DgtOk2	;
      E776 4C 20 E8   001482 |	jmp ErrDump	;
      E779            001483 |DgtOk2:		;
      E779 8D 08 00   001484 |	sta PointerA	;
                      001485 |	
      E77C A2 14      001486 |	ldx #20d	;If no end address was entered then perform a
      E77E BD 5F 00   001487 |	lda OpFld1,x	; standard dump.
      E781 C9 00      001488 |	cmp #0h		;
      E783 F0 1A      001489 |	beq DoStdDmp	;
                      001490 |	
      E785 20 3D F3   001491 |	Jsr AsToBin	;Get end address from operand field #2 and place
      E788 B0 03      001492 |	bcs OpFldOk1	; in the variable EndAdd.
      E78A 4C 20 E8   001493 |	jmp ErrDump	;
      E78D            001494 |OpFldOk1:		;
      E78D 8D 5D 00   001495 |	sta EndAdd+1d	;
      E790 E8         001496 |	inx 		;
      E791 20 3D F3   001497 |	jsr AsToBin	;
      E794 B0 03      001498 |	bcs OpFldOk2	;
      E796 4C 20 E8   001499 |	jmp ErrDump	;
      E799            001500 |OpFldOk2:		;
      E799 8D 5C 00   001501 |	sta EndAdd	;
                      001502 |	
      E79C 4C B6 E7   001503 |	jmp DoDump	
                      001504 |	
      E79F            001505 |DoStdDmp:
      E79F AD 09 00   001506 |	lda PointerA+1d	;Adjust end address so that it will only dump the
      E7A2 8D 5D 00   001507 |	sta EndAdd+1d	; contents of 16 memory locations.
      E7A5 AD 08 00   001508 |	lda PointerA	;
      E7A8 8D 5C 00   001509 |	sta EndAdd	;
      E7AB 18         001510 |	clc   		;Note: check to make sure this is correct.
      E7AC 69 0F      001511 |	adc #15d	;
      E7AE 8D 5C 00   001512 |	sta EndAdd	;
      E7B1 90 03      001513 |	bcc DoDump	;
      E7B3 EE 5D 00   001514 |	inc EndAdd+1d	;
                      001515 |	
      E7B6            001516 |DoDump:
      E7B6 A9 0D      001517 |	lda #13d	;Output a CRLF.
      E7B8 20 14 F4   001518 |	jsr OutChar	;
      E7BB A9 0A      001519 |	lda #10d	;
      E7BD 20 14 F4   001520 |	jsr OutChar	;
                      001521 |
      E7C0 A2 00      001522 |	ldx #0d		;
      E7C2 A0 00      001523 |	ldy #0d		;
                      001524 |
      E7C4 20 26 F3   001525 |	jsr PrntAdd	;Output address of first dump memory location.
                      001526 |	
      E7C7            001527 |DumpAgin:
      E7C7 B1 08      001528 |	lda (PointerA),y;Get byte from memory location.
                      001529 |
      E7C9 20 44 E8   001530 |	jsr PutASCBf	;Put character in ASCII buffer.
                      001531 |	
      E7CC 20 5F F3   001532 |	jsr OutHex	;Convert to ASCII/Hex and print.
                      001533 |	
      E7CF E8         001534 |	inx
      E7D0 E0 10      001535 |	cpx #16d	;
      E7D2 D0 03      001536 |	bne Chk8	;
      E7D4 20 2C E8   001537 |	jsr DumpASC	;Output ASCII interpretion of dumped line.
                      001538 |	
      E7D7            001539 |Chk8:			;
      E7D7 E0 08      001540 |	cpx #8d		;Put a '-' between the 8th and 9th bex bytes on
      E7D9 D0 12      001541 |	bne OutSpc	; the dump screen.
      E7DB A9 20      001542 |	lda #32d	;
      E7DD 20 14 F4   001543 |	jsr OutChar	;
      E7E0 A9 2D      001544 |	lda #45d	;
      E7E2 20 14 F4   001545 |	jsr OutChar	;
      E7E5 A9 20      001546 |	lda #32d	;
      E7E7 20 14 F4   001547 |	jsr OutChar	;
      E7EA 4C F2 E7   001548 |	jmp ChkEndAd	;
                      001549 |	
      E7ED            001550 |OutSpc:
      E7ED A9 20      001551 |	lda #32d	;Print a space between hex characters on dump screen.
      E7EF 20 14 F4   001552 |	jsr OutChar	;
                      001553 |	
      E7F2            001554 |ChkEndAd:
      E7F2 AD 08 00   001555 |	lda PointerA	;Check pointer against end address holder.  Exit
      E7F5 CD 5C 00   001556 |	cmp EndAdd	; subroutine if the end address has been reached,
      E7F8 D0 08      001557 |	bne PointNxt	; increment pointer and dump the contents of 
      E7FA AD 09 00   001558 |	lda PointerA+1d	; another memory location if not.
      E7FD CD 5D 00   001559 |	cmp EndAdd+1d	;
      E800 F0 20      001560 |	beq ExitDump	;
      E802            001561 |PointNxt:
      E802 EE 08 00   001562 |	inc PointerA	;
      E805 D0 03      001563 |	bne NoCary2	;
      E807 EE 09 00   001564 |	inc PointerA+1d	;
      E80A            001565 |NoCary2:		;
                      001566 |
      E80A            001567 |ChkCR:			;Perform end of dump line functions.
      E80A E0 10      001568 |	cpx #16d	;
      E80C D0 0F      001569 |	bne NotEnd	;
                      001570 |	
      E80E A9 0A      001571 |	lda #10d	;Print a CRLF and reset X register to point to
      E810 20 14 F4   001572 |	jsr OutChar	; beginning of new dump line.
      E813 A9 0D      001573 |	lda #13d	;
      E815 20 14 F4   001574 |	jsr Outchar	;
      E818 20 26 F3   001575 |	jsr PrntAdd	;
      E81B A2 00      001576 |	ldx #0d		;
      E81D            001577 |NotEnd:
                      001578 |	
      E81D 4C C7 E7   001579 |	jmp DumpAgin	;
                      001580 |
      E820            001581 |ErrDump:
      E820 18         001582 |	clc
      E821 60         001583 |	rts
                      001584 |
      E822            001585 |ExitDump:
      E822 EE 08 00   001586 |	inc PointerA	;Point to next location in memory to be dumped
      E825 D0 03      001587 |	bne NoCary3	;
      E827 EE 09 00   001588 |	inc PointerA+1d	;
      E82A            001589 |NoCary3:		;
      E82A 38         001590 |	sec
      E82B 60         001591 |	rts
                      001592 |
                      001593 |;****************************************************************************
                      001594 |;                 Output the ASCII interpretation of the dumped line.
                      001595 |;****************************************************************************
      E82C            001596 |DumpASC:
      E82C A9 20      001597 |	lda #32d	;
      E82E 20 14 F4   001598 |	jsr OutChar	;
      E831 A9 20      001599 |	lda #32d	;
      E833 20 14 F4   001600 |	jsr OutChar	;
      E836 A2 00      001601 |	ldx #0d		;
      E838            001602 |OutAsc:
      E838 BD 4C 00   001603 |	lda ASCIIbuf,x	;
      E83B 20 14 F4   001604 |	jsr OutChar	;
      E83E E8         001605 |	inx		;
      E83F E0 10      001606 |	cpx #16d	;
      E841 D0 F5      001607 |	bne OutAsc	;
      E843 60         001608 |	rts
                      001609 |
                      001610 |
                      001611 |;****************************************************************************
                      001612 |;         Put byte from memory into ASCII buffer from Dump command.
                      001613 |;****************************************************************************
      E844            001614 |PutASCBf:
      E844 48         001615 |	pha
      E845 C9 20      001616 |	cmp #32d
      E847 30 0A      001617 |	bmi Period
      E849 C9 7F      001618 |	cmp #127d
      E84B 10 06      001619 |	bpl Period
      E84D 9D 4C 00   001620 |	sta ASCIIbuf,x
      E850 4C 58 E8   001621 |	jmp ExitPut
      E853            001622 |Period:
      E853 A9 2E      001623 |	lda #46d
      E855 9D 4C 00   001624 |	sta ASCIIbuf,x
      E858            001625 |ExitPut:
      E858 68         001626 |	pla
      E859 60         001627 |	rts
                      001628 |	
                      001629 |;****************************************************************************
                      001630 |;                        Enter Command Subroutine.
                      001631 |;****************************************************************************
      E85A            001632 |Enter:
      E85A AD 5F 00   001633 |	lda OpFld1	;Check for operand in operand field #1.
      E85D C9 00      001634 |	cmp #0d		;
      E85F D0 03      001635 |	bne ChkOp2	;
      E861 4C 88 E8   001636 |	jmp ErrEntr	;
                      001637 |	
      E864            001638 |ChkOp2:
      E864 AD 73 00   001639 |	lda OpFld2	;Check for operand in operand field #2.
      E867 C9 00      001640 |	cmp #0d		;
      E869 D0 03      001641 |	bne ProcEntr	;
      E86B 4C 88 E8   001642 |	jmp ErrEntr	;
                      001643 |	
      E86E            001644 |ProcEntr:
      E86E A2 00      001645 |	ldx #0d		;Get address from operand field #1.
      E870 20 E4 F2   001646 |	jsr GetAdd	;
      E873 B0 03      001647 |	bcs EnAddOk	;
      E875 4C 88 E8   001648 |	jmp ErrEntr	;
                      001649 |
      E878            001650 |EnAddOk:
      E878 8E 08 00   001651 |	stx PointerA	;Put address from operand field #1 into
      E87B 8C 09 00   001652 |	sty PointerA+1d	; zero page variable Pointer.
                      001653 |	
      E87E A2 14      001654 |	ldx #20d	;Get list of bytes to be entered into memory
      E880 20 8C E8   001655 |	jsr GetList	; from operand field #2 and put them in memory
      E883 90 03      001656 |	bcc ErrEntr	; starting at Pointer.
      E885 4C 8A E8   001657 |	jmp ExitEntr	;
                      001658 |	
      E888            001659 |ErrEntr:
      E888 18         001660 |	clc
      E889 60         001661 |	rts	
                      001662 |
      E88A            001663 |ExitEntr:
      E88A 38         001664 |	sec
      E88B 60         001665 |	rts
                      001666 |
                      001667 |
                      001668 |;****************************************************************************
                      001669 |;                        Get List Subroutine
                      001670 |;
                      001671 |;	Zero page variable Pointer points to location in memory where
                      001672 |;	 list members will be placed.
                      001673 |;****************************************************************************
      E88C            001674 |GetList:
      E88C A0 00      001675 |	ldy #0d
                      001676 |	
      E88E 8C CF 00   001677 |	sty DataTemp	;Use this variable to count bytes in list.	
                      001678 |	
      E891            001679 |GLNxtByt:
      E891 BD 5F 00   001680 |	lda OpFld1,x	;Check for NULL that terminates current
      E894 F0 28      001681 |	beq ListErr	; operand field.
                      001682 |	
      E896 20 3D F3   001683 |	jsr AsToBin	;Convert byte in list to binary form and place
      E899 B0 03      001684 |	bcs StInMem	; in memory.
      E89B 4C BE E8   001685 |	jmp ListErr	;
      E89E            001686 |StInMem:		;
      E89E 91 08      001687 |	sta (PointerA),y;
      E8A0 EE 08 00   001688 |	inc PointerA	;
      E8A3 D0 03      001689 |	bne LstNoOv	;
      E8A5 EE 09 00   001690 |	inc PointerA+1d	;
      E8A8            001691 |LstNoOv:		;
      E8A8 EE CF 00   001692 |	inc DataTemp	;
      E8AB AD CF 00   001693 |	lda DataTemp	;
      E8AE C9 0A      001694 |	cmp #10d	;
      E8B0 F0 0A      001695 |	beq ExtGtLst	;
                      001696 |	
      E8B2 E8         001697 |	inx		;Point to comma between bytes.
                      001698 |
      E8B3 BD 5F 00   001699 |	lda OpFld1,x	;Check for NULL that terminates current
      E8B6 F0 04      001700 |	beq ExtGtLst	; operand field.
                      001701 |	
      E8B8 E8         001702 |	inx		;Point to next byte in list.
                      001703 |	
      E8B9 4C 91 E8   001704 |	jmp GLNxtByt	;
                      001705 |	
      E8BC            001706 |ExtGtLst:
      E8BC 38         001707 |	sec
      E8BD 60         001708 |	rts
                      001709 |
      E8BE            001710 |ListErr:
      E8BE 18         001711 |	clc
      E8BF 60         001712 |	rts
                      001713 |
                      001714 |;****************************************************************************
                      001715 |;                        Fill Command Subroutine.
                      001716 |;****************************************************************************
      E8C0            001717 |Fill:
                      001718 |
      E8C0 A2 00      001719 |	ldx #0d		;Get start address.
      E8C2 20 E4 F2   001720 |	jsr GetAdd	;
      E8C5 B0 03      001721 |	bcs FAdd1ok	;
      E8C7 4C FD E8   001722 |	jmp ErrFill	;
      E8CA            001723 |FAdd1ok:		;
      E8CA 8E 08 00   001724 |	stx PointerA	;
      E8CD 8C 09 00   001725 |	sty PointerA+1d	;
                      001726 |	
      E8D0 A2 14      001727 |	ldx #20d	;Get end address.
      E8D2 20 E4 F2   001728 |	jsr GetAdd	;
      E8D5 B0 03      001729 |	bcs FAdd2ok	;
      E8D7 4C FD E8   001730 |	jmp ErrFill	;
      E8DA            001731 |FAdd2ok:		;
      E8DA 8E 5C 00   001732 |	stx EndAdd	;
      E8DD 8C 5D 00   001733 |	sty EndAdd+1d	;
                      001734 |	
      E8E0            001735 |FillAgin:
      E8E0 A2 28      001736 |	ldx #40d	;Get list and place in memory.
      E8E2 20 8C E8   001737 |	jsr GetList	;
      E8E5 90 16      001738 |	bcc ErrFill	;
                      001739 |
      E8E7 AD 5D 00   001740 |	lda EndAdd+1d	;Check to see if end address has been reached.
      E8EA CD 09 00   001741 |	cmp PointerA+1d	;
      E8ED F0 03      001742 |	beq ChkFLSB	;
                      001743 |;	bmi ExitFill 	;
      E8EF 4C E0 E8   001744 |	jmp FillAgin 	;
      E8F2            001745 |ChkFLSB:
      E8F2 AD 5C 00   001746 |	lda EndAdd	; 
      E8F5 CD 08 00   001747 |	cmp PointerA	;
      E8F8 F0 05      001748 |	beq ExitFill	;
                      001749 |	
      E8FA 4C E0 E8   001750 |	jmp  FillAgin	;
                      001751 |	
                      001752 |
      E8FD            001753 |ErrFill:
      E8FD 18         001754 |	clc
      E8FE 60         001755 |	rts
                      001756 |
      E8FF            001757 |ExitFill:
      E8FF 38         001758 |	sec
      E900 60         001759 |	rts
                      001760 |
                      001761 |;****************************************************************************
                      001762 |;                        Go Command Subroutine
                      001763 |;****************************************************************************
      E901            001764 |Go:
                      001765 |
      E901 AD 5F 00   001766 |	lda OpFld1	;Check for operand.
      E904 C9 00      001767 |	cmp #0d		;
      E906 F0 10      001768 |	beq CurentPC	;
                      001769 |			
      E908 A2 00      001770 |	ldx #0d		;Get address from operand field #1.
      E90A 20 E4 F2   001771 |	jsr GetAdd	;
      E90D B0 03      001772 |	bcs GAddOk	;
      E90F 4C 7E E9   001773 |	jmp ErrGo	;
                      001774 |	
      E912            001775 |GAddOk:		;
      E912 8E 45 00   001776 |	stx UPgmCntr	;
      E915 8C 46 00   001777 |	sty UPgmCntr+1d	;
                      001778 |
      E918            001779 |CurentPC:
      E918 AE 45 00   001780 |	ldx UPgmCntr	;
      E91B 8E 2B 00   001781 |	stx TempAdd	;
      E91E AC 46 00   001782 |	ldy UPgmCntr+1d	;
      E921 8C 2C 00   001783 |	sty TempAdd+1d	;
      E924 A0 03      001784 |	ldy #3d		;Check to make sure that breakpoint address has
      E926 A2 06      001785 |	ldx #6d		; not already been entered into table.
      E928            001786 |CkBPAddG:		;
      E928 B9 2F 00   001787 |	lda BrkPt1St,y	;
      E92B C9 00      001788 |	cmp #0d		;
      E92D F0 05      001789 |	beq NoCmpG	;
      E92F 20 15 E7   001790 |	jsr CmpBPAdd	;
      E932 B0 08      001791 |	bcs MaError	;
      E934            001792 |NoCmpG:		;
      E934 88         001793 |	dey		;
      E935 CA         001794 |	dex		;
      E936 CA         001795 |	dex		;
      E937 10 EF      001796 |	bpl CkBPAddG	;
      E939 4C 46 E9   001797 |	jmp NoMatchG	;
                      001798 |
      E93C            001799 |MaError:
      E93C A2 14      001800 |	ldx #GoBPErrM<	;If breakpoint exists at GO address then print
      E93E A0 F6      001801 |	ldy #GoBPErrM>	; error message and exit.
      E940 20 B3 F3   001802 |	jsr PrntMess	;
      E943 4C 80 E9   001803 |	jmp ExitGo	;
                      001804 |
      E946            001805 |NoMatchG:
      E946 A0 03      001806 |	ldy #3d		;Check all active breakpoints in table, save
      E948 A2 06      001807 |	ldx #6d		; the opcodes of the breakpointed addresses, 
      E94A            001808 |CkBPSt:		;
      E94A B9 2F 00   001809 |	lda BrkPt1St,y	; and replace them with BRKs.
      E94D C9 01      001810 |	cmp #1d		;
      E94F D0 09      001811 |	bne NxtBPSt	;
      E951 A1 12      001812 |	lda (BrkPt1Ad,x);
      E953 99 33 00   001813 |	sta BP1OpHld,y	;
      E956 A9 00      001814 |	lda #0d		;
      E958 81 12      001815 |	sta (BrkPt1Ad,x);
      E95A            001816 |NxtBPSt:		;
      E95A 88         001817 |	dey		;
      E95B CA         001818 |	dex		;
      E95C CA         001819 |	dex		;
      E95D 10 EB      001820 |	bpl CkBPSt	;
                      001821 |
      E95F 68         001822 |	pla		;Remove Go command's return address and the check
      E960 68         001823 |	pla		; command's return address from the stack.
      E961 68         001824 |	pla		;
      E962 68         001825 |	pla		;
                      001826 |    
      E963 AD 5F 00   001827 |    lda OpFld1	;Check for operand.
      E966 C9 00      001828 |	cmp #0d		;
      E968 F0 11      001829 |	beq DoNotRestoreRegistersGo
                      001830 | 
      E96A A2 FF      001831 |    ldx #0ffh    ;Restore user's registers.
      E96C 9A         001832 |    txs          ;
      E96D AD 4B 00   001833 |    lda UStatReg ;
      E970 48         001834 |	pha          ;
      E971 AD 47 00   001835 |	lda UAccum	 ;
      E974 AE 48 00   001836 |	ldx UXReg	 ;
      E977 AC 49 00   001837 |	ldy UYReg	 ;
      E97A 28         001838 |    plp          ;
                      001839 |   
      E97B            001840 |DoNotRestoreRegistersGo:
                      001841 |	
      E97B 6C 45 00   001842 |	jmp (UPgmCntr)	;Start executing at address being pointed to by
                      001843 |			; UPGmCntr.	
                      001844 |
      E97E            001845 |ErrGo:
      E97E 18         001846 |	clc
      E97F 60         001847 |	rts
                      001848 |	
      E980            001849 |ExitGo:
      E980 38         001850 |	sec
      E981 60         001851 |	rts
                      001852 |
                      001853 |;****************************************************************************
                      001854 |;                       Help Command Subroutine.
                      001855 |;****************************************************************************
      E982            001856 |Help:
      E982 A2 5A      001857 |	ldx #HelpMess<
      E984 A0 F6      001858 |	ldy #HelpMess>
      E986 20 B3 F3   001859 |	jsr PrntMess
      E989 60         001860 |	rts
                      001861 |
                      001862 |;****************************************************************************
                      001863 |;                     Load Command Subroutine
                      001864 |;****************************************************************************
      E98A            001865 |LdSRecs:
      E98A A2 E0      001866 |	ldx #SRecStMs<
      E98C A0 F4      001867 |	ldy #SRecStMs>	
      E98E 20 B3 F3   001868 |	jsr PrntMess
                      001869 |	
      E991 20 F3 F3   001870 |	jsr GetCharW	;Wait for first character of record.
      E994 A2 DD      001871 |	ldx #CRLF<	;
      E996 A0 F4      001872 |	ldy #CRLF>	;
      E998 20 B3 F3   001873 |	jsr PrntMess	;
      E99B 4C A1 E9   001874 |	jmp CkS		;
                      001875 |	
      E99E            001876 |GtAnCh:		;
      E99E 20 F3 F3   001877 |	jsr GetCharW	;Check for an S.
      E9A1            001878 |CkS:			;
      E9A1 C9 53      001879 |	cmp #83d	;
      E9A3 D0 F9      001880 |	bne GtAnCh	;
                      001881 |	
      E9A5 20 14 F4   001882 |	jsr OutChar	;Print an S to the user.
                      001883 |	
      E9A8 20 F3 F3   001884 |	jsr GetCharW	;Get record type ECHO it and store it.
      E9AB 20 14 F4   001885 |	jsr OutChar	;
      E9AE 8D A1 00   001886 |	sta RecType	;
                      001887 |	
      E9B1 C9 30      001888 |	cmp #48d	;Check for header record and process.
      E9B3 D0 08      001889 |	bne NtHdr	;
      E9B5 20 B6 EA   001890 |	jsr ProcHdr	;
      E9B8 90 25      001891 |	bcc SError	;
      E9BA 4C DC E9   001892 |	jmp NextLine	;
                      001893 |	
      E9BD            001894 |NtHdr:			;
      E9BD C9 31      001895 |	cmp #49d	;Check for code record and process.
      E9BF D0 08      001896 |	bne NtCd	;
      E9C1 20 C0 EA   001897 |	jsr ProcCode	;
      E9C4 90 19      001898 |	bcc SError	;
      E9C6 4C DC E9   001899 |	jmp NextLine	;
                      001900 |	
      E9C9            001901 |NtCd:			;
      E9C9 C9 39      001902 |	cmp #57d	;Check for termination record process, and print
      E9CB D0 12      001903 |	bne SError	; records loaded message.
      E9CD 20 CA EA   001904 |	jsr ProcTerm	;
      E9D0 90 0D      001905 |	bcc SError	;
      E9D2 A2 29      001906 |	ldx #SRecEnMs<	;
      E9D4 A0 F5      001907 |	ldy #SRecEnMs>	;
      E9D6 20 B3 F3   001908 |	jsr PrntMess	;
      E9D9 4C E8 E9   001909 |	jmp ExitSRec	;
                      001910 |	
      E9DC            001911 |NextLine:
      E9DC 4C 9E E9   001912 |	jmp GtAnCh
                      001913 |
      E9DF            001914 |SError:
      E9DF A2 09      001915 |	ldx #SRecErMe<
      E9E1 A0 F5      001916 |	ldy #SRecErMe>	
      E9E3 20 B3 F3   001917 |	jsr PrntMess
      E9E6 38         001918 |	sec
      E9E7 60         001919 |	rts
                      001920 |	
      E9E8            001921 |ExitSRec:
      E9E8 20 F3 F3   001922 |	jsr GetCharW
      E9EB 38         001923 |	sec
      E9EC 60         001924 |	rts
                      001925 |	
                      001926 |;****************************************************************************
                      001927 |;                Process Record Length and Address Subroutine
                      001928 |;****************************************************************************
      E9ED            001929 |PrRLeAdd:	
                      001930 |	
      E9ED A9 00      001931 |	lda #0h		;Zero out Checksum accumulator.
      E9EF 8D 9F 00   001932 |	sta CkSumAc	;
      E9F2 8D A0 00   001933 |	sta CkSumAc+1h	;
                      001934 |	
      E9F5 20 5D EA   001935 |	jsr Getnum	;Fetch record length and update checksum
      E9F8 8D 9E 00   001936 |	sta RecLen	; accumulator.
      E9FB 20 84 EA   001937 |	jsr AccCkSum	;
                      001938 |	
      E9FE AA         001939 |	tax		;Adjust code byte counter and store it.
      E9FF CA         001940 |	dex		;
      EA00 CA         001941 |	dex		;
      EA01 CA         001942 |	dex		;
      EA02 8A         001943 |	txa		;
      EA03 8D 9B 00   001944 |	sta CodeCntr	;
                      001945 |	
      EA06 20 5D EA   001946 |	jsr GetNum	;Get most significant byte of address and
      EA09 8D 09 00   001947 |	sta PointerA+1h	; store it.
      EA0C 20 84 EA   001948 |	jsr AccCkSum	;
                      001949 |	
      EA0F 20 5D EA   001950 |	jsr GetNum	;Get least significant byte of address and
      EA12 8D 08 00   001951 |	sta PointerA	; store it.
      EA15 20 84 EA   001952 |	jsr AccCkSum	;
                      001953 |	
      EA18 60         001954 |	rts
                      001955 |	
                      001956 |;****************************************************************************
                      001957 |;        Get Code Byte Without Loading into Memory Subroutine.
                      001958 |;****************************************************************************
      EA19            001959 |GtCodNld:
                      001960 |	
      EA19 AD 9B 00   001961 |	lda CodeCntr
      EA1C F0 0B      001962 |	beq ExitNld
                      001963 |	
      EA1E            001964 |GetOneNl:
      EA1E 20 5D EA   001965 |	jsr GetNum
      EA21 20 84 EA   001966 |	jsr AccCkSum
      EA24 CE 9B 00   001967 |	dec CodeCntr
      EA27 D0 F5      001968 |	Bne GetOneNl
                      001969 |	
      EA29            001970 |ExitNld:
      EA29 60         001971 |	rts
                      001972 |
                      001973 |;****************************************************************************
                      001974 |;        Get Code Byte and Load it into Memory Subroutine.
                      001975 |;****************************************************************************
      EA2A            001976 |GtCodLd:
                      001977 |
      EA2A AD 9B 00   001978 |	lda CodeCntr
      EA2D F0 17      001979 |	beq ExitLd
                      001980 |	
      EA2F A0 00      001981 |	ldy #0h
      EA31            001982 |GtOneLd:
      EA31 20 5D EA   001983 |	jsr GetNum
      EA34 20 84 EA   001984 |	jsr AccCkSum
      EA37 91 08      001985 |	sta (PointerA),y	
      EA39 EE 08 00   001986 |	inc PointerA
      EA3C D0 03      001987 |	bne NxtCode
      EA3E EE 09 00   001988 |	inc PointerA+1h
      EA41            001989 |NxtCode:
      EA41 CE 9B 00   001990 |	dec CodeCntr
      EA44 D0 EB      001991 |	bne GtOneld
                      001992 |	
      EA46            001993 |ExitLd:
      EA46 60         001994 |	rts
                      001995 |
                      001996 |;****************************************************************************
                      001997 |;                      Check Checksum Subroutine.
                      001998 |;****************************************************************************
      EA47            001999 |ChkChkSm:
                      002000 |
      EA47 AD 9F 00   002001 |	lda CkSumAc	;Invert lowest byte of the checksum accumulator
      EA4A 49 FF      002002 |	eor #0ffh	; and store it in CkhSum.
      EA4C 8D 9D 00   002003 |	sta ChkSum	;
                      002004 |	
      EA4F 20 5D EA   002005 |	jsr GetNum	;Compare calculated checksum against S record	
      EA52 CD 9D 00   002006 |	cmp ChkSum	; checksum.
      EA55 F0 04      002007 |	beq CkSumOK	;
      EA57 18         002008 |	clc
      EA58 4C 5C EA   002009 |	jmp Chkexit
      EA5B            002010 |CkSumOK:
      EA5B 38         002011 |	sec
      EA5C            002012 |Chkexit:
      EA5C 60         002013 |	rts
                      002014 |
                      002015 |;****************************************************************************
                      002016 |;                       Get Number Subroutine.
                      002017 |;****************************************************************************
      EA5D            002018 |GetNum:
      EA5D 98         002019 |	tya
      EA5E 48         002020 |	pha
                      002021 |
      EA5F 20 F3 F3   002022 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA62 20 93 EA   002023 |	jsr DgtToBin	; and position hex digit in most significat nibble
      EA65 90 1C      002024 |	bcc ExtGtNum	;
      EA67 0A         002025 |	asl a		; of number.
      EA68 0A         002026 |	asl a		;
      EA69 0A         002027 |	asl a		;
      EA6A 0A         002028 |	asl a		;
      EA6B 29 F0      002029 |	and #0f0h	;
      EA6D 8D 9C 00   002030 |	sta number	;
                      002031 |	
      EA70 20 F3 F3   002032 |	jsr GetCharW	;Get ASCII character, convert to hex digit,
      EA73 20 93 EA   002033 |	jsr DgtToBin	; and position hex digit in least significant
      EA76 90 0B      002034 |	bcc ExtGtNum	;
      EA78 0D 9C 00   002035 |	ora number	; nibble of number.
      EA7B 8D 9C 00   002036 |	sta number	;
                      002037 |	
      EA7E 68         002038 |	pla
      EA7F A8         002039 |	tay
      EA80 AD 9C 00   002040 |	lda number
      EA83            002041 |ExtGtNum:
      EA83 60         002042 |	rts
                      002043 |
                      002044 |;****************************************************************************
                      002045 |;                    Accumulate Checksum Subroutine.
                      002046 |;****************************************************************************
      EA84            002047 |AccCkSum:
      EA84 48         002048 |	pha
      EA85 18         002049 |	clc
      EA86 6D 9F 00   002050 |	adc CkSumAc
      EA89 8D 9F 00   002051 |	sta CkSumAc
      EA8C 90 03      002052 |	bcc NoOvrFlo
      EA8E EE A0 00   002053 |	inc CkSumAc+1h
      EA91            002054 |NoOvrFlo:
      EA91 68         002055 |	pla
      EA92 60         002056 |	rts
                      002057 |
                      002058 |;****************************************************************************
                      002059 |;                ASCII Digit to Binary Number Subroutine.
                      002060 |;
                      002061 |;        Enter with register 'A' containing the number to convert.
                      002062 |;        If the number was valid return its binary conversion in the
                      002063 |;        A register.  If the number is not convertable then clear the
                      002064 |;        carry flag and return.
                      002065 |;****************************************************************************
      EA93            002066 |DgtToBin:
                      002067 |	
      EA93 8E CE 00   002068 |	stx RegTemp	;Save the character to convert.
                      002069 |	
      EA96 A2 00      002070 |	ldx #0h		
                      002071 |	
      EA98            002072 |AnothDgt:
      EA98 DD 53 F4   002073 |	cmp DgtTblUC,x	;Search through character table and try to find
      EA9B F0 13      002074 |	beq Match	; a match for the character present in the X
      EA9D DD 64 F4   002075 |	cmp DgtTblLC,x	; register.
      EAA0 F0 0E      002076 |	beq Match	;
                      002077 |	
      EAA2 E8         002078 |	inx		;If a match was not found then increment the
      EAA3 E0 10      002079 |	cpx #16d	; table index register and check the next
      EAA5 F0 03      002080 |	beq DgtError	; character.  If all the characters have been 
      EAA7 4C 98 EA   002081 |	jmp AnothDgt	; checked then return with an error.
                      002082 |	
      EAAA            002083 |DgtError:
      EAAA A9 00      002084 |	lda #0h
      EAAC 18         002085 |	clc
      EAAD 4C B5 EA   002086 |	jmp DgtExit
                      002087 |
      EAB0            002088 |Match:
      EAB0 8A         002089 |	txa
      EAB1 38         002090 |	sec
                      002091 |	
      EAB2 AE CE 00   002092 |	ldx RegTemp
      EAB5 60         002093 |DgtExit:	rts
                      002094 |	
                      002095 |;****************************************************************************
                      002096 |;                    Process Header Record Subroutine.
                      002097 |;****************************************************************************
                      002098 |
      EAB6            002099 |ProcHdr:
                      002100 |
      EAB6 20 ED E9   002101 |	jsr PrRLeAdd
      EAB9 20 19 EA   002102 |	jsr GtCodNld		
      EABC 20 47 EA   002103 |	jsr ChkChkSm
                      002104 |	
      EABF 60         002105 |	rts
                      002106 |
                      002107 |;****************************************************************************
                      002108 |;                     Process Code Record Subroutine
                      002109 |;****************************************************************************
      EAC0            002110 |ProcCode:
                      002111 |
      EAC0 20 ED E9   002112 |	jsr PrRLeAdd
      EAC3 20 2A EA   002113 |	jsr GtCodLd
      EAC6 20 47 EA   002114 |	jsr ChkChksm
                      002115 |	
      EAC9 60         002116 |	rts
                      002117 |
                      002118 |;****************************************************************************
                      002119 |;                     Process Termination Record Subroutine
                      002120 |;****************************************************************************
      EACA            002121 |ProcTerm:
                      002122 |
      EACA 20 ED E9   002123 |	jsr PrRLeAdd
      EACD 20 19 EA   002124 |	jsr GtCodNld	
      EAD0 20 47 EA   002125 |	jsr ChkChkSm
                      002126 |
      EAD3 60         002127 |	rts
                      002128 |
                      002129 |;****************************************************************************
                      002130 |;                       Move Command Subroutine.
                      002131 |;****************************************************************************
      EAD4            002132 |Move:
      EAD4 AD 5F 00   002133 |	lda OpFld1	;Check for operands.
      EAD7 C9 00      002134 |	cmp #0d		;
      EAD9 F0 07      002135 |	beq MOut	;
                      002136 |
      EADB A2 00      002137 |	ldx #0d		;Get start address.
      EADD 20 E4 F2   002138 |	jsr GetAdd	;
      EAE0 B0 03      002139 |	bcs MAdd1ok	;
      EAE2            002140 |MOut:			;
      EAE2 4C 3F EB   002141 |	jmp ExitMove	;
      EAE5            002142 |MAdd1ok:		;
      EAE5 8E 08 00   002143 |	stx PointerA	;
      EAE8 8C 09 00   002144 |	sty PointerA+1d	;
                      002145 |	
      EAEB A2 14      002146 |	ldx #20d	;Get end address and increment by 1.
      EAED 20 E4 F2   002147 |	jsr GetAdd	;
      EAF0 B0 03      002148 |	bcs MAdd2ok	;
      EAF2 4C 3F EB   002149 |	jmp ExitMove	;
      EAF5            002150 |MAdd2ok:		;
      EAF5 8E 5C 00   002151 |	stx EndAdd	;
      EAF8 8C 5D 00   002152 |	sty EndAdd+1d	;
      EAFB EE 5C 00   002153 |	inc EndAdd	;
      EAFE D0 03      002154 |	bne MNOvFlo	;
      EB00 EE 5D 00   002155 |	inc EndAdd+1d	;
                      002156 |	
      EB03            002157 |MNOvFlo:		;
      EB03 A2 28      002158 |	ldx #40d	;Get destination address.
      EB05 20 E4 F2   002159 |	jsr GetAdd	;
      EB08 B0 03      002160 |	bcs MAdd3ok	;
      EB0A 4C 3F EB   002161 |	jmp ExitMove	;
      EB0D            002162 |MAdd3ok:		;
      EB0D 8E 0A 00   002163 |	stx PointerB	;
      EB10 8C 0B 00   002164 |	sty PointerB+1d	;
                      002165 |
      EB13 A0 00      002166 |	ldy #0d		;Move bytes between start address and end address
      EB15            002167 |MCont:			;to memory starting at destination address.
      EB15 B1 08      002168 |	lda (PointerA),y; 
      EB17 91 0A      002169 |	sta (PointerB),y;
      EB19 EE 0A 00   002170 |	inc PointerB	;
      EB1C D0 03      002171 |	bne MNoOvf1	;
      EB1E EE 0B 00   002172 |	inc PointerB+1d	;
      EB21            002173 |MNoOvf1:		;
      EB21 EE 08 00   002174 |	inc PointerA	;
      EB24 D0 03      002175 |	bne MNoOvf2	;
      EB26 EE 09 00   002176 |	inc PointerA+1d	;
      EB29            002177 |MNoOvf2:		;
      EB29 AD 08 00   002178 |	lda PointerA	;
      EB2C CD 5C 00   002179 |	cmp EndAdd	;
      EB2F F0 03      002180 |	beq MCkMSB	;
      EB31 4C 15 EB   002181 |	jmp MCont	;
      EB34            002182 |MCkMSB:		;
      EB34 AD 09 00   002183 |	lda PointerA+1d	;
      EB37 CD 5D 00   002184 |	cmp EndAdd+1d	;
      EB3A F0 03      002185 |	beq ExitMove	;
      EB3C 4C 15 EB   002186 |	jmp MCont	;
                      002187 |	
      EB3F            002188 |ExitMove:
      EB3F 60         002189 |	rts
                      002190 |
                      002191 |
                      002192 |;****************************************************************************
                      002193 |;                     Register Command Subroutine
                      002194 |;****************************************************************************
      EB40            002195 |Register:
      EB40 48         002196 |	pha
      EB41 8A         002197 |	txa
      EB42 48         002198 |	pha
      EB43 98         002199 |	tya
      EB44 48         002200 |	pha
      EB45 08         002201 |	php
                      002202 |	
      EB46 AD 5F 00   002203 |	lda OpFld1	;Check for operand.
      EB49 C9 00      002204 |	cmp #0d		;
      EB4B F0 03      002205 |	beq GenReg	;
      EB4D 4C B8 EB   002206 |	jmp SpecReg	;
                      002207 |	
      EB50            002208 |GenReg:		;
      EB50 A2 69      002209 |	ldx #RegMess<	;Output register headings.
      EB52 A0 F5      002210 |	ldy #RegMess>	;
      EB54 20 B3 F3   002211 |	jsr PrntMess	;
                      002212 |	
      EB57 A0 03      002213 |	ldy #3d		;Output contents of user's program counter.
      EB59 20 03 F3   002214 |	jsr OutSpace	;
      EB5C AD 46 00   002215 |	lda UPgmCntr+1d	;
      EB5F 20 5F F3   002216 |	jsr OutHex	;
      EB62 AD 45 00   002217 |	lda UPgmCntr	;
      EB65 20 5F F3   002218 |	jsr OutHex	;
                      002219 |	
      EB68 A0 09      002220 |	ldy #9d		;Output contents of user's accumulator.
      EB6A 20 03 F3   002221 |	jsr OutSpace	;
      EB6D AD 47 00   002222 |	lda UAccum	;
      EB70 20 5F F3   002223 |	jsr OutHex	;
                      002224 |	
      EB73 A0 09      002225 |	ldy #9d		;Output contents of user's X register.
      EB75 20 03 F3   002226 |	jsr OutSpace	;
      EB78 AD 48 00   002227 |	lda UXreg	;
      EB7B 20 5F F3   002228 |	jsr OutHex	;
                      002229 |	
      EB7E A0 08      002230 |	ldy #8d		;Output contents of user's Y register.
      EB80 20 03 F3   002231 |	jsr OutSpace	;
      EB83 AD 49 00   002232 |	lda UYReg	;
      EB86 20 5F F3   002233 |	jsr OutHex	;
                      002234 |	
      EB89 A0 08      002235 |	ldy #8d		;Output contents of user's Stack Pointer.
      EB8B 20 03 F3   002236 |	jsr OutSpace	;
      EB8E AD 4A 00   002237 |	lda UStkPtr	;
      EB91 20 5F F3   002238 |	jsr OutHex	;
                      002239 |	
      EB94 A0 07      002240 |	ldy #7d		;Output contents of user's Status register.
      EB96 20 03 F3   002241 |	jsr OutSpace	;
      EB99 AD 4B 00   002242 |	lda UStatReg	;
      EB9C A2 08      002243 |	ldx #8d		;
      EB9E            002244 |NextFlag:		;
      EB9E 2A         002245 |	rol a		;
      EB9F B0 0A      002246 |	bcs OutOne	;
      EBA1            002247 |OutZero:		;
      EBA1 48         002248 |	pha		;
      EBA2 A9 30      002249 |	lda #30h	;
      EBA4 20 14 F4   002250 |	jsr OutChar	;
      EBA7 68         002251 |	pla		;
      EBA8 4C B2 EB   002252 |	jmp CkBtPos	;
      EBAB            002253 |OutOne:		;
      EBAB 48         002254 |	pha		;
      EBAC A9 31      002255 |	lda #31h	;
      EBAE 20 14 F4   002256 |	jsr OutChar	;
      EBB1 68         002257 |	pla		;
      EBB2            002258 |CkBtPos:		;
      EBB2 CA         002259 |	dex		;
      EBB3 D0 E9      002260 |	bne NextFlag	;
      EBB5 4C FD EC   002261 |	jmp ExitReg	;
                      002262 |	
                      002263 |	
      EBB8            002264 |SpecReg:
      EBB8 A9 0D      002265 |	lda #13d
      EBBA 20 14 F4   002266 |	jsr OutChar
      EBBD A9 0A      002267 |	lda #10d
      EBBF 20 14 F4   002268 |	jsr OutChar
      EBC2 AD 5F 00   002269 |	lda OpFld1
      EBC5 20 0E F3   002270 |	jsr ToLower
                      002271 |
      EBC8            002272 |CkPCReg:		;
      EBC8 C9 70      002273 |	cmp #112d	;Get value for Program Counter from user.
      EBCA D0 3C      002274 |	bne CkAReg	;
      EBCC AD 46 00   002275 |	lda UpgmCntr+1d	;
      EBCF 20 5F F3   002276 |	jsr OutHex	;
      EBD2 AD 45 00   002277 |	lda UpgmCntr	;
      EBD5 20 5F F3   002278 |	jsr OutHex	;
      EBD8 20 FB F2   002279 |	jsr OutColn	;
      EBDB 20 A8 E0   002280 |	jsr GetLine	;
      EBDE 20 0E E1   002281 |	jsr ParseOpr	;
      EBE1 AD 5F 00   002282 |	lda OpFld1	;
      EBE4 C9 00      002283 |	cmp #0d		;
      EBE6 D0 03      002284 |	bne GetPC	;
      EBE8 4C FD EC   002285 |	jmp ExitReg	;
      EBEB A2 00      002286 |GetPC:	ldx #0d		;
      EBED 20 3D F3   002287 |	jsr AsToBin	;
      EBF0 B0 03      002288 |	bcs PCMSBOK	;
      EBF2 4C FD EC   002289 |	jmp ExitReg	;
      EBF5 A8         002290 |PCMSBOK:	tay		;
      EBF6 E8         002291 |	inx		;
      EBF7 20 3D F3   002292 |	jsr AsToBin	;
      EBFA B0 03      002293 |	bcs PCLSBOK	;
      EBFC 4C FD EC   002294 |	jmp ExitReg	;
      EBFF 8D 45 00   002295 |PCLSBOK:	sta UPgmCntr	;
      EC02 8C 46 00   002296 |	sty UPgmCntr+1d	;
      EC05 4C FD EC   002297 |	jmp ExitReg	;
                      002298 |	
      EC08            002299 |CkAReg:		;Get value for Accumulator from user.
      EC08 C9 61      002300 |	cmp #97d	;
      EC0A D0 29      002301 |	bne CkXReg	;
      EC0C AD 47 00   002302 |	lda UAccum	;
      EC0F 20 5F F3   002303 |	jsr OutHex	;
      EC12 20 FB F2   002304 |	jsr OutColn	;
      EC15 20 A8 E0   002305 |	jsr GetLine	;
      EC18 20 0E E1   002306 |	jsr ParseOpr	;
      EC1B AD 5F 00   002307 |	lda OpFld1	;
      EC1E C9 00      002308 |	cmp #0d		;
      EC20 D0 03      002309 |	bne GetA	;
      EC22 4C FD EC   002310 |	jmp ExitReg	;
      EC25            002311 |GetA:			;
      EC25 A2 00      002312 |	ldx #0d		;
      EC27 20 3D F3   002313 |	jsr AsToBin	;
      EC2A B0 03      002314 |	bcs AOK		;
      EC2C 4C FD EC   002315 |	jmp ExitReg	;
      EC2F            002316 |AOK:			;
      EC2F 8D 47 00   002317 |	sta UAccum	;
      EC32 4C FD EC   002318 |	jmp ExitReg	;
                      002319 |	
      EC35            002320 |CkXReg:		;Get value for X register from user.
      EC35 C9 78      002321 |	cmp #120d	;
      EC37 D0 29      002322 |	bne CkYReg	;
      EC39 AD 48 00   002323 |	lda UXreg	;
      EC3C 20 5F F3   002324 |	jsr OutHex	;
      EC3F 20 FB F2   002325 |	jsr OutColn	;
      EC42 20 A8 E0   002326 |	jsr GetLine	;
      EC45 20 0E E1   002327 |	jsr ParseOpr	;
      EC48 AD 5F 00   002328 |	lda OpFld1	;
      EC4B C9 00      002329 |	cmp #0d		;
      EC4D D0 03      002330 |	bne GetX	;
      EC4F 4C FD EC   002331 |	jmp ExitReg	;
      EC52            002332 |GetX:			;
      EC52 A2 00      002333 |	ldx #0d		;
      EC54 20 3D F3   002334 |	jsr AsToBin	;
      EC57 B0 03      002335 |	bcs XOK		;
      EC59 4C FD EC   002336 |	jmp ExitReg	;
      EC5C            002337 |XOK:			;
      EC5C 8D 48 00   002338 |	sta UXReg	;
      EC5F 4C FD EC   002339 |	jmp ExitReg	;
                      002340 |	
      EC62            002341 |CkYReg:		;Get value for Y register from user.
      EC62 C9 79      002342 |	cmp #121d	;
      EC64 D0 29      002343 |	bne CkForS	;
      EC66 AD 49 00   002344 |	lda UYReg	;
      EC69 20 5F F3   002345 |	jsr OutHex	;
      EC6C 20 FB F2   002346 |	jsr OutColn	;
      EC6F 20 A8 E0   002347 |	jsr GetLine	;
      EC72 20 0E E1   002348 |	jsr ParseOpr	;
      EC75 AD 5F 00   002349 |	lda OpFld1	;
      EC78 C9 00      002350 |	cmp #0d		;
      EC7A D0 03      002351 |	bne GetY	;
      EC7C 4C FD EC   002352 |	jmp ExitReg	;
      EC7F            002353 |GetY:			;
      EC7F A2 00      002354 |	ldx #0d		;
      EC81 20 3D F3   002355 |	jsr AsToBin	;
      EC84 B0 03      002356 |	bcs YOK		;
      EC86 4C FD EC   002357 |	jmp ExitReg	;
      EC89            002358 |YOK:			;
      EC89 8D 49 00   002359 |	sta UYReg	;
      EC8C 4C FD EC   002360 |	jmp ExitReg	;
                      002361 |	
      EC8F            002362 |CkForS:		;Check if user is accessing the Stack Pointer or
      EC8F C9 73      002363 |	cmp #115d	; the Status Register.
      EC91 F0 03      002364 |	beq CkPorR	;
      EC93 4C F9 EC   002365 |	jmp RegInErr	;
      EC96            002366 |CkPorR:		;
      EC96 AD 60 00   002367 |	lda OpFld1+1d	;
      EC99 20 0E F3   002368 |	jsr ToLower	;
      EC9C C9 70      002369 |	cmp #112d	;
      EC9E F0 07      002370 |	beq CkSpReg	;
      ECA0 C9 72      002371 |	cmp #114d	;
      ECA2 F0 2C      002372 |	beq CkSRReg	;
      ECA4 4C F9 EC   002373 |	jmp RegInErr	;
                      002374 |
      ECA7            002375 |CkSpReg:		;
      ECA7 AD 4A 00   002376 |	lda UStkPtr	;Get value for Stack Pointer from user.
      ECAA 20 5F F3   002377 |	jsr OutHex	;
      ECAD 20 FB F2   002378 |	jsr OutColn	;
      ECB0 20 A8 E0   002379 |	jsr GetLine	;
      ECB3 20 0E E1   002380 |	jsr ParseOpr	;
      ECB6 AD 5F 00   002381 |	lda OpFld1	;
      ECB9 C9 00      002382 |	cmp #0d		;
      ECBB D0 03      002383 |	bne GetSP	;
      ECBD 4C FD EC   002384 |	jmp ExitReg	;
      ECC0            002385 |GetSP:			;
      ECC0 A2 00      002386 |	ldx #0d		;
      ECC2 20 3D F3   002387 |	jsr AsToBin	;
      ECC5 B0 03      002388 |	bcs SPOK	;
      ECC7 4C FD EC   002389 |	jmp ExitReg	;
      ECCA            002390 |SPOK:			;
      ECCA 8D 4A 00   002391 |	sta UStkPtr	;
      ECCD 4C FD EC   002392 |	jmp ExitReg	;
                      002393 |	
      ECD0            002394 |CkSRReg:		;Get value for Status Register from user.
      ECD0 AD 4B 00   002395 |	lda UStatReg	;
      ECD3 20 5F F3   002396 |	jsr OutHex	;
      ECD6 20 FB F2   002397 |	jsr OutColn	;
      ECD9 20 A8 E0   002398 |	jsr GetLine	;
      ECDC 20 0E E1   002399 |	jsr ParseOpr	;
      ECDF AD 5F 00   002400 |	lda OpFld1	;
      ECE2 C9 00      002401 |	cmp #0d		;
      ECE4 D0 03      002402 |	bne GetSR	;
      ECE6 4C FD EC   002403 |	jmp ExitReg	;
      ECE9 A2 00      002404 |GetSR:	ldx #0d		;
      ECEB 20 3D F3   002405 |	jsr AsToBin	;
      ECEE B0 03      002406 |	bcs SROK	;
      ECF0 4C FD EC   002407 |	jmp ExitReg	;
      ECF3 8D 4B 00   002408 |SROK:	sta UStatReg	;
      ECF6 4C FD EC   002409 |	jmp ExitReg	;
                      002410 |
      ECF9            002411 |RegInErr:
      ECF9 18         002412 |	clc
      ECFA 4C FE EC   002413 |	jmp ErrRegOt
                      002414 |	
      ECFD            002415 |ExitReg:
      ECFD 38         002416 |	sec
      ECFE            002417 |ErrRegOt:
      ECFE 28         002418 |	plp
      ECFF 68         002419 |	pla
      ED00 A8         002420 |	tay
      ED01 68         002421 |	pla
      ED02 AA         002422 |	tax
      ED03 68         002423 |	pla
      ED04 60         002424 |	rts
                      002425 |
                      002426 |;****************************************************************************
                      002427 |;                       Search Command Subroutine.
                      002428 |;****************************************************************************
      ED05            002429 |Search:
      ED05 AD 5F 00   002430 |	lda OpFld1	;Check for operands.
      ED08 C9 00      002431 |	cmp #0d		;
      ED0A F0 07      002432 |	beq SOut	;
                      002433 |
      ED0C A2 00      002434 |	ldx #0d		;Get start address.
      ED0E 20 E4 F2   002435 |	jsr GetAdd	;
      ED11 B0 03      002436 |	bcs SAdd1ok	;
      ED13            002437 |SOut:			;
      ED13 4C 95 ED   002438 |	jmp ExitSrch	;
      ED16            002439 |SAdd1ok:		;
      ED16 8E 0A 00   002440 |	stx PointerB	;
      ED19 8C 0B 00   002441 |	sty PointerB+1d	;
                      002442 |	
      ED1C A2 14      002443 |	ldx #20d	;Get end address and increment by 1.
      ED1E 20 E4 F2   002444 |	jsr GetAdd	;
      ED21 B0 03      002445 |	bcs SAdd2ok	;
      ED23 4C 95 ED   002446 |	jmp ExitSrch	;
      ED26            002447 |SAdd2ok:		;
      ED26 8E 5C 00   002448 |	stx EndAdd	;
      ED29 8C 5D 00   002449 |	sty EndAdd+1d	;
      ED2C EE 5C 00   002450 |	inc EndAdd	;
      ED2F D0 03      002451 |	bne SNOvFlo	;
      ED31 EE 5D 00   002452 |	inc EndAdd+1d	;
                      002453 |	
      ED34            002454 |SNOvFlo:		;
      ED34 A2 28      002455 |	ldx #40d	;Get search list from operand field #3 and store
      ED36 A9 20      002456 |	lda #SrchTabl<	; it in table SrchTabl.  Store list count in
      ED38 8D 08 00   002457 |	sta PointerA	; SrchBtCt.
      ED3B A9 00      002458 |	lda #SrchTabl>	;
      ED3D 8D 09 00   002459 |	sta PointerA+1d	;
      ED40 20 8C E8   002460 |	jsr GetList	;
      ED43 90 50      002461 |	bcc ExitSrch	;
      ED45 AD CF 00   002462 |	lda DataTemp	;
      ED48 8D 2A 00   002463 |	sta SrchBtCt	;
                      002464 |	
      ED4B AD 0A 00   002465 |	lda PointerB	;Transfer start address from pointer A to 
      ED4E 8D 08 00   002466 |	sta PointerA	; pointer B.  Output a CRLF.
      ED51 AD 0B 00   002467 |	lda PointerB+1d	;
      ED54 8D 09 00   002468 |	sta PointerA+1d	;
      ED57 A2 DD      002469 |	ldx #CRLF<	;
      ED59 A0 F4      002470 |	ldy #CRLF>	;
      ED5B 20 B3 F3   002471 |	jsr PrntMess	;
                      002472 |	
      ED5E            002473 |SCkByte1:		;Compare list with memory.
      ED5E A2 00      002474 |	ldx #0d		;
      ED60 A0 00      002475 |	ldy #0d		;
      ED62            002476 |SCkByte2:		;
      ED62 B1 08      002477 |	lda (PointerA),y;
      ED64 DD 20 00   002478 |	cmp SrchTabl,x	;
      ED67 F0 19      002479 |	beq SMatch	;
                      002480 |	
      ED69            002481 |IncScPtr:
      ED69 20 DB F2   002482 |	jsr IncPntrA	;Increment memory pointer and check to see if
      ED6C AD 08 00   002483 |	lda PointerA	; the end address has been reached.
      ED6F CD 5C 00   002484 |	cmp EndAdd	;
      ED72 F0 03      002485 |	beq SckMSB	;
      ED74 4C 5E ED   002486 |	jmp SCkByte1	;
      ED77            002487 |SCkMSB:		;
      ED77 AD 09 00   002488 |	lda PointerA+1d	;
      ED7A CD 5D 00   002489 |	cmp EndAdd+1d	;
      ED7D F0 16      002490 |	beq ExitSrch	;
      ED7F 4C 5E ED   002491 |	jmp SCkByte1	;
                      002492 |	
      ED82            002493 |SMatch:		;
      ED82 C8         002494 |	iny		;Check to see if all bytes in search list match
      ED83 E8         002495 |	inx		; bytes in memory.
      ED84 EC 2A 00   002496 |	cpx SrchBtCt	;
      ED87 F0 03      002497 |	beq SFulMtch	;
      ED89 4C 62 ED   002498 |	jmp SCkByte2	;
                      002499 |
      ED8C            002500 |SFulMtch:		;
      ED8C 20 26 F3   002501 |	jsr PrntAdd	;Output address where match was found.
      ED8F 20 DB F2   002502 |	jsr IncPntrA	;
      ED92 4C 5E ED   002503 |	jmp SCkByte1	;
                      002504 |
      ED95            002505 |ExitSrch:
      ED95 60         002506 |	rts
                      002507 |
                      002508 |
                      002509 |
                      002510 |;****************************************************************************
                      002511 |;                       Trace Command Subroutine.
                      002512 |;****************************************************************************
      ED96            002513 |Trace:
                      002514 |
      ED96 AD 5F 00   002515 |	lda OpFld1	;Check for operands.
      ED99 C9 00      002516 |	cmp #0d		;
      ED9B F0 17      002517 |	beq TNoOper	;
                      002518 |	
      ED9D A2 00      002519 |	ldx #0d		;Get start address.
      ED9F 20 E4 F2   002520 |	jsr GetAdd	;
      EDA2 B0 03      002521 |	bcs TAdd1ok	;
      EDA4 4C 9D EF   002522 |	jmp ErrTrce	;
      EDA7            002523 |TAdd1ok:		;
      EDA7 8E 45 00   002524 |	stx UPgmCntr	;
      EDAA 8C 46 00   002525 |	sty UPgmCntr+1d	;
                      002526 |	
      EDAD AD 73 00   002527 |	lda OpFld2	;Check to see if a trace count has been 
      EDB0 C9 00      002528 |	cmp #0d		; specified.
      EDB2 D0 08      002529 |	bne GtTrcCnt	;
                      002530 |
      EDB4            002531 |TNoOper:
      EDB4 A0 01      002532 |	ldy #1d		;Set trace count to 1.
      EDB6 8C 3E 00   002533 |	sty TracCnt	;
      EDB9 4C C9 ED   002534 |	jmp StartTrc	;
                      002535 |
      EDBC            002536 |GtTrcCnt:	
      EDBC A2 14      002537 |	ldx #20d	;Get trace count from user.
      EDBE 20 3D F3   002538 |	jsr AsToBin	;
      EDC1 B0 03      002539 |	bcs TrValOK	;
      EDC3 4C 9D EF   002540 |	jmp ErrTrce	;
      EDC6            002541 |TrValOK:		;
      EDC6 8D 3E 00   002542 |	sta TracCnt	;
                      002543 |	
      EDC9            002544 |StartTrc:
      EDC9 68         002545 |	pla		;Remove trace command's return address and
      EDCA 68         002546 |	pla		; the check command routine's return address from
      EDCB 68         002547 |	pla		; the stack.
      EDCC 68         002548 |	pla		;
                      002549 |
      EDCD            002550 |ContTrc:	
      EDCD AC 45 00   002551 |	ldy UPgmCntr	;Transfer user's program counter to pointer A.
      EDD0 8C 08 00   002552 |	sty PointerA	;
      EDD3 AC 46 00   002553 |	ldy UPgmCntr+1d	;
      EDD6 8C 09 00   002554 |	sty PointerA+1d	;
                      002555 |
      EDD9 A0 00      002556 |	ldy #0d		;Get opcode of current instruction.
      EDDB B1 08      002557 |	lda (PointerA),y;
      EDDD 8D 43 00   002558 |	sta OpCdHold	;
                      002559 |	
      EDE0 20 A1 EF   002560 |	jsr ScanOpCd	;Check to see if byte from memory location was
      EDE3 B0 03      002561 |	bcs TOpCdFnd	; an opcode.
      EDE5 4C 9D EF   002562 |	jmp ErrTrce
                      002563 |
      EDE8            002564 |TOpCdFnd:
      EDE8 A0 08      002565 |	ldy #8d		;Get number of bytes in the current instruction
      EDEA B1 0A      002566 |	lda (PointerB),y; information from opcode table.
      EDEC 8D 3A 00   002567 |	sta CurInsLn	;
                      002568 |	
      EDEF A0 01      002569 |	ldy #1d		;Get opcode of current instruction.
      EDF1 AD 43 00   002570 |	lda OpCdHold	;
                      002571 |
      EDF4            002572 |TrRTS:			;If the opcode is an RTS then copy the return
      EDF4 C9 60      002573 |	cmp #60h	; address from the stack, save the opcode to
      EDF6 D0 28      002574 |	bne TNxtOp0	; be returned to, and place a BRK at the return
      EDF8 A9 02      002575 |	lda #2d		; address.
      EDFA 8D 3D 00   002576 |	sta BrnchFlg	;
      EDFD 68         002577 |	pla		;
      EDFE 8D 10 00   002578 |	sta BOpAdPtr	;
      EE01 68         002579 |	pla		;
      EE02 8D 11 00   002580 |	sta BOpAdPtr+1d	;
      EE05 48         002581 |	pha		;
      EE06 AD 10 00   002582 |	lda BOpAdPtr	;
      EE09 48         002583 |	pha		;
      EE0A EE 10 00   002584 |	inc BOpAdPtr	;
      EE0D D0 03      002585 |	bne NNOvflo	;
      EE0F EE 11 00   002586 |	inc BOpAdPtr+1d	;
      EE12            002587 |NNOvflo:		;
      EE12 A0 00      002588 |	ldy #0d		;
      EE14 B1 10      002589 |	lda (BOpAdPtr),y;
      EE16 8D 3C 00   002590 |	sta BOpCdHld	;
      EE19 A9 00      002591 |	lda #0d		;
      EE1B 91 10      002592 |	sta (BOpAdPtr),y;
      EE1D 4C 2C EF   002593 |	jmp ChBkVect	;
                      002594 |	
      EE20            002595 |TNxtOp0:		;
      EE20 C9 4C      002596 |	cmp #4ch	;If the opcode is an absolute jump, JMP aaaa,
      EE22 D0 1E      002597 |	bne TNxtOp1	; then save the opcode of the instruction that
      EE24 A9 02      002598 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE26 8D 3D 00   002599 |	sta BrnchFlg	;
      EE29 B1 08      002600 |	lda (PointerA),y;
      EE2B 8D 10 00   002601 |	sta BOpAdPtr	;
      EE2E C8         002602 |	iny		;
      EE2F B1 08      002603 |	lda (PointerA),y;
      EE31 8D 11 00   002604 |	sta BOpAdPtr+1d	;
      EE34 A0 00      002605 |	ldy #0d		;
      EE36 B1 10      002606 |	lda (BOpAdPtr),y;
      EE38 8D 3C 00   002607 |	sta BOpCdHld	;
      EE3B A9 00      002608 |	lda #0d		;
      EE3D 91 10      002609 |	sta (BOpAdPtr),y;
      EE3F 4C 2C EF   002610 |	jmp ChBkVect	;
                      002611 |	
      EE42            002612 |TNxtOp1:
      EE42 C9 6C      002613 |	cmp #6ch	;If the opcode is an indirect jump, JMP (aaaa),
      EE44 D0 2B      002614 |	bne TNxtOp2	; then save the opcode of the instruction that
      EE46 A9 02      002615 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE48 8D 3D 00   002616 |	sta BrnchFlg	;
      EE4B B1 08      002617 |	lda (PointerA),y;
      EE4D 8D 0C 00   002618 |	sta PointerC	;
      EE50 C8         002619 |	iny		;
      EE51 B1 08      002620 |	lda (PointerA),y;
      EE53 8D 0D 00   002621 |	sta PointerC+1d	;
      EE56 A0 00      002622 |	ldy #0d		;
      EE58 B1 0C      002623 |	lda (PointerC),y;
      EE5A 8D 10 00   002624 |	sta BOpAdPtr	;
      EE5D C8         002625 |	iny		;
      EE5E B1 0C      002626 |	lda (PointerC),y;
      EE60 8D 11 00   002627 |	sta BOpAdPtr+1d	;
      EE63 A0 00      002628 |	ldy #0d		;
      EE65 B1 10      002629 |	lda (BOpAdPtr),y;
      EE67 8D 3C 00   002630 |	sta BOpCdHld	;
      EE6A A9 00      002631 |	lda #0d		;
      EE6C 91 10      002632 |	sta (BOpAdPtr),y;
      EE6E 4C 2C EF   002633 |	jmp ChBkVect	;
                      002634 |		
                      002635 |	
      EE71            002636 |TNxtOp2:
      EE71 C9 20      002637 |	cmp #20h	;If the opcode is a subroutine jump, JSR aaaa,
      EE73 D0 1E      002638 |	bne TNxtOp3	; then save the opcode of the instruction that
      EE75 A9 02      002639 |	lda #2d		; will be jumped to and replace it with a BRK.
      EE77 8D 3D 00   002640 |	sta BrnchFlg	;
      EE7A B1 08      002641 |	lda (PointerA),y;
      EE7C 8D 10 00   002642 |	sta BOpAdPtr	;
      EE7F C8         002643 |	iny		;
      EE80 B1 08      002644 |	lda (PointerA),y;
      EE82 8D 11 00   002645 |	sta BOpAdPtr+1d	;
      EE85 A0 00      002646 |	ldy #0d		;
      EE87 B1 10      002647 |	lda (BOpAdPtr),y;
      EE89 8D 3C 00   002648 |	sta BOpCdHld	;
      EE8C A9 00      002649 |	lda #0d		;
      EE8E 91 10      002650 |	sta (BOpAdPtr),y;
      EE90 4C 2C EF   002651 |	jmp ChBkVect	;
                      002652 |	
      EE93            002653 |TNxtOp3:
      EE93 A0 00      002654 |	ldy #0d		;Check to see if the current instruction is an
      EE95 B1 0A      002655 |	lda (PointerB),y; actual branch.
      EE97 C9 42      002656 |	cmp #'B'	;
      EE99 D0 08      002657 |	bne NoBrnch2	;
      EE9B A0 01      002658 |	ldy #1d		;
      EE9D B1 0A      002659 |	lda (PointerB),y;
      EE9F C9 49      002660 |	cmp #'I'	;
      EEA1 D0 03      002661 |	bne Branch	;
      EEA3            002662 |NoBrnch2:		;
      EEA3 4C 09 EF   002663 |	jmp NoBranch	;
                      002664 |	
      EEA6            002665 |Branch:		;If the opcode is a branch, Bxx aaaa,
      EEA6 A9 01      002666 |	lda #1d		; then save the opcode of the instruction that
      EEA8 8D 3D 00   002667 |	sta BrnchFlg	; will be branched to and replace it with a BRK.
      EEAB 18         002668 |	clc		;
      EEAC AD 08 00   002669 |	lda PointerA	;
      EEAF 6D 3A 00   002670 |	adc CurInsLn	;
      EEB2 8D 10 00   002671 |	sta BOpAdPtr	;
      EEB5 AD 09 00   002672 |	lda PointerA+1d	;
      EEB8 69 00      002673 |	adc #0d		;
      EEBA 8D 11 00   002674 |	sta BOpAdPtr+1d	;
                      002675 |			;
      EEBD A0 01      002676 |	ldy #1d		;
      EEBF B1 08      002677 |	lda (PointerA),y;
      EEC1 8D 38 00   002678 |	sta BrValHld	;
      EEC4 10 20      002679 |	bpl AddAdd	;
      EEC6            002680 |SubAdd:		;
      EEC6 CE 38 00   002681 |	dec BrValHld	;
      EEC9 AD 38 00   002682 |	lda BrValHld	;
      EECC 49 FF      002683 |	eor #0ffh	;
      EECE 8D 38 00   002684 |	sta BrValHld	;
      EED1 38         002685 |	sec		;
      EED2 AD 10 00   002686 |	lda BOpAdPtr	;
      EED5 ED 38 00   002687 |	sbc BrValHld	;
      EED8 8D 10 00   002688 |	sta BOpAdPtr	;
      EEDB AD 11 00   002689 |	lda BOpAdPtr+1d	;
      EEDE E9 00      002690 |	sbc #0d		;
      EEE0 8D 11 00   002691 |	sta BOpAdPtr+1d	;
      EEE3 4C FB EE   002692 |	jmp GtBrOpCd	;
      EEE6            002693 |AddAdd:		;
      EEE6 18         002694 |	clc		;
      EEE7 AD 10 00   002695 |	lda BOpAdPtr	;
      EEEA 6D 38 00   002696 |	adc BrValHld	;
      EEED 8D 10 00   002697 |	sta BOpAdPtr	;
      EEF0 AD 11 00   002698 |	lda BOpAdPtr+1d	;
      EEF3 69 00      002699 |	adc #0d		;
      EEF5 8D 11 00   002700 |	sta BOpAdPtr+1d	;
      EEF8 4C FB EE   002701 |	jmp GtBrOpCd	;
      EEFB            002702 |GtBrOpCd:		;
      EEFB A0 00      002703 |	ldy #0d		;
      EEFD B1 10      002704 |	lda (BOpAdPtr),y;
      EEFF 8D 3C 00   002705 |	sta BOpCdHld	;
      EF02 A9 00      002706 |	lda #0d		;
      EF04 91 10      002707 |	sta (BOpAdPtr),y;
      EF06 4C 0E EF   002708 |	jmp Both	;
                      002709 |	
      EF09            002710 |NoBranch:
      EF09 A9 00      002711 |	lda #0d		;Set branch flag to 0 to indicate the current
      EF0B 8D 3D 00   002712 |	sta BrnchFlg	; instruction is not a branch instruction.
                      002713 |
      EF0E            002714 |Both:
      EF0E AC 3A 00   002715 |	ldy CurInsLn	;
      EF11 B1 08      002716 |	lda (PointerA),y;Save the opcode of the next instruction to be
      EF13 8D 3B 00   002717 |	sta NOpCdHld	; executed if no branch is taken and replace it
                      002718 |			; with a BRK command.
      EF16 18         002719 |	clc		;
      EF17 AD 08 00   002720 |	lda PointerA	;
      EF1A 6D 3A 00   002721 |	adc CurInsLn	;
      EF1D 8D 0E 00   002722 |	sta NOpAdPtr	;
      EF20 AD 09 00   002723 |	lda PointerA+1d	;
      EF23 69 00      002724 |	adc #0d		;
      EF25 8D 0F 00   002725 |	sta NOpAdPtr+1d	;
      EF28 A9 00      002726 |	lda #0d		;
      EF2A 91 08      002727 |	sta (PointerA),y;
                      002728 |	
      EF2C            002729 |ChBkVect:
      EF2C A9 01      002730 |	lda #1d		    ;Make BRK jump here instead of main.
      EF2E 8D 39 00   002731 |	sta TrBrkFlg	;
                      002732 |	
      EF31 AD 5F 00   002733 |    lda OpFld1	;Check to see if user entered address.
      EF34 C9 00      002734 |	cmp #0d		;
      EF36 F0 03      002735 |	beq DoNotRestoreStackPointer
      EF38 A2 FF      002736 |    ldx #0ffh    
      EF3A 9A         002737 |    txs          ;
      EF3B            002738 |DoNotRestoreStackPointer:
                      002739 |
      EF3B AD 4B 00   002740 |	lda UStatReg	;Restore user's registers.
      EF3E 48         002741 |	pha		        ;
      EF3F AD 47 00   002742 |	lda UAccum	    ;
      EF42 AE 48 00   002743 |	ldx UXreg	    ;
      EF45 AC 49 00   002744 |	ldy UYReg	    ;
      EF48 28         002745 |	plp		        ;
                      002746 |    
      EF49 6C 45 00   002747 |	jmp (UPgmCntr)	;Jump to user's code.
                      002748 |	
      EF4C            002749 |Tr2ndEnt:
      EF4C A9 00      002750 |	lda #0d		;Reset trace break flag.
      EF4E 8D 39 00   002751 |	sta TrBrkFlg	;
                      002752 |	
      EF51            002753 |CkBrnch:		;
      EF51 A0 00      002754 |	ldy #0d		;Check to see which opcodes need to be restored.
      EF53 AD 3D 00   002755 |	lda BrnchFlg	;
      EF56 C9 00      002756 |	cmp #0d		;
      EF58 F0 11      002757 |	beq NoBrnch	;
      EF5A C9 01      002758 |	cmp #1d		;
      EF5C F0 08      002759 |	beq Brnch	;
                      002760 |	
      EF5E            002761 |DoJmp:
      EF5E AD 3C 00   002762 |	lda BOpCdHld	;Restore opcode to be jumped to.
      EF61 91 10      002763 |	sta (BOpAdPtr),y;
      EF63 4C 70 EF   002764 |	jmp UpDtPtrA	;
                      002765 |
      EF66            002766 |Brnch:
      EF66 AD 3C 00   002767 |	lda BOpCdHld	;Restore opcode to be branched to.
      EF69 91 10      002768 |	sta (BOpAdPtr),y;
                      002769 |	
      EF6B            002770 |NoBrnch:
      EF6B AD 3B 00   002771 |	lda NOpCdHld	;Restore opcode that will be executed next in
      EF6E 91 0E      002772 |	sta (NOpAdPtr),y; the instruction stream.
                      002773 |
      EF70            002774 |UpDtPtrA:
      EF70 AC 45 00   002775 |	ldy UPgmCntr	;Set pointer A to point to the next instruction
      EF73 8C 08 00   002776 |	sty PointerA	; to be executed for unassemble.
      EF76 AC 46 00   002777 |	ldy UPgmCntr+1d	;
      EF79 8C 09 00   002778 |	sty PointerA+1d	;
                      002779 |	
      EF7C A2 DD      002780 |	ldx #CRLF<	;Unassemble next instruction in memory.
      EF7E A0 F4      002781 |	ldy #CRLF>	;
      EF80 20 B3 F3   002782 |	jsr PrntMess	;
      EF83 AD 08 00   002783 |	lda PointerA	;
      EF86 8D 5C 00   002784 |	sta EndAdd	;
      EF89 AD 09 00   002785 |	lda PointerA+1d	;
      EF8C 8D 5D 00   002786 |	sta EndAdd+1d	;
      EF8F 20 20 F0   002787 |	jsr StartUnA	;
                      002788 |	
      EF92            002789 |NxtIn:
      EF92 CE 3E 00   002790 |	dec TracCnt	;Decrement trace count and trace again if it
      EF95 F0 03      002791 |	beq OutTrce	; is not zero.
      EF97 4C CD ED   002792 |	jmp ContTrc	;
                      002793 |
      EF9A            002794 |OutTrce:
      EF9A 4C 95 E0   002795 |	jmp MainLoop	;Enter the main monitor loop using a jump
                      002796 |			; because the trace command's return address
                      002797 |			; and the check command routine's return address
                      002798 |			; were removed when a trace was initiated.
      EF9D            002799 |ErrTrce:
      EF9D 18         002800 |	clc
      EF9E 60         002801 |	rts	
                      002802 |
      EF9F            002803 |ExitTrce:
      EF9F 38         002804 |	sec
      EFA0 60         002805 |	rts	
                      002806 |
                      002807 |;****************************************************************************
                      002808 |;                       Scan for Valid Opcode Subroutine.
                      002809 |;****************************************************************************
      EFA1            002810 |ScanOpCd:
                      002811 |	
      EFA1 A2 5C      002812 |	ldx #OpTable<	;Point pointer B to beginning of opcode table.
      EFA3 8E 0A 00   002813 |	stx PointerB	;
      EFA6 A2 F8      002814 |	ldx #OpTable>	;
      EFA8 8E 0B 00   002815 |	stx PointerB+1d	;
                      002816 |	
      EFAB            002817 |CkTblEnd:
      EFAB A0 04      002818 |	ldy #4d		;Check for end of opcode table.
      EFAD B1 0A      002819 |	lda (PointerB),y;
      EFAF C9 5A      002820 |	cmp #90d	;
      EFB1 F0 1C      002821 |	beq OpCdNtFd	;
                      002822 |	
      EFB3            002823 |CkNxtOp:		;
      EFB3 A0 07      002824 |	ldy #7d		;Check for an opcode match in the opcode table.
      EFB5 B1 0A      002825 |	lda (PointerB),y;
      EFB7 CD 43 00   002826 |	cmp OpCdHold	;
      EFBA F0 11      002827 |	beq OpCdFndS	;
                      002828 |	
      EFBC AD 0A 00   002829 |	lda PointerB	;Point pointer B to next entry in opcode table.
      EFBF 18         002830 |	clc		;
      EFC0 69 0A      002831 |	adc #10d	;
      EFC2 8D 0A 00   002832 |	sta PointerB	;
      EFC5 90 03      002833 |	bcc ScNoCary	;
      EFC7 EE 0B 00   002834 |	inc PointerB+1d	;
                      002835 |		
      EFCA            002836 |ScNoCary:
      EFCA 4C AB EF   002837 |	jmp CkTblEnd
                      002838 |	
                      002839 |	
      EFCD            002840 |OpCdFndS:
      EFCD 38         002841 |	sec
      EFCE 60         002842 |	rts
                      002843 |	
      EFCF            002844 |OpCdNtFd:
      EFCF 18         002845 |	clc
      EFD0 60         002846 |	rts
                      002847 |	
                      002848 |;****************************************************************************
                      002849 |;                       Unassemble Command Subroutine.
                      002850 |;****************************************************************************
      EFD1            002851 |UnAssem:
      EFD1 AD 5F 00   002852 |	lda OpFld1	;Check for operands.
      EFD4 C9 00      002853 |	cmp #0d		;
      EFD6 F0 17      002854 |	beq UNoOper	;
                      002855 |
      EFD8 A2 00      002856 |	ldx #0d		;Get start address.
      EFDA 20 E4 F2   002857 |	jsr GetAdd	;
      EFDD B0 03      002858 |	bcs UAdd1ok	;
      EFDF 4C C5 F2   002859 |	jmp ErrUnAs	;
      EFE2            002860 |UAdd1ok:		;
      EFE2 8E 08 00   002861 |	stx PointerA	;
      EFE5 8C 09 00   002862 |	sty PointerA+1d	;
                      002863 |	
      EFE8 AD 73 00   002864 |	lda OpFld2	;Check to see if an end address has been 
      EFEB C9 00      002865 |	cmp #0d		; specified.
      EFED D0 21      002866 |	bne GtUEndAd	;
                      002867 |	
      EFEF            002868 |UNoOper:
      EFEF AD 08 00   002869 |	lda PointerA	;
      EFF2 8D 5C 00   002870 |	sta EndAdd	;
      EFF5 AD 09 00   002871 |	lda PointerA+1d	;
      EFF8 8D 5D 00   002872 |	sta EndAdd+1d	;
      EFFB 18         002873 |	clc		;If no end address has been specified by the
      EFFC AD 08 00   002874 |	lda PointerA	; user then set the end address to start address
      EFFF 69 14      002875 |	adc #20d	; + 20d.
      F001 8D 5C 00   002876 |	sta EndAdd	;
      F004 90 07      002877 |	bcc UNoCary	;
      F006 AE 5D 00   002878 |	ldx EndAdd+1d	;
      F009 E8         002879 |	inx		;
      F00A 8E 5D 00   002880 |	stx EndAdd+1d	;
      F00D            002881 |UNoCary:		;
      F00D 4C 20 F0   002882 |	jmp StartUnA	;
                      002883 |	
      F010            002884 |GtUEndAd:
      F010 A2 14      002885 |	ldx #20d	;Get end address.
      F012 20 E4 F2   002886 |	jsr GetAdd	;
      F015 B0 03      002887 |	bcs UAdd2ok	;
      F017 4C C5 F2   002888 |	jmp ErrUnAs	;
      F01A            002889 |UAdd2ok:		;
      F01A 8E 5C 00   002890 |	stx EndAdd	;
      F01D 8C 5D 00   002891 |	sty EndAdd+1d	;
                      002892 |	
      F020            002893 |StartUnA:
      F020 AD 5D 00   002894 |	lda EndAdd+1d	;Check to see if end address has been reached.
      F023 CD 09 00   002895 |	cmp PointerA+1d	;
      F026 F0 05      002896 |	beq UChkFLSB	;
      F028 90 0E      002897 |	bcc UOut	;
      F02A 4C 3B F0   002898 |	jmp UNotFin 	;
      F02D            002899 |UChkFLSB:
      F02D AD 5C 00   002900 |	lda EndAdd	; 
      F030 CD 08 00   002901 |	cmp PointerA	;
      F033 90 03      002902 |	bcc UOut	;
      F035 4C 3B F0   002903 |	jmp UNotFin	;
      F038            002904 |UOut:			;
      F038 4C C7 F2   002905 |	jmp ExitUnAs	;
                      002906 |
      F03B            002907 |UNotFin:		;
      F03B A0 00      002908 |	ldy #0d		;Get opcode byte from memory and save.
      F03D B1 08      002909 |	lda (PointerA),y;
      F03F 8D 43 00   002910 |	sta OpCdHold	;
      F042 20 A1 EF   002911 |	jsr ScanOpCd	;Check to see if byte from memory location was
      F045 B0 1D      002912 |	bcs OpCdFnd	; an opcode.
                      002913 |
      F047            002914 |NtOpCode:
      F047 A2 DD      002915 |	ldx #CRLF<	;Print start address of current instruction.
      F049 A0 F4      002916 |	ldy #CRLF>	;
      F04B 20 B3 F3   002917 |	jsr PrntMess	;
      F04E 20 26 F3   002918 |	jsr PrntAdd	;
                      002919 |
      F051 AD 43 00   002920 |	lda OpCdHold	;Print the bad opcode.
      F054 20 5F F3   002921 |	jsr OutHex	;
                      002922 |	
      F057 A2 B8      002923 |	ldx #BadOpMes<	;If byte was not an opcode then print question
      F059 A0 F5      002924 |	ldy #BadOpMes>	; marks indicating that byte was not an opcode.
      F05B 20 B3 F3   002925 |	jsr PrntMess	;
      F05E 20 DB F2   002926 |	jsr IncPntrA	;
      F061 4C 20 F0   002927 |	jmp StartUnA	;
                      002928 |
      F064            002929 |OpCdFnd:
      F064 A2 DD      002930 |	ldx #CRLF<	;Print start address of current instruction.
      F066 A0 F4      002931 |	ldy #CRLF>	;
      F068 20 B3 F3   002932 |	jsr PrntMess	;
      F06B 20 26 F3   002933 |	jsr PrntAdd	;
      F06E 20 DB F2   002934 |	jsr IncPntrA	;
                      002935 |
      F071            002936 |CkAdMode:
      F071 A0 06      002937 |	ldy #6d		;Get addressing mode indicator from table.
      F073 B1 0A      002938 |	lda (PointerB),y;
                      002939 |	
      F075            002940 |NxAdMo1:		;
      F075 C9 50      002941 |	cmp #'P'	;Check for implied addressing mode.
      F077 D0 03      002942 |	bne NxAdMo2	;
      F079 4C BE F0   002943 |	jmp ImpAdMo	;
                      002944 |	
      F07C            002945 |NxAdMo2:		;
      F07C C9 4D      002946 |	cmp #'M'	;Check for immediate addressing mode.
      F07E D0 03      002947 |	bne NxAdMo3	;
      F080 4C E5 F0   002948 |	jmp ImmAdMo	;	
                      002949 |
      F083            002950 |NxAdMo3:		;
      F083 C9 53      002951 |	cmp #'S'	;Check for absolute addressing mode.
      F085 D0 03      002952 |	bne NxAdMo4	;
      F087 4C 18 F1   002953 |	jmp AbsxyAdM	;	
                      002954 |
      F08A            002955 |NxAdMo4:		;
      F08A C9 58      002956 |	cmp #'X'	;Check for absolute x addressing mode.
      F08C D0 03      002957 |	bne NxAdMo5	;
      F08E 4C 18 F1   002958 |	jmp AbsxyAdM	;
                      002959 |
      F091            002960 |NxAdMo5:		;
      F091 C9 59      002961 |	cmp #'Y'	;Check for absolute y addressing mode.
      F093 D0 03      002962 |	bne NxAdMo6	;
      F095 4C 18 F1   002963 |	jmp AbsxyAdM	;
                      002964 |
      F098            002965 |NxAdMo6:		;
      F098 C9 52      002966 |	cmp #'R'	;Check for indexed indirect addressing mode.
      F09A D0 03      002967 |	bne NxAdMo7	;
      F09C 4C 35 F2   002968 |	jmp IIRAdMo	;
                      002969 |
      F09F            002970 |NxAdMo7:		;
      F09F C9 4C      002971 |	cmp #'L'	;Check for relative addressing mode.
      F0A1 D0 03      002972 |	bne NxAdMo8 	;
      F0A3 4C 82 F1   002973 |	jmp RelAdMo	;
                      002974 |
      F0A6            002975 |NxAdMo8:		;
      F0A6 C9 43      002976 |	cmp #'C'	;Check for accumulator addressing mode.
      F0A8 D0 03      002977 |	bne NxAdMo9 	;
      F0AA 4C CF F0   002978 |	jmp AccAdMo	;
                      002979 |
      F0AD            002980 |NxAdMo9:		;
      F0AD C9 44      002981 |	cmp #'D'	;Check for indirect addressing mode.
      F0AF D0 03      002982 |	bne NxAdMo10 	;
      F0B1 4C 77 F2   002983 |	jmp IndAdMo	;
                      002984 |
      F0B4            002985 |NxAdMo10:
      F0B4 C9 49      002986 |	cmp #'I'	;Check for indirect indexed addressing mode.
      F0B6 D0 03      002987 |	bne BdOpCd	;
      F0B8 4C F3 F1   002988 |	jmp IRIAdMo	;
                      002989 |
      F0BB            002990 |BdOpCd:		;
      F0BB 4C 47 F0   002991 |	jmp NtOpCode	;
                      002992 |
                      002993 |
      F0BE            002994 |ImpAdMo:
      F0BE AD 43 00   002995 |	lda OpCdHold	;Print the opcode.
      F0C1 20 5F F3   002996 |	jsr OutHex	;
                      002997 |	
      F0C4 A0 08      002998 |	ldy #8d		;Print spaces between object code field and
      F0C6 20 03 F3   002999 |	jsr OutSpace	; operator field.
                      003000 |		
      F0C9 20 C9 F2   003001 |	jsr PrntMnem	;Print the operator.
                      003002 |	
      F0CC 4C 20 F0   003003 |	jmp StartUnA
                      003004 |
      F0CF            003005 |AccAdMo:
      F0CF AD 43 00   003006 |	lda OpCdHold	;Print the opcode.
      F0D2 20 5F F3   003007 |	jsr OutHex	;
                      003008 |	
      F0D5 A0 08      003009 |	ldy #8d		;Print spaces between object code field and
      F0D7 20 03 F3   003010 |	jsr OutSpace	; operator field.
                      003011 |		
      F0DA 20 C9 F2   003012 |	jsr PrntMnem	;Print the operator.
                      003013 |	
      F0DD A9 41      003014 |	lda #65d	;Print a capital A for accumulator addressing.
      F0DF 20 14 F4   003015 |	jsr OutChar	;
                      003016 |	
      F0E2 4C 20 F0   003017 |	jmp StartUnA
                      003018 |
                      003019 |
      F0E5            003020 |ImmAdMo:
      F0E5 A0 00      003021 |	ldy #0d
                      003022 |
      F0E7 AD 43 00   003023 |	lda OpCdHold	;Print the opcode and a space.
      F0EA 20 5F F3   003024 |	jsr OutHex	;
      F0ED A9 20      003025 |	lda #32d	;
      F0EF 20 14 F4   003026 |	jsr OutChar	;
                      003027 |	
      F0F2 B1 08      003028 |	lda (PointerA),y;Print the second byte of the instruction and
      F0F4 8D 41 00   003029 |	sta ObCdHld1	; increment the memory pointer.
      F0F7 20 5F F3   003030 |	jsr OutHex	;
      F0FA 20 DB F2   003031 |	jsr IncPntrA	;
                      003032 |	
      F0FD A0 05      003033 |	ldy #5d		;Print spaces between object code field and
      F0FF 20 03 F3   003034 |	jsr OutSpace	; operator field.
                      003035 |	
      F102 20 C9 F2   003036 |	jsr PrntMnem	;Print the operator.
                      003037 |	
      F105 A9 23      003038 |	lda #35d	;Print a pound sign.
      F107 20 14 F4   003039 |	jsr OutChar	;
                      003040 |	
      F10A AD 41 00   003041 |	lda ObCdHld1	;Print immediate operand value.
      F10D 20 5F F3   003042 |	jsr OutHex	;
                      003043 |	
      F110 A9 68      003044 |	lda #104d	;Print lower case h to indicate hex number.
      F112 20 14 F4   003045 |	jsr OutChar	;
                      003046 |	
      F115 4C 20 F0   003047 |	jmp StartUnA
                      003048 |
                      003049 |
      F118            003050 |AbsxyAdM:
      F118 A0 00      003051 |	ldy #0d
                      003052 |
      F11A AD 43 00   003053 |	lda OpCdHold	;Print the opcode and a space.
      F11D 20 5F F3   003054 |	jsr OutHex	;
      F120 A9 20      003055 |	lda #32d	;
      F122 20 14 F4   003056 |	jsr OutChar	;
                      003057 |	
      F125 B1 08      003058 |	lda (PointerA),y;Print the second byte of the instruction and
      F127 8D 41 00   003059 |	sta ObCdHld1	; increment the memory pointer
      F12A 20 5F F3   003060 |	jsr OutHex	;
      F12D 20 DB F2   003061 |	jsr IncPntrA	;
                      003062 |	
      F130 A9 20      003063 |	lda #32d	;Print a space between obj codes.
      F132 20 14 F4   003064 |	jsr OutChar	;
                      003065 |	
      F135 B1 08      003066 |	lda (PointerA),y;Print the third byte of the instruction and
      F137 8D 42 00   003067 |	sta ObCdHld2	; increment the memory pointer
      F13A 20 5F F3   003068 |	jsr OutHex	;
      F13D 20 DB F2   003069 |	jsr IncPntrA	;
                      003070 |	
      F140 A0 02      003071 |	ldy #2d		;Print spaces between object code field and
      F142 20 03 F3   003072 |	jsr OutSpace	; operator field.
                      003073 |	
      F145 20 C9 F2   003074 |	jsr PrntMnem	;Print the operator.
                      003075 |
      F148 AD 42 00   003076 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F14B 20 5F F3   003077 |	jsr OutHex	;
      F14E AD 41 00   003078 |	lda ObCdHld1	;
      F151 20 5F F3   003079 |	jsr OutHex	;
                      003080 |	
      F154 A9 68      003081 |	lda #104d	;Print lower case h to indicate hex number.
      F156 20 14 F4   003082 |	jsr OutChar	;
                      003083 |
      F159 A0 06      003084 |	ldy #6d		;Check to see if address mode is abs, abx or
      F15B B1 0A      003085 |	lda (PointerB),y; aby.
      F15D C9 58      003086 |	cmp #'X'	;
      F15F F0 07      003087 |	beq AbxAdMo	;
      F161 C9 59      003088 |	cmp #'Y'	;
      F163 F0 10      003089 |	beq AbyAdMo	;
                      003090 |	
      F165            003091 |AbsAM:
      F165 4C 20 F0   003092 |	jmp StartUnA
                      003093 |
      F168            003094 |AbxAdMo:
      F168 A9 2C      003095 |	lda #44d	;Print comma and x.
      F16A 20 14 F4   003096 |	jsr OutChar	;
      F16D A9 58      003097 |	lda #88d	;
      F16F 20 14 F4   003098 |	jsr OutChar	;
                      003099 |	
      F172 4C 20 F0   003100 |	jmp StartUna
                      003101 |	
      F175            003102 |AbyAdMo:
      F175 A9 2C      003103 |	lda #44d	;Print comma and y.
      F177 20 14 F4   003104 |	jsr OutChar	;
      F17A A9 59      003105 |	lda #89d	;
      F17C 20 14 F4   003106 |	jsr OutChar	;
                      003107 |
      F17F 4C 20 F0   003108 |	jmp StartUnA
                      003109 |
                      003110 |
      F182            003111 |RelAdMo:
      F182 A0 00      003112 |	ldy #0d
                      003113 |
      F184 AD 43 00   003114 |	lda OpCdHold	;Print the opcode and a space.
      F187 20 5F F3   003115 |	jsr OutHex	;
      F18A A9 20      003116 |	lda #32d	;
      F18C 20 14 F4   003117 |	jsr OutChar	;
                      003118 |	
      F18F B1 08      003119 |	lda (PointerA),y;Print the second byte of the instruction and
      F191 8D 41 00   003120 |	sta ObCdHld1	; increment the memory pointer.
      F194 20 5F F3   003121 |	jsr OutHex	;
      F197 20 DB F2   003122 |	jsr IncPntrA	;
                      003123 |	
      F19A A0 05      003124 |	ldy #5d		;Print spaces between object code field and
      F19C 20 03 F3   003125 |	jsr OutSpace	; operator field.
                      003126 |	
      F19F 20 C9 F2   003127 |	jsr PrntMnem	;Print the operator.
                      003128 |
      F1A2 AD 08 00   003129 |	lda PointerA	;Store a copy of the next instruction's start
      F1A5 8D 3F 00   003130 |	sta AddHold	; address.
      F1A8 AD 09 00   003131 |	lda PointerA+1d	;
      F1AB 8D 40 00   003132 |	sta AddHold+1d	;
                      003133 |	
      F1AE AD 41 00   003134 |	lda ObCdHld1	;Check to see if branch is positive or negative.
      F1B1 30 12      003135 |	bmi NegBrnch	;
                      003136 |	
      F1B3            003137 |PosBrnch:		;If branch is positive then find address being
      F1B3 AD 3F 00   003138 |	lda AddHold	; branched to by adding offset to start address
      F1B6 18         003139 |	clc		; of next instruction in memory.
      F1B7 6D 41 00   003140 |	adc ObCdHld1	;
      F1BA 8D 3F 00   003141 |	sta AddHold	;
      F1BD 90 20      003142 |	bcc OutBrAdd	;
      F1BF EE 40 00   003143 |	inc AddHold+1d	;
      F1C2 4C DF F1   003144 |	jmp OutBrAdd	;
                      003145 |		
      F1C5            003146 |NegBrnch:
      F1C5 CE 41 00   003147 |	dec ObCdHld1	;If branch is negative then find address being
      F1C8 AD 41 00   003148 |	lda ObCdHld1	; branched to by subtracting offset from start
      F1CB 49 FF      003149 |	eor #0ffh	; address of next instruction in memory.
      F1CD 8D 41 00   003150 |	sta ObCdHld1	;
      F1D0 AD 3F 00   003151 |	lda AddHold	;
      F1D3 38         003152 |	sec		;
      F1D4 ED 41 00   003153 |	sbc ObCdHld1	;
      F1D7 8D 3F 00   003154 |	sta AddHold	;
      F1DA B0 03      003155 |	bcs OutBrAdd	;
      F1DC CE 40 00   003156 |	dec AddHold+1d	;
                      003157 |	
      F1DF            003158 |OutBrAdd:
      F1DF AD 40 00   003159 |	lda AddHold+1d	;Print address being branched to.
      F1E2 20 5F F3   003160 |	jsr OutHex	;
      F1E5 AD 3F 00   003161 |	lda AddHold	;
      F1E8 20 5F F3   003162 |	jsr OutHex	;
                      003163 |	
      F1EB A9 68      003164 |	lda #104d	;Print lower case h to indicate hex number.
      F1ED 20 14 F4   003165 |	jsr OutChar	;
                      003166 |
      F1F0 4C 20 F0   003167 |	jmp StartUnA
                      003168 |
                      003169 |
      F1F3            003170 |IRIAdMo:
      F1F3 A0 00      003171 |	ldy #0d
                      003172 |
      F1F5 AD 43 00   003173 |	lda OpCdHold	;Print the opcode and a space.
      F1F8 20 5F F3   003174 |	jsr OutHex	;
      F1FB A9 20      003175 |	lda #32d	;
      F1FD 20 14 F4   003176 |	jsr OutChar	;
                      003177 |	
      F200 B1 08      003178 |	lda (PointerA),y;Print the second byte of the instruction and
      F202 8D 41 00   003179 |	sta ObCdHld1	; increment the memory pointer.
      F205 20 5F F3   003180 |	jsr OutHex	;
      F208 20 DB F2   003181 |	jsr IncPntrA	;
                      003182 |	
      F20B A0 05      003183 |	ldy #5d		;Print spaces between object code field and
      F20D 20 03 F3   003184 |	jsr OutSpace	; operator field.
                      003185 |	
      F210 20 C9 F2   003186 |	jsr PrntMnem	;Print the operator.
                      003187 |	
      F213 A9 28      003188 |	lda #40d	;Print (.
      F215 20 14 F4   003189 |	jsr OutChar	;
                      003190 |	
      F218 AD 41 00   003191 |	lda ObCdHld1	;Print offset into zero page.
      F21B 20 5F F3   003192 |	jsr OutHex	;
                      003193 |	
      F21E A9 68      003194 |	lda #104d	;Print lower case h to indicate hex.
      F220 20 14 F4   003195 |	jsr OutChar	;
                      003196 |	
      F223 A9 29      003197 |	lda #41d	;Print ).
      F225 20 14 F4   003198 |	jsr OutChar	;
                      003199 |	
      F228 A9 2C      003200 |	lda #44d	;Print comma and y.
      F22A 20 14 F4   003201 |	jsr OutChar	;
      F22D A9 59      003202 |	lda #89d	;
      F22F 20 14 F4   003203 |	jsr OutChar	;
                      003204 |	
      F232 4C 20 F0   003205 |	jmp StartUnA
                      003206 |	
      F235            003207 |IIRAdMo:
      F235 A0 00      003208 |	ldy #0d
                      003209 |
      F237 AD 43 00   003210 |	lda OpCdHold	;Print the opcode and a space.
      F23A 20 5F F3   003211 |	jsr OutHex	;
      F23D A9 20      003212 |	lda #32d	;
      F23F 20 14 F4   003213 |	jsr OutChar	;
                      003214 |	
      F242 B1 08      003215 |	lda (PointerA),y;Print the second byte of the instruction and
      F244 8D 41 00   003216 |	sta ObCdHld1	; increment the memory pointer.
      F247 20 5F F3   003217 |	jsr OutHex	;
      F24A 20 DB F2   003218 |	jsr IncPntrA	;
                      003219 |	
      F24D A0 05      003220 |	ldy #5d		;Print spaces between object code field and
      F24F 20 03 F3   003221 |	jsr OutSpace	; operator field.
                      003222 |	
      F252 20 C9 F2   003223 |	jsr PrntMnem	;Print the operator.
                      003224 |	
      F255 A9 28      003225 |	lda #40d	;Print (.
      F257 20 14 F4   003226 |	jsr OutChar	;
                      003227 |	
      F25A AD 41 00   003228 |	lda ObCdHld1	;Print offset into zero page.
      F25D 20 5F F3   003229 |	jsr OutHex	;
                      003230 |	
      F260 A9 68      003231 |	lda #104d	;Print lower case h to indicate hex.
      F262 20 14 F4   003232 |	jsr OutChar	;
                      003233 |	
      F265 A9 2C      003234 |	lda #44d	;Print comma and x.
      F267 20 14 F4   003235 |	jsr OutChar	;
      F26A A9 58      003236 |	lda #88d	;
      F26C 20 14 F4   003237 |	jsr OutChar	;
                      003238 |	
      F26F A9 29      003239 |	lda #41d	;Print ).
      F271 20 14 F4   003240 |	jsr OutChar	;
                      003241 |	
      F274 4C 20 F0   003242 |	jmp StartUnA
                      003243 |
      F277            003244 |IndAdMo:
      F277 A0 00      003245 |	ldy #0d
                      003246 |
      F279 AD 43 00   003247 |	lda OpCdHold	;Print the opcode and a space.
      F27C 20 5F F3   003248 |	jsr OutHex	;
      F27F A9 20      003249 |	lda #32d	;
      F281 20 14 F4   003250 |	jsr OutChar	;
                      003251 |	
      F284 B1 08      003252 |	lda (PointerA),y;Print the second byte of the instruction and
      F286 8D 41 00   003253 |	sta ObCdHld1	; increment the memory pointer
      F289 20 5F F3   003254 |	jsr OutHex	;
      F28C 20 DB F2   003255 |	jsr IncPntrA	;
                      003256 |	
      F28F A9 20      003257 |	lda #32d	;Print a space between obj codes.
      F291 20 14 F4   003258 |	jsr OutChar	;
                      003259 |	
      F294 B1 08      003260 |	lda (PointerA),y;Print the third byte of the instruction and
      F296 8D 42 00   003261 |	sta ObCdHld2	; increment the memory pointer
      F299 20 5F F3   003262 |	jsr OutHex	;
      F29C 20 DB F2   003263 |	jsr IncPntrA	;
                      003264 |	
      F29F A0 02      003265 |	ldy #2d		;Print spaces between object code field and
      F2A1 20 03 F3   003266 |	jsr OutSpace	; operator field.
                      003267 |	
      F2A4 20 C9 F2   003268 |	jsr PrntMnem	;Print the operator.
                      003269 |
      F2A7 A9 28      003270 |	lda #40d	;Print (.
      F2A9 20 14 F4   003271 |	jsr OutChar	;
                      003272 |	
      F2AC AD 42 00   003273 |	lda ObCdHld2	;Print absolute address in msb, lsb order.
      F2AF 20 5F F3   003274 |	jsr OutHex	;
      F2B2 AD 41 00   003275 |	lda ObCdHld1	;
      F2B5 20 5F F3   003276 |	jsr OutHex	;
                      003277 |	
      F2B8 A9 68      003278 |	lda #104d	;Print lower case h to indicate hex number.
      F2BA 20 14 F4   003279 |	jsr OutChar	;
                      003280 |	
      F2BD A9 29      003281 |	lda #41d	;Print ).
      F2BF 20 14 F4   003282 |	jsr OutChar	;
                      003283 |	
      F2C2 4C 20 F0   003284 |	jmp StartUnA
                      003285 |	
      F2C5            003286 |ErrUnAs:
      F2C5 18         003287 |	clc
      F2C6 60         003288 |	rts
                      003289 |
      F2C7            003290 |ExitUnAs:
      F2C7 38         003291 |	sec
      F2C8 60         003292 |	rts
                      003293 |
                      003294 |
                      003295 |;****************************************************************************
                      003296 |;                       Print Mnemonic Subroutine.
                      003297 |;****************************************************************************
      F2C9            003298 |PrntMnem:
                      003299 |
      F2C9 A0 00      003300 |	ldy #0d		;Use loop to print all three characters of
      F2CB            003301 |PrntMore:
      F2CB B1 0A      003302 |	lda (PointerB),y; mnemonic.
      F2CD 20 14 F4   003303 |	jsr OutChar	;
      F2D0 C8         003304 |	iny		;
      F2D1 C0 03      003305 |	cpy #3d		;
      F2D3 D0 F6      003306 |	bne PrntMore	;
                      003307 |	
      F2D5 A9 20      003308 |	lda #32d	;Print a space after the mnemonic.
      F2D7 20 14 F4   003309 |	jsr OutChar	;
                      003310 |	
      F2DA 60         003311 |	rts
                      003312 |
                      003313 |;****************************************************************************
                      003314 |;                       Increment Pointer A Subroutine.
                      003315 |;****************************************************************************
      F2DB            003316 |IncPntrA:
      F2DB EE 08 00   003317 |	inc PointerA
      F2DE D0 03      003318 |	bne NoOvFl1
      F2E0 EE 09 00   003319 |	inc PointerA+1d
      F2E3            003320 |NoOvFl1:
      F2E3 60         003321 |	rts
                      003322 |
                      003323 |
                      003324 |
                      003325 |;****************************************************************************
                      003326 |;                        Get Address Subroutine
                      003327 |;
                      003328 |;	X returns LSB of address.  Y returns MSB of address.
                      003329 |;****************************************************************************
      F2E4            003330 |GetAdd:		;Convert address found in operand field #x
      F2E4 20 3D F3   003331 |	jsr AsToBin	; into binary.
      F2E7 B0 03      003332 |	bcs AdMSBOK	;
      F2E9 4C F9 F2   003333 |	jmp ErrGtAd	;
      F2EC            003334 |AdMSBOK:		;
      F2EC A8         003335 |	tay		;
      F2ED E8         003336 |	inx		;
      F2EE 20 3D F3   003337 |	jsr AsToBin	;
      F2F1 B0 03      003338 |	bcs AdLSBOK	;
      F2F3 4C F9 F2   003339 |	jmp ErrGtAd	;
      F2F6            003340 |AdLSBOK:		;
      F2F6 AA         003341 |	tax
                      003342 |
      F2F7 38         003343 |	sec		;If conversion OK then set carry flag and
      F2F8 60         003344 |	rts		; return.
                      003345 |	
      F2F9            003346 |ErrGtAd:		;
      F2F9 18         003347 |	clc		;If error then clear carry and return.
      F2FA 60         003348 |	rts		;
                      003349 |
                      003350 |
                      003351 |;****************************************************************************
                      003352 |;                     Output a Colon Prompt Subroutine.
                      003353 |;****************************************************************************
      F2FB            003354 |OutColn:
      F2FB A2 B3      003355 |	ldx #ColnPrmt<
      F2FD A0 F5      003356 |	ldy #ColnPrmt>
      F2FF 20 B3 F3   003357 |	jsr PrntMess
      F302 60         003358 |	rts
                      003359 |
                      003360 |;****************************************************************************
                      003361 |;                     Out Spaces Subroutine
                      003362 |;
                      003363 |;       Enter with the Y register indicating the number of spaces to output.
                      003364 |;****************************************************************************
      F303            003365 |OutSpace:		;Output the number of spaces indicated by
      F303 48         003366 |	pha		; the Y register.
      F304            003367 |OtAnoSpc:
      F304 A9 20      003368 |	lda #32d
      F306 20 14 F4   003369 |	jsr OutChar
      F309 88         003370 |	dey
      F30A D0 F8      003371 |	bne OtAnoSpc
      F30C 68         003372 |	pla
      F30D 60         003373 |	rts
                      003374 |
                      003375 |
                      003376 |;****************************************************************************
                      003377 |;              Covert ASCII character to lower case Subroutine.
                      003378 |;****************************************************************************
      F30E            003379 |ToLower:
      F30E C9 41      003380 |	cmp #65d
      F310 30 07      003381 |	bmi ExitToLo
      F312 C9 5B      003382 |	cmp #91d
      F314 10 03      003383 |	bpl ExitToLo
      F316 18         003384 |	clc
      F317 69 20      003385 |	adc #32d
      F319            003386 |ExitTolo:
      F319 60         003387 |	rts
                      003388 |
                      003389 |
                      003390 |;****************************************************************************
                      003391 |;              Covert ASCII character to upper case Subroutine.
                      003392 |;****************************************************************************
      F31A            003393 |ToUpper:
      F31A C9 61      003394 |	cmp #'a'
      F31C 30 07      003395 |	bmi ExitToUp
      F31E C9 7B      003396 |	cmp #123d
      F320 10 03      003397 |	bpl ExitToUp
      F322 38         003398 |	sec
      F323 E9 20      003399 |	sbc #32d
      F325            003400 |ExitToUp:
      F325 60         003401 |	rts
                      003402 |
                      003403 |
                      003404 |
                      003405 |;****************************************************************************
                      003406 |;                         Print address.
                      003407 |;****************************************************************************
      F326            003408 |PrntAdd:
      F326 AD 09 00   003409 |	lda PointerA+1d	;
      F329 20 5F F3   003410 |	jsr OutHex	;
      F32C AD 08 00   003411 |	lda PointerA	;
      F32F 20 5F F3   003412 |	jsr OutHex	;
      F332 A9 20      003413 |	lda #32d	;
      F334 20 14 F4   003414 |	jsr OutChar	;
      F337 A9 20      003415 |	lda #32d	;
      F339 20 14 F4   003416 |	jsr OutChar	;
                      003417 |	
      F33C 60         003418 |	rts
                      003419 |
                      003420 |;****************************************************************************
                      003421 |;                         Ascii to Binary Subroutine.
                      003422 |;****************************************************************************
      F33D            003423 |AsToBin:		;X points to digits to be converted using
                      003424 |			; OpFld1 as a base.
                      003425 |
      F33D BD 5F 00   003426 |	lda OpFld1,x	;Convert most significant digit to binary.
      F340 20 93 EA   003427 |	jsr DgtToBin	;
      F343 90 19      003428 |	bcc ExtAs2Bn	;
      F345 0A         003429 |	asl a		;
      F346 0A         003430 |	asl a		;
      F347 0A         003431 |	asl a		;
      F348 0A         003432 |	asl a		;
      F349 29 F0      003433 |	and #0f0h	;
      F34B 8D 9C 00   003434 |	sta number	;
                      003435 |	
      F34E E8         003436 |	inx		;Convert least significant digit to binary.
      F34F BD 5F 00   003437 |	lda OpFld1,x	;
      F352 20 93 EA   003438 |	jsr DgtToBin	;
      F355 90 07      003439 |	bcc ExtAs2Bn	;
      F357 0D 9C 00   003440 |	ora number	;
                      003441 |	
      F35A 8D 9C 00   003442 |	sta number	;Store full binary number in number.
      F35D 38         003443 |	sec
      F35E            003444 |ExtAs2Bn:
      F35E 60         003445 |	rts
                      003446 |	
                      003447 |;****************************************************************************
                      003448 |;                     Output a Hex byte to the serial port.
                      003449 |;
                      003450 |;            Enter with the number to be output in the A register.
                      003451 |;****************************************************************************
      F35F            003452 |OutHex:
      F35F 8D 9C 00   003453 |	sta number
                      003454 |	
      F362 4A         003455 |	lsr a		;Output most significant digit of hex byte to
      F363 4A         003456 |	lsr a		; serial port.
      F364 4A         003457 |	lsr a		;
      F365 4A         003458 |	lsr a		;
      F366 29 0F      003459 |	and #0fh	;
      F368 C9 0A      003460 |	cmp #0ah	;
      F36A 10 05      003461 |	bpl Letter1	;
      F36C 09 30      003462 |	ora #30h	;
      F36E 4C 76 F3   003463 |	jmp Print1st	;
      F371            003464 |Letter1:		;
      F371 38         003465 |	sec
      F372 E9 09      003466 |	sbc #9d		;
      F374 09 40      003467 |	ora #40h
      F376            003468 |Print1st:
      F376 20 14 F4   003469 |	jsr OutChar	;
                      003470 |	
      F379 AD 9C 00   003471 |	lda number	;Output least significant digit of hex byte to
      F37C 29 0F      003472 |	and #0fh	; serial port.
      F37E C9 0A      003473 |	cmp #0ah	;
      F380 10 05      003474 |	bpl Letter2	;
      F382 09 30      003475 |	ora #30h	;
      F384 4C 8C F3   003476 |	jmp Print2nd	;
      F387            003477 |Letter2:		;
      F387 38         003478 |	sec
      F388 E9 09      003479 |	sbc #9d		;
      F38A 09 40      003480 |	ora #40h	;
      F38C            003481 |Print2nd:		;
      F38C 20 14 F4   003482 |	jsr OutChar	;
                      003483 |	
      F38F AD 9C 00   003484 |	lda number
      F392 60         003485 |	rts
                      003486 |	
                      003487 |;****************************************************************************
                      003488 |;                     Initialize Variables Subroutine
                      003489 |;****************************************************************************
      F393            003490 |InitVars:
                      003491 |
                      003492 |	;lda #1ah	;Initialize ACIA control register, 2400
                      003493 |	;sta 6551CtR	; Baud.
                      003494 |	
                      003495 |	;lda #0bh	;Initialize ACIA command register.
                      003496 |	;sta 6551CmR	;
                      003497 |		
      F393 A9 1E      003498 |	lda #BRK<	;Initialize BRK vector.
      F395 8D 04 00   003499 |	sta BRKVect	;
      F398 A9 E2      003500 |	lda #BRK>	;
      F39A 8D 05 00   003501 |	sta BRKVect+1d	;
                      003502 |	
      F39D A9 00      003503 |	lda #0d		;Initialize trace break flag.
      F39F 8D 39 00   003504 |	sta TrBrkFlg	;
                      003505 |	
      F3A2 A9 00      003506 |	lda #0d		;Initialize break point status variables.
      F3A4 8D 2F 00   003507 |	sta BrkPt1St	;
      F3A7 8D 30 00   003508 |	sta BrkPt2St	;
      F3AA 8D 31 00   003509 |	sta BrkPt3St	;
      F3AD 8D 32 00   003510 |	sta BrkPt4St	;
                      003511 |	
      F3B0 A9 00      003512 |	lda #0d		;Set the output port to all zeros (turn
                      003513 |	;sta OutPort0	; off all of the LEDs).
                      003514 |	
      F3B2 60         003515 |	rts
                      003516 |
                      003517 |;****************************************************************************
                      003518 |;                          Print Message Subroutine.
                      003519 |;
                      003520 |; X holds the message pointer's low byte (< means less than) and Y holds its 
                      003521 |; high byte (> means greater than).  The message must have a NULL (0) after 
                      003522 |; the last character in the  Message so the PrntMess subroutine knows when to 
                      003523 |; stop printing.
                      003524 |;****************************************************************************
      F3B3            003525 |PrntMess:
      F3B3 48         003526 |	pha
                      003527 |	
      F3B4 8E 06 00   003528 |	stx MessPtr	;Initialize pointer that will point to each
      F3B7 8C 07 00   003529 |	sty MessPtr+1h	; character of message.
                      003530 |	
      F3BA A0 00      003531 |	ldy #0h
                      003532 |	
      F3BC            003533 |OutMess:		;
      F3BC B1 06      003534 |	lda (MessPtr),y	;Get a character from the message and if it is
      F3BE F0 0E      003535 |	beq ExitMess	; a NULL (0) then exit this subroutine.
                      003536 |	
      F3C0 20 14 F4   003537 |	jsr OutChar	;Output the character to the serial port.
                      003538 |	
      F3C3 EE 06 00   003539 |	inc MessPtr	;Increment the message pointer to point to the
      F3C6 D0 03      003540 |	bne PrNoOvf	; next character in the message.
      F3C8 EE 07 00   003541 |	inc MessPtr+1d	;
                      003542 |	
      F3CB            003543 |PrNoOvf:
      F3CB 4C BC F3   003544 |	jmp OutMess
                      003545 |		
      F3CE            003546 |ExitMess:
      F3CE 68         003547 |	pla
                      003548 |	
      F3CF 60         003549 |	rts
                      003550 |
                      003551 |;****************************************************************************
                      003552 |;           Get Character (Don't Wait) From Serial Channel Subroutine
                      003553 |;****************************************************************************
      F3D0            003554 |GetChar:
      F3D0 08         003555 |	php		;Save the registers on the stack.
      F3D1 8A         003556 |	txa		;
      F3D2 48         003557 |	pha		;
      F3D3 98         003558 |	tya		;
      F3D4 48         003559 |	pha		;
                      003560 |	
      F3D5 AD 01 A0   003561 |	lda 6551StR	;Check ACIA to see if a character has been
      F3D8 29 08      003562 |	and #00001000b	; received and return with a NULL if no
      F3DA F0 09      003563 |	beq NoChar	; character was present.
                      003564 |	
      F3DC AD 00 A0   003565 |	lda 6551TRR	;Get the received character from the ACIA's 
      F3DF 8D CE 00   003566 |	sta RegTemp	; receive register.
      F3E2 4C EA F3   003567 |	jmp ExitGtCh	;
                      003568 |	
      F3E5            003569 |NoChar:
      F3E5 A9 00      003570 |	lda #0d
      F3E7 8D CE 00   003571 |	sta RegTemp
                      003572 |	
      F3EA            003573 |ExitGtCh:
      F3EA 68         003574 |	pla		;Restore the registers.
      F3EB A8         003575 |	tay		;
      F3EC 68         003576 |	pla		;
      F3ED AA         003577 |	tax		;
      F3EE 28         003578 |	plp		;
      F3EF AD CE 00   003579 |	lda RegTemp	;
                      003580 |	
      F3F2 60         003581 |	rts
                      003582 |	
                      003583 |;****************************************************************************
                      003584 |;             Get Character (Wait) From Serial Channel Subroutine
                      003585 |;****************************************************************************
      F3F3            003586 |GetCharW:
      F3F3 08         003587 |	php		;Save the registers on the stack.
      F3F4 8A         003588 |	txa		;
      F3F5 48         003589 |	pha		;
      F3F6 98         003590 |	tya		;
      F3F7 48         003591 |	pha		;
                      003592 |	
      F3F8            003593 |GtCkAgn:	
      F3F8 AD 01 A0   003594 |	lda 6551StR	;Check the ACIA's receiver buffer full register
      F3FB 29 08      003595 |	and #00001000b	; and wait until a character is received.
      F3FD D0 06      003596 |	bne CharRec	;
                      003597 |	
      F3FF AD 02 A0   003598 |	lda 6551Sleep ;Allow the emulator to be put to sleep.
      F402 4C F8 F3   003599 |	jmp GtCkAgn
                      003600 |	
      F405            003601 |CharRec:
      F405 AD 00 A0   003602 |	lda 6551TRR	;Get the received character from the ACIA's 
      F408 8D CE 00   003603 |	sta RegTemp	; receive register.
                      003604 |	
      F40B 68         003605 |	pla		;Restore the registers.
      F40C A8         003606 |	tay		;
      F40D 68         003607 |	pla		;
      F40E AA         003608 |	tax		;
      F40F 28         003609 |	plp		;
      F410 AD CE 00   003610 |	lda RegTemp	;
                      003611 |	
      F413 60         003612 |	rts
                      003613 |	
                      003614 |;****************************************************************************
                      003615 |;                 Output Character to Serial Channel Subroutine 
                      003616 |;                   Character to print is in register 'A'
                      003617 |;****************************************************************************
      F414            003618 |OutChar:
                      003619 |	
      F414 8D CE 00   003620 |	sta RegTemp	;Save registers.
      F417 08         003621 |	php		;
      F418 98         003622 |	tya		;
      F419 48         003623 |	pha		;
      F41A 8A         003624 |	txa		;
      F41B 48         003625 |	pha		;
                      003626 |	
      F41C            003627 |OtCkAgn:
      F41C AD 01 A0   003628 |	lda 6551StR	;Check the ACIA's Transmitter Buffer Empty
      F41F 29 10      003629 |	and #00010000b	; register and wait until the buffer is empty.
      F421 F0 F9      003630 |	beq OtCkAgn	;
                      003631 |	
      F423 AD CE 00   003632 |	lda RegTemp	;Output a character to the ACIA's Transmitt
      F426 8D 00 A0   003633 |	sta 6551TRR	; register.
                      003634 |	
      F429 68         003635 |	pla		;Restore registers.
      F42A AA         003636 |	tax		;
      F42B 68         003637 |	pla		;
      F42C A8         003638 |	tay		;
      F42D 28         003639 |	plp		;
      F42E AD CE 00   003640 |	lda RegTemp	;
                      003641 |		
      F431 60         003642 |	rts
                      003643 |
                      003644 |
                      003645 |;****************************************************************************
                      003646 |;                          Delay Subroutine
                      003647 |;****************************************************************************
      F432            003648 |delay:
      F432 48         003649 |	pha
      F433 8A         003650 |	txa
      F434 48         003651 |	pha
      F435 98         003652 |	tya
      F436 48         003653 |	pha
                      003654 |	
      F437 A9 00      003655 |	lda #0h
      F439 8D A2 00   003656 |	sta wait0
      F43C A9 10      003657 |	lda #10h
      F43E 8D A3 00   003658 |	sta wait1
                      003659 |	
                      003660 |	
      F441            003661 |dw0:
      F441 CE A2 00   003662 |	dec wait0
      F444 D0 FB      003663 |	bne dw0
      F446 CE A3 00   003664 |	dec wait1
      F449 D0 F6      003665 |	bne dw0
                      003666 |	
      F44B 68         003667 |	pla
      F44C A8         003668 |	tay
      F44D 68         003669 |	pla                                                                        
      F44E AA         003670 |	tax
      F44F 68         003671 |	pla
      F450 60         003672 |	rts
                      003673 |
                      003674 |
                      003675 |;****************************************************************************
                      003676 |;                Constants
                      003677 |;****************************************************************************
                      003678 |
      F451 16         003679 |UARTval:		dbt 16h,0bh
      F452 0B               
      F453 30         003680 |DgtTblUC:		dbt "0123456789ABCDEF"
      F454 31 32 33         
      F457 34 35 36         
      F45A 37 38 39         
      F45D 41 42 43         
      F460 44 45 46         
      F463 00         003681 |				dbt 0h
      F464 30         003682 |DgtTblLC:		dbt "0123456789abcdef"
      F465 31 32 33         
      F468 34 35 36         
      F46B 37 38 39         
      F46E 61 62 63         
      F471 64 65 66         
      F474 00         003683 |				dbt 0h
      F475 0A         003684 |EmulatorMess:	dbt 10d,13d
      F476 0D               
      F477 45         003685 |				dbt "Emulator v"
      F478 6D 75 6C         
      F47B 61 74 6F         
      F47E 72 20 76         
      F481 20         003686 |EmuVersionTo:	dbt "        " ;8 characters.
      F482 20 20 20         
      F485 20 20 20         
      F488 20               
      F489 0A         003687 |				dbt 10d,13d
      F48A 0D               
      F48B 00         003688 |				dbt 0h
      F48C 55         003689 |OpenMess:		dbt "UMON65 v1.22 - Understandable Monitor for the 6500 series microprocessors."
      F48D 4D 4F 4E         
      F490 36 35 20         
      F493 76 31 2E         
      F496 32 32 20         
      F499 2D 20 55         
      F49C 6E 64 65         
      F49F 72 73 74         
      F4A2 61 6E 64         
      F4A5 61 62 6C         
      F4A8 65 20 4D         
      F4AB 6F 6E 69         
      F4AE 74 6F 72         
      F4B1 20 66 6F         
      F4B4 72 20 74         
      F4B7 68 65 20         
      F4BA 36 35 30         
      F4BD 30 20 73         
      F4C0 65 72 69         
      F4C3 65 73 20         
      F4C6 6D 69 63         
      F4C9 72 6F 70         
      F4CC 72 6F 63         
      F4CF 65 73 73         
      F4D2 6F 72 73         
      F4D5 2E               
      F4D6 0A         003690 |				dbt 10d,13d
      F4D7 0D               
      F4D8 00         003691 |				dbt 0h
      F4D9 0A         003692 |prompt:			dbt 10d,13d
      F4DA 0D               
      F4DB 2D         003693 |				dbt "-"
      F4DC 00         003694 |				dbt 0h
      F4DD 0A         003695 |CRLF:			dbt 10d,13d,0d
      F4DE 0D               
      F4DF 00               
      F4E0 0A         003696 |SRecStMs:		dbt 10d,13d
      F4E1 0D               
      F4E2 53         003697 |				dbt "Send S records when you are ready..."
      F4E3 65 6E 64         
      F4E6 20 53 20         
      F4E9 72 65 63         
      F4EC 6F 72 64         
      F4EF 73 20 77         
      F4F2 68 65 6E         
      F4F5 20 79 6F         
      F4F8 75 20 61         
      F4FB 72 65 20         
      F4FE 72 65 61         
      F501 64 79 2E         
      F504 2E 2E            
      F506 0A         003698 |				dbt 10d,13d,0d
      F507 0D               
      F508 00               
      F509 0A         003699 |SRecErMe:		dbt 10d,13d,7d
      F50A 0D               
      F50B 07               
      F50C 45         003700 |				dbt "Error Loading S Records..."
      F50D 72 72 6F         
      F510 72 20 4C         
      F513 6F 61 64         
      F516 69 6E 67         
      F519 20 53 20         
      F51C 52 65 63         
      F51F 6F 72 64         
      F522 73 2E 2E         
      F525 2E               
      F526 0A         003701 |				dbt 10d,13d,0d
      F527 0D               
      F528 00               
      F529 0A         003702 |SRecEnMs:		dbt 10d,13d,7d
      F52A 0D               
      F52B 07               
      F52C 53         003703 |				dbt "S records successfully loaded (press <enter> to continue)."
      F52D 20 72 65         
      F530 63 6F 72         
      F533 64 73 20         
      F536 73 75 63         
      F539 63 65 73         
      F53C 73 66 75         
      F53F 6C 6C 79         
      F542 20 6C 6F         
      F545 61 64 65         
      F548 64 20 28         
      F54B 70 72 65         
      F54E 73 73 20         
      F551 3C 65 6E         
      F554 74 65 72         
      F557 3E 20 74         
      F55A 6F 20 63         
      F55D 6F 6E 74         
      F560 69 6E 75         
      F563 65 29 2E         
      F566 0A         003704 |				dbt 10d,13d,0d
      F567 0D               
      F568 00               
      F569 0A         003705 |RegMess:		dbt 10d,13d,10d
      F56A 0D               
      F56B 0A               
      F56C 50         003706 |				dbt "PgmCntr(PC)  Accum(AC)  XReg(XR)  YReg(YR)  StkPtr(SP)  NV-BDIZC(SR)"
      F56D 67 6D 43         
      F570 6E 74 72         
      F573 28 50 43         
      F576 29 20 20         
      F579 41 63 63         
      F57C 75 6D 28         
      F57F 41 43 29         
      F582 20 20 58         
      F585 52 65 67         
      F588 28 58 52         
      F58B 29 20 20         
      F58E 59 52 65         
      F591 67 28 59         
      F594 52 29 20         
      F597 20 53 74         
      F59A 6B 50 74         
      F59D 72 28 53         
      F5A0 50 29 20         
      F5A3 20 4E 56         
      F5A6 2D 42 44         
      F5A9 49 5A 43         
      F5AC 28 53 52         
      F5AF 29               
      F5B0 0A         003707 |				dbt 10d,13d,0d
      F5B1 0D               
      F5B2 00               
      F5B3 0A         003708 |ColnPrmt:		dbt 10d,13d
      F5B4 0D               
      F5B5 20         003709 |				dbt " :"
      F5B6 3A               
      F5B7 00         003710 |				dbt 0d
      F5B8 20         003711 |BadOpMes:		dbt "        ???"
      F5B9 20 20 20         
      F5BC 20 20 20         
      F5BF 20 3F 3F         
      F5C2 3F               
      F5C3 00         003712 |				dbt 0d
      F5C4 0A         003713 |BPFulMes:		dbt 10d,13d
      F5C5 0D               
      F5C6 41         003714 |				dbt "All breakpoints are currently in use."
      F5C7 6C 6C 20         
      F5CA 62 72 65         
      F5CD 61 6B 70         
      F5D0 6F 69 6E         
      F5D3 74 73 20         
      F5D6 61 72 65         
      F5D9 20 63 75         
      F5DC 72 72 65         
      F5DF 6E 74 6C         
      F5E2 79 20 69         
      F5E5 6E 20 75         
      F5E8 73 65 2E         
      F5EB 00         003715 |				dbt 0d
      F5EC 0A         003716 |NoBPMess:		dbt 10d,13d
      F5ED 0D               
      F5EE 4E         003717 |				dbt "No breakpoint exists at this address."
      F5EF 6F 20 62         
      F5F2 72 65 61         
      F5F5 6B 70 6F         
      F5F8 69 6E 74         
      F5FB 20 65 78         
      F5FE 69 73 74         
      F601 73 20 61         
      F604 74 20 74         
      F607 68 69 73         
      F60A 20 61 64         
      F60D 64 72 65         
      F610 73 73 2E         
      F613 00         003718 |				dbt 0d
      F614 0A         003719 |GoBPErrM:		dbt 10d,13d
      F615 0D               
      F616 59         003720 |				dbt "You cannot GO at a breakpointed address, TRACE past it then GO."
      F617 6F 75 20         
      F61A 63 61 6E         
      F61D 6E 6F 74         
      F620 20 47 4F         
      F623 20 61 74         
      F626 20 61 20         
      F629 62 72 65         
      F62C 61 6B 70         
      F62F 6F 69 6E         
      F632 74 65 64         
      F635 20 61 64         
      F638 64 72 65         
      F63B 73 73 2C         
      F63E 20 54 52         
      F641 41 43 45         
      F644 20 70 61         
      F647 73 74 20         
      F64A 69 74 20         
      F64D 74 68 65         
      F650 6E 20 47         
      F653 4F 2E            
      F655 00         003721 |				dbt 0d
      F656 0A         003722 |CmdErMes:		dbt 10d,13d
      F657 0D               
      F658 3F         003723 |				dbt "?"
      F659 00         003724 |				dbt 0d
      F65A 0A         003725 |HelpMess:		dbt 10d,13d,10d
      F65B 0D               
      F65C 0A               
      F65D 41         003726 |				dbt "Assemble       A start_address"
      F65E 73 73 65         
      F661 6D 62 6C         
      F664 65 20 20         
      F667 20 20 20         
      F66A 20 20 41         
      F66D 20 73 74         
      F670 61 72 74         
      F673 5F 61 64         
      F676 64 72 65         
      F679 73 73            
      F67B 0A         003727 |				dbt 10d,13d
      F67C 0D               
      F67D 42         003728 |				dbt "Breakpoint     B (+,-,?) address"
      F67E 72 65 61         
      F681 6B 70 6F         
      F684 69 6E 74         
      F687 20 20 20         
      F68A 20 20 42         
      F68D 20 28 2B         
      F690 2C 2D 2C         
      F693 3F 29 20         
      F696 61 64 64         
      F699 72 65 73         
      F69C 73               
      F69D 0A         003729 |				dbt 10d,13d
      F69E 0D               
      F69F 44         003730 |				dbt "Dump           D [start_address [end_address]]"
      F6A0 75 6D 70         
      F6A3 20 20 20         
      F6A6 20 20 20         
      F6A9 20 20 20         
      F6AC 20 20 44         
      F6AF 20 5B 73         
      F6B2 74 61 72         
      F6B5 74 5F 61         
      F6B8 64 64 72         
      F6BB 65 73 73         
      F6BE 20 5B 65         
      F6C1 6E 64 5F         
      F6C4 61 64 64         
      F6C7 72 65 73         
      F6CA 73 5D 5D         
      F6CD 0A         003731 |				dbt 10d,13d
      F6CE 0D               
      F6CF 45         003732 |				dbt "Enter          E address list"
      F6D0 6E 74 65         
      F6D3 72 20 20         
      F6D6 20 20 20         
      F6D9 20 20 20         
      F6DC 20 20 45         
      F6DF 20 61 64         
      F6E2 64 72 65         
      F6E5 73 73 20         
      F6E8 6C 69 73         
      F6EB 74               
      F6EC 0A         003733 |				dbt 10d,13d
      F6ED 0D               
      F6EE 46         003734 |				dbt "Fill           F start_address end_address list"
      F6EF 69 6C 6C         
      F6F2 20 20 20         
      F6F5 20 20 20         
      F6F8 20 20 20         
      F6FB 20 20 46         
      F6FE 20 73 74         
      F701 61 72 74         
      F704 5F 61 64         
      F707 64 72 65         
      F70A 73 73 20         
      F70D 65 6E 64         
      F710 5F 61 64         
      F713 64 72 65         
      F716 73 73 20         
      F719 6C 69 73         
      F71C 74               
      F71D 0A         003735 |				dbt 10d,13d
      F71E 0D               
      F71F 47         003736 |				dbt "Go             G [start_address]"
      F720 6F 20 20         
      F723 20 20 20         
      F726 20 20 20         
      F729 20 20 20         
      F72C 20 20 47         
      F72F 20 5B 73         
      F732 74 61 72         
      F735 74 5F 61         
      F738 64 64 72         
      F73B 65 73 73         
      F73E 5D               
      F73F 0A         003737 |				dbt 10d,13d
      F740 0D               
      F741 48         003738 |				dbt "Help           H or ?"
      F742 65 6C 70         
      F745 20 20 20         
      F748 20 20 20         
      F74B 20 20 20         
      F74E 20 20 48         
      F751 20 6F 72         
      F754 20 3F            
      F756 0A         003739 |				dbt 10d,13d
      F757 0D               
      F758 4C         003740 |				dbt "Load           L"
      F759 6F 61 64         
      F75C 20 20 20         
      F75F 20 20 20         
      F762 20 20 20         
      F765 20 20 4C         
      F768 0A         003741 |				dbt 10d,13d
      F769 0D               
      F76A 4D         003742 |				dbt "Move           M start_address end_address destination_address"
      F76B 6F 76 65         
      F76E 20 20 20         
      F771 20 20 20         
      F774 20 20 20         
      F777 20 20 4D         
      F77A 20 73 74         
      F77D 61 72 74         
      F780 5F 61 64         
      F783 64 72 65         
      F786 73 73 20         
      F789 65 6E 64         
      F78C 5F 61 64         
      F78F 64 72 65         
      F792 73 73 20         
      F795 64 65 73         
      F798 74 69 6E         
      F79B 61 74 69         
      F79E 6F 6E 5F         
      F7A1 61 64 64         
      F7A4 72 65 73         
      F7A7 73               
      F7A8 0A         003743 |				dbt 10d,13d
      F7A9 0D               
      F7AA 52         003744 |				dbt "Register       R [PC,AC,XR,YR,SP,SR]"
      F7AB 65 67 69         
      F7AE 73 74 65         
      F7B1 72 20 20         
      F7B4 20 20 20         
      F7B7 20 20 52         
      F7BA 20 5B 50         
      F7BD 43 2C 41         
      F7C0 43 2C 58         
      F7C3 52 2C 59         
      F7C6 52 2C 53         
      F7C9 50 2C 53         
      F7CC 52 5D            
      F7CE 0A         003745 |				dbt 10d,13d
      F7CF 0D               
      F7D0 53         003746 |				dbt "Search         S start_address end_address list"
      F7D1 65 61 72         
      F7D4 63 68 20         
      F7D7 20 20 20         
      F7DA 20 20 20         
      F7DD 20 20 53         
      F7E0 20 73 74         
      F7E3 61 72 74         
      F7E6 5F 61 64         
      F7E9 64 72 65         
      F7EC 73 73 20         
      F7EF 65 6E 64         
      F7F2 5F 61 64         
      F7F5 64 72 65         
      F7F8 73 73 20         
      F7FB 6C 69 73         
      F7FE 74               
      F7FF 0A         003747 |				dbt 10d,13d
      F800 0D               
      F801 54         003748 |				dbt "Trace          T [start_address [value]]"
      F802 72 61 63         
      F805 65 20 20         
      F808 20 20 20         
      F80B 20 20 20         
      F80E 20 20 54         
      F811 20 5B 73         
      F814 74 61 72         
      F817 74 5F 61         
      F81A 64 64 72         
      F81D 65 73 73         
      F820 20 5B 76         
      F823 61 6C 75         
      F826 65 5D 5D         
      F829 0A         003749 |				dbt 10d,13d
      F82A 0D               
      F82B 55         003750 |				dbt "Unassemble     U [start_address [end_address]]"
      F82C 6E 61 73         
      F82F 73 65 6D         
      F832 62 6C 65         
      F835 20 20 20         
      F838 20 20 55         
      F83B 20 5B 73         
      F83E 74 61 72         
      F841 74 5F 61         
      F844 64 64 72         
      F847 65 73 73         
      F84A 20 5B 65         
      F84D 6E 64 5F         
      F850 61 64 64         
      F853 72 65 73         
      F856 73 5D 5D         
      F859 0A         003751 |				dbt 10d,13d,0d
      F85A 0D               
      F85B 00               
                      003752 |	        	
                      003753 |            	
      F85C 41         003754 |OpTable:		dbt "ADC IMM"
      F85D 44 43 20         
      F860 49 4D 4D         
      F863 69         003755 |				dbt 069h,2h,2h
      F864 02               
      F865 02               
      F866 41         003756 |				dbt "ADC ABS"
      F867 44 43 20         
      F86A 41 42 53         
      F86D 6D         003757 |				dbt 06Dh,3h,4h
      F86E 03               
      F86F 04               
      F870 41         003758 |				dbt "ADC ABX"
      F871 44 43 20         
      F874 41 42 58         
      F877 7D         003759 |				dbt 07Dh,3h,4h
      F878 03               
      F879 04               
      F87A 41         003760 |				dbt "ADC ABY"
      F87B 44 43 20         
      F87E 41 42 59         
      F881 79         003761 |				dbt 079h,3h,4h
      F882 03               
      F883 04               
      F884 41         003762 |				dbt "ADC IIR"
      F885 44 43 20         
      F888 49 49 52         
      F88B 61         003763 |				dbt 061h,2h,6h
      F88C 02               
      F88D 06               
      F88E 41         003764 |				dbt "ADC IRI"
      F88F 44 43 20         
      F892 49 52 49         
      F895 71         003765 |				dbt 071h,2h,5h
      F896 02               
      F897 05               
      F898 41         003766 |				dbt "AND IMM"
      F899 4E 44 20         
      F89C 49 4D 4D         
      F89F 29         003767 |				dbt 029h,2h,2h
      F8A0 02               
      F8A1 02               
      F8A2 41         003768 |				dbt "AND ABS"
      F8A3 4E 44 20         
      F8A6 41 42 53         
      F8A9 2D         003769 |				dbt 02Dh,3h,4h
      F8AA 03               
      F8AB 04               
      F8AC 41         003770 |				dbt "AND ABX"
      F8AD 4E 44 20         
      F8B0 41 42 58         
      F8B3 3D         003771 |				dbt 03Dh,3h,4h
      F8B4 03               
      F8B5 04               
      F8B6 41         003772 |				dbt "AND ABY"
      F8B7 4E 44 20         
      F8BA 41 42 59         
      F8BD 39         003773 |				dbt 039h,3h,4h
      F8BE 03               
      F8BF 04               
      F8C0 41         003774 |				dbt "AND IIR"
      F8C1 4E 44 20         
      F8C4 49 49 52         
      F8C7 21         003775 |				dbt 021h,2h,6h
      F8C8 02               
      F8C9 06               
      F8CA 41         003776 |				dbt "AND IRI"
      F8CB 4E 44 20         
      F8CE 49 52 49         
      F8D1 31         003777 |				dbt 031h,2h,5h
      F8D2 02               
      F8D3 05               
      F8D4 41         003778 |				dbt "ASL ACC"
      F8D5 53 4C 20         
      F8D8 41 43 43         
      F8DB 0A         003779 |				dbt 00Ah,1h,2h
      F8DC 01               
      F8DD 02               
      F8DE 41         003780 |				dbt "ASL ABS"
      F8DF 53 4C 20         
      F8E2 41 42 53         
      F8E5 0E         003781 |				dbt 00Eh,3h,6h
      F8E6 03               
      F8E7 06               
      F8E8 41         003782 |				dbt "ASL ABX"
      F8E9 53 4C 20         
      F8EC 41 42 58         
      F8EF 1E         003783 |				dbt 01Eh,3h,7h
      F8F0 03               
      F8F1 07               
      F8F2 42         003784 |				dbt "BCC REL"
      F8F3 43 43 20         
      F8F6 52 45 4C         
      F8F9 90         003785 |				dbt 090h,2h,2h
      F8FA 02               
      F8FB 02               
      F8FC 42         003786 |				dbt "BCS REL"
      F8FD 43 53 20         
      F900 52 45 4C         
      F903 B0         003787 |				dbt 0B0h,2h,2h
      F904 02               
      F905 02               
      F906 42         003788 |				dbt "BEQ REL"
      F907 45 51 20         
      F90A 52 45 4C         
      F90D F0         003789 |				dbt 0F0h,2h,2h
      F90E 02               
      F90F 02               
      F910 42         003790 |				dbt "BIT ABS"
      F911 49 54 20         
      F914 41 42 53         
      F917 2C         003791 |				dbt 02Ch,3h,4h
      F918 03               
      F919 04               
      F91A 42         003792 |				dbt "BMI REL"
      F91B 4D 49 20         
      F91E 52 45 4C         
      F921 30         003793 |				dbt 030h,2h,2h
      F922 02               
      F923 02               
      F924 42         003794 |				dbt "BNE REL"
      F925 4E 45 20         
      F928 52 45 4C         
      F92B D0         003795 |				dbt 0D0h,2h,2h
      F92C 02               
      F92D 02               
      F92E 42         003796 |				dbt "BPL REL"
      F92F 50 4C 20         
      F932 52 45 4C         
      F935 10         003797 |				dbt 010h,2h,2h
      F936 02               
      F937 02               
      F938 42         003798 |				dbt "BRK IMP"
      F939 52 4B 20         
      F93C 49 4D 50         
      F93F 00         003799 |				dbt 000h,1h,7h
      F940 01               
      F941 07               
      F942 42         003800 |				dbt "BVC REL"
      F943 56 43 20         
      F946 52 45 4C         
      F949 50         003801 |				dbt 050h,2h,2h
      F94A 02               
      F94B 02               
      F94C 42         003802 |				dbt "BVS REL"
      F94D 56 53 20         
      F950 52 45 4C         
      F953 70         003803 |				dbt 070h,2h,2h
      F954 02               
      F955 02               
      F956 43         003804 |				dbt "CLC IMP"
      F957 4C 43 20         
      F95A 49 4D 50         
      F95D 18         003805 |				dbt 018h,1h,2h
      F95E 01               
      F95F 02               
      F960 43         003806 |				dbt "CLD IMP"
      F961 4C 44 20         
      F964 49 4D 50         
      F967 D8         003807 |				dbt 0D8h,1h,2h
      F968 01               
      F969 02               
      F96A 43         003808 |				dbt "CLI IMP"
      F96B 4C 49 20         
      F96E 49 4D 50         
      F971 58         003809 |				dbt 058h,1h,2h
      F972 01               
      F973 02               
      F974 43         003810 |				dbt "CLV IMP"
      F975 4C 56 20         
      F978 49 4D 50         
      F97B B8         003811 |				dbt 0B8h,1h,2h
      F97C 01               
      F97D 02               
      F97E 43         003812 |				dbt "CMP IMM"
      F97F 4D 50 20         
      F982 49 4D 4D         
      F985 C9         003813 |				dbt 0C9h,2h,2h
      F986 02               
      F987 02               
      F988 43         003814 |				dbt "CMP ABS"
      F989 4D 50 20         
      F98C 41 42 53         
      F98F CD         003815 |				dbt 0CDh,3h,4h
      F990 03               
      F991 04               
      F992 43         003816 |				dbt "CMP ABX"
      F993 4D 50 20         
      F996 41 42 58         
      F999 DD         003817 |				dbt 0DDh,3h,4h
      F99A 03               
      F99B 04               
      F99C 43         003818 |				dbt "CMP ABY"
      F99D 4D 50 20         
      F9A0 41 42 59         
      F9A3 D9         003819 |				dbt 0D9h,3h,4h
      F9A4 03               
      F9A5 04               
      F9A6 43         003820 |				dbt "CMP IIR"
      F9A7 4D 50 20         
      F9AA 49 49 52         
      F9AD C1         003821 |				dbt 0C1h,2h,6h
      F9AE 02               
      F9AF 06               
      F9B0 43         003822 |				dbt "CMP IRI"
      F9B1 4D 50 20         
      F9B4 49 52 49         
      F9B7 D1         003823 |				dbt 0D1h,2h,5h
      F9B8 02               
      F9B9 05               
      F9BA 43         003824 |				dbt "CPX IMM"
      F9BB 50 58 20         
      F9BE 49 4D 4D         
      F9C1 E0         003825 |				dbt 0E0h,2h,2h
      F9C2 02               
      F9C3 02               
      F9C4 43         003826 |				dbt "CPX ABS"
      F9C5 50 58 20         
      F9C8 41 42 53         
      F9CB EC         003827 |				dbt 0ECh,3h,4h
      F9CC 03               
      F9CD 04               
      F9CE 43         003828 |				dbt "CPY IMM"
      F9CF 50 59 20         
      F9D2 49 4D 4D         
      F9D5 C0         003829 |				dbt 0C0h,2h,2h
      F9D6 02               
      F9D7 02               
      F9D8 43         003830 |				dbt "CPY ABS"
      F9D9 50 59 20         
      F9DC 41 42 53         
      F9DF CC         003831 |				dbt 0CCh,3h,4h
      F9E0 03               
      F9E1 04               
      F9E2 44         003832 |				dbt "DEC ABS"
      F9E3 45 43 20         
      F9E6 41 42 53         
      F9E9 CE         003833 |				dbt 0CEh,3h,6h
      F9EA 03               
      F9EB 06               
      F9EC 44         003834 |				dbt "DEC ABX"
      F9ED 45 43 20         
      F9F0 41 42 58         
      F9F3 DE         003835 |				dbt 0DEh,3h,7h
      F9F4 03               
      F9F5 07               
      F9F6 44         003836 |				dbt "DEX IMP"
      F9F7 45 58 20         
      F9FA 49 4D 50         
      F9FD CA         003837 |				dbt 0CAh,1h,2h
      F9FE 01               
      F9FF 02               
      FA00 44         003838 |				dbt "DEY IMP"
      FA01 45 59 20         
      FA04 49 4D 50         
      FA07 88         003839 |				dbt 088h,1h,2h
      FA08 01               
      FA09 02               
      FA0A 45         003840 |				dbt "EOR IMM"
      FA0B 4F 52 20         
      FA0E 49 4D 4D         
      FA11 49         003841 |				dbt 049h,2h,2h
      FA12 02               
      FA13 02               
      FA14 45         003842 |				dbt "EOR ABS"
      FA15 4F 52 20         
      FA18 41 42 53         
      FA1B 4D         003843 |				dbt 04Dh,3h,4h
      FA1C 03               
      FA1D 04               
      FA1E 45         003844 |				dbt "EOR ABX"
      FA1F 4F 52 20         
      FA22 41 42 58         
      FA25 5D         003845 |				dbt 05Dh,3h,4h
      FA26 03               
      FA27 04               
      FA28 45         003846 |				dbt "EOR ABY"
      FA29 4F 52 20         
      FA2C 41 42 59         
      FA2F 59         003847 |				dbt 059h,3h,4h
      FA30 03               
      FA31 04               
      FA32 45         003848 |				dbt "EOR IIR"
      FA33 4F 52 20         
      FA36 49 49 52         
      FA39 41         003849 |				dbt 041h,2h,6h
      FA3A 02               
      FA3B 06               
      FA3C 45         003850 |				dbt "EOR IRI"
      FA3D 4F 52 20         
      FA40 49 52 49         
      FA43 51         003851 |				dbt 051h,2h,5h
      FA44 02               
      FA45 05               
      FA46 49         003852 |				dbt "INC ABS"
      FA47 4E 43 20         
      FA4A 41 42 53         
      FA4D EE         003853 |				dbt 0EEh,3h,6h
      FA4E 03               
      FA4F 06               
      FA50 49         003854 |				dbt "INC ABX"
      FA51 4E 43 20         
      FA54 41 42 58         
      FA57 FE         003855 |				dbt 0FEh,3h,7h
      FA58 03               
      FA59 07               
      FA5A 49         003856 |				dbt "INX IMP"
      FA5B 4E 58 20         
      FA5E 49 4D 50         
      FA61 E8         003857 |				dbt 0E8h,1h,2h
      FA62 01               
      FA63 02               
      FA64 49         003858 |				dbt "INY IMP"
      FA65 4E 59 20         
      FA68 49 4D 50         
      FA6B C8         003859 |				dbt 0C8h,1h,2h
      FA6C 01               
      FA6D 02               
      FA6E 4A         003860 |				dbt "JMP ABS"
      FA6F 4D 50 20         
      FA72 41 42 53         
      FA75 4C         003861 |				dbt 04Ch,3h,3h
      FA76 03               
      FA77 03               
      FA78 4A         003862 |				dbt "JMP IND"
      FA79 4D 50 20         
      FA7C 49 4E 44         
      FA7F 6C         003863 |				dbt 06Ch,3h,5h
      FA80 03               
      FA81 05               
      FA82 4A         003864 |				dbt "JSR ABS"
      FA83 53 52 20         
      FA86 41 42 53         
      FA89 20         003865 |				dbt 020h,3h,6h
      FA8A 03               
      FA8B 06               
      FA8C 4C         003866 |				dbt "LDA IMM"
      FA8D 44 41 20         
      FA90 49 4D 4D         
      FA93 A9         003867 |				dbt 0A9h,2h,2h
      FA94 02               
      FA95 02               
      FA96 4C         003868 |				dbt "LDA ABS"
      FA97 44 41 20         
      FA9A 41 42 53         
      FA9D AD         003869 |				dbt 0ADh,3h,4h
      FA9E 03               
      FA9F 04               
      FAA0 4C         003870 |				dbt "LDA ABX"
      FAA1 44 41 20         
      FAA4 41 42 58         
      FAA7 BD         003871 |				dbt 0BDh,3h,4h
      FAA8 03               
      FAA9 04               
      FAAA 4C         003872 |				dbt "LDA ABY"
      FAAB 44 41 20         
      FAAE 41 42 59         
      FAB1 B9         003873 |				dbt 0B9h,3h,4h
      FAB2 03               
      FAB3 04               
      FAB4 4C         003874 |				dbt "LDA IIR"
      FAB5 44 41 20         
      FAB8 49 49 52         
      FABB A1         003875 |				dbt 0A1h,2h,6h
      FABC 02               
      FABD 06               
      FABE 4C         003876 |				dbt "LDA IRI"
      FABF 44 41 20         
      FAC2 49 52 49         
      FAC5 B1         003877 |				dbt 0B1h,2h,5h
      FAC6 02               
      FAC7 05               
      FAC8 4C         003878 |				dbt "LDX IMM"
      FAC9 44 58 20         
      FACC 49 4D 4D         
      FACF A2         003879 |				dbt 0A2h,2h,2h
      FAD0 02               
      FAD1 02               
      FAD2 4C         003880 |				dbt "LDX ABS"
      FAD3 44 58 20         
      FAD6 41 42 53         
      FAD9 AE         003881 |				dbt 0AEh,3h,4h
      FADA 03               
      FADB 04               
      FADC 4C         003882 |				dbt "LDX ABY"
      FADD 44 58 20         
      FAE0 41 42 59         
      FAE3 BE         003883 |				dbt 0BEh,3h,4h
      FAE4 03               
      FAE5 04               
      FAE6 4C         003884 |				dbt "LDY IMM"
      FAE7 44 59 20         
      FAEA 49 4D 4D         
      FAED A0         003885 |				dbt 0A0h,2h,2h
      FAEE 02               
      FAEF 02               
      FAF0 4C         003886 |				dbt "LDY ABS"
      FAF1 44 59 20         
      FAF4 41 42 53         
      FAF7 AC         003887 |				dbt 0ACh,3h,4h
      FAF8 03               
      FAF9 04               
      FAFA 4C         003888 |				dbt "LDY ABX"
      FAFB 44 59 20         
      FAFE 41 42 58         
      FB01 BC         003889 |				dbt 0BCh,3h,4h
      FB02 03               
      FB03 04               
      FB04 4C         003890 |				dbt "LSR ACC"
      FB05 53 52 20         
      FB08 41 43 43         
      FB0B 4A         003891 |				dbt 04Ah,1h,2h
      FB0C 01               
      FB0D 02               
      FB0E 4C         003892 |				dbt "LSR ABS"
      FB0F 53 52 20         
      FB12 41 42 53         
      FB15 4E         003893 |				dbt 04Eh,3h,6h
      FB16 03               
      FB17 06               
      FB18 4C         003894 |				dbt "LSR ABX"
      FB19 53 52 20         
      FB1C 41 42 58         
      FB1F 5E         003895 |				dbt 05Eh,3h,7h
      FB20 03               
      FB21 07               
      FB22 4E         003896 |				dbt "NOP IMP"
      FB23 4F 50 20         
      FB26 49 4D 50         
      FB29 EA         003897 |				dbt 0EAh,1h,2h
      FB2A 01               
      FB2B 02               
      FB2C 4F         003898 |				dbt "ORA IMM"
      FB2D 52 41 20         
      FB30 49 4D 4D         
      FB33 09         003899 |				dbt 009h,2h,2h
      FB34 02               
      FB35 02               
      FB36 4F         003900 |				dbt "ORA ABS"
      FB37 52 41 20         
      FB3A 41 42 53         
      FB3D 0D         003901 |				dbt 00Dh,3h,4h
      FB3E 03               
      FB3F 04               
      FB40 4F         003902 |				dbt "ORA ABX"
      FB41 52 41 20         
      FB44 41 42 58         
      FB47 1D         003903 |				dbt 01Dh,3h,4h
      FB48 03               
      FB49 04               
      FB4A 4F         003904 |				dbt "ORA ABY"
      FB4B 52 41 20         
      FB4E 41 42 59         
      FB51 19         003905 |				dbt 019h,3h,4h
      FB52 03               
      FB53 04               
      FB54 4F         003906 |				dbt "ORA IIR"
      FB55 52 41 20         
      FB58 49 49 52         
      FB5B 01         003907 |				dbt 001h,2h,6h
      FB5C 02               
      FB5D 06               
      FB5E 4F         003908 |				dbt "ORA IRI"
      FB5F 52 41 20         
      FB62 49 52 49         
      FB65 11         003909 |				dbt 011h,2h,5h
      FB66 02               
      FB67 05               
      FB68 50         003910 |				dbt "PHA IMP"
      FB69 48 41 20         
      FB6C 49 4D 50         
      FB6F 48         003911 |				dbt 048h,1h,3h
      FB70 01               
      FB71 03               
      FB72 50         003912 |				dbt "PHP IMP"
      FB73 48 50 20         
      FB76 49 4D 50         
      FB79 08         003913 |				dbt 008h,1h,3h
      FB7A 01               
      FB7B 03               
      FB7C 50         003914 |				dbt "PLA IMP"
      FB7D 4C 41 20         
      FB80 49 4D 50         
      FB83 68         003915 |				dbt 068h,1h,4h
      FB84 01               
      FB85 04               
      FB86 50         003916 |				dbt "PLP IMP"
      FB87 4C 50 20         
      FB8A 49 4D 50         
      FB8D 28         003917 |				dbt 028h,1h,4h
      FB8E 01               
      FB8F 04               
      FB90 52         003918 |				dbt "ROL ACC"
      FB91 4F 4C 20         
      FB94 41 43 43         
      FB97 2A         003919 |				dbt 02Ah,1h,2h
      FB98 01               
      FB99 02               
      FB9A 52         003920 |				dbt "ROL ABS"
      FB9B 4F 4C 20         
      FB9E 41 42 53         
      FBA1 2E         003921 |				dbt 02Eh,3h,6h
      FBA2 03               
      FBA3 06               
      FBA4 52         003922 |				dbt "ROL ABX"
      FBA5 4F 4C 20         
      FBA8 41 42 58         
      FBAB 3E         003923 |				dbt 03Eh,3h,7h
      FBAC 03               
      FBAD 07               
      FBAE 52         003924 |				dbt "ROR ACC"
      FBAF 4F 52 20         
      FBB2 41 43 43         
      FBB5 6A         003925 |				dbt 06Ah,1h,2h
      FBB6 01               
      FBB7 02               
      FBB8 52         003926 |				dbt "ROR ABS"
      FBB9 4F 52 20         
      FBBC 41 42 53         
      FBBF 6E         003927 |				dbt 06Eh,3h,6h
      FBC0 03               
      FBC1 06               
      FBC2 52         003928 |				dbt "ROR ABX"
      FBC3 4F 52 20         
      FBC6 41 42 58         
      FBC9 7E         003929 |				dbt 07Eh,3h,7h
      FBCA 03               
      FBCB 07               
      FBCC 52         003930 |				dbt "RTI IMP"
      FBCD 54 49 20         
      FBD0 49 4D 50         
      FBD3 40         003931 |				dbt 040h,1h,6h
      FBD4 01               
      FBD5 06               
      FBD6 52         003932 |				dbt "RTS IMP"
      FBD7 54 53 20         
      FBDA 49 4D 50         
      FBDD 60         003933 |				dbt 060h,1h,6h
      FBDE 01               
      FBDF 06               
      FBE0 53         003934 |				dbt "SBC IMM"
      FBE1 42 43 20         
      FBE4 49 4D 4D         
      FBE7 E9         003935 |				dbt 0E9h,2h,2h
      FBE8 02               
      FBE9 02               
      FBEA 53         003936 |				dbt "SBC ABS"
      FBEB 42 43 20         
      FBEE 41 42 53         
      FBF1 ED         003937 |				dbt 0EDh,3h,4h
      FBF2 03               
      FBF3 04               
      FBF4 53         003938 |				dbt "SBC ABX"
      FBF5 42 43 20         
      FBF8 41 42 58         
      FBFB FD         003939 |				dbt 0FDh,3h,4h
      FBFC 03               
      FBFD 04               
      FBFE 53         003940 |				dbt "SBC ABY"
      FBFF 42 43 20         
      FC02 41 42 59         
      FC05 F9         003941 |				dbt 0F9h,3h,4h
      FC06 03               
      FC07 04               
      FC08 53         003942 |				dbt "SBC IIR"
      FC09 42 43 20         
      FC0C 49 49 52         
      FC0F E1         003943 |				dbt 0E1h,2h,6h
      FC10 02               
      FC11 06               
      FC12 53         003944 |				dbt "SBC IRI"
      FC13 42 43 20         
      FC16 49 52 49         
      FC19 F1         003945 |				dbt 0F1h,2h,5h
      FC1A 02               
      FC1B 05               
      FC1C 53         003946 |				dbt "SEC IMP"
      FC1D 45 43 20         
      FC20 49 4D 50         
      FC23 38         003947 |				dbt 038h,1h,2h
      FC24 01               
      FC25 02               
      FC26 53         003948 |				dbt "SED IMP"
      FC27 45 44 20         
      FC2A 49 4D 50         
      FC2D F8         003949 |				dbt 0F8h,1h,2h
      FC2E 01               
      FC2F 02               
      FC30 53         003950 |				dbt "SEI IMP"
      FC31 45 49 20         
      FC34 49 4D 50         
      FC37 78         003951 |				dbt 078h,1h,2h
      FC38 01               
      FC39 02               
      FC3A 53         003952 |				dbt "STA ABS"
      FC3B 54 41 20         
      FC3E 41 42 53         
      FC41 8D         003953 |				dbt 08Dh,3h,4h
      FC42 03               
      FC43 04               
      FC44 53         003954 |				dbt "STA ABX"
      FC45 54 41 20         
      FC48 41 42 58         
      FC4B 9D         003955 |				dbt 09Dh,3h,5h
      FC4C 03               
      FC4D 05               
      FC4E 53         003956 |				dbt "STA ABY"
      FC4F 54 41 20         
      FC52 41 42 59         
      FC55 99         003957 |				dbt 099h,3h,5h
      FC56 03               
      FC57 05               
      FC58 53         003958 |				dbt "STA IIR"
      FC59 54 41 20         
      FC5C 49 49 52         
      FC5F 81         003959 |				dbt 081h,2h,6h
      FC60 02               
      FC61 06               
      FC62 53         003960 |				dbt "STA IRI"
      FC63 54 41 20         
      FC66 49 52 49         
      FC69 91         003961 |				dbt 091h,2h,6h
      FC6A 02               
      FC6B 06               
      FC6C 53         003962 |				dbt "STX ABS"
      FC6D 54 58 20         
      FC70 41 42 53         
      FC73 8E         003963 |				dbt 08Eh,3h,4h
      FC74 03               
      FC75 04               
      FC76 53         003964 |				dbt "STY ABS"
      FC77 54 59 20         
      FC7A 41 42 53         
      FC7D 8C         003965 |				dbt 08Ch,3h,4h
      FC7E 03               
      FC7F 04               
      FC80 54         003966 |				dbt "TAX IMP"
      FC81 41 58 20         
      FC84 49 4D 50         
      FC87 AA         003967 |				dbt 0AAh,1h,2h
      FC88 01               
      FC89 02               
      FC8A 54         003968 |				dbt "TAY IMP"
      FC8B 41 59 20         
      FC8E 49 4D 50         
      FC91 A8         003969 |				dbt 0A8h,1h,2h
      FC92 01               
      FC93 02               
      FC94 54         003970 |				dbt "TSX IMP"
      FC95 53 58 20         
      FC98 49 4D 50         
      FC9B BA         003971 |				dbt 0BAh,1h,2h
      FC9C 01               
      FC9D 02               
      FC9E 54         003972 |				dbt "TXA IMP"
      FC9F 58 41 20         
      FCA2 49 4D 50         
      FCA5 8A         003973 |				dbt 08Ah,1h,2h
      FCA6 01               
      FCA7 02               
      FCA8 54         003974 |				dbt "TXS IMP"
      FCA9 58 53 20         
      FCAC 49 4D 50         
      FCAF 9A         003975 |				dbt 09Ah,1h,2h
      FCB0 01               
      FCB1 02               
      FCB2 54         003976 |				dbt "TYA IMP"
      FCB3 59 41 20         
      FCB6 49 4D 50         
      FCB9 98         003977 |				dbt 098h,1h,2h
      FCBA 01               
      FCBB 02               
      FCBC 5A         003978 |				dbt "ZZZ ZZZ"
      FCBD 5A 5A 20         
      FCC0 5A 5A 5A         
      FCC3 00         003979 |				dbt 000h,0h,0h
      FCC4 00               
      FCC5 00               
                      003980 |				
                      003981 |	
                      003982 |;****************************************************************************
                      003983 |;       Emulator version number (to be set by the emulator).
                      003984 |;****************************************************************************
      FCC6            003985 |EmuVersionFrom:
      FFF0            003986 |				org 0fff0h
      FFF0 4A         003987 |				dbt "J0.01   "
      FFF1 30 2E 30         
      FFF4 31 20 20         
      FFF7 20               
                      003988 |
                      003989 |;****************************************************************************
                      003990 |;       Initialize 6502 reset vector and maskable interrupt vector.
                      003991 |;****************************************************************************
      FFFC            003992 |			org 0fffch	    ;Initialize reset vector.
      FFFC 00         003993 |			dbt 00h,0e0h	;                                                                                         
      FFFD E0               
                      003994 |;	
      FFFE            003995 |			org 0fffeh	    ;Initialize maskable
      FFFE 0B         003996 |			dbt #MaskInt<	; interrupt vector.
      FFFF E2         003997 |			dbt #MaskInt>	;
                      003998 |			
                      003999 |			end
                      004000 |		
                      004001 |; ,output="array",start_address="E000"
      
      *** Symbol Table ***
      {OBCDHLD1=65, NUMBER=156, IRIADMO=61939, CHARREC=62469, OPNDADOK=58656, DGTTBLUC=62547, CKSPREG=60583, CKBPADDG=59688, CKAREG=60424, CCHKFLSB=59213, NOCMP=59047, PROMPT=62681, REGTEMP=206, OTADAGIN=58903, OPBRNOOV=58769, USTKPTR=74, MINUS=58940, TOUPPER=62234, LSOTLOOP=57476, CKFORS=60559, FOUNDBP=59000, BOTH=61198, OPINADOK=58696, GO=59649, OPCDHOLD=67, ZEROBP=58959, CKSPNULL=58309, CHKCR=59402, OPNMHFND=58621, ADMSBOK=62188, EMUVERSIONTO=62593, GETLINE=57512, OPCKPOFF=58799, EXITSRCH=60821, AMSSCNAB=58360, DGTTOBIN=60051, OPENMESS=62604, NOBRNCH=61291, SCNOCARY=61386, DATATEMP=207, MCONT=60181, PRNTQUES=58030, CKBPST=59722, NOMATCH=59226, DUMP=59228, CLR1BP=58970, NOBPMESS=62956, EXITMOVE=60223, CKADMODE=61553, ADLSBOK=62198, SCNFORHEX=58831, IRQ=57880, OPOFFSET=94, NOBRNCH2=61091, UPDTPTRA=61296, OSMATCH=58267, OSCKANCM=58225, RECTYPE=161, SADD1OK=60694, CMDOK=57865, ALLBPFULL=59066, PROCTERM=60106, BRKPT3ST=49, BRKPT2AD=20, MADD3OK=60173, CKPCREG=60360, POINTERC=12, CHKOP2=59492, POINTERB=10, EXITENTR=59530, POINTERA=8, DOIND=58718, RESETENTRYPOINT=57921, CLRALLBP=58957, 6551STR=40961, UNASSEM=61393, SROK=60659, SRECENMS=62761, GTTRCCNT=60860, COLNPRMT=62899, OPNDAB??=58640, SRECERME=62729, SNOVFLO=60724, CURENTPC=59672, BRNCHFLG=61, YOK=60553, PRINT2ND=62348, NOPADPTR=14, ABYADMO=61813, GOMAIN=57960, NOOBJCD3=58171, AMSCKIMP=58269, USTATREG=75, CKDEL=57557, AMSCKIMM=58286, INITVARS=62355, OPNDDOBR=58735, ERRENTR=59528, DW0=62529, SFHNXTDG=58833, GETADD=62180, IMPADMO=61630, EXITTRCE=61343, PRINT1ST=62326, CKNXTBP=59054, PRNTMNEM=62153, GTCKAGN=62456, GETNUM=59997, LDSRECS=59786, SRCHTABL=32, CKSUMAC=159, LISTERR=59582, INCSCPTR=60777, LGHTSHOW=57471, EXITTOUP=62245, OTANOSPC=62212, TR2NDENT=61260, OUTSPC=59373, ASEMTOP=57979, TEMPADD2=45, AOPTBFND=58086, OPTABLE=63580, PARSLINE=57619, AMSCKREL=58332, AOK=60463, OPTSCAN2=58232, OPCDFNDS=61389, OSNOCARY=58246, CHKCHKSM=59975, OPNINFND=58688, ABXADMO=61800, GTCODNLD=59929, CKSMCASE=57637, BRKVECT=4, ISIRI=58502, ABSAM=61797, PRRLEADD=59885, INCPNTRA=62171, CODECNTR=155, ERRTRCE=61341, DGTERROR=60074, CKCONFIG=57415, NXTIN=61330, BPMATCH=59224, DELAY=62514, DOLGTSHO=57468, UNOOPER=61423, EMUVERSIONFROM=64710, EXITLD=59974, CURINSLN=58, COMMAND=205, PROCHDR=60086, OPNDIMP=58607, UCHKFLSB=61485, ASEMDONE=58006, CKSRREG=60624, GETY=60543, EXTOPNDS=58829, OPNDIMM=58613, GETX=60498, FADD2OK=59610, BRVALHLD=56, BADOPMES=62904, ASTOBIN=62269, OUTSPACE=62211, GTCKCHAR=57582, DONESCAN=57697, OUTONE=60331, BP4OPHLD=54, CHK8=59351, ENDADD=92, EXITADMD=58544, CMDERMES=63062, GETCMD=57645, CHKFLSB=59634, GETSR=60649, GETA=60453, GETSP=60608, NTCD=59849, BPNTFND=58990, UADD2OK=61466, DGTTBLLC=62564, REGINERR=60665, TEMPA=68, CHBKVECT=61228, PROCENTR=59502, MESSPTR=6, DODELETE=57561, LSTNOOV=59560, ASCIIBUF=76, AOPTROK=58070, GETCHAR=62416, NEGBRNCH=61893, BRKPT2ST=48, BRKPT1AD=18, GETLINEP=57505, OUTMESS=62396, CONTTRC=60877, MADD2OK=60149, EMPTYBP=59076, UARTVAL=62545, NXTCMD9=57804, NXTCMD8=57794, WAIT1=163, NXTCMD7=57784, WAIT0=162, NXTCMD6=57774, NXTCMD5=57764, NXTCMD4=57754, NXTCMD3=57744, ADMDTBSC=58514, NXTCMD2=57734, NXTCMD1=57724, OPNDIN??=58680, GTANCHAR=57543, ERRADMD=58542, EXTGTLST=59580, TNOOPER=60852, OUTPORT0=41216, RECLEN=158, TOPCDFND=60904, NOTEND=59421, CKIRI=58479, NXADMO9=61613, NXADMO8=61606, NOPCDHLD=59, NXADMO7=61599, NOCARY3=59434, NXADMO6=61592, NOCARY2=59402, NXADMO5=61585, NXADMO4=61578, IMMADMO=61669, NXADMO3=61571, NXADMO2=61564, NXADMO1=61557, TNXTOP3=61075, TNXTOP2=61041, ERROPNDS=58827, TNXTOP1=60994, TNXTOP0=60960, NOBRANCH=61193, OUTHEX=62303, XOK=60508, ISIND=58494, SCANOPCD=61345, MAERROR=59708, BDOPCD=61627, EXITCMD=57854, BOPADPTR=16, GLNXTBYT=59537, BREAKPNT=58868, PERIOD=59475, EXITUNAS=62151, DOSTDDMP=59295, PRNTMORE=62155, INPTBUFR=165, NOCHAR=62437, PROCCODE=60096, SMATCH=60802, ACCCKSUM=60036, OPFLDOK2=59289, OPFLDOK1=59277, BP3OPHLD=53, UNOTFIN=61499, CKIRIIND=58464, STARTUNA=61472, FILLAGIN=59616, PRNTASSM=58094, ENTER=59482, FILL=59584, GETPC=60395, UXREG=72, EXITGO=59776, NOOVFL1=62179, EXITDUMP=59426, OUTZERO=60321, AMSCKA_I=58346, CKTBLEND=61355, CMPNXT3=59202, SRCHBTCT=42, EMULATORMESS=62581, CMPNXT2=59187, CMPNXT1=59172, ANOTHDGT=60056, ERRUNAS=62149, NXADMO10=61620, CKBPADD=58980, MAINLOOP=57493, INPORT0=40960, PARSEOPR=57614, SEARCH=60677, OBJ2FLG=29, ENADDOK=59512, CHKEXIT=59996, ERRGO=59774, POSBRNCH=61875, OUTCOLN=62203, OUTBP2=59022, ERRDUMP=59424, STARTTRC=60873, ACCADMO=61647, FADD1OK=59594, DOADD=58663, CKBRNCH=61265, AADDOK=57973, AMSCKID?=58422, CHKENDAD=59378, ADDADD=61158, NNOVFLO=60946, POINTNXT=59394, TRANDGT=57674, GETCHARW=62451, EXITTOLO=62233, NOCMPG=59700, CKPORR=60566, UADD1OK=61410, BP2OPHLD=52, ABSXYADM=61720, CMPBPADD=59157, BRKPT4AD=24, ISIIR=58456, DUMPASC=59436, OPFLD3=135, BRKPT1ST=47, NTOPCODE=61511, OPFLD2=115, OPFLD1=95, EXITGTCH=62442, MADD1OK=60133, NOOBJCD=58160, ERRSFH=58864, REGMESS=62825, AMSCKACC=58298, TRBRKFLG=57, HELPMESS=63066, IIRADMO=62005, UYREG=73, CKSUMOK=59995, GOBPERRM=62996, UNOCARY=61453, REPBPOP=57939, CONVANO=58011, NXTBPSLT3=59141, CKXREG=60469, NXTBPSLT2=59122, NXTBPSLT1=59103, NXTBPSLT0=59084, SOUT=60691, SPOK=60618, NXTCMD13=57844, OFFOK=58816, NXTCMD12=57834, OUTASC=59448, NXTCMD11=57824, DONOTRESTORESTACKPOINTER=61243, NXTCMD10=57814, GTONELD=59953, CMDERROR=57856, OSNOMTCH=58265, SCKBYTE2=60770, OPNDSCAN=58546, SCKBYTE1=60766, BOPCDHLD=60, EXITSFH=58866, MASKINT=57867, ASSEMBLE=57963, PUTNULL=57608, OBJ3FLG=30, MOVE=60116, AMSCKAB?=58358, EXITBP=59156, CKNXTOP=61363, NEXTFLAG=60318, ADMDSCAN=58269, TOLOWER=62222, MNOVFLO=60163, DGTOK2=59257, DGTOK1=59245, EXITNLD=59945, MOUT=60130, TADD1OK=60839, BPFULMES=62916, GTLNDONE=57599, CKEEPROM=57445, EXITMESS=62414, SERROR=59871, MCKMSB=60212, OPCKNOFF=58809, GADDOK=59666, CRLF=62685, BPNUMHLD=55, TRVALOK=60870, OSCKANO=58223, ADDHOLD=63, START=57371, DOBRK=57883, BRANCH=61094, BP1OPHLD=51, OPNDACC=58610, OPNDCVOK=58629, DONOTRESTOREREGISTERSGO=59771, OUTCHAR=62484, CKIIR=58441, LETTER2=62343, LETTER1=62321, ADMDNOCY=58537, OUTBRADD=61919, SFULMTCH=60812, ERRGTAD=62201, ERRREGOT=60670, OBJ3=28, OBJ2=27, GTBROPCD=61179, OBJ1=26, PRNOOVF=62411, OPCDFND=61540, GENPOINT=0, HELP=59778, SFHCKDGT=58838, EXITPUT=59480, CKYREG=60514, SPECREG=60344, TRACCNT=62, CHARMTCH=58257, UPGMCNTR=69, MNOOVF2=60201, MNOOVF1=60193, SCANOPRN=57664, GETLIST=59532, DOPLUS=58886, EXTGTNUM=60035, NXTBPST=59738, TEMPADD=43, CKVALCMD=57707, PARERROR=57705, SUBADD=61126, 6551SLEEP=40962, EXITASEM=58211, OPTRSCAN=58213, OPNAHFND=58648, SADD2OK=60710, ADDMODE=31, SRECSTMS=62688, NXTCODE=59969, ADEMPTY=58926, CKXORY=58375, BRKPT4ST=50, PRNTADD=62246, BRKPT3AD=22, OUTTRCE=61338, SCKMSB=60791, CKBPSTBR=57943, BRK=57886, INCBFPTR=58856, OTCKAGN=62492, RELADMO=61826, GETONENL=59934, NEXTLINE=59868, REGISTER=60224, CHKSUM=157, COPYVERSION=57417, NTHDR=59837, UACCUM=71, EXITFILL=59647, CKBTPOS=60338, ERRAMS=58510, CKS=59809, GTANCH=59806, INDADMO=62071, PCMSBOK=60405, ISACC=58324, ACONT=58009, GTCODLD=59946, GENREG=60240, CLRINPBF=57533, ERRASEM=58209, DOJMP=61278, ISABY=58406, ISABX=58398, IRQVECT=2, PRNTMESS=62387, ATSTART=57577, ISABS=58414, BPADOK=59025, EXTAS2BN=62302, EXITAMS=58512, GTANOOPR=57648, NOEXSPCS=58182, PUTASCBF=59460, BRNCH=61286, PLUS=59008, DGTEXIT=60085, NOMATCHG=59718, OPCDNTFD=61391, MATCH=60080, GTUENDAD=61456, AOPNDOK=58078, ERRFILL=59645, DODUMP=59318, NOOVRFLO=60049, EXITREG=60669, LSINLOOP=57478, PCLSBOK=60415, DOMINUS=58889, DMPBPADD=58892, STINMEM=59550, UOUT=61496, EXITSREC=59880, 6551TRR=40960, TRRTS=60916, NXTBPSTB=57955, DUMPAGIN=59335, EXTPRSLN=57706, ENTERMON=57415, TRACE=60822, =0, CKBPADDP=59035, OBCDHLD2=66}
.   %/output







