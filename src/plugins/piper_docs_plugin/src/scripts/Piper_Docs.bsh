import javax.swing.*;
import javax.swing.event.*;
import java.util.ArrayList;
import org.gjt.sp.jedit.jEdit;
//import org.mathrider.piperplugin.PiperInterpreter;


//System.out.println("VVVVVM " + pageIndex);
//{{{ setEditorPane
setPage(url,save)
{		
	try 
	{ 
		editorPane.setPage(url);
		
		
		//forward button logic.
		if(pageIndex+1 == pageList.size())
		{
			toolPanel.forwardButtonEnabled(false);
		}
		else
		{
			toolPanel.forwardButtonEnabled(true);
		}//end else.
		

		
		
		if(save)
		{
	if(pageIndex >= 0 && url == pageList.get(pageIndex))
	{
		//System.out.println("VVVVVM Same URL");
		return;
	}//end if.
			if(pageIndex+1 != pageList.size())
			{
				pageList = pageList.subList(0,pageIndex+1);
				toolPanel.forwardButtonEnabled(false);
			}//end if.

			
			pageList.add(url);
			pageIndex++;
		}//end if.
		
		
		//back button logic.
		if(pageIndex <= 0)
		{
			toolPanel.backButtonEnabled(false);
		}
		else
		{
			toolPanel.backButtonEnabled(true);
		}//end else.

		//System.out.println("TTTTT " + pageList );
	} catch (IOException e) 
	{
		System.err.println("Attempted to read a bad URL: " + url);
	}//end try/catch
	
}//end method }}}



//{{{ functions JList

//{{{ functions array.
  functions = new String[] 
{ 
"Abs",
"Add",
"Append",
"Apply",
"ArcCos",
"ArcSin",
"ArcTan",
"Arg",
"Array'Create",
"Array'CreateFromList",
"Array'Get",
"Array'Set",
"Array'Size",
"Array'ToList",
"Assert",
"Assoc",
"AssocDelete",
"AssocIndices",
"Atom",
"BaseVector",
"Bernoulli",
"BernoulliDistribution",
"BigOh",
"Bin",
"BinomialDistribution",
"BinSplitData",
"BinSplitFinal",
"BinSplitNum",
"BitAnd",
"BitOr",
"BitXor",
"Bodied",
"BracketRational",
"BubbleSort",
"Builtin'Precision'Get",
"Builtin'Precision'Set",
"CachedConstant",
"CanProve",
"Catalan",
"CatalanNumber",
"Ceil",
"CForm",
"CharacteristicEquation",
"Check",
"ChiSquareTest",
"Cholesky",
"Clear",
"ClearError",
"ClearErrors",
"Coef",
"CoFactor",
"Complex",
"Concat",
"ConcatStrings",
"Conjugate",
"Contains",
"Content",
"ContFrac",
"ContFracEval",
"ContFracList",
"Cos",
"Count",
"CrossProduct",
"Curl",
"CurrentFile",
"CurrentLine",
"Cyclotomic",
"D",
"Decimal",
"DefaultTokenizer",
"DefLoad",
"DefMacroRuleBase",
"DefMacroRuleBaseListed",
"Degree",
"Delete",
"Denom",
"DestructiveAppend",
"DestructiveDelete",
"DestructiveInsert",
"DestructiveReplace",
"DestructiveReverse",
"Determinant",
"Diagonal",
"DiagonalMatrix",
"Difference",
"Div",
"Diverge",
"Divisors",
"DivisorsList",
"DivisorsSum",
"Dot",
"Drop",
"DumpErrors",
"Echo",
"EigenValues",
"EigenVectors",
"Eliminate",
"EndOfFile",
"Equals",
"Euler",
"Eulerian",
"Eval",
"EvalFormula",
"EvaluateHornerScheme",
"Exp",
"Expand",
"ExpandBrackets",
"ExtraInfo'Get",
"ExtraInfo'Set",
"Factor",
"FactorialSimplify",
"Factorize",
"Factors",
"FermatNumber",
"FillList",
"Find",
"FindFile",
"FindFunction",
"FindRealRoots",
"FlatCopy",
"Flatten",
"Floor",
"For",
"ForEach",
"FromBase",
"FromFile",
"FromString",
"FullForm",
"FuncList",
"FuncListArith",
"FuncListSome",
"Function",
"Gamma",
"GarbageCollect",
"GaussianFactors",
"GaussianGcd",
"GaussianNorm",
"Gcd",
"GenericTypeName",
"GetCoreError",
"GetError",
"GetErrorTableau",
"GetTime",
"GlobalPop",
"GlobalPush",
"GoldenRatio",
"GreaterThan",
"GuessRational",
"HarmonicNumber",
"HasExpr",
"HasExprArith",
"HasExprSome",
"HasFunc",
"HasFuncArith",
"HasFuncSome",
"Head",
"HeapSort",
"HessianMatrix",
"HilbertInverseMatrix",
"HilbertMatrix",
"Hold",
"HoldArg",
"HoldArgNr",
"Horner",
"I",
"Identity",
"If",
"Im",
"Infinity",
"Infix",
"InNumericMode",
"InProduct",
"Insert",
"Integrate",
"Intersection",
"IntLog",
"IntNthRoot",
"IntPowerNum",
"InVerboseMode",
"Inverse",
"InverseTaylor",
"IsAmicablePair",
"IsAtom",
"IsBodied",
"IsBoolean",
"IsBound",
"IsCarmichaelNumber",
"IsCFormable",
"IsComposite",
"IsConstant",
"IsCoprime",
"IsDiagonal",
"IsError",
"IsEven",
"IsEvenFunction",
"IsFreeOf",
"IsFunction",
"IsGaussianInteger",
"IsGaussianPrime",
"IsGaussianUnit",
"IsGeneric",
"IsHermitian",
"IsIdempotent",
"IsInfinity",
"IsInfix",
"IsIrregularPrime",
"IsList",
"IsLowerTriangular",
"IsMatrix",
"IsNegativeInteger",
"IsNegativeNumber",
"IsNegativeReal",
"IsNonObject",
"IsNonZeroInteger",
"IsNotZero",
"IsNumber",
"IsNumericList",
"IsOdd",
"IsOddFunction",
"IsOrthogonal",
"IsPositiveInteger",
"IsPositiveNumber",
"IsPositiveReal",
"IsPostfix",
"IsPrefix",
"IsPrime",
"IsPrimePower",
"IsPromptShown",
"IsQuadraticResidue",
"IsRational",
"IsScalar",
"IsSkewSymmetric",
"IsSmallPrime",
"IsSquareFree",
"IsSquareMatrix",
"IsString",
"IsSymmetric",
"IsTwinPrime",
"IsUnitary",
"IsUpperTriangular",
"IsVector",
"IsZero",
"IsZeroVector",
"JacobianMatrix",
"JacobiSymbol",
"KnownFailure",
"LagrangeInterpolant",
"LambertW",
"LaplaceTransform",
"Lcm",
"LeadingCoef",
"LeftPrecedence",
"LegendreSymbol",
"Length",
"LessThan",
"LeviCivita",
"Limit",
"LispRead",
"LispReadListed",
"List",
"Listify",
"Ln",
"LnCombine",
"LnExpand",
"Load",
"Local",
"LocalSymbols",
"LogicTest",
"LogicVerify",
"Macro",
"MakeVector",
"Map",
"MapArgs",
"MapSingle",
"MatchLinear",
"MathAbs",
"MathAdd",
"MathAnd",
"MathArcCos",
"MathArcCosh",
"MathArcSin",
"MathArcSinh",
"MathArcTan",
"MathArcTanh",
"MathCeil",
"MathCos",
"MathCosh",
"MathDiv",
"MathDivide",
"MathExp",
"MathFloor",
"MathGcd",
"MathGetExactBits",
"MathLog",
"MathMod",
"MathMultiply",
"MathNot",
"MathOr",
"MathPower",
"MathSetExactBits",
"MathSin",
"MathSinh",
"MathSqrt",
"MathSubtract",
"MathTan",
"MathTanh",
"MatrixPower",
"MatrixSolve",
"Max",
"MaxEvalDepth",
"MaximumBound",
"Min",
"MinimumBound",
"Minor",
"Mod",
"Moebius",
"MoebiusDivisorsList",
"Monic",
"MultiplyNum",
"N",
"NearRational",
"NewLine",
"Newton",
"NewtonNum",
"NextPrime",
"NFunction",
"Nl",
"NonN",
"Normalize",
"Not",
"NrArgs",
"Nth",
"NthRoot",
"Numer",
"NumRealRoots",
"Object",
"OdeOrder",
"OdeSolve",
"OdeTest",
"OldSolve",
"OMDef",
"OMForm",
"OMRead",
"OpLeftPrecedence",
"OpPrecedence",
"OpRightPrecedence",
"OrthoG",
"OrthogonalBasis",
"OrthoGSum",
"OrthoH",
"OrthoHSum",
"OrthoL",
"OrthoLSum",
"OrthonormalBasis",
"OrthoP",
"OrthoPoly",
"OrthoPolySum",
"OrthoPSum",
"OrthoT",
"OrthoTSum",
"OrthoU",
"OrthoUSum",
"Outer",
"PAdicExpand",
"Partition",
"PatchLoad",
"PatchString",
"PDF",
"Permutations",
"Pi",
"Plot2D",
"Plot3DS",
"Pop",
"PopBack",
"PopFront",
"Postfix",
"Prefix",
"PrettyForm",
"PrimitivePart",
"PrintList",
"Prog",
"ProperDivisors",
"ProperDivisorsSum",
"Pslq",
"PSolve",
"Push",
"RadSimp",
"RamanujanSum",
"Random",
"RandomIntegerMatrix",
"RandomIntegerVector",
"RandomPoly",
"RandomSeed",
"RandVerifyArithmetic",
"Rationalize",
"Re",
"Read",
"ReadCmdLineString",
"ReadToken",
"RemoveDuplicates",
"Replace",
"Retract",
"Reverse",
"ReversePoly",
"RightAssociative",
"RightPrecedence",
"Rng",
"RngCreate",
"RngSeed",
"Round",
"RoundTo",
"Rule",
"RuleBase",
"RuleBaseArgList",
"RuleBaseListed",
"Secure",
"Select",
"Set",
"SetGlobalLazyVariable",
"ShiftLeft",
"ShiftRight",
"Sign",
"Simplify",
"Sin",
"Solve",
"SolveMatrix",
"Space",
"Sparsity",
"Sqrt",
"SquareFree",
"SquareFreeDivisorsList",
"StirlingNumber1",
"String",
"StringMid'Get",
"StringMid'Set",
"Subfactorial",
"Subst",
"SuchThat",
"Sum",
"SumForDivisors",
"SumTaylorNum",
"Swap",
"SylvesterMatrix",
"SystemCall",
"Table",
"TableForm",
"Tail",
"Take",
"Tan",
"Taylor",
"TestPiper",
"TeXForm",
"Time",
"ToBase",
"ToeplitzMatrix",
"ToFile",
"ToStdout",
"ToString",
"Trace",
"TraceExp",
"TraceRule",
"TraceStack",
"Transpose",
"TrapError",
"TrigSimpCombine",
"TruncRadian",
"Type",
"Undefined",
"UnFence",
"UnFlatten",
"Union",
"UniqueConstant",
"UnList",
"Until",
"Use",
"V, InVerboseMode",
"VandermondeMatrix",
"VarList",
"VarListArith",
"VarListSome",
"Verify",
"VerifyArithmetic",
"VerifyDiv",
"While",
"WithValue",
"Write",
"WriteString",
"WronskianMatrix",
"XmlExplodeTag",
"XmlTokenizer",
"ZeroMatrix",
"ZeroVector",
"Zeta"
};

numericFunctions = new String[]
{
"MathAbs",
"MathAdd",
"MathArcCos",
"MathArcCosh",
"MathArcSin",
"MathArcSinh",
"MathArcTan",
"MathArcTanh",
"MathCeil",
"MathCos",
"MathCosh",
"MathDiv",
"MathDivide",
"MathExp",
"MathFloor",
"MathGcd",
"MathLog",
"MathMod",
"MathMultiply",
"MathPower",
"MathSin",
"MathSinh",
"MathSqrt",
"MathSubtract",
"MathTan",
"MathTanh"
};
//}}}
  
     listPanel = new JPanel();
  
//    listPanel.setLayout(new BorderLayout());
    list = new JList(functions);
    list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
    list.addListSelectionListener(this);
    JScrollPane pane = new JScrollPane(list);
//    JButton button = new JButton("Print");
//    button.addActionListener(this);

//    listPanel.add(pane, BorderLayout.CENTER);
//    listPanel.add(button, BorderLayout.SOUTH);
 
    piperDocPanel.add(pane, BorderLayout.WEST);

//    JFrame frame = new JFrame("Simple List Example");
    //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
    
//    frame.setContentPane(listPanel);
//    frame.setSize(250, 200);
//    frame.setVisible(true);
 


  // An inner class to respond to clicks on the Print button

    
    
    valueChanged(e)
    {
        if (e.getValueIsAdjusting())
          return;
        index = e.getFirstIndex();
		item = list.getSelectedValue();
        
        //System.out.println("IIIII Item: " + list.getSelectedValue());
		
	//System.out.println("MMMMMM match: " + findFileForFunction(item));

		
		//Determine if function is a numeric Math function.
		match = false;
		for(index = 0; index < numericFunctions.length ;index++)
		{
			if(item.equalsIgnoreCase(numericFunctions[index]))
			{
				match = true;
				break;
			}//end if.
		}//end for.

		if(match == true)
		{
			docPart = "piper_manual/refprogchapter5.html";
			item = "Math...";
		}
		else
		{
			chapter = findFileForFunction(item);
			if(! chapter.equals(""))
			{
            //path = url.getPath();
//	    path = urlString;
//            path = path.replaceFirst("ref.html", match);
	    
	
	    		docPart = "piper_manual/" + chapter;
	    //System.out.println("   QQQ path: " + path  + "   docPart: " + docPart + "  chapter: " + chapter);
	    		

	    
            //path = path + "#" + query;
           // path = "file://" + path;
           // System.out.println("TTT path: " + path );
            //url = new URL(path);
			
			}//end if
			else
			{
				docPart = null;
			}//end else.
		}//end else.
		

	

	if(docPart != null)
	{
        urlWithChapter = jEdit.getPlugin("org.mathrider.piperdocsplugin.PiperDocsPlugin").getPluginJAR().getClassLoader().getResource(docPart);
	    if (urlWithChapter != null) 
		{

			    addChapter = urlWithChapter.toExternalForm() + "#" + item;
			    setPage(new URL(addChapter),true);
				toolPanel.sourceButtonEnabled(true);
			    //editorPane.setPage(urlWithChapter);
			    //System.out.println(   "QRQRQR " + " urlWithChapter: " + urlWithChapter + " Chapter: " + Chapter + "  addChapter: " + addChapter + " item: " + item);
			    //editorPane.scrollToReference(Chapter);
		} 
	    else 
		{
		    System.err.println("Couldn't find file: " + urlWithChapter );
	    }//end else	    

     }//end if 

  }//end method.
///}}}


//{{{
back()
{
	if(pageIndex != 0)
	{	
		page = pageList.get(--pageIndex);
		//System.out.println("XXXXX back" + page);
		setPage(page,false);
	}//end if.
	
}//end method.
//}}}


//{{{forward
forward()
{
	page = pageList.get(++pageIndex);
	//System.out.println("XXXXX forward");
	setPage(page,false);
}//end method.
//}}}


//{{{ home
home()
{
	toolPanel.sourceButtonEnabled(false);
	//toolPanel.backButtonEnabled(false);
	//toolPanel.forwardButtonEnabled(false);
	
	//pageIndex = 0;
	
	//java.net.URL docURL = jEdit.getPlugin("org.mathrider.piperdocsplugin.PiperDocsPlugin").getPluginJAR().getClassLoader().getResource("piper_manual/books2.html");
	//homePage = pageList.get(0);
	if ( homePage != null) {
		setPage(homePage,true);
	} else {
		System.err.println("Couldn't find file: " + homePage );
	}//end else
	
}//end method.}}}


//{{{source()
source()
{
	interpreter = jPiperInterpreter; //Note:tk:PiperInterpreter.getInstance(); 
	item = list.getSelectedValue();
	
	try{
		location = interpreter.evaluate("FindFunction(\"" + item + "\");");
		
	}catch(org.mathrider.piper.Piperexception ye) 
	{
		ye.printStackTrace();
	}
	finally
	{
		//System.out.println("XXXXXXXX name: " + item + "  location: " + location);
	}//finally.
	
	
	
import java.io.*;
//Print the contents of the Piper script zip file.
 instance = jPiperInterpreter; //Note:tk:PiperInterpreter.getInstance();
 scriptZip = instance.getScriptsZip();
 entries = scriptZip.entries();
 
 //while( entries.hasMoreElements())
 //{
 //   element = entries.nextElement();
 //   System.out.println("XXXXX " + element);
 //}
 
 location = location.replaceAll("\"","");
 entry = scriptZip.getEntry(location);//location.trim());//"assoc.rep/code.pi"); 
 
 if(entry != null)
 {
 //System.out.println("YYYYYY " + entry);
 
 fis = scriptZip.getInputStream(entry);
 //
        entry = entry.toString().replaceAll("/","-");
         // Create temp file.
        File tempFile = File.createTempFile(entry, ".pi");
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
	//File originFile = new File("c:\\file1.txt");
    //File destinationFile = new File("c:\\file1.txt");
    //if (!originFile.exists() || destinationFile.exists()) {
      //return;
    //}
    try {
      byte[] readData = new byte[1024];
      //FileInputStream fis = new FileInputStream(originFile);
      FileOutputStream fos = new FileOutputStream(tempFile);
      int i = fis.read(readData);

      while (i != -1) {
        fos.write(readData, 0, i);
        i = fis.read(readData);
      }
      fis.close();
      fos.flush();
      fos.close();
    } catch (IOException e) {
      System.out.println(e);
    }//end try/catch.
    
    
    
    //textArea = org.gjt.sp.jedit.jEdit.createTextArea();
    
    activeView = org.gjt.sp.jedit.jEdit.getActiveView();
    
    //buffer = org.gjt.sp.jedit.jEdit.openFile(activeView, tempFile.getAbsolutePath());
    
   // jf = new javax.swing.JFrame();
   // cf = jf.getContentPane();
   // cf.add(textArea);
   // jf.show();
   
   
				void delayDisplay()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						buffer = org.gjt.sp.jedit.jEdit.openFile(activeView, tempFile.getAbsolutePath());//

					}
					org.gjt.sp.jedit.io.VFSManager.runInAWTThread(this);
				
				}//end method.
				
	delayDisplay();
 }
 else
 {
	 org.gjt.sp.jedit.Macros.message(org.gjt.sp.jedit.jEdit.getActiveView(), "Source file for (" + item + ") not found.");
 }//end if/else.
	
}//end source.

//}}}


editorPane.setEditable(false);
editorPane.addHyperlinkListener(this);
//java.net.URL helpURL =new java.net.URL( "file:///C:/ted/download/piper_manual/refchapter26.html#c26");


//Put the editor pane in a scroll pane.
//JScrollPane editorScrollPane = new JScrollPane(editorPane);


editorScrollPane.setVerticalScrollBarPolicy(
                JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);


home();
//piperDocPanel.add(java.awt.BorderLayout.CENTER, editorScrollPane);
//piperDocPanel.revalidate();


//piperDocPanel.invalidate();
//piperDocPanel.validate(); 
//view.getContentPane().invalidate();
//view.getContentPane().validate();
//editorScrollPane.setPreferredSize(new Dimension(250, 145));
//editorScrollPane.setMinimumSize(new Dimension(10, 10));



import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
docker = jEdit.getActiveView().getDockableWindowManager();


//frame = new javax.swing.JFrame();
//guiBox = new Box(BoxLayout.Y_AXIS);
//messageTextField = new JTextField();
//guiBox.add(messageTextField);
//button1 = new JButton("Close GeoGebra");
//button1.setBackground(Color.green);
//button1.addActionListener(this);
//guiBox.add(button1);
//button2 = new JButton("Open GeoGebra");
//button2.setBackground(Color.yellow);
//button2.addActionListener(this);
//guiBox.add(button2);
//
//contentPane = frame.getContentPane();
//contentPane.add(editorScrollPane);//guiBox,BorderLayout.NORTH);
//frame.pack();
//frame.setAlwaysOnTop(true);
//frame.setTitle("MathRider");
//frame.setSize(new Dimension(400, 400));
//frame.setResizable(true);
//frame.setPreferredSize(new Dimension(400, 400));
//frame.setLocationRelativeTo(null);
//frame.show();
//
//actionPerformed(event)
//{
//    src = event.getSource();
//
//    if (src == button1)
//    {
//      messageTextField.setText("GeoGebra closed.");
//      docker.hideDockableWindow( "geogebra" );
//    }
//    else if (src == button2)
//    {
//      messageTextField.setText("GeoGebra opened.");
//      docker.showDockableWindow( "geogebra" );
//    }
//
//}//end method
//
//

hyperlinkUpdate(event)
{
  url = event.getURL();
//System.out.println("YYYPiperDocsYYY: " + url.getPath() + " reference: " + url.getRef() + " query: " + url.getQuery() );
  if(event.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
  {
    reference = url.getRef();
    query = url.getQuery();
    
    urlStringForm = url.toString();

    urlString = urlStringForm.substring(urlStringForm.indexOf("!/")+2,urlStringForm.length());
    
//System.out.println("    YYYYXX: " + "url: " + url +"  path: " + url.getPath() + "   urlString: " + urlString + "   url StringForm: " + urlStringForm);

    
    
    if(reference != null)
    {
        docPart = urlString.substring(0,urlString.indexOf("#"));

	urlWithReference = jEdit.getPlugin("org.mathrider.piperdocsplugin.PiperDocsPlugin").getPluginJAR().getClassLoader().getResource(docPart);

        if (urlWithReference != null) {

		    addReference = urlWithReference.toExternalForm() + "#"+reference;
		    setPage(new URL(addReference),true);
		    //editorPane.setPage(urlWithReference);
		    //editorPane.scrollToReference(reference);

	    } 
	    else {
		    System.err.println("Couldn't find file: " + urlWithReference );
	    }//end else
    }
    else if(query != null)
    {   
        match = findFileForFunctionInref(query);
        if(! match.equals(""))
        {
            //path = url.getPath();
	    path = urlString;
            path = path.replaceFirst("ref.html", match);
	    
	
	    docPart = path.substring(0,path.indexOf("?"));
	    //System.out.println("   QQQ path: " + path  + "   docPart: " + docPart + "  match: " + match);
	    urlWithQuery = jEdit.getPlugin("org.mathrider.piperdocsplugin.PiperDocsPlugin").getPluginJAR().getClassLoader().getResource(docPart);

	    
            //path = path + "#" + query;
           // path = "file://" + path;
           // System.out.println("TTT path: " + path );
            //url = new URL(path);
        
	    if (urlWithQuery != null) {

		    addQuery = urlWithQuery.toExternalForm() + "#"+query;
		    setPage(new URL(addQuery),true);
		    //editorPane.setPage(urlWithQuery);
		    //System.out.println(   "QRQRQR " + " urlWithQuery: " + urlWithQuery + " query: " + query + "  addQuery: " + addQuery);
		    //editorPane.scrollToReference(query);

	    } 
	    else {
		    System.err.println("Couldn't find file: " + urlWithQuery );
	    }//end else	    

        }//end if 
    }
    else
    {
	    	urlNormal = jEdit.getPlugin("org.mathrider.piperdocsplugin.PiperDocsPlugin").getPluginJAR().getClassLoader().getResource(urlString);

        if (urlNormal != null) {

		    setPage(urlNormal,true);
		    editorPane.scrollToReference(reference);

	    } 
	    else {
		    System.err.println("Couldn't find file: " + urlNormal );
	    }//end else
    }//end else. 
    
    
    
  }//end if.  + getRef())
}//end method.





findFileForFunctionInref(seach) 
{

funcs_refchapter1 = new String[] {};
funcs_refchapter2 =  new String[]{
"+"
, "-"
, "*"
, "/"
, "^"
, "Div"
, "Mod"
, "Gcd"
, "Lcm"
, "<<"
, ">>"
, "FromBase"
, "ToBase"
, "N"
, "Rationalize"
, "ContFrac"
, "Decimal"
, "Floor"
, "Ceil"
, "Round"
, "Min"
, "Max"
, "Numer"
, "Denom"
, "Pslq"
};
funcs_refchapter3 = new String[]{
"<"
, ">"
, "<="
, ">="
, "IsZero"
, "IsRational"
};
funcs_refchapter4 = new String[]{
"Sin"
, "Cos"
, "Tan"
, "ArcSin"
, "ArcCos"
, "ArcTan"
, "Exp"
, "Ln"
, "Sqrt"
, "Abs"
, "Sign"
, "D"
, "Curl"
, "Diverge"
, "Integrate"
, "Limit"
};
funcs_refchapter5 = new String[]{
"Random"
,"RandomSeed"
, "RngCreate"
, "RngSeed"
, "Rng"
, "RandomIntegerMatrix"
, "RandomIntegerVector"
, "RandomPoly"
};
funcs_refchapter6 = new String[]{
"Add"
, "Sum"
, "Factorize"
, "Taylor"
, "InverseTaylor"
, "ReversePoly"
, "BigOh"
, "LagrangeInterpolant"
};
funcs_refchapter7 = new String[]{
"!"
, "!!"
, "***"
, "Subfactorial"
, "Bin"
, "Eulerian"
, "LeviCivita"
, "Permutations"
};
funcs_refchapter8 = new String[]{
"Gamma"
, "Zeta"
, "Bernoulli"
, "Euler"
, "LambertW"
};
funcs_refchapter9 = new String[]{
"Complex"
, "Re"
, "Im"
, "I"
, "Conjugate"
, "Arg"
};
funcs_refchapter10 = new String[]{
"LaplaceTransform"
};
funcs_refchapter11 = new String[]{
"Simplify"
, "RadSimp"
, "FactorialSimplify"
, "LnExpand"
, "LnCombine"
, "TrigSimpCombine"
};
funcs_refchapter12 = new String[]{
"Solve"
, "OldSolve"
, "SuchThat"
, "Eliminate"
, "PSolve"
, "MatrixSolve"
};
funcs_refchapter13 = new String[]{
"Newton"
, "FindRealRoots"
, "NumRealRoots"
, "MinimumBound"
, "MaximumBound"
};
funcs_refchapter14 = new String[]{
"CanProve"
};
funcs_refchapter15 = new String[]{
"OdeSolve"
, "OdeTest"
, "OdeOrder"
};
funcs_refchapter16 = new String[]{
"Dot, ."
, "InProduct"
, "CrossProduct"
, "Outer, o"
, "ZeroVector"
, "BaseVector"
, "Identity"
, "ZeroMatrix"
, "Diagonal"
, "DiagonalMatrix"
, "OrthogonalBasis"
, "OrthonormalBasis"
, "Normalize"
, "Transpose"
, "Determinant"
, "Trace"
, "Inverse"
, "Minor"
, "CoFactor"
, "MatrixPower"
, "SolveMatrix"
, "CharacteristicEquation"
, "EigenValues"
, "EigenVectors"
, "Sparsity"
, "Cholesky"
};
funcs_refchapter17 = new String[]{
"IsScalar"
, "IsVector"
, "IsMatrix"
, "IsSquareMatrix"
, "IsHermitian"
, "IsOrthogonal"
, "IsDiagonal"
, "IsLowerTriangular"
, "IsUpperTriangular"
, "IsSymmetric"
, "IsSkewSymmetric"
, "IsUnitary"
, "IsIdempotent"
};
funcs_refchapter18 = new String[]{
"JacobianMatrix"
, "VandermondeMatrix"
, "HessianMatrix"
, "HilbertMatrix"
, "HilbertInverseMatrix"
, "ToeplitzMatrix"
, "WronskianMatrix"
, "SylvesterMatrix"
};
funcs_refchapter19 = new String[]{
"Expand"
, "Degree"
, "Coef"
, "Content"
, "PrimitivePart"
, "LeadingCoef"
, "Monic"
, "SquareFree"
, "Horner"
, "ExpandBrackets"
, "EvaluateHornerScheme"
};
funcs_refchapter20 = new String[]{
"OrthoP"
, "OrthoH"
, "OrthoG"
, "OrthoL"
, "OrthoT"
, "OrthoU"
, "OrthoPSum"
, "OrthoHSum"
, "OrthoLSum"
, "OrthoGSum"
, "OrthoTSum"
, "OrthoUSum"
, "OrthoPoly"
, "OrthoPolySum"
};
funcs_refchapter21 = new String[]{
"Head"
, "Tail"
, "Length"
, "Map"
, "MapSingle"
, "MakeVector"
, "Select"
, "Nth"
, "DestructiveReverse"
, "Reverse"
, "List"
, "UnList"
, "Listify"
, "Concat"
, "Delete"
, "Insert"
, "DestructiveDelete"
, "DestructiveInsert"
, "Replace"
, "DestructiveReplace"
, "FlatCopy"
, "Contains"
, "Find"
, "Append"
, "DestructiveAppend"
, "RemoveDuplicates"
, "Push"
, "Pop"
, "PopFront"
, "PopBack"
, "Swap"
, "Count"
, "Intersection"
, "Union"
, "Difference"
, "FillList"
, "Drop"
, "Take"
, "Partition"
, "Assoc"
, "AssocIndices"
, "AssocDelete"
, "Flatten"
, "UnFlatten"
, "Type"
, "NrArgs"
, "VarList"
, "VarListArith"
, "VarListSome"
, "FuncList"
, "FuncListArith"
, "FuncListSome"
, "BubbleSort"
, "HeapSort"
, "PrintList"
, "Table"
, "TableForm"
, "GlobalPop"
, "GlobalPush"
};
funcs_refchapter22 = new String[]{
":"
, "@"
, "/@"
, ".."
, "NFunction"
, "Where"
, "AddTo"
};
funcs_refchapter23 = new String[]{
"MaxEvalDepth"
, "Hold"
, "Eval"
, "While"
, "Until"
, "If"
, "SystemCall"
, "Function"
, "Macro"
, "Use"
, "For"
, "ForEach"
, "Apply"
, "MapArgs"
, "Subst"
, "WithValue"
, "/:"
, "/::"
, "TraceStack"
, "TraceExp"
, "TraceRule"
, "Time"
};
funcs_refchapter24 = new String[]{
"!="
, "="
, "Not"
, "And"
, "Or"
, "IsFreeOf"
, "IsZeroVector"
, "IsNonObject"
, "IsEven"
, "IsOdd"
, "IsEvenFunction"
, "IsOddFunction"
, "IsFunction"
, "IsAtom"
, "IsString"
, "IsNumber"
, "IsList"
, "IsNumericList"
, "IsBound"
, "IsBoolean"
, "IsNegativeNumber"
, "IsNegativeInteger"
, "IsPositiveNumber"
, "IsPositiveInteger"
, "IsNotZero"
, "IsNonZeroInteger"
, "IsInfinity"
, "IsPositiveReal"
, "IsNegativeReal"
, "IsConstant"
, "IsGaussianInteger"
, "MatchLinear"
, "HasExpr"
, "HasExprArith"
, "HasExprSome"
, "HasFunc"
, "HasFuncArith"
, "HasFuncSome"
};
funcs_refchapter25 = new String[]{
"%"
, "True"
, "False"
, "EndOfFile"
};
funcs_refchapter26 = new String[]{
"Infinity"
, "Pi"
, "Undefined"
, "GoldenRatio"
, "Catalan"
, "gamma"
};
funcs_refchapter27 = new String[]{
":="
, "Set"
, "Clear"
, "Local"
, "++"
, "--"
, "Object"
, "SetGlobalLazyVariable"
, "UniqueConstant"
, "LocalSymbols"
};
funcs_refchapter28 = new String[]{
"FullForm"
, "Echo"
, "PrettyForm"
, "EvalFormula"
, "TeXForm"
, "CForm"
, "IsCFormable"
, "Write"
, "WriteString"
, "Space"
, "NewLine"
, "FromFile"
, "FromString"
, "ToFile"
, "ToString"
, "Read"
, "ToStdout"
, "ReadCmdLineString"
, "LispRead"
, "LispReadListed"
, "ReadToken"
, "Load"
, "Use"
, "DefLoad"
, "FindFile"
, "PatchLoad"
, "Nl"
, "V, InVerboseMode"
, "Plot2D"
, "Plot3DS"
, "XmlExplodeTag"
, "DefaultTokenizer"
, "XmlTokenizer"
, "OMForm"
, "OMRead"
, "OMDef"
};
funcs_refchapter29 = new String[]{
"StringMid'Set"
, "StringMid'Get"
, "String"
, "Atom"
, "ConcatStrings"
, "PatchString"
};
funcs_refchapter30 = new String[]{
"BernoulliDistribution"
, "BinomialDistribution"
, "tDistribution"
, "PDF"
, "ChiSquareTest"
};
funcs_refchapter31 = new String[]{
"IsPrime"
, "IsSmallPrime"
, "IsComposite"
, "IsCoprime"
, "IsSquareFree"
, "IsPrimePower"
, "NextPrime"
, "IsTwinPrime"
, "IsIrregularPrime"
, "IsCarmichaelNumber"
, "Factors"
, "IsAmicablePair"
, "Factor"
, "Divisors"
, "DivisorsSum"
, "ProperDivisors"
, "ProperDivisorsSum"
, "Moebius"
, "CatalanNumber"
, "FermatNumber"
, "HarmonicNumber"
, "StirlingNumber1"
, "StirlingNumber2"
, "DivisorsList"
, "SquareFreeDivisorsList"
, "MoebiusDivisorsList"
, "SumForDivisors"
, "RamanujanSum"
, "Cyclotomic"
, "PAdicExpand"
, "IsQuadraticResidue"
, "LegendreSymbol"
, "JacobiSymbol"
, "GaussianFactors"
, "GaussianNorm"
, "IsGaussianUnit"
, "IsGaussianPrime"
, "GaussianGcd"
};
funcs_refchapter32 = new String[]{
};

  if (containsFunc(funcs_refchapter1,seach))
    return "refchapter1.html";
  if (containsFunc(funcs_refchapter2,seach))
    return "refchapter2.html";
  if (containsFunc(funcs_refchapter3,seach))
    return "refchapter3.html";
  if (containsFunc(funcs_refchapter4,seach))
    return "refchapter4.html";
  if (containsFunc(funcs_refchapter5,seach))
    return "refchapter5.html";
  if (containsFunc(funcs_refchapter6,seach))
    return "refchapter6.html";
  if (containsFunc(funcs_refchapter7,seach))
    return "refchapter7.html";
  if (containsFunc(funcs_refchapter8,seach))
    return "refchapter8.html";
  if (containsFunc(funcs_refchapter9,seach))
    return "refchapter9.html";
  if (containsFunc(funcs_refchapter10,seach))
    return "refchapter10.html";
  if (containsFunc(funcs_refchapter11,seach))
    return "refchapter11.html";
  if (containsFunc(funcs_refchapter12,seach))
    return "refchapter12.html";
  if (containsFunc(funcs_refchapter13,seach))
    return "refchapter13.html";
  if (containsFunc(funcs_refchapter14,seach))
    return "refchapter14.html";
  if (containsFunc(funcs_refchapter15,seach))
    return "refchapter15.html";
  if (containsFunc(funcs_refchapter16,seach))
    return "refchapter16.html";
  if (containsFunc(funcs_refchapter17,seach))
    return "refchapter17.html";
  if (containsFunc(funcs_refchapter18,seach))
    return "refchapter18.html";
  if (containsFunc(funcs_refchapter19,seach))
    return "refchapter19.html";
  if (containsFunc(funcs_refchapter20,seach))
    return "refchapter20.html";
  if (containsFunc(funcs_refchapter21,seach))
    return "refchapter21.html";
  if (containsFunc(funcs_refchapter22,seach))
    return "refchapter22.html";
  if (containsFunc(funcs_refchapter23,seach))
    return "refchapter23.html";
  if (containsFunc(funcs_refchapter24,seach))
    return "refchapter24.html";
  if (containsFunc(funcs_refchapter25,seach))
    return "refchapter25.html";
  if (containsFunc(funcs_refchapter26,seach))
    return "refchapter26.html";
  if (containsFunc(funcs_refchapter27,seach))
    return "refchapter27.html";
  if (containsFunc(funcs_refchapter28,seach))
    return "refchapter28.html";
  if (containsFunc(funcs_refchapter29,seach))
    return "refchapter29.html";
  if (containsFunc(funcs_refchapter30,seach))
    return "refchapter30.html";
  if (containsFunc(funcs_refchapter31,seach))
    return "refchapter31.html";
  if (containsFunc(funcs_refchapter32,seach))
    return "refchapter32.html";
  return "";
 
  
}//end method.






findFileForFunctionInrefprog(seach2) {
funcs_refprogchapter1 = new String[]{};
funcs_refprogchapter2 = new String[]{
"/*"
, "*/"
, "//"
, "Prog"
, "["
, "]"
, "Bodied"
, "Infix"
, "Postfix"
, "Prefix"
, "IsBodied"
, "IsInfix"
, "IsPostfix"
, "IsPrefix"
, "OpPrecedence"
, "OpLeftPrecedence"
, "OpRightPrecedence"
, "RightAssociative"
, "LeftPrecedence"
, "RightPrecedence"
, "RuleBase"
, "RuleBaseListed"
, "Rule"
, "HoldArg"
, "Retract"
, "UnFence"
, "HoldArgNr"
, "RuleBaseArgList"
, "MacroSet"
, "MacroClear"
, "MacroLocal"
, "MacroRuleBase"
, "MacroRuleBaseListed"
, "MacroRule"
, "Backquoting"
, "DefMacroRuleBase"
, "DefMacroRuleBaseListed"
, "ExtraInfo'Set, ExtraInfo'Get"
, "GarbageCollect"
, "FindFunction"
, "Secure"
};
funcs_refprogchapter3 = new String[]{
"MultiplyNum"
, "CachedConstant"
, "NewtonNum"
, "SumTaylorNum"
, "IntPowerNum"
, "BinSplitNum"
, "BinSplitData"
, "BinSplitFinal"
, "MathSetExactBits"
, "MathGetExactBits"
, "InNumericMode"
, "NonN"
, "IntLog"
, "IntNthRoot"
, "NthRoot"
, "ContFracList"
, "ContFracEval"
, "GuessRational"
, "NearRational"
, "BracketRational"
, "TruncRadian"
, "Builtin'Precision'Set"
, "Builtin'Precision'Get"
};
funcs_refprogchapter4 = new String[]{
"Check"
, "TrapError"
, "GetCoreError"
, "Assert"
, "DumpErrors"
, "ClearErrors"
, "IsError"
, "GetError"
, "ClearError"
, "GetErrorTableau"
, "CurrentFile"
, "CurrentLine"
};
funcs_refprogchapter5 = new String[]{
"MathNot"
, "MathAnd"
, "MathOr"
, "BitAnd"
, "BitOr"
, "BitXor"
, "Equals"
, "GreaterThan"
, "LessThan"
, "Math..."
, "Fast..."
, "ShiftLeft"
, "ShiftRight"
, "IsPromptShown"
, "GetTime"
};
funcs_refprogchapter6 = new String[]{
"IsGeneric"
, "GenericTypeName"
, "Array'Create"
, "Array'Size"
, "Array'Get"
, "Array'Set"
, "Array'CreateFromList"
, "Array'ToList"
};
funcs_refprogchapter7 = new String[]{
"Verify"
, "TestPiper"
, "LogicVerify"
, "LogicTest"
, "KnownFailure"
, "RoundTo"
, "VerifyArithmetic"
, "RandVerifyArithmetic"
, "VerifyDiv"
};
funcs_refprogchapter8 = new String[]{
};
funcs_refprogchapter9 = new String[]{
};
funcs_refprogchapter10 = new String[]{
};
  if (containsFunc(funcs_refprogchapter1,seach2))
    return "refprogchapter1.html";
  if (containsFunc(funcs_refprogchapter2,seach2))
    return "refprogchapter2.html";
  if (containsFunc(funcs_refprogchapter3,seach2))
    return "refprogchapter3.html";
  if (containsFunc(funcs_refprogchapter4,seach2))
    return "refprogchapter4.html";
  if (containsFunc(funcs_refprogchapter5,seach2))
    return "refprogchapter5.html";
  if (containsFunc(funcs_refprogchapter6,seach2))
    return "refprogchapter6.html";
  if (containsFunc(funcs_refprogchapter7,seach2))
    return "refprogchapter7.html";
  if (containsFunc(funcs_refprogchapter8,seach2))
    return "refprogchapter8.html";
  if (containsFunc(funcs_refprogchapter9,seach2))
    return "refprogchapter9.html";
  if (containsFunc(funcs_refprogchapter10,seach2))
    return "refprogchapter10.html";
  return "";
}//end method.


findFileForFunction(seach3)
{
  file = "";
  if (file.equals(""))
    file = findFileForFunctionInref(seach3);
  if (file.equals(""))
    file = findFileForFunctionInrefprog(seach3);
  return file;
}//end method.

containsFunc(chapterx,func)
{
  for (i=0;i<chapterx.length;i++)
  {
    if (chapterx[i].equals(func))
      return true;
  }
  return false;
}//end method.


// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=0:
