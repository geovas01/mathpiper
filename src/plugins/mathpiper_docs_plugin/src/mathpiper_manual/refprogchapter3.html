<html>
<head>
  <title>Arbitrary-precision numerical programming</title>
  <link rel="stylesheet" href="mathpiper.css" TYPE="text/css" MEDIA="screen">
</head>
<body>
<a name="c3">

</a>
(directly go to documentation on : <a href="refprogchapter3.html#MultiplyNum" target='Chapters' title="optimized numerical multiplication">MultiplyNum</a>, <a href="refprogchapter3.html#CachedConstant" target='Chapters' title="precompute multiple-precision constants">CachedConstant</a>, <a href="refprogchapter3.html#NewtonNum" target='Chapters' title="low-level optimized Newton's iterations">NewtonNum</a>, <a href="refprogchapter3.html#SumTaylorNum" target='Chapters' title="optimized numerical evaluation of Taylor series">SumTaylorNum</a>, <a href="refprogchapter3.html#IntPowerNum" target='Chapters' title="optimized computation of integer powers">IntPowerNum</a>, <a href="refprogchapter3.html#BinSplitNum" target='Chapters' title="computations of series by the binary splitting method">BinSplitNum</a>, <a href="refprogchapter3.html#BinSplitData" target='Chapters' title="computations of series by the binary splitting method">BinSplitData</a>, <a href="refprogchapter3.html#BinSplitFinal" target='Chapters' title="computations of series by the binary splitting method">BinSplitFinal</a>, <a href="refprogchapter3.html#SetExactBitsN" target='Chapters' title="manipulate precision of floating-point numbers">SetExactBitsN</a>, <a href="refprogchapter3.html#GetExactBitsN" target='Chapters' title="manipulate precision of floating-point numbers">GetExactBitsN</a>, <a href="refprogchapter3.html#InNumericMode" target='Chapters' title="determine if currently in numeric mode">InNumericMode</a>, <a href="refprogchapter3.html#NonN" target='Chapters' title="calculate part in non-numeric mode">NonN</a>, <a href="refprogchapter3.html#IntLog" target='Chapters' title="integer part of logarithm">IntLog</a>, <a href="refprogchapter3.html#IntNthRoot" target='Chapters' title="integer part of <b>n</b>-th root">IntNthRoot</a>, <a href="refprogchapter3.html#NthRoot" target='Chapters' title="calculate/simplify nth root of an integer">NthRoot</a>, <a href="refprogchapter3.html#ContFracList" target='Chapters' title="manipulate continued fractions">ContFracList</a>, <a href="refprogchapter3.html#ContFracEval" target='Chapters' title="manipulate continued fractions">ContFracEval</a>, <a href="refprogchapter3.html#GuessRational" target='Chapters' title="find optimal rational approximations">GuessRational</a>, <a href="refprogchapter3.html#NearRational" target='Chapters' title="find optimal rational approximations">NearRational</a>, <a href="refprogchapter3.html#BracketRational" target='Chapters' title="find optimal rational approximations">BracketRational</a>, <a href="refprogchapter3.html#TruncRadian" target='Chapters' title="remainder modulo <b>2*Pi</b>">TruncRadian</a>, <a href="refprogchapter3.html#BuiltinPrecisionSet" target='Chapters' title="set the precision">BuiltinPrecisionSet</a>, <a href="refprogchapter3.html#BuiltinPrecisionGet" target='Chapters' title="get the current precision">BuiltinPrecisionGet</a>.
)<h1>
3. Arbitrary-precision numerical programming
</h1>
This chapter contains functions that help programming numerical calculations with arbitrary precision.

<p> </p>
<center><table>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#MultiplyNum" target='Chapters' title="optimized numerical multiplication">MultiplyNum</a></td>
<td>optimized numerical multiplication</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#CachedConstant" target='Chapters' title="precompute multiple-precision constants">CachedConstant</a></td>
<td>precompute multiple-precision constants</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#NewtonNum" target='Chapters' title="low-level optimized Newton's iterations">NewtonNum</a></td>
<td>low-level optimized Newton's iterations</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#SumTaylorNum" target='Chapters' title="optimized numerical evaluation of Taylor series">SumTaylorNum</a></td>
<td>optimized numerical evaluation of Taylor series</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#IntPowerNum" target='Chapters' title="optimized computation of integer powers">IntPowerNum</a></td>
<td>optimized computation of integer powers</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BinSplitNum" target='Chapters' title="computations of series by the binary splitting method">BinSplitNum</a></td>
<td>computations of series by the binary splitting method</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BinSplitData" target='Chapters' title="computations of series by the binary splitting method">BinSplitData</a></td>
<td>computations of series by the binary splitting method</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BinSplitFinal" target='Chapters' title="computations of series by the binary splitting method">BinSplitFinal</a></td>
<td>computations of series by the binary splitting method</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#SetExactBitsN" target='Chapters' title="manipulate precision of floating-point numbers">SetExactBitsN</a></td>
<td>manipulate precision of floating-point numbers</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#GetExactBitsN" target='Chapters' title="manipulate precision of floating-point numbers">GetExactBitsN</a></td>
<td>manipulate precision of floating-point numbers</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#InNumericMode" target='Chapters' title="determine if currently in numeric mode">InNumericMode</a></td>
<td>determine if currently in numeric mode</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#NonN" target='Chapters' title="calculate part in non-numeric mode">NonN</a></td>
<td>calculate part in non-numeric mode</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#IntLog" target='Chapters' title="integer part of logarithm">IntLog</a></td>
<td>integer part of logarithm</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#IntNthRoot" target='Chapters' title="integer part of <b>n</b>-th root">IntNthRoot</a></td>
<td>integer part of <b>n</b>-th root</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#NthRoot" target='Chapters' title="calculate/simplify nth root of an integer">NthRoot</a></td>
<td>calculate/simplify nth root of an integer</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#ContFracList" target='Chapters' title="manipulate continued fractions">ContFracList</a></td>
<td>manipulate continued fractions</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#ContFracEval" target='Chapters' title="manipulate continued fractions">ContFracEval</a></td>
<td>manipulate continued fractions</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#GuessRational" target='Chapters' title="find optimal rational approximations">GuessRational</a></td>
<td>find optimal rational approximations</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#NearRational" target='Chapters' title="find optimal rational approximations">NearRational</a></td>
<td>find optimal rational approximations</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BracketRational" target='Chapters' title="find optimal rational approximations">BracketRational</a></td>
<td>find optimal rational approximations</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#TruncRadian" target='Chapters' title="remainder modulo <b>2*Pi</b>">TruncRadian</a></td>
<td>remainder modulo <b>2*Pi</b></td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BuiltinPrecisionSet" target='Chapters' title="set the precision">BuiltinPrecisionSet</a></td>
<td>set the precision</td>
</tr>
<tr BGCOLOR=#E0E0E0>
<td><a href="refprogchapter3.html#BuiltinPrecisionGet" target='Chapters' title="get the current precision">BuiltinPrecisionGet</a></td>
<td>get the current precision</td>
</tr>
</table></center>

<p>

<a name="MultiplyNum">

</a>
<a name="multiplynum">

</a>
<h3>
<hr>MultiplyNum -- optimized numerical multiplication
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
MultiplyNum(x,y)
MultiplyNum(x,y,z,...)
MultiplyNum({x,y,z,...})
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>x</tt></b>, <b><tt>y</tt></b>, <b><tt>z</tt></b> -- integer, rational or floating-point numbers to multiply


<p>

<h5>
Description:
</h5>
The function <b><tt>MultiplyNum</tt></b> is used to speed up multiplication of floating-point numbers with rational numbers. Suppose we need to compute <b>p/q*x</b> where <b> p</b>, <b> q</b> are integers and <b> x</b> is a floating-point number. At high precision, it is faster to multiply <b> x</b> by an integer <b> p</b> and divide by an integer <b> q</b> than to compute <b> p/q</b> to high precision and then multiply by <b> x</b>. The function  <b><tt>MultiplyNum</tt></b> performs this optimization.


<p>
The function accepts any number of arguments (not less than two) or a list of numbers. The result is always a floating-point number (even if <b><tt>InNumericMode()</tt></b> returns False).


<p>

<h5>
See also:
</h5>
<a href="ref.html?MultiplyN" target="Chapters">
MultiplyN
</a>
.<a name="CachedConstant">

</a>
<a name="cachedconstant">

</a>
<h3>
<hr>CachedConstant -- precompute multiple-precision constants
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
CachedConstant(cache, Cname, Cfunc)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>cache</tt></b> -- atom, name of the cache


<p>
<b><tt>Cname</tt></b> -- atom, name of the constant


<p>
<b><tt>Cfunc</tt></b> -- expression that evaluates the constant


<p>

<h5>
Description:
</h5>
This function is used to create precomputed multiple-precision values of
constants. Caching these values will save time if they are frequently used.


<p>
The call to <b><tt>CachedConstant</tt></b> defines a new function named <b><tt>Cname()</tt></b> that
returns the value of the constant at given precision. If the precision is
increased, the value will be recalculated as necessary, otherwise calling <b><tt>Cname()</tt></b> will take very little time.


<p>
The parameter <b><tt>Cfunc</tt></b> must be an expression that can be evaluated and returns
the value of the desired constant at the current precision. (Most arbitrary-precision mathematical functions do this by default.)


<p>
The associative list <b><tt>cache</tt></b> contains elements of the form <b><tt>{Cname, prec, value}</tt></b>, as illustrated in the example. If this list does not exist, it will be created.


<p>
This mechanism is currently used by <b><tt>N()</tt></b> to precompute the values of <b> Pi</b> and <b> gamma</b> (and the golden ratio through <b><tt>GoldenRatio</tt></b>, and <b><tt>Catalan</tt></b>).
The name of the cache for <b><tt>N()</tt></b> is <b><tt>CacheOfConstantsN</tt></b>.
The code in the function <b><tt>N()</tt></b> assigns unevaluated calls to <b><tt>Internal'Pi()</tt></b> and <b><tt>Internal'gamma()</tt></b> to the atoms <b><tt>Pi</tt></b> and <b><tt>gamma</tt></b> and declares them to be lazy global variables through <b><tt>SetGlobalLazyVariable</tt></b> (with equivalent functions assigned to other constants that are added to the list of cached constants).


<p>
The result is that the constants will be recalculated only when they are used in the expression under <b><tt>N()</tt></b>.
In other words, the code in <b><tt>N()</tt></b> does the equivalent of


<p>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
SetGlobalLazyVariable(mypi,Hold(Internal'Pi()));
SetGlobalLazyVariable(mygamma,Hold(Internal'gamma()));
</pre></tr>
</table>


<p>
After this, evaluating an expression such as <b><tt>1/2+gamma</tt></b> will call the function <b><tt>Internal'gamma()</tt></b> but not the function <b><tt>Internal'Pi()</tt></b>.


<p>

<h5>
Example:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; CachedConstant( my'cache, Ln2, Internal'LnNum(2) )
Out&gt; True;
In&gt; Internal'Ln2()
Out&gt; 0.6931471806;
In&gt; V(N(Internal'Ln2(),20))
CachedConstant: Info: constant Ln2 is being
  recalculated at precision 20 
Out&gt; 0.69314718055994530942;
In&gt; my'cache
Out&gt; {{"Ln2",20,0.69314718055994530942}};
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?N" target="Chapters">
N
</a>
, <a href="ref.html?BuiltinPrecisionSet" target="Chapters">
BuiltinPrecisionSet
</a>
, <a href="ref.html?Pi" target="Chapters">
Pi
</a>
, <a href="ref.html?GoldenRatio" target="Chapters">
GoldenRatio
</a>
, <a href="ref.html?Catalan" target="Chapters">
Catalan
</a>
, <a href="ref.html?gamma" target="Chapters">
gamma
</a>
.<a name="NewtonNum">

</a>
<a name="newtonnum">

</a>
<h3>
<hr>NewtonNum -- low-level optimized Newton's iterations
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
NewtonNum(func, x0, prec0, order)
NewtonNum(func, x0, prec0)
NewtonNum(func, x0)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>func</tt></b> -- a function specifying the iteration sequence


<p>
<b><tt>x0</tt></b> -- initial value (must be close enough to the root)


<p>
<b><tt>prec0</tt></b> -- initial precision (at least 4, default 5)


<p>
<b><tt>order</tt></b> -- convergence order (typically 2 or 3, default 2)


<p>

<h5>
Description:
</h5>
This function is an optimized interface for computing Newton's
iteration sequences for numerical solution of equations in arbitrary precision.


<p>
<b><tt>NewtonNum</tt></b> will iterate the given function starting from the initial
value, until the sequence converges within current precision.
Initially, up to 5 iterations at the initial precision <b><tt>prec0</tt></b> is
performed (the low precision is set for speed). The initial value <b><tt>x0</tt></b>
must be close enough to the root so that the initial iterations
converge. If the sequence does not produce even a single correct digit
of the root after these initial iterations, an error message is
printed. The default value of the initial precision is 5.


<p>
The <b><tt>order</tt></b> parameter should give the convergence order of the scheme.
Normally, Newton iteration converges quadratically (so the default
value is <b><tt>order</tt></b>=2) but some schemes converge faster and you can speed
up this function by specifying the correct order. (Caution: if you give
<b><tt>order</tt></b>=3 but the sequence is actually quadratic, the result will be
silently incorrect. It is safe to use <b><tt>order</tt></b>=2.)


<p>


<p>

<h5>
Example:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BuiltinPrecisionSet(20)
Out&gt; True;
In&gt; NewtonNum({{x}, x+Sin(x)}, 3, 5, 3)
Out&gt; 3.14159265358979323846;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?Newton" target="Chapters">
Newton
</a>
.<a name="SumTaylorNum">

</a>
<a name="sumtaylornum">

</a>
<h3>
<hr>SumTaylorNum -- optimized numerical evaluation of Taylor series
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
SumTaylorNum(x, NthTerm, order)
SumTaylorNum(x, NthTerm, TermFactor, order)
SumTaylorNum(x, ZerothTerm, TermFactor, order)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>NthTerm</tt></b> -- a function specifying <b> n</b>-th coefficient of the series


<p>
<b><tt>ZerothTerm</tt></b> -- value of the <b> 0</b>-th coefficient of the series


<p>
<b><tt>x</tt></b> -- number, value of the expansion variable


<p>
<b><tt>TermFactor</tt></b> -- a function specifying the ratio of <b> n</b>-th term to the previous one


<p>
<b><tt>order</tt></b> -- power of <b> x</b> in the last term


<p>

<h5>
Description:
</h5>
<b><tt>SumTaylorNum</tt></b> computes a Taylor series <b> Sum(k,0,n,a[k]*x^k)</b>
numerically. This function allows very efficient computations of
functions given by Taylor series, although some tweaking of the
parameters is required for good results.


<p>
The coefficients <b>a[k]</b> of the Taylor series are given as functions of one integer variable (<b>k</b>). It is convenient to pass them to <b><tt>SumTaylorNum</tt></b> as closures.
For example, if a function <b><tt>a(k)</tt></b> is defined, then
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
SumTaylorNum(x, {{k}, a(k)}, n)
</pre></tr>
</table>
computes the series <b> Sum(k,0,n,a(k)*x^k)</b>.


<p>
Often a simple relation between successive coefficients <b>a[k-1]</b>,
<b>a[k]</b> of the series is available; usually they are related by a
rational factor. In this case, the second form of <b><tt>SumTaylorNum</tt></b> should
be used because it will compute the series faster. The function
<b><tt>TermFactor</tt></b> applied to an integer <b>k&gt;=1</b> must return the ratio
<b> a[k]</b>/<b>a[k-1]</b>. (If possible, the function <b><tt>TermFactor</tt></b> should return
a rational number and not a floating-point number.) The function
<b><tt>NthTerm</tt></b> may also be given, but the current implementation only calls
<b><tt>NthTerm(0)</tt></b> and obtains all other coefficients by using <b><tt>TermFactor</tt></b>.
Instead of the function <b><tt>NthTerm</tt></b>, a number giving the <b>0</b>-th term can be given.


<p>
The algorithm is described elsewhere in the documentation.
The number of terms <b><tt>order</tt></b>+1
must be specified and a sufficiently high precision must be preset in
advance to achieve the desired accuracy.
(The function <b><tt>SumTaylorNum</tt></b> does not change the current precision.)


<p>

<h5>
Examples:
</h5>
To compute 20 digits of <b> Exp(1)</b> using the Taylor series, one needs 21
digits of working precision and 21 terms of the series. 


<p>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BuiltinPrecisionSet(21)
Out&gt; True;
In&gt; SumTaylorNum(1, {{k},1/k!}, 21)
Out&gt; 2.718281828459045235351;
In&gt; SumTaylorNum(1, 1, {{k},1/k}, 21)
Out&gt; 2.71828182845904523535;
In&gt; SumTaylorNum(1, {{k},1/k!}, {{k},1/k}, 21)
Out&gt; 2.71828182845904523535;
In&gt; RoundTo(N(Ln(%)),20)
Out&gt; 1;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?Taylor" target="Chapters">
Taylor
</a>
.<a name="IntPowerNum">

</a>
<a name="intpowernum">

</a>
<h3>
<hr>IntPowerNum -- optimized computation of integer powers
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
IntPowerNum(x, n, mult, unity)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>x</tt></b> -- a number or an expression


<p>
<b><tt>n</tt></b> -- a non-negative integer (power to raise <b><tt>x</tt></b> to)


<p>
<b><tt>mult</tt></b> -- a function that performs one multiplication


<p>
<b><tt>unity</tt></b> -- value of the unity with respect to that multiplication


<p>

<h5>
Description:
</h5>
<b><tt>IntPowerNum</tt></b> computes the power <b>x^n</b> using the fast binary algorithm.
It can compute integer powers with <b> n&gt;=0</b> in any ring where multiplication with unity is defined.
The multiplication function and the unity element must be specified.
The number of multiplications is no more than <b> 2*Ln(n)/Ln(2)</b>.


<p>
Mathematically, this function is a generalization of <b><tt>PowerN</tt></b> to rings other than that of real numbers.


<p>
In the current implementation, the <b><tt>unity</tt></b> argument is only used when the given power <b><tt>n</tt></b> is zero.


<p>

<h5>
Examples:
</h5>
For efficient numerical calculations, the <b><tt>MultiplyN</tt></b> function can be passed:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntPowerNum(3, 3, MultiplyN,1)
Out&gt; 27;
</pre></tr>
</table>
Otherwise, the usual <b><tt>*</tt></b> operator suffices:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntPowerNum(3+4*I, 3, *,1)
Out&gt; Complex(-117,44);
In&gt; IntPowerNum(HilbertMatrix(2), 4, *,
  Identity(2))
Out&gt; {{289/144,29/27},{29/27,745/1296}};
</pre></tr>
</table>
Compute <b>Mod(3^100,7)</b>:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntPowerNum(3,100,{{x,y},Mod(x*y,7)},1)
Out&gt; 4;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?MultiplyNum" target="Chapters">
MultiplyNum
</a>
, <a href="ref.html?PowerN" target="Chapters">
PowerN
</a>
, <a href="ref.html?MatrixPower" target="Chapters">
MatrixPower
</a>
.<a name="BinSplitNum">

</a>
<a name="binsplitnum">

</a>
<h3>
<hr>BinSplitNum -- computations of series by the binary splitting method
</h3>
<a name="BinSplitData">

</a>
<a name="binsplitdata">

</a>
<h3>
<hr>BinSplitData -- computations of series by the binary splitting method
</h3>
<a name="BinSplitFinal">

</a>
<a name="binsplitfinal">

</a>
<h3>
<hr>BinSplitFinal -- computations of series by the binary splitting method
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
BinSplitNum(n1, n2, a, b, c, d)
BinSplitData(n1,n2, a, b, c, d)
BinSplitFinal({P,Q,B,T})
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>n1</tt></b>, <b><tt>n2</tt></b> -- integers, initial and final indices for summation


<p>
<b><tt>a</tt></b>, <b><tt>b</tt></b>, <b><tt>c</tt></b>, <b><tt>d</tt></b> -- functions of one argument, coefficients of the series


<p>
<b><tt>P</tt></b>, <b><tt>Q</tt></b>, <b><tt>B</tt></b>, <b><tt>T</tt></b> -- numbers, intermediate data as returned by <b><tt>BinSplitData</tt></b>


<p>

<h5>
Description:
</h5>
The binary splitting method is an efficient way to evaluate many series when fast multiplication is available and when the series contains only rational numbers.
The function <b><tt>BinSplitNum</tt></b> evaluates a series of the form

<p><center><b>S(n[1],n[2])=Sum(k,n[1],n[2],a(k)/b(k)*p(0)/q(0)*...*p(k)/q(k)).</b></center></p>

Most series for elementary and special functions at rational points are of this form when the functions <b>a(k)</b>, <b>b(k)</b>, <b>p(k)</b>, <b>q(k)</b> are chosen appropriately.


<p>
The last four arguments of <b><tt>BinSplitNum</tt></b> are functions of one argument that give the coefficients <b>a(k)</b>, <b>b(k)</b>, <b>p(k)</b>, <b>q(k)</b>.
In most cases these will be short integers that are simple to determine.
The binary splitting method will work also for non-integer coefficients, but the calculation will take much longer in that case.


<p>
Note: the binary splitting method outperforms the straightforward summation only if the multiplication of integers is faster than quadratic in the number of digits.
See <a href="Algochapter3.html#c3s14" target="Chapters">
the algorithm documentation
</a>
 for more information.


<p>
The two other functions are low-level functions that allow a finer control over the calculation.
The use of the low-level routines allows checkpointing or parallelization of a binary splitting calculation.


<p>
The binary splitting method recursively reduces the calculation of <b>S(n[1],n[2])</b> to the same calculation for the two halves of the interval [<b>n[1]</b>, <b>n[2]</b>].
The intermediate results of a binary splitting calculation are returned by <b><tt>BinSplitData</tt></b> and consist of four integers <b>P</b>, <b> Q</b>, <b> B</b>, <b> T</b>.
These four integers are converted into the final answer <b> S</b> by the routine <b><tt>BinSplitFinal</tt></b> using the relation

<p><center><b> S=T/(B*Q).</b></center></p>



<p>

<h5>
Examples:
</h5>
Compute the series for <b>e=Exp(1)</b> using binary splitting.
(We start from <b>n=1</b> to simplify the coefficient functions.)
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BuiltinPrecisionSet(21)
Out&gt; True;
In&gt;  BinSplitNum(1,21, {{k},1},
  {{k},1},{{k},1},{{k},k})
Out&gt; 1.718281828459045235359;
In&gt; N(Exp(1)-1)
Out&gt; 1.71828182845904523536;
In&gt;  BinSplitData(1,21, {{k},1},
  {{k},1},{{k},1},{{k},k})
Out&gt; {1,51090942171709440000,1,
  87788637532500240022};
In&gt; BinSplitFinal(%)
Out&gt; 1.718281828459045235359;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?SumTaylorNum" target="Chapters">
SumTaylorNum
</a>
.<a name="SetExactBitsN">

</a>
<a name="mathsetexactbits">

</a>
<h3>
<hr>SetExactBitsN -- manipulate precision of floating-point numbers
</h3>
<a name="GetExactBitsN">

</a>
<a name="mathgetexactbits">

</a>
<h3>
<hr>GetExactBitsN -- manipulate precision of floating-point numbers
</h3>
<h5 align=right>Internal function</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
GetExactBitsN(x)
SetExactBitsN(x,bits)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>x</tt></b> -- an expression evaluating to a floating-point number


<p>
<b><tt>bits</tt></b> -- integer, number of bits 


<p>

<h5>
Description:
</h5>
Each floating-point number in MathPiper has an internal precision counter that stores the number of exact bits in the mantissa.
The number of exact bits is automatically updated after each arithmetic operation to reflect the gain or loss of precision due to round-off.
The functions <b><tt>GetExactBitsN</tt></b>, <b><tt>SetExactBitsN</tt></b> allow to query or set the precision flags of individual number objects.


<p>
<b><tt>GetExactBitsN(x)</tt></b> returns an integer number <b> n</b> such that <b><tt>x</tt></b> represents a real number in the interval [<b> x*(1-2^(-n))</b>, <b>x*(1+2^(-n))</b>] if <b>x!=0</b> and in the interval [<b>-2^(-n)</b>, <b>2^(-n)</b>] if <b>x=0</b>.
The integer <b> n</b> is always nonnegative unless <b><tt>x</tt></b> is zero (a "floating zero").
A floating zero can have a negative value of the number <b> n</b> of exact bits.


<p>
These functions are only meaningful for floating-point numbers.
(All integers are always exact.)
For integer <b><tt>x</tt></b>, the function <b><tt>GetExactBitsN</tt></b> returns the bit count of <b><tt>x</tt></b>
and the function <b><tt>SetExactBitsN</tt></b> returns the unmodified integer <b><tt>x</tt></b>.


<p>


<p>

<h5>
Examples:
</h5>
The default precision of 10 decimals corresponds to 33 bits:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; GetExactBitsN(1000.123)
Out&gt; 33;
In&gt; x:=SetExactBitsN(10., 20)
Out&gt; 10.;
In&gt; GetExactBitsN(x)
Out&gt; 20;
</pre></tr>
</table>
Prepare a "floating zero" representing an interval [-4, 4]:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; x:=SetExactBitsN(0., -2)
Out&gt; 0.;
In&gt; x=0
Out&gt; True;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?BuiltinPrecisionSet" target="Chapters">
BuiltinPrecisionSet
</a>
, <a href="ref.html?BuiltinPrecisionGet" target="Chapters">
BuiltinPrecisionGet
</a>
.<a name="InNumericMode">

</a>
<a name="innumericmode">

</a>
<h3>
<hr>InNumericMode -- determine if currently in numeric mode
</h3>
<a name="NonN">

</a>
<a name="nonn">

</a>
<h3>
<hr>NonN -- calculate part in non-numeric mode
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
NonN(expr)
InNumericMode()
</pre></tr>
</table>

<h5>
Parameters:
</h5>
<b><tt>expr</tt></b> -- expression to evaluate


<p>
<b><tt>prec</tt></b> -- integer, precision to use


<p>

<h5>
Description:
</h5>
When in numeric mode, <b><tt>InNumericMode()</tt></b> will return <b><tt>True</tt></b>, else it will
return <b><tt>False</tt></b>. <b><tt>MathPiper</tt></b> is in numeric mode when evaluating an expression
with the function <b><tt>N</tt></b>. Thus when calling <b><tt>N(expr)</tt></b>, <b><tt>InNumericMode()</tt></b> will
return <b><tt>True</tt></b> while <b><tt>expr</tt></b> is being evaluated.


<p>
<b><tt>InNumericMode()</tt></b> would typically be used to define a transformation rule 
that defines how to get a numeric approximation of some expression. One
could define a transformation rule


<p>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
f(_x)_InNumericMode() &lt;- [... some code to get a numeric approximation of f(x) ... ];
</pre></tr>
</table>


<p>
<b><tt>InNumericMode()</tt></b> usually returns <b><tt>False</tt></b>, so transformation rules that check for this
predicate are usually left alone.


<p>
When in numeric mode, <b><tt>NonN</tt></b> can be called to switch back to non-numeric
mode temporarily.


<p>
<b><tt>NonN</tt></b> is a macro. Its argument <b><tt>expr</tt></b> will only 
be evaluated after the numeric mode has been set appropriately.


<p>

<h5>
Examples:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; InNumericMode()
Out&gt; False
In&gt; N(InNumericMode())
Out&gt; True
In&gt; N(NonN(InNumericMode()))
Out&gt; False
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?N" target="Chapters">
N
</a>
, <a href="ref.html?BuiltinPrecisionSet" target="Chapters">
BuiltinPrecisionSet
</a>
, <a href="ref.html?BuiltinPrecisionGet" target="Chapters">
BuiltinPrecisionGet
</a>
, <a href="ref.html?Pi" target="Chapters">
Pi
</a>
, <a href="ref.html?CachedConstant" target="Chapters">
CachedConstant
</a>
.<a name="IntLog">

</a>
<a name="intlog">

</a>
<h3>
<hr>IntLog -- integer part of logarithm
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
IntLog(n, base)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>n</tt></b>, <b><tt>base</tt></b> -- positive integers


<p>

<h5>
Description:
</h5>
<b><tt>IntLog</tt></b> calculates the integer part of the logarithm of <b><tt>n</tt></b> in base <b><tt>base</tt></b>. The algorithm uses only integer math and may be faster than computing 
<p><center><b> Ln(n)/Ln(base) </b></center></p>
 with multiple precision floating-point math and rounding off to get the integer part.


<p>
This function can also be used to quickly count the digits in a given number.


<p>

<h5>
Examples:
</h5>
Count the number of bits:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntLog(257^8, 2)
Out&gt; 64;
</pre></tr>
</table>


<p>
Count the number of decimal digits:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntLog(321^321, 10)
Out&gt; 804;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?IntNthRoot" target="Chapters">
IntNthRoot
</a>
, <a href="ref.html?Div" target="Chapters">
Div
</a>
, <a href="ref.html?Mod" target="Chapters">
Mod
</a>
, <a href="ref.html?Ln" target="Chapters">
Ln
</a>
.<a name="IntNthRoot">

</a>
<a name="intnthroot">

</a>
<h3>
<hr>IntNthRoot -- integer part of <b>n</b>-th root
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
IntNthRoot(x, n)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>x</tt></b>, <b><tt>n</tt></b> -- positive integers


<p>

<h5>
Description:
</h5>
<b><tt>IntNthRoot</tt></b> calculates the integer part of the <b> n</b>-th root of <b> x</b>. The algorithm uses only integer math and may be faster than computing <b> x^(1/n)</b> with floating-point and rounding.


<p>
This function is used to test numbers for prime powers.


<p>

<h5>
Example:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; IntNthRoot(65537^111, 37)
Out&gt; 281487861809153;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?IntLog" target="Chapters">
IntLog
</a>
, <a href="ref.html?PowerN" target="Chapters">
PowerN
</a>
, <a href="ref.html?IsPrimePower" target="Chapters">
IsPrimePower
</a>
.<a name="NthRoot">

</a>
<a name="nthroot">

</a>
<h3>
<hr>NthRoot -- calculate/simplify nth root of an integer
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
NthRoot(m,n)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>m</tt></b> -- a non-negative integer (<b>m&gt;0</b>)


<p>
<b><tt>n</tt></b> -- a positive integer greater than 1 (<b> n&gt;1</b>)


<p>

<h5>
Description:
</h5>
<b><tt>NthRoot(m,n)</tt></b> calculates the integer part of the <b> n</b>-th root <b> m^(1/n)</b> and
returns a list <b><tt>{f,r}</tt></b>. <b><tt>f</tt></b> and <b><tt>r</tt></b> are both positive integers
that satisfy <b>f^n*r</b>=<b> m</b>.
In other words, <b> f</b> is the largest integer such that <b> m</b> divides <b> f^n</b> and <b> r</b> is the remaining factor.


<p>
For large <b><tt>m</tt></b> and small <b><tt>n</tt></b>
<b><tt>NthRoot</tt></b> may work quite slowly. Every result <b><tt>{f,r}</tt></b> for given
<b><tt>m</tt></b>, <b><tt>n</tt></b> is saved in a lookup table, thus subsequent calls to
<b><tt>NthRoot</tt></b> with the same values <b><tt>m</tt></b>, <b><tt>n</tt></b> will be executed quite
fast.


<p>

<h5>
Example:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; NthRoot(12,2)
Out&gt; {2,3};
In&gt; NthRoot(81,3)
Out&gt; {3,3};
In&gt; NthRoot(3255552,2)
Out&gt; {144,157};
In&gt; NthRoot(3255552,3)
Out&gt; {12,1884};
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?IntNthRoot" target="Chapters">
IntNthRoot
</a>
, <a href="ref.html?Factors" target="Chapters">
Factors
</a>
, <a href="ref.html?PowerN" target="Chapters">
PowerN
</a>
.<a name="ContFracList">

</a>
<a name="contfraclist">

</a>
<h3>
<hr>ContFracList -- manipulate continued fractions
</h3>
<a name="ContFracEval">

</a>
<a name="contfraceval">

</a>
<h3>
<hr>ContFracEval -- manipulate continued fractions
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
ContFracList(frac)
ContFracList(frac, depth)
ContFracEval(list)
ContFracEval(list, rest)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>frac</tt></b> -- a number to be expanded


<p>
<b><tt>depth</tt></b> -- desired number of terms


<p>
<b><tt>list</tt></b> -- a list of coefficients


<p>
<b><tt>rest</tt></b> -- expression to put at the end of the continued fraction


<p>

<h5>
Description:
</h5>
The function <b><tt>ContFracList</tt></b> computes terms of the continued fraction
representation of a rational number <b><tt>frac</tt></b>.  It returns a list of terms of length <b><tt>depth</tt></b>. If <b><tt>depth</tt></b> is not specified, it returns all terms.


<p>
The function <b><tt>ContFracEval</tt></b> converts a list of coefficients into a continued fraction expression. The optional parameter <b><tt>rest</tt></b> specifies the symbol to put at the end of the expansion. If it is not given, the result is the same as if <b><tt>rest=0</tt></b>.


<p>

<h5>
Examples:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; A:=ContFracList(33/7 + 0.000001)
Out&gt; {4,1,2,1,1,20409,2,1,13,2,1,4,1,1,3,3,2};
In&gt; ContFracEval(Take(A, 5))
Out&gt; 33/7;
In&gt; ContFracEval(Take(A,3), remainder)
Out&gt; 1/(1/(remainder+2)+1)+4;

</pre></tr>
</table>

<h5>
See also:
</h5>
<a href="ref.html?ContFrac" target="Chapters">
ContFrac
</a>
, <a href="ref.html?GuessRational" target="Chapters">
GuessRational
</a>
.<a name="GuessRational">

</a>
<a name="guessrational">

</a>
<h3>
<hr>GuessRational -- find optimal rational approximations
</h3>
<a name="NearRational">

</a>
<a name="nearrational">

</a>
<h3>
<hr>NearRational -- find optimal rational approximations
</h3>
<a name="BracketRational">

</a>
<a name="bracketrational">

</a>
<h3>
<hr>BracketRational -- find optimal rational approximations
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
GuessRational(x)
GuessRational(x, digits)
NearRational(x)
NearRational(x, digits)
BracketRational(x, eps)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>x</tt></b> -- a number to be approximated (must be already evaluated to floating-point)


<p>
<b><tt>digits</tt></b> -- desired number of decimal digits (integer)


<p>
<b><tt>eps</tt></b> -- desired precision


<p>

<h5>
Description:
</h5>
The functions <b><tt>GuessRational(x)</tt></b> and <b><tt>NearRational(x)</tt></b> attempt to find "optimal"
rational approximations to a given value <b><tt>x</tt></b>. The approximations are "optimal"
in the sense of having smallest numerators and denominators among all rational
numbers close to <b><tt>x</tt></b>. This is done by computing a continued fraction
representation of <b><tt>x</tt></b> and truncating it at a suitably chosen term.  Both
functions return a rational number which is an approximation of <b><tt>x</tt></b>.


<p>
Unlike the function <b><tt>Rationalize()</tt></b> which converts floating-point numbers to
rationals without loss of precision, the functions <b><tt>GuessRational()</tt></b> and
<b><tt>NearRational()</tt></b> are intended to find the best rational that is <i>approximately</i>
equal to a given value.


<p>
The function <b><tt>GuessRational()</tt></b> is useful if you have obtained a
floating-point representation of a rational number and you know
approximately how many digits its exact representation should contain.
This function takes an optional second parameter <b><tt>digits</tt></b> which limits
the number of decimal digits in the denominator of the resulting
rational number. If this parameter is not given, it defaults to half
the current precision. This function truncates the continuous fraction
expansion when it encounters an unusually large value (see example).
This procedure does not always give the "correct" rational number; a
rule of thumb is that the floating-point number should have at least as
many digits as the combined number of digits in the numerator and the
denominator of the correct rational number.


<p>
The function <b><tt>NearRational(x)</tt></b> is useful if one needs to
approximate a given value, i.e. to find an "optimal" rational number
that lies in a certain small interval around a certain value <b><tt>x</tt></b>. This
function takes an optional second parameter <b><tt>digits</tt></b> which has slightly
different meaning: it specifies the number of digits of precision of
the approximation; in other words, the difference between <b><tt>x</tt></b> and the
resulting rational number should be at most one digit of that
precision. The parameter <b><tt>digits</tt></b> also defaults to half of the current
precision.


<p>
The function <b><tt>BracketRational(x,eps)</tt></b> can be used to find approximations with a given relative precision from above and from below.
This function returns a list of two rational numbers <b><tt>{r1,r2}</tt></b> such that <b> r1&lt;x&lt;r2</b> and <b> Abs(r2-r1)&lt;Abs(x*eps)</b>.
The argument <b><tt>x</tt></b> must be already evaluated to enough precision so that this approximation can be meaningfully found.
If the approximation with the desired precision cannot be found, the function returns an empty list.


<p>

<h5>
Examples:
</h5>
Start with a rational number and obtain a floating-point approximation:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; x:=N(956/1013)
Out&gt; 0.9437314906
In&gt; Rationalize(x)
Out&gt; 4718657453/5000000000;
In&gt; V(GuessRational(x))

GuessRational: using 10 terms of the
  continued fraction
Out&gt; 956/1013;
In&gt; ContFracList(x)
Out&gt; {0,1,16,1,3,2,1,1,1,1,508848,3,1,2,1,2,2};
</pre></tr>
</table>
The first 10 terms of this continued fraction correspond to the correct continued fraction for the original rational number.
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; NearRational(x)
Out&gt; 218/231;
</pre></tr>
</table>
This function found a different rational number closeby because the precision was not high enough.
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; NearRational(x, 10)
Out&gt; 956/1013;
</pre></tr>
</table>
Find an approximation to <b>Ln(10)</b> good to 8 digits:
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BracketRational(N(Ln(10)), 10^(-8))
Out&gt; {12381/5377,41062/17833};
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?ContFrac" target="Chapters">
ContFrac
</a>
, <a href="ref.html?ContFracList" target="Chapters">
ContFracList
</a>
, <a href="ref.html?Rationalize" target="Chapters">
Rationalize
</a>
.<a name="TruncRadian">

</a>
<a name="truncradian">

</a>
<h3>
<hr>TruncRadian -- remainder modulo <b>2*Pi</b>
</h3>
<h5 align=right>Standard library</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
TruncRadian(r)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>r</tt></b> -- a number


<p>

<h5>
Description:
</h5>
<b><tt>TruncRadian</tt></b> calculates <b> Mod(r,2*Pi)</b>, returning a value between <b>0</b>
and <b> 2*Pi</b>. This function is used in the trigonometry functions, just
before doing a numerical calculation using a Taylor series. It greatly
speeds up the calculation if the value passed is a large number.


<p>
The library uses the formula

<p><center><b> TruncRadian(r)=r-Floor(r/(2*Pi))*2*Pi,</b></center></p>

where <b> r</b> and <b> 2*Pi</b> are calculated with twice the precision used in the
environment to make sure there is no rounding error in the significant
digits.


<p>

<h5>
Examples:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; 2*Internal'Pi()
Out&gt; 6.283185307;
In&gt; TruncRadian(6.28)
Out&gt; 6.28;
In&gt; TruncRadian(6.29)
Out&gt; 0.0068146929;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?Sin" target="Chapters">
Sin
</a>
, <a href="ref.html?Cos" target="Chapters">
Cos
</a>
, <a href="ref.html?Tan" target="Chapters">
Tan
</a>
.<a name="BuiltinPrecisionSet">

</a>
<a name="builtin'precision'set">

</a>
<h3>
<hr>BuiltinPrecisionSet -- set the precision
</h3>
<h5 align=right>Internal function</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
BuiltinPrecisionSet(n)
</pre></tr>
</table>


<p>

<h5>
Parameters:
</h5>
<b><tt>n</tt></b> -- integer, new value of precision


<p>

<h5>
Description:
</h5>
This command sets the number of decimal digits to be used in calculations.
All subsequent floating point operations will allow for
at least <b><tt>n</tt></b> digits of mantissa.


<p>
This is not the number of digits after the decimal point.
For example, <b><tt>123.456</tt></b> has 3 digits after the decimal point and 6 digits of mantissa.
The number <b><tt>123.456</tt></b> is adequately computed by specifying <b><tt>BuiltinPrecisionSet(6)</tt></b>.


<p>
The call <b><tt>BuiltinPrecisionSet(n)</tt></b> will not guarantee that all results are precise to <b><tt>n</tt></b> digits.


<p>
When the precision is changed, all variables containing previously calculated values
remain unchanged.
The <b><tt>BuiltinPrecisionSet</tt></b> function only makes all further calculations proceed with a different precision.


<p>
Also, when typing floating-point numbers, the current value of <b><tt>BuiltinPrecisionSet</tt></b> is used to implicitly determine the number of precise digits in the number.


<p>

<h5>
Examples:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BuiltinPrecisionSet(10)
Out&gt; True;
In&gt; N(Sin(1))
Out&gt; 0.8414709848;
In&gt; BuiltinPrecisionSet(20)
Out&gt; True;
In&gt; x:=N(Sin(1))
Out&gt; 0.84147098480789650665;
</pre></tr>
</table>


<p>
The value <b><tt>x</tt></b> is not changed by a <b><tt>BuiltinPrecisionSet()</tt></b> call:


<p>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; [ BuiltinPrecisionSet(10); x; ]
Out&gt; 0.84147098480789650665;
</pre></tr>
</table>


<p>
The value <b><tt>x</tt></b> is rounded off to 10 digits after an arithmetic operation:


<p>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; x+0.
Out&gt; 0.8414709848;
</pre></tr>
</table>


<p>
In the above operation, <b><tt>0.</tt></b> was interpreted as a number which is precise to 10 digits (the user does not need to type <b><tt>0.0000000000</tt></b> for this to happen).
So the result of <b><tt>x+0.</tt></b> is precise only to 10 digits.


<p>

<h5>
See also:
</h5>
<a href="ref.html?BuiltinPrecisionGet" target="Chapters">
BuiltinPrecisionGet
</a>
, <a href="ref.html?N" target="Chapters">
N
</a>
.<a name="BuiltinPrecisionGet">

</a>
<a name="builtin'precision'get">

</a>
<h3>
<hr>BuiltinPrecisionGet -- get the current precision
</h3>
<h5 align=right>Internal function</h5><h5>
Calling format:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
BuiltinPrecisionGet()
</pre></tr>
</table>


<p>

<h5>
Description:
</h5>
This command returns the current precision, as set by <b><tt>BuiltinPrecisionSet</tt></b>.


<p>

<h5>
Examples:
</h5>
<table cellpadding="0" width="100%">
<tr><td width=100% bgcolor="#DDDDEE"><pre>
In&gt; BuiltinPrecisionGet();
Out&gt; 10;
In&gt; BuiltinPrecisionSet(20);
Out&gt; True;
In&gt; BuiltinPrecisionGet();
Out&gt; 20;
</pre></tr>
</table>


<p>

<h5>
See also:
</h5>
<a href="ref.html?BuiltinPrecisionSet" target="Chapters">
BuiltinPrecisionSet
</a>
, <a href="ref.html?N" target="Chapters">
N
</a>
.
<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
</script>
<script type="text/javascript">
_uacct = "UA-2425144-1";
urchinTracker();
</script>
</body>

</html>
