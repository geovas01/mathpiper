//Run the yacas script that is in the current buffer.

import org.mathrider.jyacasplugin.JYacasInterpreter;
import java.io.File;
import java.io.BufferedWriter;
import org.gjt.sp.jedit.textarea.Selection.Range;
import org.gjt.sp.jedit.textarea.Selection;
import errorlist.*;


//Note: This code needs to be moved to a Java object.
//errorSource = new DefaultErrorSource("MathRider");
//ErrorSource.registerErrorSource(errorSource);


buffer.save(view,null);

path = buffer.getPath();


if(path.endsWith(".ys")){
	
	//Remove Windows drive letter from the path.
	if(path.indexOf(":") != -1){
		path = path.split(":")[1];
		
		//Chance window's backslashes to forward slashes.
		path = path.replace("\\","/");
		//System.out.println(path);
	}
		
	runCommandInConsole(view,"JYacas","Load(\""+path+"\");");
	//interpreter=JYacasInterpreter.getInstance();
	

	//result = interpreter.evaluate("Load(\""+path+"\");");
	
	//System.out.println(result);
}else if (path.endsWith(".mrn")){
	currentCaretPosition = textArea.getCaretPosition();
	textArea.selectFold();
	fold  = textArea.getSelection()[0];
	foldStartIndex = fold.getStart();
	foldEndIndex = fold.getEnd();
	foldStartLine = fold.getStartLine();
	foldEndLine = fold.getEndLine();
	foldStartLineText = textArea.getLineText(foldStartLine);
	codeStartLine = foldStartLine+1;
	codeEndLine = foldEndLine-1;
	codeStartIndex = fold.getStart(textArea.getBuffer(),codeStartLine);
	codeEndIndex = fold.getEnd(textArea.getBuffer(),codeEndLine);
	codeSelection = new Range(codeStartIndex, codeEndIndex);
	textArea.setSelection(codeSelection);
	



	
	allFoldText = textArea.getSelectedText().replaceAll("\\s+$", "");
	//replaceAll("^\\s+", "");Remove whitespace at end of string.
	//replaceAll("\\s+$", "");Remove whitespace at beginning of string.
  //System.out.println("YYYY allFoldText: " + allFoldText); 
	
	textArea.setSelection(null);  
	
	
		//{{{ Fold type.
	//	defaultFoldType = "%yacas";
		

			foldStartSelection = new Range(foldStartIndex, foldStartIndex + foldStartLineText.length());
			
			//Obtain fold type.
			typeText = foldStartLineText.substring(foldStartLineText.indexOf("%"));
			foldTypePropertyStrings = typeText.split(",");
			
			foldType = foldTypePropertyStrings[0];
			foldType = foldType.trim();
			
			foldProperties = new java.util.Hashtable();
			foldProperties.put("mode","");
			foldProperties.put("collapse","false");
			foldProperties.put("clear","false");
			if(foldTypePropertyStrings.length != 1)
			{
				for(x = 1; x < foldTypePropertyStrings.length; x++)
				{
					property = foldTypePropertyStrings[x].split("=");
					key = property[0].trim();
					value = property[1].trim().replaceAll("\"","");
					foldProperties.put(key,value);
				}//end for.
			}//end if.
			//}}}

	
	
/*	endDollarSignIndex = -1;
	if(foldType.equalsIgnoreCase("%hoteqn"))
	{
		startDollarSignIndex = allFoldText.indexOf("$");
		if(startDollarSignIndex != -1)
		{
			endDollarSignIndex = allFoldText.indexOf("$", startDollarSignIndex+1);
		}//end if.

	}//end if.
	*/		
	foldSections = allFoldText.split("%yacas|%output|%geogebra|%beanshell|%hoteqn|%error");
	codeText = foldSections[0];
	codeText = codeText.replaceAll("\\s+$", "");
/*	
	//Do not include subfold as code.
	if(endDollarSignIndex != -1)
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b", endDollarSignIndex+1);
	}
	else
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b");
	}//end else.
	
	if(subFoldIndex != -1)
	{
		codeText = allFoldText.substring(0,subFoldIndex).replaceAll("\\s+$", "");
	}
	else
	{
		codeText = allFoldText;
	}
*/	
//   System.out.println("YYYY: codeText " + codeText);

//	noCrLf = text.replace("\n","").replace("\r","");
	isolatedCodeLength = codeText.length();
	isolatedCodeEndIndex = codeStartIndex + isolatedCodeLength;
	
	textArea.setCaretPosition(isolatedCodeEndIndex);

	
	try {
        // Create temp file.
        File tempFile = File.createTempFile("mathrider", ".mrn_tmp");
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
        // Write to temp file
        BufferedWriter out = new BufferedWriter(new FileWriter(tempFile));
        out.write(codeText);
        out.close();
		                                                                                        


		

		result = "";
		status = "";
		collapseFold = foldProperties.get("collapse");
		
		///{{{ *** %yacas ***.
		if(foldType.equalsIgnoreCase("%yacas"))    
		{
			//JYacas section.
			
			interpreter = JYacasInterpreter.getInstance();
			

			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				
				//Remove Windows drive letter from the path.
				if(tempFilePath.indexOf(":") != -1){
					tempFilePath = tempFilePath.split(":")[1];
			
					//Change window's backslashes to forward slashes.
					tempFilePath = tempFilePath.replace("\\","/");
				}//end if
			
				//System.out.println(tempFilePath);
        	
				result = interpreter.evaluate("Load(\""+tempFilePath+"\");");
				if(result.indexOf("$") != -1)
				{
					result = result.replace("\"$","$");
					result = result.replace("$\"","$");
					status = "%hoteqn";
				}
				else
				{
					status = "%geogebra";
				}
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(net.sf.yacas.Yacasexception ye) 
			{
				result = ye.getMessage();
				status = "%error ";
			}
			
			
			if(result != null )
			{
				
				if(result.startsWith("True:"))
				{
					result = result.substring(5,result.length());//Remove True: which is returned by Load.
				}
				else if (result.startsWith("True"))
				{
					result = result.substring(4,result.length());//Remove True which is returned by Load.
				}
			}//end if.}}}
					
		}//end if }}}
	///{{{ *** %beanshell ***
		else if(foldType.equalsIgnoreCase("%beanshell"))
		{
			import bsh.Interpreter;
			interpreter = new Interpreter();
			interpreter.eval("import geogebra.GeoGebraApplet;");
			ggb = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			interpreter.set("ggb",ggb);
			interpreter.set("jEdit",jEdit);
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();

				//System.out.println(tempFilePath);

				interpreter.source(tempFilePath);
				result = "";
	//System.out.println("tempFilePath: " + tempFilePath);
				status = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(Exception e) 
			{
				result = e.getMessage();
				status = "%error ";
			}
		}//end else
		// end %beanshell }}}
	
	///{{{ *** %geogebra ***
		else if(foldType.equalsIgnoreCase("%geogebra")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "geogebra" );
			
			errorSource = JYacasInterpreter.getErrorSource();
			
			import geogebra.GeoGebraApplet;
			geogebra = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				//Clear geogebra.
				geogebra.setXML("<?xml version=\"1.0\" encoding=\"utf-8\"?> <geogebra format=\"2.5\"> </geogebra>");
				
			}//end if.
			
			
			
			
			result = "GeoGebra updated.";
			status = "%output";
			if(foldProperties.get("mode").equalsIgnoreCase("xml") )
			{
				geogebra.setXML(codeText);
			}
			else
			{
				lines = codeText.split("\n");
				
				lineCount = lines.length;
				lineIndex = 0;
            	
				
				for(lineIndex = 0; lineIndex < lineCount; lineIndex++)
				{
					//System.out.println("YYYYY" + lines[lineIndex]);
					
					if(lines[lineIndex].trim().length() != 0 && ! lines[lineIndex].trim().startsWith("//"))
					{
					    endOfLineCommentIndex = lines[lineIndex].indexOf("//");
						if(endOfLineCommentIndex != -1)
						{
							currentLine = lines[lineIndex].split("//")[0];
						}
						else
						{
							currentLine = lines[lineIndex].trim();
						}//end if.
						
						returnFlag = geogebra.evalCommand(currentLine);
						
						if(returnFlag == false)
						{
							errorLine = foldStartLine + lineIndex+2;
							result = "Error on line " + errorLine + ".";
							status = "%error";
							
							filePath = textArea.getBuffer().getPath();
				    	
							errorSource.clear();
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, currentLine ) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
							
							break;      
						}//end if.
					}//end if.
				}//end for.

			}//end else
			
			
		}//end else
		//end %geogebra }}}

				                                                                                
	///{{{ *** %hoteqn ***
		else if(foldType.equalsIgnoreCase("%hoteqn")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "hoteqn" );
			
			errorSource = JYacasInterpreter.getErrorSource();
			
			//import geogebra.GeoGebraApplet;
			hotEqn = org.mathrider.hoteqnplugin.HotEqn.getHotEqn();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				hotEqn.setEquation("");
			}//end if.
			
			
			//lines = codeText.split("\n");
			

			
			//lineCount = lines.length;
			//lineIndex = 0;

			hotEqn.setEquation(codeText);
			result = "HotEqn updated.";
			status = "%output";
			
					/*
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						status = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
					*/

		}//end else
		//end %hoteqn }}}

				
				//Determine how many lines are in the result.
				numberOfLines = 0;
				charIndex = 0;
				while(charIndex != result.length()){
					if(result.charAt(charIndex) == "\n"){
						numberOfLines++;
					}
					charIndex++;
				}//end while
				
				
				//Make room at the end of the current fold for output and place output there.
				//currentCaretPosition = textArea.getCaretPosition();
        	
        	
				rangeSelection = new Range(isolatedCodeEndIndex, codeEndIndex);
				
				textArea.setSelection(rangeSelection);
				
				result = result.trim();
				
			
				void displayResult()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						
						result = result.replaceAll("\n","\n      ");
						textArea.setSelectedText("\n\n     " + status + "\n      "+ result + "\n     %end\n",false);
				 
						/*//If fold type was blank, set it to the default fold type.
						if(foldStartSelection != null)
						{
							textArea.setSelection(foldStartSelection);
							line = textArea.getSelectedText();
							line = line.replaceFirst("\\{\\{\\{", "\u007b\u007b\u007b" + defaultFoldType);
							textArea.setSelectedText(line);
							textArea.setSelection(null);
						}//end if
						  */
						
						textArea.setCaretPosition(currentCaretPosition);
						
						if(collapseFold.equalsIgnoreCase("true"))
						{
							textArea.collapseFold();
						}//end if.
						
						buffer.save(view,null);
					}
					VFSManager.runInAWTThread(this);
				
				}//end method.
				
				displayResult();
							
        	
			
				

    } 
	catch (IOException e) 
	{
		e.printStackTrace();
    }
	

	

}//end else if.
	


// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=1:
