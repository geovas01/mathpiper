// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=0:
//Copyright (C) 2008 Ted Kosan
/* {{{ License.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */ //}}}


import org.mathrider.piperplugin.PiperInterpreter;
import org.mathrider.pipermeplugin.PiperMEInterpreter;
import org.mathrider.maximaplugin.MaximaWrapper;
import java.io.File;
import java.io.BufferedWriter;
import org.gjt.sp.jedit.textarea.Selection.Range;
import org.gjt.sp.jedit.textarea.Selection;
import errorlist.*;
import org.gjt.sp.jedit.bsh.EvalError;


ChangeToForwardSlash(tempFilePath)
{
// 	//Remove Windows drive letter from the path.
// 	if(tempFilePath.indexOf(":") != -1)
// 	{
// 		tempFilePath = tempFilePath.split(":")[1];
// 			
// 		//Change window's backslashes to forward slashes.
// 		tempFilePath = tempFilePath.replace("\\","/");
// 	}//end if
//

//Change window's backslashes to forward slashes.
 	tempFilePath = tempFilePath.replace("\\","/");

	return tempFilePath;
}//end method.

//Note: This code needs to be moved to a Java object.
//errorSource = new DefaultErrorSource("MathRider");
//ErrorSource.registerErrorSource(errorSource);

errorSource = PiperInterpreter.getErrorSource(); //Note: obtaining error source from central location.
errorSource.clear();
					
buffer.save(view,null);

path = buffer.getPath();


if(path.endsWith(".pi")){
	
	buffer.setMode("piper");
	
	//Remove Windows drive letter from the path.
	if(path.indexOf(":") != -1){
		path = path.split(":")[1];
		
		//Chance window's backslashes to forward slashes.
		path = path.replace("\\","/");
		//System.out.println(path);
	}
		
	runCommandInConsole(view,"Piper","Load(\""+path+"\");");
	//interpreter=PiperInterpreter.getInstance();
	

	//result = interpreter.evaluate("Load(\""+path+"\");");
	
	//System.out.println(result);
}
else if (path.endsWith(".uasm"))
{
	buffer.setMode("uasm65");
	
	if ( asm == void )
	{
		asm = new org.mathrider.u6502.UASM65();
	}
	
	asm.assemble(new File(path));
	
	org.gjt.sp.jedit.Macros.message(jEdit.getActiveView(),"A .lst and a .s19 file have been successfully created\n in the same directory as the source .uasm file.");
	
}
else if (path.endsWith(".mrw"))
{
	//buffer.setMode("mathrider");
	currentCaretPosition = textArea.getCaretPosition();
	textArea.selectFold();
	fold  = textArea.getSelection()[0];
	foldStartIndex = fold.getStart();
	foldEndIndex = fold.getEnd();
	foldStartLine = fold.getStartLine();
	foldEndLine = fold.getEndLine();
	foldStartLineText = textArea.getLineText(foldStartLine);
	codeStartLine = foldStartLine+1;
	codeEndLine = foldEndLine-1;
	codeStartIndex = fold.getStart(textArea.getBuffer(),codeStartLine);
	codeEndIndex = fold.getEnd(textArea.getBuffer(),codeEndLine);
	codeSelection = new Range(codeStartIndex, codeEndIndex);

	textArea.setSelection(codeSelection);
	



	//Remove the whitespace at the end of the selected fold text.
	allFoldText = textArea.getSelectedText().replaceAll("\\s+$", "");
	//replaceAll("^\\s+", "");Remove whitespace at end of string.
	//replaceAll("\\s+$", "");Remove whitespace at beginning of string.
  //System.out.println("YYYY allFoldText: " + allFoldText); 

	textArea.setSelection(null);
	
	
		//{{{ Fold information.
	//	defaultFoldType = "%piper";
		

			foldStartSelection = new Range(foldStartIndex, foldStartIndex + foldStartLineText.length());
			
			
			//Determine the indent character and how much the fold is indented by.  Then, create a string
			//that indents one more level for the output fold.
			indentCharType = foldStartLineText.charAt(0);
			indentAmount = new StringBuffer();
			if(indentCharType == 9 || indentCharType == 32)
			{
				
				for(indentCount = 0; foldStartLineText.charAt(indentCount) == indentCharType; indentCount++)
				{
					indentAmount.append(indentCharType);
				}//end for.
				
				
				if(indentCharType == 9)
				{indentAmount.append("\t");
				}
				else
				{
					indentAmount.append("    ");
				}//end if/else/
			}//end if.
			else
			{
				indentAmount.append("    ");
			}//end else.
				
			
			
			getFoldProperties(startLine)
			{
			
			foldStartLineText = textArea.getLineText(startLine);
			//Obtain fold type.
			typeText = foldStartLineText.substring(foldStartLineText.indexOf("%"));
			
			//Remove // commenf from line if present.
			if((commentIndex = typeText.indexOf("//")) != -1)
			{
				//System.out.println("XXXXXXX " + typeText);
				typeText = typeText.substring(0,commentIndex);
				
			}//end if.
			
			foldTypePropertyStrings = typeText.split(",");
			
			foldType = foldTypePropertyStrings[0];
			foldType = foldType.trim();
			
			properties = new java.util.Hashtable();
			properties.put("type",foldType);
			properties.put("preserve","true");
			//properties.put("input","");
			properties.put("width","400");
			properties.put("height","400");
			properties.put("name","");
			properties.put("output","output");
			properties.put("collapse","false");
			properties.put("clear","false");
			properties.put("description","");
			properties.put("pipe_to","");
			properties.put("scope","local");
			properties.put("ver","");
			if(foldTypePropertyStrings.length != 1)
			{
				for(x = 1; x < foldTypePropertyStrings.length; x++)
				{
					property = foldTypePropertyStrings[x].split("=");
					key = property[0].trim();
					value = property[1].trim().replaceAll("\"","");
					properties.put(key,value);
				}//end for.
			}//end if.
			
			return properties;
			}//end function.
			//}}}

			foldProperties = getFoldProperties(foldStartLine);
			foldType = foldProperties.get("type");
			
	
/*	endDollarSignIndex = -1;
	if(foldType.equalsIgnoreCase("%hoteqn"))
	{
		startDollarSignIndex = allFoldText.indexOf("$");
		if(startDollarSignIndex != -1)
		{
			endDollarSignIndex = allFoldText.indexOf("$", startDollarSignIndex+1);
		}//end if.

	}//end if.
	*/	

	/* Used when output folds were inside of the parent fold.
	foldSections = allFoldText.split("%piper|%maxima|%lisp|%output|%geogebra|%beanshell|%hoteqn|%error|%html|%group");
	codeText = foldSections[0];
	codeText = codeText.replaceAll("\\s+$", "");//Note:tk:verify that this is needed.
	*/
	
	if(foldProperties.get("type").equalsIgnoreCase("%html"))
	{
		codeText = allFoldText.trim();
	}
	else
	{
		codeText = allFoldText;
	}//end if/else
	
	
	
/*	
	//Do not include subfold as code.
	if(endDollarSignIndex != -1)
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b", endDollarSignIndex+1);
	}
	else
	{
		subFoldIndex = allFoldText.indexOf("\u007b\u007b\u007b");
	}//end else.
	
	if(subFoldIndex != -1)
	{
		codeText = allFoldText.substring(0,subFoldIndex).replaceAll("\\s+$", "");
	}
	else
	{
		codeText = allFoldText;
	}
*/	
   //System.out.println("YYYY: codeText " + codeText);

//	noCrLf = text.replace("\n","").replace("\r","");
	isolatedCodeLength = codeText.length();
	isolatedCodeEndIndex = codeStartIndex + isolatedCodeLength;
	
	textArea.setCaretPosition(isolatedCodeEndIndex);

	
	try {
        // Create temp file.
		
		if(foldType.equalsIgnoreCase("%maxima"))
		{
			fileExtension = ".mac";
		}
		else if(foldType.equalsIgnoreCase("%lisp"))
		{
			fileExtension = ".lisp";
		}
		else
		{
			fileExtension = ".mrw_tmp";
		}//end if/else.
		
        File tempFile = File.createTempFile("mathrider", fileExtension);
    
        // Delete temp file when program exits.
        tempFile.deleteOnExit();
    
        // Write to temp file
        BufferedWriter out = new BufferedWriter(new FileWriter(tempFile));
        out.write(codeText);
        out.close();
		                                                                                        


		

		result = "";
		output_fold_type = "";
		collapseFold = foldProperties.get("collapse");
		
		///{{{ *** %piper ***.
		if(foldType.equalsIgnoreCase("%piper"))    
		{
			//Piper section.
			
			if( foldProperties.get("ver").equalsIgnoreCase("me"))
			{
				system = PiperMEInterpreter.getInstance();
			}
			else
			{
				system = PiperInterpreter.getInstance();
			}
			
			

			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				
				tempFilePath = ChangeToForwardSlash(tempFilePath);
			
				//System.out.println(tempFilePath);
        	
				result = system.evaluate("Load(\""+tempFilePath+"\");");
				
				if(result != null )
				{
				
					if(result.startsWith("True:"))
					{
						result = result.substring(5,result.length());//Remove True: which is returned by Load.
					}
					else if (result.startsWith("True"))
					{
						result = result.substring(4,result.length());//Remove True which is returned by Load.
					}
				}//end if.
				
				//Note: Since Load returns "True", it kills what was in %.
				//lastResult = system.evaluate("%");
				//System.out.println(" XXXXX: " + lastResult);
				
				if(foldProperties.get("output").equalsIgnoreCase("latex") )
				{
					result = system.evaluate("TeXForm(Hold(" + result + "));");
					result = result.replace("\"$","");
					result = result.replace("$\"","");
					output_fold_type = "%hoteqn";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("openmath") )
				{	
					result = system.evaluate("OMForm(" + result + ");");
					output_fold_type = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("pretty") )
				{	
					result = system.evaluate("PrettyForm(Hold(" + result + "));");
					output_fold_type = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("c") )
				{	
					result = system.evaluate("CForm(" + result + ");");
					output_fold_type = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("lisp") )
				{	
					result = system.evaluate("FullForm(" + result + ");");
					output_fold_type = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("table") )
				{	
					result = system.evaluate("TableForm(" + result + ");");
					output_fold_type = "%output";
				}
				else if(foldProperties.get("output").equalsIgnoreCase("geogebra") )
				{
					output_fold_type = "%geogebra";
				}
				else
				{
					output_fold_type = "%output";
				}
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(org.mathrider.piper.Piperexception ye) 
			{
				result = ye.getMessage();
				output_fold_type = "%error ";
			}
			
			

					
		}//end if }}}



		///{{{ *** %maxima ***.
		else if(foldType.equalsIgnoreCase("%maxima"))    
		{
			//Maxima section.			
			

			try 
			{   
				//tempFilePath = tempFile.getAbsolutePath();
				
				//tempFilePath = ChangeToForwardSlash(tempFilePath);
			
				
				//Determine how many lines are in the result.
				//numberOfLines = 0;
				//charIndex = 0;
				//while(charIndex != result.length()){
				//	if(result.charAt(charIndex) == "\n"){
				//		numberOfLines++;
				//	}
				//	charIndex++;
				//}//end while
				
				
				//Make room at the end of the current fold for output and place output there.
				//currentCaretPosition = textArea.getCaretPosition();
        	
							
				foldName = foldProperties.get("name");
				
				
			//{{{
			org.mathrider.ResponseListener responseListener = new org.mathrider.ResponseListener() {
				response(response)
				{
					System.out.println("WWWW " + response + ", " + foldName);
				}//end method.
				
				remove()
				{
					return true;
				}//end method.
				
			};//end interface implementation.
			//}}}
				system = MaximaWrapper.getInstance();
				system.addResponseListener(responseListener);
				//System.out.println(tempFilePath);
				tempFileName = tempFile.getName();
				sendString = "load(\""+tempFileName+"\");\n";
				system.send(sendString);//sendString
				
				//this.console.setShell("Maxima");o = console.getOutput();o.writeAttrs(null, "\n");
				//runCommandInConsole(view,"Maxima","Load(\""+path+"\");");
				//runCommandInConsole(view,"Maxima",codeText + "\n");
				
				output_fold_type = "%output,name=\"" + foldName + "\"";
				//System.out.println(
				
				
				//Note: Since Load returns "True", it kills what was in %.
				//lastResult = system.evaluate("%");
				//System.out.println(" XXXXX: " + lastResult);
				
				//if(foldProperties.get("output").equalsIgnoreCase("latex") )
				//{
				//	result = system.evaluate("TeXForm(Hold(" + result + "));");
				//	result = result.replace("\"$","$");
				//	result = result.replace("$\"","$");
				//	output_fold_type = "%hoteqn";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("openmath") )
				//{	
				//	result = system.evaluate("OMForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("pretty") )
				//{	
				//	result = system.evaluate("PrettyForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("c") )
				//{	
				//	result = system.evaluate("CForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("lisp") )
				//{	
				//	result = system.evaluate("FullForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("table") )
				//{	
				//	result = system.evaluate("TableForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("geogebra") )
				//{
				//	output_fold_type = "%geogebra";
				//}
				//else
				//{
				//	output_fold_type = "%output";
				//}
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(org.mathrider.maxima.Piperexception ye) 
			{
				result = ye.getMessage();
				output_fold_type = "%error ";
			}
			
			

					
		}//end if }}}



		
		///{{{ *** %lisp ***.
		else if(foldType.equalsIgnoreCase("%lisp"))    
		{
						

			try 
			{   
				//tempFilePath = tempFile.getAbsolutePath();
				
				//tempFilePath = ChangeToForwardSlash(tempFilePath);
			
				
				//Determine how many lines are in the result.
				//numberOfLines = 0;
				//charIndex = 0;
				//while(charIndex != result.length()){
				//	if(result.charAt(charIndex) == "\n"){
				//		numberOfLines++;
				//	}
				//	charIndex++;
				//}//end while
				
				
				//Make room at the end of the current fold for output and place output there.
				//currentCaretPosition = textArea.getCaretPosition();
        	
				
			//{{{
			org.mathrider.ResponseListener responseListener = new org.mathrider.ResponseListener() {
				response(response)
				{
					System.out.println("XXXX " + response + ", " + foldType);
				}//end method.
				
				remove()
				{
					return true;
				}//end method.
				
			};//end interface implementation.
			//}}}
				system = MaximaWrapper.getInstance();
				system.addResponseListener(responseListener);
				//System.out.println(tempFilePath);
				tempFileName = tempFile.getName();
				sendString = "load(\""+tempFileName+"\");\n";
				system.send(sendString);
				output_fold_type = "%output";
				//System.out.println(
				
				
				//Note: Since Load returns "True", it kills what was in %.
				//lastResult = system.evaluate("%");
				//System.out.println(" XXXXX: " + lastResult);
				
				//if(foldProperties.get("output").equalsIgnoreCase("latex") )
				//{
				//	result = system.evaluate("TeXForm(Hold(" + result + "));");
				//	result = result.replace("\"$","$");
				//	result = result.replace("$\"","$");
				//	output_fold_type = "%hoteqn";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("openmath") )
				//{	
				//	result = system.evaluate("OMForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("pretty") )
				//{	
				//	result = system.evaluate("PrettyForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("c") )
				//{	
				//	result = system.evaluate("CForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("lisp") )
				//{	
				//	result = system.evaluate("FullForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("table") )
				//{	
				//	result = system.evaluate("TableForm(" + result + ");");
				//	output_fold_type = "%output";
				//}
				//else if(foldProperties.get("output").equalsIgnoreCase("geogebra") )
				//{
				//	output_fold_type = "%geogebra";
				//}
				//else
				//{
				//	output_fold_type = "%output";
				//}
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(org.mathrider.maxima.Piperexception ye) 
			{
				result = ye.getMessage();
				output_fold_type = "%error ";
			}
			
			

					
		}//end if }}}

		
		
		
	///{{{ *** %beanshell ***
		else if(foldType.equalsIgnoreCase("%beanshell"))
		{
			ggbWraper()
			{
				if(org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet() == null)
				{
					org.gjt.sp.jedit.jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "geogebra" );
				}
				evalCommand(command)
				{
					org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet().evalCommand(command);
				}
				return this;
			}

			
			scope = foldProperties.get("scope");
			if(scope.equalsIgnoreCase("global"))
			{
				bshInterpreter = bsi;
				ggb = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
				bshInterpreter.set("ggb",ggbWraper());
				//bshInterpreter.set("jEdit",jEdit); Note:tk: this stopped working for some reason.
				bshInterpreter.set("returnError","none");
			}
			else if(scope.equalsIgnoreCase("local"))
			{

				import bsh.Interpreter;
				bshInterpreter = new Interpreter();
				bshInterpreter.eval("import geogebra.GeoGebraApplet;");
				ggb = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
				bshInterpreter.set("ggb",ggbWraper());
				//bshInterpreter.set("jEdit",jEdit); Note:tk: this stopped working for some reason.
				bshInterpreter.set("returnError","none");
				
			
			}else if(scope.equalsIgnoreCase("ide"))
			{
				bshInterpreter=this.interpreter;
			}//end else/if.
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();

				//System.out.println(tempFilePath);
				
				//foldOutput is for printing to %output fold.
				bshInterpreter.set("foldOutput","");

				bshInterpreter.source(tempFilePath);
				
				
				//Print content of print statement if present. 
				
				
				foldOutput = bshInterpreter.get("foldOutput");
				//print("BBBB " + foldOutput);
				if(foldOutput == void || foldOutput == "")
				{
					result = "";
				}
				else
				{
					if(foldOutput instanceof String)
					{
						result = foldOutput;
					}
					else
					{
						result = String.valueOf(foldOutput);
					}//end else.
					
					foldOutput = "";
					
				}
				
	//System.out.println("tempFilePath: " + tempFilePath);
				output_fold_type = "%output ";
	//Sy	stem.out.println("Out> " + result);
				
					
			}catch(Exception e) 
			{
				System.out.println(" XXXX ERROR: " + bshInterpreter.get("returnError"));
				System.out.println(" XXX Beanshell Exception: " + e.getMessage());
				
				message = e.getMessage();
				
				//Note: ugly hack to work around EvalError object sometimes throwing null pointer exceptions 
				// when either getErrorText() or getErrorLineNumber() is called. 
				if(message.indexOf("line") == -1)
				{
					errorText = e.getErrorText();
					errorLineNumber = e.getErrorLineNumber();
				}
				else
				{
					errorText = e.getMessage();
					errorLineNumber = Integer.parseInt( errorText.substring(errorText.indexOf("line") + 5, errorText.indexOf(",")));
				}
				
				


				

				output_fold_type = "%error ";
							
							errorSource = PiperInterpreter.getErrorSource(); //Note: obtaining error source from central location.

							adjustedErrorLineNumber = foldStartLine + (errorLineNumber + 1);
							result =  e.getMessage() + " " + errorText + " Line: " + adjustedErrorLineNumber;							
							
							filePath = textArea.getBuffer().getPath();
				    	
							errorSource.clear();
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, adjustedErrorLineNumber-1, 0, 0, result ) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );

			}
		}//end else
		// end %beanshell }}}
	
	///{{{ *** %geogebra ***
		else if(foldType.startsWith("%geogebra")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "geogebra" );
			
			errorSource = PiperInterpreter.getErrorSource(); //Note: obtaining error source from central location.
			
			import geogebra.GeoGebraApplet;
			geogebra = org.mathrider.geogebraplugin.Geogebra.getGeoGebraApplet();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				//Clear geogebra.
				geogebra.setXML("<?xml version=\"1.0\" encoding=\"utf-8\"?> <geogebra format=\"2.5\"> </geogebra>");
				
			}//end if.
			
			
			
			
			result = "GeoGebra updated.";
			output_fold_type = "%output";
			if(foldType.endsWith("_xml"))
			{
				geogebra.setXML(codeText);
				//System.out.println(codeText);
			}
			else
			{
				lines = codeText.split("\n");
				
				lineCount = lines.length;
				lineIndex = 0;
            	
				
				for(lineIndex = 0; lineIndex < lineCount; lineIndex++)
				{
					//System.out.println("YYYYY" + lines[lineIndex]);
					
					if(lines[lineIndex].trim().length() != 0 && ! lines[lineIndex].trim().startsWith("//"))
					{
					    endOfLineCommentIndex = lines[lineIndex].indexOf("//");
						if(endOfLineCommentIndex != -1)
						{
							currentLine = lines[lineIndex].split("//")[0];
						}
						else
						{
							currentLine = lines[lineIndex].trim();
						}//end if.
						
						returnFlag = geogebra.evalCommand(currentLine);
						
						if(returnFlag == false)
						{
							errorLine = foldStartLine + lineIndex+2;
							result = "Error on line " + errorLine + ".";
							output_fold_type = "%error";
							
							filePath = textArea.getBuffer().getPath();
				    	
							errorSource.clear();
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, currentLine ) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
							
							break;      
						}//end if.
					}//end if.
				}//end for.

			}//end else
			
			
		}//end else
		//end %geogebra }}}

				                                                                                
	///{{{ *** %hoteqn ***
		else if(foldType.equalsIgnoreCase("%hoteqn")) //(foldStartLineText.indexOf("%geogebra") != -1)
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "hoteqn" );
			
			errorSource = PiperInterpreter.getErrorSource();
			
			//import geogebra.GeoGebraApplet;
			hotEqn = org.mathrider.hoteqnplugin.HotEqn.getHotEqn();
			
		
			if(foldProperties.get("clear").equalsIgnoreCase("true") )
			{
				hotEqn.setEquation("");
			}//end if.
			
			
			//lines = codeText.split("\n");
			

			
			//lineCount = lines.length;
			//lineIndex = 0;

			hotEqn.setEquation(codeText);
			result = "HotEqn updated.";
			output_fold_type = "%output";
			
					/*
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						output_fold_type = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
					*/

		}//end else
		//end %hoteqn }}}

	///{{{ *** %html ***
		else if(foldType.equalsIgnoreCase("%html")) 
		{
			//jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "piperdocs" );
			
			
			result = "";
			output_fold_type = "%output";
			
			try 
			{   
				tempFilePath = tempFile.getAbsolutePath();
				tempFilePath = ChangeToForwardSlash(tempFilePath);
				tempFilePath = "file:///" + tempFilePath;
				frame = new javax.swing.JFrame(); 
				contentPane = frame.getContentPane();
				contentPane.setLayout(new java.awt.BorderLayout());
				JEditorPane editorPane = new JEditorPane();
				JScrollPane editorScrollPane = new JScrollPane(editorPane);
				editorScrollPane.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
				editorPane.setEditable(false);
				editorPane.setPage(tempFilePath);
				contentPane.add(editorScrollPane);//guiBox,BorderLayout.NORTH);
				
				
				//{{{Experimental screen capture code.
				button = new org.gjt.sp.jedit.gui.RolloverButton(GUIUtilities.loadIcon("Save.png"));
				button.setToolTipText("Save image of this window.");
				ActionListener actionListener = new java.awt.event.ActionListener() {
					
					public void actionPerformed(ActionEvent evt) 
					{
						String[] paths = org.gjt.sp.jedit.GUIUtilities.showVFSFileDialog(view, null, JFileChooser.SAVE_DIALOG, false);
				
						if (paths != null ) 
						{
							String fileName = paths[0];
							java.io.File exportImageFile = new File(fileName);
							try
							{
								org.mathrider.library.ScreenCapture.createImage(editorPane, fileName);
							}
							catch (java.io.IOException ioe)
							{
								ioe.printStackTrace();
							}//end try/catch.
						}//end if.
					}//end method.
				};//end anonymous.
        		
				button.addActionListener( actionListener);
				
				
				toolPanel = new javax.swing.JPanel();
				toolPanel.add(button);
				contentPane.add(toolPanel, java.awt.BorderLayout.NORTH);
				
				//}}}*/

				
				

				frame.pack();
				frame.setAlwaysOnTop(false);
				frame.setTitle("MathRider");
				xsize = Integer.parseInt(foldProperties.get("width"));
				ysize = Integer.parseInt(foldProperties.get("height"));
				frame.setSize(new Dimension(xsize, ysize));
				frame.setResizable(true);
				//frame.setPreferredSize(new Dimension(400, 400));
				frame.setLocationRelativeTo(null);
				frame.show();


			}catch(Exception e) 
			{
				result = e.getMessage();
				output_fold_type = "%error ";
			}
			
					/*
					if(returnFlag == false)
					{
						errorLine = foldStartLine + lineIndex+2;
						result = "Error on line " + errorLine + ".";
						output_fold_type = "%error";
						
						filePath = textArea.getBuffer().getPath();
			    	
						errorSource.clear();
                	
						errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, 0, "Hello" ) );
			    	
						jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
						
						break;      
					}//end if.
					*/

		}//end else
		//end %html }}}

		
	///{{{ *** %uasm65 ***
		else if(foldType.equalsIgnoreCase("%uasm65")) 
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "u6502" );
			
			if ( asm == void )
			{
				asm = new org.mathrider.u6502.UASM65();
			}
			

			
			try 
			{   
				results = asm.assemble(codeText + "\n"); //Add newline to prevent no CR after END error.
				
				//System.out.println("LLLLL " + results.size() + " " + results.get(0));
				
				lst_or_error = results.get(0);
				if(results.size() > 1)
				{
					s19 = results.get(1);
					symbolTable = results.get(2);
					result = "*** List file ***\n" + lst_or_error + "\n\n";
					//result = result + "*** Symbol table ***\n\n" + symbolTable + "\n\n";
					s19 = s19.substring(0,s19.length()-1);
					s19 = s19.replaceAll("\n","\n\t");
					result = result + "***Executable code ***\n\n"+ "%s19,descrption=\"Execute this fold to send program to U6502 monitor.\"\n\t" + s19 + "\n%/s19";
					
					output_fold_type = "%output ";
				}
				else
				{
					filePath = textArea.getBuffer().getPath();
					errorSource = PiperInterpreter.getErrorSource(); //Note: obtaining error source from central location.
					errorSource.clear();
					java.util.Iterator errorEntries = lst_or_error.iterator();
					
					while(errorEntries.hasNext())
					{
							errorEntry = (java.util.Hashtable) errorEntries.next();
							errorLine = foldStartLine + errorEntry.get("line_number") + 1;
							errorIndex =  errorEntry.get("line_index");
							errorMessage = errorEntry.get("error_message");
							result = "Error on line " + errorLine + " : " + errorMessage ;
							//output_fold_type = "%error";
							
							
            	    	
							errorSource.addError(new DefaultErrorSource.DefaultError( errorSource, ErrorSource.ERROR, filePath, errorLine-1, 0, errorIndex, errorMessage) );
				    	
							jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "error-list" );
					
					}
					output_fold_type = "%error ";
				}
				
				
				
					
			}catch(java.io.IOException e) 
			{
				result = e.getMessage();
				output_fold_type = "%error ";
			}
		}//end else
		
	///{{{ *** %s19 ***
		else if(foldType.equalsIgnoreCase("%s19")) 
		{
			jEdit.getActiveView().getDockableWindowManager().showDockableWindow( "u6502" );
			
			uart = org.mathrider.u6502.EMU6551.getInstance();
			

			
			try 
			{   
					
				uart.send("L\n");
				codeText = codeText.replaceAll(" ", "");
				codeText = codeText.replaceAll("\t", "");
				uart.send(codeText);
				
				output_fold_type = "%output";
				
			}catch(java.io.IOException e) 
			{
				result = e.getMessage();
				output_fold_type = "%error ";
			}
		}//end else
		
	///{{{ *** %output ***
		else if(foldType.equalsIgnoreCase("%output"))
		{
			return; //For now.
		}
		//end %uasm65 }}}
		else
		{
			return;
		}//end if/else

//===================================================================================
				//Determine how many lines are in the result.
				numberOfLines = 0;
				charIndex = 0;
				while(charIndex != result.length()){
					if(result.charAt(charIndex) == "\n"){
						numberOfLines++;
					}
					charIndex++;
				}//end while
				
				

        	
        	

				
				result = result.trim();
				
				
				//Send output to a macro if the macro is specified.
				macro = foldProperties.get("pipe_to");
				//print("YYYYY " + macro);
				if(! macro.equalsIgnoreCase(""))
				{
					//bshInterpreter = PiperInterpreter.getBshInstance();
					bshInterpreter = bsi;
					//print("XXXX " + bshInterpreter.getNameSpace().getMethods());
					globalMethods = bshInterpreter.getNameSpace().getMethods();
					//for( method : globalMethods )
					//	print(method);
					
					bshInterpreter.eval(macro+"(\"" + result + "\");");
					//print("AAAA " + a);
				    //bshInterpreter.invokeMethod(macro, new Object [] {result} );
					
				}//end if.
				
						
				
				
				void displayResult()
				{
					//Buffer update needs to be done later in the AWT thread because of needing
					// to wait for the buffer to be saved (which was requested earlier).
					void run()
					{
						
						boolean isLastFold = true;
						buffer = textArea.getBuffer();
						lineCount = buffer.getLineCount();
						for(int i = foldEndLine; i < lineCount; i++)
						{
							if(buffer.isFoldStart(i))
							{
								isLastFold = false;
								break;
							}//end if.
						}//end for.
						
						if(isLastFold == true)
						{
							//System.out.println("XXXXX " + foldEndLine + ",   " + lineCount);return;
							if(foldEndLine == lineCount-1)
							{
								textArea.setCaretPosition(buffer.getLength());
								textArea.insert("\n\n",false);
							}//
								
								
							afterFoldIndex = textArea.getLineStartOffset(foldEndLine+1);
							rangeSelection = new Range(afterFoldIndex,afterFoldIndex+1);//(isolatedCodeEndIndex, codeEndIndex);
							textArea.setSelection(rangeSelection);
							beforeNewlines = "\n";
							afterNewlines = "\n\n";
						}
						else
						{
							textArea.goToNextFold(false);
							nextFoldProperties = getFoldProperties(textArea.getCaretLine());
							if(nextFoldProperties.get("preserve").equalsIgnoreCase("false"))//Delete next fold if set to preserve="false".
							{
								textArea.selectFold();
								beforeNewlines = afterNewlines = "";
								//textArea.setSelectedText("");
								//textArea.deleteLine();
								//textArea.deleteLine();
							}//end if.
							else if(nextFoldProperties.get("preserve").equalsIgnoreCase("true"))
							{
								afterFoldIndex = textArea.getLineStartOffset(foldEndLine+1);
								rangeSelection = new Range(afterFoldIndex,afterFoldIndex+1);
								textArea.setSelection(rangeSelection);
								beforeNewlines = "\n";
								afterNewlines = "\n\n";
							}
						}//end if/else.
				
						
						
					//System.out.println(result);
						result = result.trim();
						result = result.replaceAll("\n","\n" + indentAmount + "  ");//("\n","\n      ");
						result = indentAmount + "  " + result;
						textArea.setSelectedText(beforeNewlines + indentAmount + output_fold_type + ",preserve=\"false\"\n" + result + "\n" + indentAmount + "%/" + output_fold_type.substring(1,output_fold_type.length() ) + afterNewlines, false);
						
						//("\n\n     " + output_fold_type + "\n      "+ result + "\n     %end\n",false);
				 
						/*//If fold type was blank, set it to the default fold type.
						if(foldStartSelection != null)
						{
							textArea.setSelection(foldStartSelection);
							line = textArea.getSelectedText();
							line = line.replaceFirst("\\{\\{\\{", "\u007b\u007b\u007b" + defaultFoldType);
							textArea.setSelectedText(line);
							textArea.setSelection(null);
						}//end if
						  */
						
						textArea.setCaretPosition(currentCaretPosition);
						
						if(collapseFold.equalsIgnoreCase("true"))
						{
							textArea.collapseFold();
						}//end if.
						
						buffer.save(view,null);
					}
					VFSManager.runInAWTThread(this);
				
				}//end method.
				
				displayResult();
							

    } 
	catch (IOException e) 
	{
		e.printStackTrace();
    }
	

	

}//end else if.




