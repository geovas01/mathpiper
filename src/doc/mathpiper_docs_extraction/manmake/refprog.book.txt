
















/*
%mathpiper_docs,name=""
*CMD GetTime --- measure the time taken by an evaluation
*CORE
*CALL
	GetTime(expr)
*PARMS
{expr} -- any expression
*DESC
The function {GetTime(expr)} evaluates the expression {expr} and returns the time needed for the evaluation.
The result is returned as a floating-point number of seconds.
The value of the expression {expr} is lost.

The result is the "user time" as reported by the OS, not the real ("wall clock") time.
Therefore, any CPU-intensive processes running alongside Yacas will not significantly affect the result of {GetTime}.

*EG
	In> GetTime(Simplify((a*b)/(b*a)))
	Out> 0.09;

*SEE Time



			Generic objects

*INTRO Generic objects are objects that are implemented in C++, but
can be accessed through the Yacas interpreter.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD IsGeneric --- check for generic object
*CORE
*CALL
	IsGeneric(object)

*DESC
Returns {True} if an object is of a generic object type.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD GenericTypeName --- get type name
*CORE
*CALL
	GenericTypeName(object)

*DESC
Returns a string representation of
the name of a generic object.

EG

	In> GenericTypeName(ArrayCreate(10,1))
	Out> "Array";

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArrayCreate --- create array
*CORE
*CALL
	ArrayCreate(size,init)

*DESC
Creates an array with {size} elements, all initialized to the
value {init}.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArraySize --- get array size
*CORE
*CALL
	ArraySize(array)

*DESC
Returns the size of an array (number of elements in the array).

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArrayGet --- fetch array element
*CORE
*CALL
	ArrayGet(array,index)

*DESC
Returns the element at position index in the array passed. Arrays are treated
as base-one, so {index} set to 1 would return the first element.

Arrays can also be accessed through the {[]} operators. So
{array[index]} would return the same as {ArrayGet(array, index)}.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArraySet --- set array element
*CORE
*CALL
	ArraySet(array,index,element)

*DESC
Sets the element at position index in the array passed to the value
passed in as argument to element. Arrays are treated
as base-one, so {index} set to 1 would set first element.

Arrays can also be accessed through the {[]} operators. So
{array[index] := element} would do the same as {ArraySet(array, index,element)}.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArrayCreateFromList --- convert list to array
*CORE
*CALL
	ArrayCreateFromList(list)

*DESC
Creates an array from the contents of the list passed in.

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD ArrayToList --- convert array to list
*CORE
*CALL
	ArrayToList(array)

*DESC
Creates a list from the contents of the array passed in.



			The Yacas test suite

*INTRO This chapter describes commands used for verifying correct performance
of Yacas.

Yacas comes with a test suite which can be found in
the directory {tests/}. Typing 
	make test
on the command line after Yacas was built will run the test.
This test can be run even before {make install}, as it only 
uses files in the local directory of the Yacas source tree.
The default extension for test scripts is {.yts} (Yacas test script).

The verification commands described in this chapter only  display the
expressions that do not evaluate correctly. Errors do not terminate the
execution of the Yacas script that uses these testing commands, since they are
meant to be used in test scripts.


%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD Verify --- verifying equivalence of two expressions
*CMD TestYacas --- verifying equivalence of two expressions
*CMD LogicVerify --- verifying equivalence of two expressions
*CMD LogicTest --- verifying equivalence of two expressions
*STD
*CALL
	Verify(question,answer)
	TestYacas(question,answer)
	LogicVerify(question,answer)
	LogicTest(variables,expr1,expr2)

*PARMS

{question} -- expression to check for

{answer} -- expected result after evaluation

{variables} -- list of variables

{exprN} -- Some boolean expression

*DESC

The commands {Verify}, {TestYacas}, {LogicVerify} and {LogicTest} can be used to verify that an
expression is <I>equivalent</I> to  a correct answer after evaluation. All
three commands return {True} or {False}.

For some calculations, the demand that two expressions
are <I>identical</I> syntactically is too stringent. The 
Yacas system might change at various places in the future,
but $ 1+x $ would still be equivalent, from a mathematical
point of view, to $ x+1 $.

The general problem of deciding that two expressions $ a $ and $ b $
are equivalent, which is the same as saying that $ a-b=0 $ , 
is generally hard to decide on. The following commands solve
this problem by having domain-specific comparisons.

The comparison commands do the following comparison types:

*	{Verify} -- verify for literal equality. 
This is the fastest and simplest comparison, and can be 
used, for example, to test that an expression evaluates to $ 2 $.
*	{TestYacas} -- compare two expressions after simplification as 
multivariate polynomials. If the two arguments are equivalent
multivariate polynomials, this test succeeds. {TestYacas} uses {Simplify}. Note: {TestYacas} currently should not be used to test equality of lists.
*	{LogicVerify} -- Perform a test by using {CanProve} to verify that from 
{question} the expression {answer} follows. This test command is 
used for testing the logic theorem prover in Yacas.
*	{LogicTest} -- Generate a truth table for the two expressions and compare these two tables. They should be the same if the two expressions are logically the same.

*E.G.

	In> Verify(1+2,3)
	Out> True;
	In> Verify(x*(1+x),x^2+x)
	******************
	x*(x+1) evaluates to x*(x+1) which differs
	  from x^2+x
	******************
	Out> False;
	In> TestYacas(x*(1+x),x^2+x)
	Out> True;
	In> Verify(a And c Or b And Not c,a Or b)
	******************
	 a And c Or b And Not c evaluates to  a And c
	  Or b And Not c which differs from  a Or b
	******************
	Out> False;
	In> LogicVerify(a And c Or b And Not c,a Or b)
	Out> True;
	In> LogicVerify(a And c Or b And Not c,b Or a)
	Out> True;
	In> LogicTest({A,B,C},Not((Not A) And (Not B)),A Or B)
	Out> True
	In> LogicTest({A,B,C},Not((Not A) And (Not B)),A Or C)
	******************
	CommandLine: 1 
	
	$TrueFalse4({A,B,C},Not(Not A And Not B))
	 evaluates to 
	{{{False,False},{True,True}},{{True,True},{True,True}}}
	 which differs from 
	{{{False,True},{False,True}},{{True,True},{True,True}}}
	******************
	Out> False

*SEE Simplify, CanProve, KnownFailure


%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD KnownFailure --- Mark a test as a known failure
*STD
*CALL
	KnownFailure(test)

*PARMS

{test} -- expression that should return {False} on failure

*DESC

The command {KnownFailure} marks a test as known to fail
by displaying a message to that effect on screen. 

This might be used by developers when they have no time
to fix the defect, but do not wish to alarm users who download
Yacas and type {make test}.

*E.G.

	In> KnownFailure(Verify(1,2))
	Known failure:
	******************
	 1 evaluates to  1 which differs from  2
	******************
	Out> False;
	In> KnownFailure(Verify(1,1))
	Known failure:
	Failure resolved!
	Out> True;

*SEE Verify, TestYacas, LogicVerify

%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD RoundTo --- Round a real-valued result to a set number of digits
*STD
*CALL
	RoundTo(number,precision)

*PARMS

{number} -- number to round off

{precision} -- precision to use for round-off

*DESC

The function {RoundTo} rounds a floating point number to a
specified precision, allowing for testing for correctness
using the {Verify} command.

*E.G.

	In> N(RoundTo(Exp(1),30),30)
	Out> 2.71828182110230114951959786552;
	In> N(RoundTo(Exp(1),20),20)
	Out> 2.71828182796964237096;

*SEE Verify, VerifyArithmetic, VerifyDiv



%/mathpiper_docs
*/


/*
%mathpiper_docs,name=""
*CMD VerifyArithmetic --- Special purpose arithmetic verifiers
*CMD RandVerifyArithmetic --- Special purpose arithmetic verifiers
*CMD VerifyDiv --- Special purpose arithmetic verifiers
*STD
*CALL
	VerifyArithmetic(x,n,m)
	RandVerifyArithmetic(n)
	VerifyDiv(u,v)

*PARMS

{x}, {n}, {m}, {u}, {v} -- integer arguments

*DESC

The commands {VerifyArithmetic} and {VerifyDiv} test a 
mathematic equality which should hold, testing that the
result returned by the system is mathematically correct
according to a mathematically provable theorem.

{VerifyArithmetic} verifies for an arbitrary set of numbers
$ x $, $ n $ and $ m $ that
$$ (x^n-1)*(x^m-1) = x^(n+m)-(x^n)-(x^m)+1 $$.

The left and right side represent two ways to arrive at the
same result, and so an arithmetic module actually doing the
calculation does the calculation in two different ways. 
The results should be exactly equal.

{RandVerifyArithmetic(n)} calls {VerifyArithmetic} with
random values, {n} times.

{VerifyDiv(u,v)} checks that 
$$ u = v*Div(u,v) + Mod(u,v) $$.


*E.G.

	In> VerifyArithmetic(100,50,60)
	Out> True;
	In> RandVerifyArithmetic(4)
	Out> True;
	In> VerifyDiv(x^2+2*x+3,x+1)
	Out> True;
	In> VerifyDiv(3,2)
	Out> True;

*SEE Verify

%/mathpiper_docs
*/




*A {MathExp}
*A {MathLog}
*A {MathPower}
*A {MathSin}
*A {MathCos}
*A {MathTan}
*A {MathArcSin}
*A {MathArcCos}
*A {MathArcTan}
*A {MathSinh}
*A {MathCosh}
*A {MathTanh}
*A {MathArcSinh}
*A {MathArcCosh}
*A {MathArcTanh}
*A {MathGcd}
*A {MathAdd}
*A {MathSubtract}
*A {MathMultiply}
*A {MathDivide}
*A {MathSqrt}
*A {MathFloor}
*A {MathCeil}
*A {MathAbs}
*A {MathMod}
*A {MathDiv}
*CMD Math... --- arbitrary-precision math functions
*CORE
*REM these are not made into code examples to save space
*CALL
	MathGcd(n,m)      (Greatest Common Divisor)
	MathAdd(x,y)      (add two numbers)
	MathSubtract(x,y) (subtract two numbers)
	MathMultiply(x,y) (multiply two numbers)
	MathDivide(x,y)   (divide two numbers)
	MathSqrt(x)    (square root, must be x>=0)
	MathFloor(x)   (largest integer not larger than x)
	MathCeil(x)    (smallest integer not smaller than x)
	MathAbs(x)     (absolute value of x, or |x| )
	MathExp(x)     (exponential, base 2.718...)
	MathLog(x)     (natural logarithm, for x>0)
	MathPower(x,y) (power, x ^ y)
	MathSin(x)     (sine)
	MathCos(x)     (cosine)
	MathTan(x)     (tangent)
	MathSinh(x)     (hyperbolic sine)
	MathCosh(x)     (hyperbolic cosine)
	MathTanh(x)     (hyperbolic tangent)
	MathArcSin(x)   (inverse sine)
	MathArcCos(x)   (inverse cosine)
	MathArcTan(x)   (inverse tangent)
	MathArcSinh(x)  (inverse hyperbolic sine)
	MathArcCosh(x)  (inverse hyperbolic cosine)
	MathArcTanh(x)  (inverse hyperbolic tangent)
	MathDiv(x,y)    (integer division, result is an integer)
	MathMod(x,y)    (remainder of division, or x mod y)

*DESC

These commands perform the calculation of elementary mathematical functions.
The arguments <i>must</i> be numbers.
The reason for the prefix {Math} is that
the library needs to define equivalent
non-numerical functions for symbolic computations, such as {Exp}, {Sin} and so on.

Note that all functions, such as the {MathPower}, {MathSqrt}, {MathAdd} etc., accept integers as well as floating-point numbers.
The resulting values may be integers or floats.
If the mathematical result is an exact integer, then the integer is returned.
For example, {MathSqrt(25)} returns the integer {5}, and {MathPower(2,3)} returns the integer {8}.
In such cases, the integer result is returned even if the calculation requires more digits than set by {BuiltinPrecisionSet}.
However, when the result is mathematically not an integer, the functions return a floating-point result which is correct only to the current precision.

*EG
	In> BuiltinPrecisionSet(10)
	Out> True
	In> Sqrt(10)
	Out> Sqrt(10)
	In> MathSqrt(10)
	Out> 3.16227766
	In> MathSqrt(490000*2^150)
	Out> 26445252304070013196697600
	In> MathSqrt(490000*2^150+1)
	Out> 0.264452523e26
	In> MathPower(2,3)
	Out> 8
	In> MathPower(2,-3)
	Out> 0.125
