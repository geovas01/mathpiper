Using Rewrite Rules To Perform Mathematics. v1.03.

This is an introductory level explanation of how a computer algebra system (CAS)
can be programmed to use the same techniques to solve a simple equation that a
human typically would. There are a number of different types of CASs, and one of
these types is called a rewriting system (http://en.wikipedia.org/wiki/Rewriting). 
Rewriting systems use rules to transform expressions into different expressions.

MathPiper is primarily a rewriting system, and it includes a large number of
predefined rules. However, MathPiper was specifically designed to enable users
to easily create their own rules. The following example uses a rule (that 
was obtained from from the above Wikipedia article) to transform the expression

(x And? y) Or? z 

into 

(x Or? z) And? (y Or? z)

In>   (x And? y) Or? z  /: {(_a And? _b) Or? _c <- (a Or? c) And? (b Or? c)} 
Result: (x Or? z) And? (y Or? z)

/: is MathPiper's local rules operator. It takes the expression that is on its
left side and tries to match it to the list of rules that is on its right side
(the above example only contains one rule, but more rules can be added to the list).
If it finds a match, the result of the transformation is returned. If it does
not find a match, the original expression is returned:

In>   x And? y  /: {(_a And? _b) Or? _c <- (a Or? c) And? (b Or? c)} 
Result: x And? y


//==============================================================================

The following code shows how all of the logic rules from the Wikipedia article
can be placed into a function called SimpLogic and then be used to transform
expressions:

%mathpiper

SimpLogic(expression) :=
[
    expression /: 
      {
        //Double negative elimination.
        Not? Not? _a <- a, 
        
        //DeMorgan's laws.
        Not?(_a And? _b) <- Not? a Or? Not? b,
        Not?(_a Or? _b) <- Not? a And? Not? b,
        
        //Distributivity.
        (_a And? _b) Or? _c <- (a Or? c) And? (b Or? c),
        (_a Or? _b) And? _c <- (a And? c) Or? (b And? c)
      };
];

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output


In> SimpLogic(Not? Not? x)
Result: x

In> SimpLogic( Not? (x And? y))
Result: Not? x Or? Not? y

In> SimpLogic( Not? (x Or? y))
Result: Not? x And? Not? y

In> SimpLogic( (x And? y) Or? z )
Result: (x Or? z) And? (y Or? z)

In> SimpLogic( (x Or? y) And? z)
Result: x And? z Or? y And? z


//==============================================================================

Most rewriting-based CASs contain a pattern matching system that is able to
locate subexpressions that match a given pattern. These subexpressions can be
simple or relatively complex. The following example shows how a rule that
embodies the distributive law of multiplication over addition can match a simple
subexpression such as 3 or a more complex one such as (a - b):

In> 3*(w + x) /: { _a*(_b + _c) <- a*b + a*c }
Result: 3*w+3*x

In> (w - x)*(y + z) /: { _a*(_b + _c) <- a*b + a*c }
Result: (w-x)*y+(w-x)*z


//=============================================================================

The following image shows the step-by-step solution of a simple equation that
was generated by MathPiper using a small set of rules:

http://206.21.94.61/misc/permalink/equation_solving_with_steps_and_trees.png

MathPiper uses a data structure that is similar to an expression tree to
represent an equation and an expression tree makes it easy to determine what
operation to perform next when solving a simple equation. For example, consider
the first expression tree in the above example. Think of the = sign as being the
root of an inverted tree that has a left branch that leads to a + sign and a
right branch that leads to the variable “e”. The topmost function on either side
of the = sign is called the dominant function for that side of the equation. In
this tree, the dominant function on the left side of the equation is +.

The dominant function in an expression is the operator with the lowest
precedence. At each step, the dominant function on the left side of the = is
removed and its inverse becomes the dominant function on the right side of the
=. This process is repeated until the variable that is being isolated is by
itself on the left side of the =.


Here are the rules that were used to solve the example problem:


Isolax(side, equation) :=
[
    side : equation /: {
    
     1: -$ _lhs == _rhs <- {lhs == -$ rhs},
     
     1: _term1 +$ _term2 == _rhs <- {term1 == rhs -$ term2},
     2: _term1 +$ _term2 == _rhs <- {term2 == rhs -$ term1},
     
     1: _term1 -$ _term2 == _rhs <- {term1 == rhs +$ term2},
     2: _term1 -$ _term2 == _rhs <- {term2 == term1 -$ rhs},
     
     1: _term1 *$ _term2 == _rhs <- {term1 == rhs /$ term2},
     2: _term1 *$ _term2 == _rhs <- {term2 == rhs /$ term1},
     
     1: _term1 /$ _term2 == _rhs <- {term1 == rhs *$ term2},
     2: _term1 /$ _term2 == _rhs <- {term2 == term1 /$ rhs},
     
     1: _term1 ^$ _term2 == _rhs <- {term1 == rhs^$(1/$term2)},
    //"Exponentiation2" # 2 : _term1 ^ _term2 == _rhs <- term2 == Log(rhs)//Log(base(term1), rhs)
                      
    };                 
];


Note: these rules were obtained from the PRESS Prolog-based CAS.
