============================== Proposed function name changes: 



Change the bodied operators D, Integrate, Limit, and Taylor to non-bodied operators to make function calls uniform and to reduce confusion.
MM -> MultinomialForm
Normalize -> NormalizeVector
FW -> ?
FWatom -> ?

All Gets and Sets should be at the end of a function's name.


UnFence -> Unfence
UnbiasedVariance -> SampleVariance
Variance -> PopulationVariance
MakeVector -> MakeIdentifiers
RulebaseDefined -> RulebaseDefined?.
Map and MapSingle should have the list as the first argument to match Find and Contains.
Outer -> OuterProduct
Eval -> Evaluate
InProduct -> InnerProduct
Dot -> DotProduct
ExtractSubMatrix -> ExtractSubmatrix
CoFactor -> Cofactor
TrapError -> TrapException
GetErrorTableau -> GetErrorTable
IsError -> TrapException
GetError -> GetException
BuiltinPrecisionSet -> PrecisionSet
BuiltinPrecisionGet -> PrecisionGet
SetGlobalLazyVariable - GlobalLazyVariableSet


InVerboseMode -> VerboseMode?
V() -> Make V a bodied function so it can be more easily added and removed from code.


------------------------------------------------------------------------------------------

Have all symbolic operators and constants end with a period. This goes along with all predicate operators
ending with a ? which indicates a truth result is returned. Operators ending with a period
are simply statements.

== -> =.
!== -> !=.
<.
<=.
>.
>=.
Infinity -> Infinity.
Pi -> Pi.
e -> e.



Another idea is to have all symbolic operators and constants end with a $ because it looks
similar to an "s" and therefore it can stand for "symbolic".

== -> =$
!== -> !=$
<$
<=$
>$
>=$
Infinity -> Infinity$
Pi -> Pi$
e$
True$
False$
Empty$


--- Have all destructive functions end with a 'D', 
--- (which is similar to how numeric functions end with an 'N'.)
DestructiveAppend -> AppendD
DestructiveDelete -> DeleteD
DestructiveInsert -> InsertD
DestructiveReplace -> ReplaceD
DestructiveReverse -> ReverseD


----- Potential function name changes (Perhaps append an 'H' to the names of functions that have arguments that are held,
all other functions are assumed to have evaluated arguments.):
    Rulebase -> RulebaseHoldArguments
    RulebaseListed -> RulebaseListedHoldArguments
    Rule -> RuleHoldArguments
    RulePattern -> RulePatternHoldArguments

    MacroRulebase -> RulebaseEvaluateArguments
    MacroRulebaseListed -> RulebaseListedEvaluateArguments
    MacroRule -> RuleEvaluateArguments
    MacroRulePattern -> RulePatterrnEvaluateArguments

Local -> LocalHoldArguments (leave Local as a synonym)
MacroLocal -> LocalEvaluateArguments



    DefMacroRulebase -> MacroRulebaseHoldArguments
    DefMacroRulebaseListed -> MacroRulebaseListedHoldArguments
    

----------------------------------

Unassign -> UnassignHoldArguments (and leave Unassign as a synonym)
Assign -> AssignHoldArguments
MacroAssign -> UnassignEvaluateArguments
----------------------------------




DestructiveAppend -> AppendDestructive

----------------------------- Have most constants be in all capital letters.
True -> TRUE
False -> FALSE
Empty -> EMPTY



----------------------------- Have bitwise operator names end with a B.
BitAnd -> AndB
BitOr -> OrB
BitXor -> XorB
NotB


----------------------------- Proposed predicate operator & function name changes:


@$, @&, @%




============================= Changes that have already been done. ===================================

Table -> BuildList (Perhaps make the body the last argument or make a postfix function.  Also look at Sum.)
GenMatrix -> BuildMatrix

Prog -> Block //For pedagogical reasons.

//This should fix the problem of people becoming confused on the difference between the If function and the if function.
If -> Decide
if -> If
else -> Else

[] -> {} //Change the code block outfix operator to match the syntax used in other languages.
{} -> [] //Change the list outfix operator to match the syntax used in other languages.


A bound variable is a concept that is used differently in Lisp and mathematics. MathPiper
currently uses the Lisp version but it will probably be better to use the mathematics
version. Therefore, Bind should probably become Assign and Unbind should probably become
Unassign:
Unbind -> Unassign
Bind -> Assign
MacroUnbind -> MacroAssign

: -> ~
: -> Is now an operator that can be used to associate two things.

All predicate functions now with a ? mark.  For example:
IsInteger -> Integer?
IsList -> List?
etc.





// Changed in early September 2011.
IsNumber -> Number?
InDebugMode -> DebugMode?
IsAtom -> Atom?
IsBodied -> Bodied?
IsBound -> Bound?
IsDecimal -> Decimal?
IsEqual -> Equal?
IsFunction -> Function?
IsGeneric -> Generic?
IsGreaterThan -> GreaterThan?
IsInfix -> InFix?
IsLessThan -> LessThan?
IsList -> List?
IsListOfLists -> ListOfLists?
IsPostfix -> Postfix?
IsPrefix -> Prefix?
IsPromptShown -> PromptShown?
IsString -> String?
IsComplex -> Complex?
IsComplexII -> ComplexII
IsAssumed -> Assumed?
IsAmicablePair -> AmicablePair
IsCarmichaelNumber -> CarmichaelNumber
IsCFormable -> CFormable?
IsComposite -> Composite?
IsCoprime -> Coprime
IsError -> Error?
IsFreeOf -> FreeOf?
IsGaussianInteger -> GaussianInteger?
IsGaussianPrime -> GaussianPrime?
IsGaussianUnit -> GaussianUnit?
IsIrregularPrime -> IrregualrPrime?
IsNonObject -> NonObject?
IsPerfect -> Perfect?
IsPoint -> Point?
IsQuadraticResidue -> QuadraticResidue?
IsSegment -> Segment?
IsSmallPrime -> SmallPrime?
IsSquareFree -> SquareFree?
IsSubset -> Subset?
IsTwinPrime -> TwinPrime?
IsScalar -> Scalar?
IsMatrix -> Matrix?
IsVector -> Vector?
IsSquareMatrix -> SquareMatrix?
IsUniVar -> UniVar?
IsMultiExpression -> MultiExpression?
IsMultiConstant -> MultiConstant?
IsMulti -> Multi?
AllSatisfy -> AllSatisfy?
FloatIsInt -> FloatIsInt?
HasExpr -> HasExpression?
HasExprArith -> HasExpressionArithmetic?
HasExprSome -> HasExpressionSome?
HasFunc -> HasFunction?
HasFuncArith -> HasFunctionArithmetic?
HasFuncSome -> HasFunctionSome?
IsBoolType -> BooleanType?
IsBoolean -> Boolean?
IsConstant -> Constant?
IsDiagonal -> Diagonal?
IsEquation -> Equation?
IsEven -> Even?
IsEvenFunction -> EvenFunction?
IsHermitian -> Hermitian?
IsIdempotent -> Idempotent?
IsInfinity -> Infinity?
IsLowerTriangular -> LowerTriangular?
IsMonomial -> Monomial?
IsNegativeInteger -> NegativeInteger?
IsNegativeNumber -> NegativeNumber?
IsNegativeReal -> NegativeReal?
IsNonNegativeInteger -> NonNegativeInteger?
IsNonNegativeNumber -> NonNegativeNumber?
IsNonZeroInteger -> NonZeroInteger?
IsNotZero -> NotZero?
IsNumericList -> NumericList?
IsOdd -> Odd?
IsOddFunction -> OddFunction?
IsOne -> One?
IsOrthogonal -> Orthogonal?
IsPolynomial -> Polynomial?
IsPolynomialOverIntegers -> PolynomialOverIntegers?
IsPositiveInteger -> PositiveInteger?
IsPositiveNumber -> PositiveNumber?
IsPositiveReal -> PositiveReal?
IsRationalFunction -> RationalFunction?
IsRationalOrNumber -> RationalOrNumber?
IsRational -> Rational?
IsSkewSymmetric -> SkewSymmetric?
IsSumOfTerms -> SumOfTerms?
IsUnitary -> Unitary?
IsUpperTriangular -> UpperTriangular?
IsVariable -> Variable?
IsZeroVector -> ZeroVector?
IsZero -> Zero?
ListHasFuncSome -> ListHasFunctionSome?
NoneSatisfy -> NoneSatisfy?
IsIntegerGreaterThanZero -> IntegerGreaterThanZero?
IsInteger -> IsInteger?
IsBound -> Bound?
IsPrimePower -> PrimePower?
IsPrime -> Prime? (check the docs for IsSmallPrime because it has IsPrime info in it).




// Changed late August 2011.
= -> =?    
!= -> !=?
< -> <?
> -> >?
<= -> <=?
>= -> >=?


//Newest changes (1/8/2010). 

D -> Differentiate
Listify -> FunctionToList
UnList -> ListToFunction
Clear -> Unbind
MacroClear -> MacroUnbind
ToFile -> PipeToFile
ToString -> PipeToString
ToStdout -> PipeToStdout
FromFile -> PipeFromFile
FromString -> PipeFromString
String -> ToString
Atom -> ToAtom
Equals -> IsEqual
LessThan -> IsLessThan
GreaterThan -> IsGreaterThan
Div -> Quotient
Mod -> Modulo
DivN -> QuotientN
ModN -> ModuloN
Min -> Minimum
Max -> Maximum
RandomIntegerVector -> RandomIntegerList.
OpPrecedence -> PrecedenceGet
OpLeftPrecedence -> LeftPrecedenceGet
OpRightPrecedence -> RightPrecedenceGet
LeftPrecedence -> LeftPrecedenceSet
RightPrecedence -> RightPrecedenceSet
RightAssociative -> RightAssociativeSet
FullForm -> LispForm
Use -> LoadScriptOnce
Load -> LoadScript
NumRealRoots -> RealRootsCount


//Make RuleBase names read more like the name Database does because they are suppose to sound like "database" and operate like a database.
RuleBase -> Rulebase
MacroRuleBase -> MacroRulebase
MacroRuleBaseListed  -> MacroRulebaseListed
DefMacroRuleBase -> DefMacroRulebase
DefMacroRuleBaseListed -> DefMacroRulebaseListed
RuleBaseArgList -> RulebaseArgumentsList
NrArgs -> ArgumentsCount
HoldArgNr -> HoldArgumentNumber
HoldArg -> HoldArgument


Select -> Switched the order of the arguments (to match the ordering of most other MathPiper functions that operate on lists)?






//Older changes.


EquLeft -> EquationLeft
EquRight -> EquationRight
Factorize -> Product
Add -> Sum
Tail -> Rest
Head -> First
Bin -> BinomialCoefficient and the synonym Combinations has been added for BinomialCoefficient.
Permutations -> PermutationsList.
Numer -> Numerator
Denom -> Denominator
Time -> EchoTime
GetTime -> Time
ExtraInfoSet -> MetaSet
ExtraInfoGet -> MetaGet
CurrentTime -> SystemTimer



MathAbs -> AbsN
MathAdd -> AddN
MathAnd -> AndN
MathArcCos -> ArcCosN
MathArcCosh -> ArcCoshN
MathArcSin -> ArcSinN
MathArcSinh -> ArcSinhN
MathArcTan -> ArcTanN
MathArcTanh -> ArcTanhN
MathCeil -> CeilN
MathCos -> CosN
MathCosh -> CoshN
MathDiv -> DivN
MathDivide -> DivideN
MathExp -> ExpN
MathFloor -> FloorN
MathGcd -> GcdN
MathGetExactBits -> GExactBitsN
MathLog -> LogN
MathMod -> ModN
MathMultiply -> MultiplyN
MathNot -> NotN
MathOr -> OrN
MathPower -> PowerN
MathSetExactBits -> SetExactBitsN
MathSin -> SinN
MathSinh -> SinhN
MathSqrt -> SqrtN
MathSubtract -> SubtractN
MathTan -> TanN
MathTanh -> TanhN

//Removed the ' character from these function names.
Array'Create
Array'CreateFromList
Array'Get
Array'Set
Array'Size
Array'ToList
Builtin'Precision'Get
Builtin'Precision'Set
ExtraInfo'Get
ExtraInfo'Set
StringMid'Get
StringMid'Set
