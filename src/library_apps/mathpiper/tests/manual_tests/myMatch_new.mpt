init:
deps-jar:
compile-single:
run-single:
Maxima is initialized
Debug> Loading file"org/mathpiper/scripts/predicates.rep/code.mpi" for function IsMatrix
Debug> Finished loading file "org/mathpiper/scripts/predicates.rep/code.mpi"
Leave}(TraceOn(),True);
Enter<user>{(tellMe,tellMe(x,p1));
Arg(x,x);
Arg(p1,x+B);
Enter<builtin>{(Prog,[
    Local(m,ccs);
    Tell(CASE,expr);
    m:=myMatchLinear(var,expr);
    Tell(1,m);
    ccs:=trythis(var,expr);
    Tell(2,ccs);
]
);
    Arg(Local(m,ccs),{Local(m,ccs),Tell(CASE,expr),m:=myMatchLinear(var,expr),Tell(1,m),ccs:=trythis(var,expr),Tell(2,ccs)});
    Enter<builtin>{(Local,Local(m,ccs));
        Arg(m,{m,ccs});
    Leave}(Local(m,ccs),True);
Debug> Loading file"org/mathpiper/scripts/testers.rep/code.mpi" for function Tell
    Enter<user>{(Function,Function(BenchCall,{expr})[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000>);
    Eval(expr);
    WriteString(</font>);
    True;
]
);
        Arg(BenchCall,BenchCall);
        Arg({expr},{expr});
        Arg([
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000>);
    Eval(expr);
    WriteString(</font>);
    True;
]
,[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000>);
    Eval(expr);
    WriteString(</font>);
    True;
]
);
        Enter<builtin>{(And,GreaterThan(Length(args),1)And Equals(MathNth(args,Length(args)),Atom(...)));
            Arg(GreaterThan(Length(args),1),{GreaterThan(Length(args),1),Equals(MathNth(args,Length(args)),Atom(...))});
            Enter<builtin>{(GreaterThan,GreaterThan(Length(args),1));
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(GreaterThan(Length(args),1),False);
        Leave}(GreaterThan(Length(args),1)And Equals(MathNth(args,Length(args)),Atom(...)),False);
        Enter<builtin>{(Prog,[
    Retract(oper,Length(args));
    MacroRuleBase(oper,args);
    MacroRule(oper,Length(args),1025,True)body;
]
);
            Arg(Retract(oper,Length(args)),{Retract(oper,Length(args)),MacroRuleBase(oper,args),MacroRule(oper,Length(args),1025,True)body});
            Enter<builtin>{(Retract,Retract(oper,Length(args)));
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(Retract(oper,Length(args)),True);
            Enter<builtin>{(MacroRuleBase,MacroRuleBase(oper,args));
            Leave}(MacroRuleBase(oper,args),True);
            Enter<builtin>{(MacroRule,MacroRule(oper,Length(args),1025,True)body);
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(MacroRule(oper,Length(args),1025,True)body,True);
        Leave}([
    Retract(oper,Length(args));
    MacroRuleBase(oper,args);
    MacroRule(oper,Length(args),1025,True)body;
]
,True);
    Leave}(Function(BenchCall,{expr})[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000>);
    Eval(expr);
    WriteString(</font>);
    True;
]
,True);
    Enter<builtin>{(HoldArg,HoldArg(BenchCall,expr));
    Leave}(HoldArg(BenchCall,expr),True);
    Enter<user>{(Function,Function(BenchShow,{expr})[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000> );
    Echo({Out&gt ,Eval(expr),</font>});
    True;
]
);
        Arg(BenchShow,BenchShow);
        Arg({expr},{expr});
        Arg([
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000> );
    Echo({Out&gt ,Eval(expr),</font>});
    True;
]
,[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000> );
    Echo({Out&gt ,Eval(expr),</font>});
    True;
]
);
        Enter<builtin>{(And,GreaterThan(Length(args),1)And Equals(MathNth(args,Length(args)),Atom(...)));
            Arg(GreaterThan(Length(args),1),{GreaterThan(Length(args),1),Equals(MathNth(args,Length(args)),Atom(...))});
            Enter<builtin>{(GreaterThan,GreaterThan(Length(args),1));
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(GreaterThan(Length(args),1),False);
        Leave}(GreaterThan(Length(args),1)And Equals(MathNth(args,Length(args)),Atom(...)),False);
        Enter<builtin>{(Prog,[
    Retract(oper,Length(args));
    MacroRuleBase(oper,args);
    MacroRule(oper,Length(args),1025,True)body;
]
);
            Arg(Retract(oper,Length(args)),{Retract(oper,Length(args)),MacroRuleBase(oper,args),MacroRule(oper,Length(args),1025,True)body});
            Enter<builtin>{(Retract,Retract(oper,Length(args)));
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(Retract(oper,Length(args)),True);
            Enter<builtin>{(MacroRuleBase,MacroRuleBase(oper,args));
            Leave}(MacroRuleBase(oper,args),True);
            Enter<builtin>{(MacroRule,MacroRule(oper,Length(args),1025,True)body);
                Enter<builtin>{(Length,Length(args));
                Leave}(Length(args),1);
            Leave}(MacroRule(oper,Length(args),1025,True)body,True);
        Leave}([
    Retract(oper,Length(args));
    MacroRuleBase(oper,args);
    MacroRule(oper,Length(args),1025,True)body;
]
,True);
    Leave}(Function(BenchShow,{expr})[
    Echo({In&gt ,expr});
    WriteString(<font color=ff0000> );
    Echo({Out&gt ,Eval(expr),</font>});
    True;
]
,True);
    Enter<builtin>{(HoldArg,HoldArg(BenchShow,expr));
    Leave}(HoldArg(BenchShow,expr),True);
    Enter<user>{(<--,10#EchoInternal(string _IsString)<--[
    WriteString(string);
]
);
        Arg(10#EchoInternal(string _IsString),10#EchoInternal(string _IsString));
        Arg([
    WriteString(string);
]
,[
    WriteString(string);
]
);
        Enter<builtin>{(Equals,Equals(Type(patternleft),#));
            Enter<builtin>{(Type,Type(patternleft));
            Leave}(Type(patternleft),#);
        Leave}(Equals(Type(patternleft),#),True);
        Enter<builtin>{(Prog,[
    DefinePattern(patternleft[2],patternright,patternleft[1],True);
]
);
            Arg(DefinePattern(patternleft[2],patternright,patternleft[1],True),{DefinePattern(patternleft[2],patternright,patternleft[1],True)});
            Enter<user>{(DefinePattern,DefinePattern(patternleft[2],patternright,patternleft[1],True));
                Enter<user>{(Nth,patternleft[2]);
                    Arg(patternleft,10#EchoInternal(string _IsString));
                    Arg(2,2);
                    Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)));
                        Arg(Equals(IsFunction(alist),True),{Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)});
                        Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                            Enter<builtin>{(IsFunction,IsFunction(alist));
                            Leave}(IsFunction(alist),True);
                        Leave}(Equals(IsFunction(alist),True),True);
                        Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                            Enter<builtin>{(IsInteger,IsInteger(aindex));
                            Leave}(IsInteger(aindex),True);
                        Leave}(Equals(IsInteger(aindex),True),True);
                        Enter<builtin>{(Not,Not Equals(Head(Listify(alist)),Nth));
                            Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                Enter<builtin>{(Head,Head(Listify(alist)));
                                    Enter<builtin>{(Listify,Listify(alist));
                                    Leave}(Listify(alist),{#,10,EchoInternal(string _IsString)});
                                Leave}(Head(Listify(alist)),#);
                            Leave}(Equals(Head(Listify(alist)),Nth),False);
                        Leave}(Not Equals(Head(Listify(alist)),Nth),True);
                    Leave}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)),True);
                    Enter<builtin>{(MathNth,MathNth(alist,aindex));
                    Leave}(MathNth(alist,aindex),EchoInternal(string _IsString));
                Leave}(patternleft[2],EchoInternal(string _IsString));
                Enter<user>{(Nth,patternleft[1]);
                    Arg(patternleft,10#EchoInternal(string _IsString));
                    Arg(1,1);
                    Enter<builtin>{(And,And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)));
                        Arg(Equals(IsFunction(alist),True),{Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)});
                        Enter<builtin>{(Equals,Equals(IsFunction(alist),True));
                            Enter<builtin>{(IsFunction,IsFunction(alist));
                            Leave}(IsFunction(alist),True);
                        Leave}(Equals(IsFunction(alist),True),True);
                        Enter<builtin>{(Equals,Equals(IsInteger(aindex),True));
                            Enter<builtin>{(IsInteger,IsInteger(aindex));
                            Leave}(IsInteger(aindex),True);
                        Leave}(Equals(IsInteger(aindex),True),True);
                        Enter<builtin>{(Not,Not Equals(Head(Listify(alist)),Nth));
                            Enter<builtin>{(Equals,Equals(Head(Listify(alist)),Nth));
                                Enter<builtin>{(Head,Head(Listify(alist)));
                                    Enter<builtin>{(Listify,Listify(alist));
                                    Leave}(Listify(alist),{#,10,EchoInternal(string _IsString)});
                                Leave}(Head(Listify(alist)),#);
                            Leave}(Equals(Head(Listify(alist)),Nth),False);
                        Leave}(Not Equals(Head(Listify(alist)),Nth),True);
                    Leave}(And(Equals(IsFunction(alist),True),Equals(IsInteger(aindex),True),Not Equals(Head(Listify(alist)),Nth)),True);
                    Enter<builtin>{(MathNth,MathNth(alist,aindex));
                    Leave}(MathNth(alist,aindex),10);
                Leave}(patternleft[1],10);
                Arg(patternleft[2],EchoInternal(string _IsString));
                Arg(patternright,[
    WriteString(string);
]
);
                Arg(patternleft[1],10);
                Arg(True,True);
                Enter<builtin>{(Equals,Equals(Type(patternleft),_));
                    Enter<builtin>{(Type,Type(patternleft));
                    Leave}(Type(patternleft),EchoInternal);
                Leave}(Equals(Type(patternleft),_),False);
                Enter<builtin>{(Prog,[
    Local(patternflat,patternvars,patt,patternoper,arity);
    Set(patternflat,Listify(patternleft));
    Set(patternvars,Tail(patternflat));
    Set(patternoper,String(Head(patternflat)));
    Set(arity,Length(patternvars));
    DefLoadFunction(patternoper);
    If(Not RuleBaseDefined(patternoper,arity),[
        MacroRuleBase(patternoper,MakeVector(arg,arity));
]
);
    Set(patt,Pattern'Create(patternvars,postpredicate));
    MacroRulePattern(patternoper,arity,patternprecedence,patt)patternright;
    True;
]
);
                    Arg(Local(patternflat,patternvars,patt,patternoper,arity),{Local(patternflat,patternvars,patt,patternoper,arity),Set(patternflat,Listify(patternleft)),Set(patternvars,Tail(patternflat)),Set(patternoper,String(Head(patternflat))),Set(arity,Length(patternvars)),DefLoadFunction(patternoper),If(Not RuleBaseDefined(patternoper,arity),[
    MacroRuleBase(patternoper,MakeVector(arg,arity));
]
),Set(patt,Pattern'Create(patternvars,postpredicate)),MacroRulePattern(patternoper,arity,patternprecedence,patt)patternright,True});
                    Enter<builtin>{(Local,Local(patternflat,patternvars,patt,patternoper,arity));
                        Arg(patternflat,{patternflat,patternvars,patt,patternoper,arity});
                    Leave}(Local(patternflat,patternvars,patt,patternoper,arity),True);
                    Enter<builtin>{(Set,Set(patternflat,Listify(patternleft)));
                        Enter<builtin>{(Listify,Listify(patternleft));
                        Leave}(Listify(patternleft),{EchoInternal,string _IsString});
                    Leave}(Set(patternflat,Listify(patternleft)),True);
                    Enter<builtin>{(Set,Set(patternvars,Tail(patternflat)));
                        Enter<builtin>{(Tail,Tail(patternflat));
                        Leave}(Tail(patternflat),{string _IsString});
                    Leave}(Set(patternvars,Tail(patternflat)),True);
                    Enter<builtin>{(Set,Set(patternoper,String(Head(patternflat))));
                        Enter<builtin>{(String,String(Head(patternflat)));
                            Enter<builtin>{(Head,Head(patternflat));
                            Leave}(Head(patternflat),EchoInternal);
                        Leave}(String(Head(patternflat)),EchoInternal);
                    Leave}(Set(patternoper,String(Head(patternflat))),True);
                    Enter<builtin>{(Set,Set(arity,Length(patternvars)));
                        Enter<builtin>{(Length,Length(patternvars));
                        Leave}(Length(patternvars),1);
                    Leave}(Set(arity,Length(patternvars)),True);
                    Enter<builtin>{(DefLoadFunction,DefLoadFunction(patternoper));
                    Leave}(DefLoadFunction(patternoper),True);
                    Enter<builtin>{(If,If(Not RuleBaseDefined(patternoper,arity),[
    MacroRuleBase(patternoper,MakeVector(arg,arity));
]
));
                        Arg(Not RuleBaseDefined(patternoper,arity),Not RuleBaseDefined(patternoper,arity));
                        Enter<builtin>{(Not,Not RuleBaseDefined(patternoper,arity));
                            Enter<builtin>{(RuleBaseDefined,RuleBaseDefined(patternoper,arity));
                            Leave}(RuleBaseDefined(patternoper,arity),False);
                        Leave}(Not RuleBaseDefined(patternoper,arity),True);
                        Enter<builtin>{(Prog,[
    MacroRuleBase(patternoper,MakeVector(arg,arity));
]
);
                            Arg(MacroRuleBase(patternoper,MakeVector(arg,arity)),{MacroRuleBase(patternoper,MakeVector(arg,arity))});
                            Enter<builtin>{(MacroRuleBase,MacroRuleBase(patternoper,MakeVector(arg,arity)));
                                Enter<user>{(MakeVector,MakeVector(arg,arity));
                                    Arg(arg,arg);
                                    Arg(arity,1);
                                    Enter<builtin>{(Prog,[
    Local(res,i);
    res:={};
    i:=1;
    Set(dimension,AddN(dimension,1));
    While(LessThan(i,dimension))[
        DestructiveInsert(res,1,Atom(ConcatStrings(String(vec),String(i))));
        Set(i,AddN(i,1));
]
;
    DestructiveReverse(res);
]
);
                                        Arg(Local(res,i),{Local(res,i),res:={},i:=1,Set(dimension,AddN(dimension,1)),While(LessThan(i,dimension))[
    DestructiveInsert(res,1,Atom(ConcatStrings(String(vec),String(i))));
    Set(i,AddN(i,1));
]
,DestructiveReverse(res)});
                                        Enter<builtin>{(Local,Local(res,i));
                                            Arg(res,{res,i});
                                        Leave}(Local(res,i),True);
                                        Enter<user>{(:=,res:={});
                                            Arg(res,res);
                                            Arg({},{});
                                            Enter<builtin>{(IsList,IsList(aLeftAssign));
                                            Leave}(IsList(aLeftAssign),False);
                                            Enter<builtin>{(IsAtom,IsAtom(aLeftAssign));
                                            Leave}(IsAtom(aLeftAssign),True);
                                            Enter<builtin>{(Prog,[
    MacroSet(aLeftAssign,Eval(aRightAssign));
    Eval(aLeftAssign);
]
);
                                                Arg(MacroSet(aLeftAssign,Eval(aRightAssign)),{MacroSet(aLeftAssign,Eval(aRightAssign)),Eval(aLeftAssign)});
                                                Enter<builtin>{(MacroSet,MacroSet(aLeftAssign,Eval(aRightAssign)));
                                                    Enter<builtin>{(Eval,Eval(aRightAssign));
                                                        Enter<builtin>{(List,{});
                                                            Arg(Load test: Result: True  Side Effects: Tracing is on.  Errors: Assertion failed.
BUILD SUCCESSFUL (total time: 1 second)
