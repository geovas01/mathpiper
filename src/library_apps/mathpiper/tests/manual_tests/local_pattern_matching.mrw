%mathpiper
E := A(x,y) + B(x,y,z);
F := Deriv(z) E;
Echo("F: ",F);
G := ( F /: { (Deriv(_var)(_w))_(IsFreeOf(var,w)) <- 0 } );

//G := ( (Deriv(z)A(x,y)) /:  {(Deriv(_var)(_w))_(IsFreeOf(var,w)) <- Echo("KALI ",,,var,,,w)}  );
//G := ( (Deriv(z)A(x,y)) /:  {(Deriv(_var)(_w)) <- Echo("KALI ",,,var,,,w)}  );
                                         // (Deriv(_var)(_x / _y))_(IsFreeOf(var,y)) <-- (Deriv(var) x) / y;
//WriteString("E = ");  Echo(E);
//WriteString("F = ");  Echo(F);
WriteString("G = ");  Echo(G);

/*1 # (Deriv(_var)(_w))_(IsFreeOf(var,w)) <-- 0;
G := Eval(F) ;
WriteString("G = ");  Echo(G);NewLine();
*/


%/mathpiper

    %output,preserve="false"
      Result: True
      
      Side Effects:
      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = 0+(Deriv(z)B(x,y,z))
.   %/output


      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z))

      F: (Deriv(z)A(x,y))+(Deriv(z)B(x,y,z)) 
      G = 0+(Deriv(z)B(x,y,z)) 
      G = Deriv(z)B(x,y,z)





%mathpiper
(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};
%/mathpiper






%mathpiper,output="trace"

//(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};

Retract("LocProcessSingle",*);

40 # LocProcessSingle(pat_IsFunction <- _exp) <-- 
[
    Local(justPattern, postPredicate);
    
    If(Type(pat) = "_",
        [
            justPattern := pat[1];
            postPredicate := pat[2];
        ],
        [
            justPattern := pat;
            postPredicate := True;
        ]
    );
    
    { {justPattern[0],Pattern'Create(justPattern,postPredicate)},exp };
];


//TraceExcept("MacroLocal,ApplyPure,Apply,MapSingle,+,ForEach,*,++,>=,<=,:=,IsUniVar,IsNumber,IsNegativeNumber,For,IsInfinity,IsMatrix,IsNonObject,SubtractN,-,MathSign,IsGeneric,Or,IsString,AbsN,UnFence,LocalSymbols,GreaterThan,Retract,=,UnList,Hold,Equals,IsFunction,Listify,Head,Nth,MathNth,Type,Prog,And,NotEquals,Local,Tail,DefLoadFunction,Not,IsInteger,Set,String,Length,If,List,MakeVector,IsList,LessThan,While,DestructiveReverse,MacroSet,Eval,DestructiveInsert,AddN,IsAtom,Atom,ConcatStrings",  (b + c) * (d + e) /: {(x_IsAtom + _y)_(IsZero(0)) <- Echo(x,,,y)} );


%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: True
.   %/mathpiper_trace







%mathpiper,output="trace"

//(b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)};

Retract("LocProcessSingle",*);

40 # LocProcessSingle(pat_IsFunction <- _exp) <-- 
[
    { {pat[0],Pattern'Create(pat,True)},exp };
];

//10 # LocProcessSingle({_pat,_post,_exp}) <-- { {pat[0],Pattern'Create(pat,post)},exp };

//20 # LocProcessSingle({pat_IsFunction,_exp}) <-- { {pat[0],Pattern'Create(pat,True)},exp };

//30 # LocProcessSingle({pat_IsAtom,_exp}) <-- { pat,exp };

//50 # LocProcessSingle(pat_IsAtom <- _exp) <-- { pat,exp };

TraceExcept("MacroLocal,ApplyPure,Apply,MapSingle,+,ForEach,*,++,>=,<=,:=,IsUniVar,IsNumber,IsNegativeNumber,For,IsInfinity,IsMatrix,IsNonObject,SubtractN,-,MathSign,IsGeneric,Or,IsString,AbsN,UnFence,LocalSymbols,GreaterThan,Retract,=,UnList,Hold,Equals,IsFunction,Listify,Head,Nth,MathNth,Type,Prog,And,NotEquals,Local,Tail,DefLoadFunction,Not,IsInteger,Set,String,Length,If,List,MakeVector,IsList,LessThan,While,DestructiveReverse,MacroSet,Eval,DestructiveInsert,AddN,IsAtom,Atom,ConcatStrings",  (b + c) * (d + e) /: {(x_IsAtom + _y) <- Echo(x,,,y)} );


%/mathpiper










