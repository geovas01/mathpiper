%mathpiper,def="Nth;NrArgs;IsNonObject;Numer;Denom;NormalForm;++;--;TableForm;=;!=;+-;/-;*-;^-;:=-;:=+;&;|;%;if;else;N;NonN;InNumericMode;V;InVerboseMode"

/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */


/* Implementation of Nth that allows extending. */
RuleBase("Nth",{alist,aindex});
Rule("Nth",2,10,
    And(Equals(IsFunction(alist),True),
            Equals(IsInteger(aindex),True),
            Not(Equals(Head(Listify(alist)),Nth))
            ))
     MathNth(alist,aindex);




Rule("Nth",2,14,
     And(Equals(IsString(alist),True),IsList(aindex))
    )
[
  Local(result);
  result:="";
  ForEach(i,aindex) [ result := result : StringMidGet(i,1,alist); ];
  result;
];

Rule("Nth",2,15,Equals(IsString(alist),True))
[
  StringMidGet(aindex,1,alist);
];


Rule("Nth",2,20,Equals(IsList(aindex),True))
[
  Map({{ii},alist[ii]},{aindex});
];

Rule("Nth",2,30,
   And(
           Equals(IsGeneric(alist),True),
           Equals(GenericTypeName(alist),"Array"),
           Equals(IsInteger(aindex),True)
          )
    )
[
  ArrayGet(alist,aindex);
];



Rule("Nth",2,40,Equals(IsString(aindex),True))
[
  Local(as);
  as := Assoc(aindex,alist);
  If (Not(Equals(as,Empty)),Set(as,Nth(as,2)));
  as;
];

Function("NrArgs",{aLeft}) Length(Listify(aLeft))-1;

10 # IsNonObject(Object(_x)) <-- False;
20 # IsNonObject(_x)         <-- True;

1 # Numer(_x / _y)      <-- x;
2 # Numer(x_IsNumber)   <-- x;
1 # Denom(_x / _y)      <-- y;
2 # Denom(x_IsNumber)   <-- 1;

/* Implementation of numeric mode */
LocalSymbols(Numeric) [
  Set(Numeric,False);



  // evaluate numerically with given precision
  LocalSymbols(prev'Numeric, prev'digits, numeric'result) Macro("N",{expr,digits})
  [ // we were in non-numeric mode
      Local(prev'Numeric, prev'digits, numeric'result,errorString);
      Set(prev'digits, BuiltinPrecisionGet());
      BuiltinPrecisionSet(@digits);
      AssignCachedConstantsN();
      Set(prev'Numeric,Numeric);
      Set(Numeric, True);
      Set(errorString,"");
      TrapError(Set(numeric'result, Eval(@expr)),Set(errorString,GetCoreError()));
      Set(Numeric,prev'Numeric);
      If(Not Numeric,[
          // clear constants
          ClearCachedConstantsN();
      ]);
      BuiltinPrecisionSet(prev'digits);
      Check(errorString="",errorString);
      numeric'result;
  ];

  LocalSymbols(dig,ex) Macro("N",{expr})
  [
    Local(dig,ex);
    Set(dig,BuiltinPrecisionGet());
    Set(ex,Hold(@expr));
    `N(@ex,@dig);
  ];






  LocalSymbols(result) Macro("NonN",{expr})
  [
    Local(result);
    GlobalPush(Numeric);
    Numeric := False;
    result := (@expr);
    Numeric := GlobalPop();
    result;
  ];

  Function("InNumericMode",{}) Numeric;

]; //LocalSymbols(Numeric)

LocalSymbols(Verbose) [
  Set(Verbose,False);
  Function("V",{aNumberBody})
  [
    Local(prevVerbose,result);
    Set(prevVerbose,Verbose);
    Set(Verbose,True);
    Set(result,Eval(aNumberBody));
    Set(Verbose,prevVerbose);
    result;
  ];
  Function("InVerboseMode",{}) Verbose;

]; // LocalSymbols(Verbose)
HoldArg("V",aNumberBody);
UnFence("V",1);

Function("++",{aVar})
[
   MacroSet(aVar,AddN(Eval(aVar),1));
];
UnFence("++",1);
HoldArg("++",aVar);


Function("--",{aVar})
[
   MacroSet(aVar,SubtractN(Eval(aVar),1));
];
UnFence("--",1);
HoldArg("--",aVar);


Function("TableForm",{list})
[
  Local(i);
  ForEach(i,list)
  [
    Write(i);
    NewLine();
  ];
  True;
];

RuleBase("NormalForm",{expression});
Rule("NormalForm",1,1000,True) expression;




RuleBase("=",{left,right});
RuleBase("!=",{left,right});


a_IsNonNegativeInteger & b_IsNonNegativeInteger <-- BitAnd(a,b);
a_IsNonNegativeInteger | b_IsNonNegativeInteger <-- BitOr(a,b);
a_IsNonNegativeInteger % b_IsPositiveInteger <-- Mod(a,b);

RuleBase("if",{predicate,body});
(if(True) _body) <-- Eval(body);
HoldArg("if",body);
UnFence("if",2);

RuleBase("else",{ifthen,otherwise});
0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) == True) <--
     Eval(body);
0 # (if (_predicate) _body else _otherwise)_(Eval(predicate) == False) <--
     Eval(otherwise);
1 # (if (_predicate) _body else _otherwise) <--
    UnList({Atom("else"),
            UnList({Atom("if"), (Eval(predicate)), body}),
            otherwise});
HoldArg("else",ifthen);
HoldArg("else",otherwise);
UnFence("else",2);

%/mathpiper



%mathpiper_docs,name="N"
*CMD N --- try determine numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {Yacas} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make Yacas
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only 
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Pi
%/mathpiper_docs



%mathpiper_docs,name="Numer"
*CMD Numer --- numerator of an expression
*STD
*CALL
	Numer(expr)

*PARMS

{expr} -- expression to determine numerator of

*DESC

This function determines the numerator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns this number. If "expr" is neither
rational nor numeric, the function returns unevaluated.

*E.G.

	In> Numer(2/7)
	Out> 2;
	In> Numer(a / x^2)
	Out> a;
	In> Numer(5)
	Out> 5;

*SEE Denom, IsRational, IsNumber
%/mathpiper_docs



%mathpiper_docs,name="Denom"
*CMD Denom --- denominator of an expression
*STD
*CALL
	Denom(expr)

*PARMS

{expr} -- expression to determine denominator of

*DESC

This function determines the denominator of the rational expression
"expr" and returns it. As a special case, if its argument is numeric
but not rational, it returns {1}. If "expr" is
neither rational nor numeric, the function returns unevaluated.

*E.G.

	In> Denom(2/7)
	Out> 7;
	In> Denom(a / x^2)
	Out> x^2;
	In> Denom(5)
	Out> 1;

*SEE Numer, IsRational, IsNumber
%/mathpiper_docs



%mathpiper_docs,name="V;InVerboseMode"
*CMD V, InVerboseMode --- set verbose output mode
*STD
*CALL
	V(expression)
	InVerboseMode()

*PARMS

{expression} -- expression to be evaluated in verbose mode

*DESC

The function {V(expression)} will evaluate the expression in 
verbose mode. Various parts of Yacas can show extra information
about the work done while doing a calculation when using {V}.

In verbose mode, {InVerboseMode()} will return {True}, otherwise
it will return {False}.

*E.G. notest

	In> OldSolve({x+2=0},{x})
	Out> {{-2}};
	In> V(OldSolve({x+2=0},{x}))
	Entering OldSolve
	From  x+2=0  it follows that  x  = -2 
	   x+2=0  simplifies to  True 
	Leaving OldSolve
	Out> {{-2}};
	In> InVerboseMode()
	Out> False
	In> V(InVerboseMode())
	Out> True

*SEE Echo, N, OldSolve
%/mathpiper_docs



%mathpiper_docs,name="Nth"
*CMD Nth --- return the $n$-th element of a list
*CORE
*CALL
	Nth(list, n)

*PARMS

{list} -- list to choose from

{n} -- index of entry to pick

*DESC

The entry with index "n" from "list" is returned. The first entry
has index 1. It is possible to pick several entries of the list by
ta<= "n" to be a list of indices.

More generally, {Nth} returns the n-th operand of the
expression passed as first argument.

An alternative but equivalent form of {Nth(list, n)} is
{list[n]}.

*E.G.

	In> lst := {a,b,c,13,19};
	Out> {a,b,c,13,19};
	In> Nth(lst, 3);
	Out> c;
	In> lst[3];
	Out> c;
	In> Nth(lst, {3,4,1});
	Out> {c,13,a};
	In> Nth(b*(a+c), 2);
	Out> a+c;

*SEE Select, Nth
%/mathpiper_docs



%mathpiper_docs,name="NrArgs"
*CMD NrArgs --- return number of top-level arguments
*STD
*CALL
	NrArgs(expr)

*PARMS

{expr} -- expression to examine

*DESC

This function evaluates to the number of top-level arguments of the
expression "expr". The argument "expr" may not be an atom, since
that would lead to an error.

*E.G.

	In> NrArgs(f(a,b,c))
	Out> 3;
	In> NrArgs(Sin(x));
	Out> 1;
	In> NrArgs(a*(b+c));
	Out> 2;

*SEE Type, Length
%/mathpiper_docs



%mathpiper_docs,name="TableForm"
*CMD TableForm --- print each entry in a list on a line
*STD
*CALL
	TableForm(list)

*PARMS

{list} -- list to print

*DESC

This functions writes out the list {list} in a better readable form, by
printing every element in the list on a separate line.

*E.G.

	In> TableForm(Table(i!, i, 1, 10, 1));

	1
	 2
	 6
	 24
	 120
	 720
	 5040
	 40320
	 362880
	 3628800
	Out> True;

*SEE PrettyForm, Echo, Table
%/mathpiper_docs



%mathpiper_docs,name="IsNonObject"
*CMD IsNonObject --- test whether argument is not an {Object()}
*STD
*CALL
	IsNonObject(expr)

*PARMS

{expr} -- the expression to examine

*DESC

This function returns {True} if "expr" is not of
the form {Object(...)} and {False}
otherwise.

*HEAD Bugs

In fact, the result is always {True}.

*SEE Object
%/mathpiper_docs



%mathpiper_docs,name="++"
*CMD ++ --- increment variable
*STD
*CALL
	var++

*PARMS

{var} -- variable to increment

*DESC

The variable with name "var" is incremented, i.e. the number 1 is
added to it. The expression {x++} is equivalent to
the assignment {x := x + 1}, except that the
assignment returns the new value of {x} while {x++} always returns true. In this respect, Yacas' {++} differs from the corresponding operator in the
programming language C.

*E.G.

	In> x := 5;
	Out> 5;
	In> x++;
	Out> True;
	In> x;
	Out> 6;

*SEE --, :=
%/mathpiper_docs



%mathpiper_docs,name="--"
*CMD -- --- decrement variable
*STD
*CALL
	var--

*PARMS

{var} -- variable to decrement

*DESC

The variable with name "var" is decremented, i.e. the number 1 is
subtracted from it. The expression {x--} is
equivalent to the assignment {x := x - 1}, except
that the assignment returns the new value of {x}
while {x--} always returns true. In this respect,
Yacas' {--} differs from the corresponding operator
in the programming language C.

*E.G.

	In> x := 5;
	Out> 5;
	In> x--;
	Out> True;
	In> x;
	Out> 4;

*SEE ++, :=
%/mathpiper_docs



%mathpiper_docs,name="InNumericMode;NonN"
*CMD InNumericMode --- determine if currently in numeric mode
*CMD NonN --- calculate part in non-numeric mode

*STD
*CALL
	NonN(expr)
	InNumericMode()
*PARMS

{expr} -- expression to evaluate

{prec} -- integer, precision to use

*DESC

When in numeric mode, {InNumericMode()} will return {True}, else it will
return {False}. {Yacas} is in numeric mode when evaluating an expression
with the function {N}. Thus when calling {N(expr)}, {InNumericMode()} will
return {True} while {expr} is being evaluated.

{InNumericMode()} would typically be used to define a transformation rule 
that defines how to get a numeric approximation of some expression. One
could define a transformation rule

	f(_x)_InNumericMode() <- [... some code to get a numeric approximation of f(x) ... ];

{InNumericMode()} usually returns {False}, so transformation rules that check for this
predicate are usually left alone.

When in numeric mode, {NonN} can be called to switch back to non-numeric
mode temporarily.

{NonN} is a macro. Its argument {expr} will only 
be evaluated after the numeric mode has been set appropriately.

*E.G.

	In> InNumericMode()
	Out> False
	In> N(InNumericMode())
	Out> True
	In> N(NonN(InNumericMode()))
	Out> False

*SEE N, Builtin'Precision'Set, Builtin'Precision'Get, Pi, CachedConstant
%/mathpiper_docs
