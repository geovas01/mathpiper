%mathpiper,def="N;NonN;InNumericMode"

//"+-;/-;*-;^-;:=-;:=+" These were in the def list.

/* See the documentation on the assignment of the precedence of the rules.
 */

/* Some very basic functions that are used always any way... */







/* Implementation of numeric mode */
LocalSymbols(Numeric) [
  Set(Numeric,False);



  // evaluate numerically with given precision
  LocalSymbols(prev'Numeric, prev'digits, numeric'result) Macro("N",{expr,digits})
  [ // we were in non-numeric mode
      Local(prev'Numeric, prev'digits, numeric'result,errorString);
      Set(prev'digits, BuiltinPrecisionGet());
      BuiltinPrecisionSet(@digits);
      AssignCachedConstantsN();
      Set(prev'Numeric,Numeric);
      Set(Numeric, True);
      Set(errorString,"");
      TrapError(Set(numeric'result, Eval(@expr)),Set(errorString,GetCoreError()));
      Set(Numeric,prev'Numeric);
      If(Not Numeric,[
          // clear constants
          ClearCachedConstantsN();
      ]);
      BuiltinPrecisionSet(prev'digits);
      Check(errorString="",errorString);
      numeric'result;
  ];

  LocalSymbols(dig,ex) Macro("N",{expr})
  [
    Local(dig,ex);
    Set(dig,BuiltinPrecisionGet());
    Set(ex,Hold(@expr));
    `N(@ex,@dig);
  ];






  LocalSymbols(result) Macro("NonN",{expr})
  [
    Local(result);
    GlobalPush(Numeric);
    Numeric := False;
    result := (@expr);
    Numeric := GlobalPop();
    result;
  ];

  Function("InNumericMode",{}) Numeric;

]; //LocalSymbols(Numeric)






%/mathpiper






%mathpiper_docs,name="N",categories="User Functions;Numbers (Operations)"
*CMD N --- try determine numerical approximation of expression

*STD
*CALL
	N(expression)
	N(expression, precision)
*PARMS

{expression} -- expression to evaluate

{precision} -- integer, precision to use

*DESC

The function {N} instructs {MathPiper} to try to coerce an expression in to a numerical approximation to the
expression {expr}, using {prec} digits precision if the second calling
sequence is used, and the default precision otherwise. This overrides the normal
behaviour, in which expressions are kept in symbolic form (eg. {Sqrt(2)} instead of {1.41421}).

Application of the {N} operator will make MathPiper
calculate floating point representations of functions whenever
possible. In addition, the variable {Pi} is bound to
the value of $Pi$ calculated at the current precision.
(This value is a "cached constant", so it is not recalculated each time {N} is used, unless the precision is increased.)


{N} is a macro. Its argument {expr} will only 
be evaluated after switching to numeric mode.

*E.G.

	In> 1/2
	Out> 1/2;
	In> N(1/2)
	Out> 0.5;
	In> Sin(1)
	Out> Sin(1);
	In> N(Sin(1),10)
	Out> 0.8414709848;
	In> Pi
	Out> Pi;
	In> N(Pi,20)
	Out> 3.14159265358979323846;

*SEE Pi
%/mathpiper_docs



















%mathpiper_docs,name="InNumericMode;NonN"
*CMD InNumericMode --- determine if currently in numeric mode
*CMD NonN --- calculate part in non-numeric mode

*STD
*CALL
	NonN(expr)
	InNumericMode()
*PARMS

{expr} -- expression to evaluate

{prec} -- integer, precision to use

*DESC

When in numeric mode, {InNumericMode()} will return {True}, else it will
return {False}. {MathPiper} is in numeric mode when evaluating an expression
with the function {N}. Thus when calling {N(expr)}, {InNumericMode()} will
return {True} while {expr} is being evaluated.

{InNumericMode()} would typically be used to define a transformation rule 
that defines how to get a numeric approximation of some expression. One
could define a transformation rule

	f(_x)_InNumericMode() <- [... some code to get a numeric approximation of f(x) ... ];

{InNumericMode()} usually returns {False}, so transformation rules that check for this
predicate are usually left alone.

When in numeric mode, {NonN} can be called to switch back to non-numeric
mode temporarily.

{NonN} is a macro. Its argument {expr} will only 
be evaluated after the numeric mode has been set appropriately.

*E.G.

	In> InNumericMode()
	Out> False
	In> N(InNumericMode())
	Out> True
	In> N(NonN(InNumericMode()))
	Out> False

*SEE N, Builtin'Precision'Set, Builtin'Precision'Get, Pi, CachedConstant
%/mathpiper_docs
