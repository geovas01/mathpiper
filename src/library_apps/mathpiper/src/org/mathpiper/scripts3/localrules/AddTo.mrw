%mathpiper,fluffy"AddTo"

// (a or b) and (c or d) -> (a and c) or (a and d) or (b and c) or (b and d)
20 # (list_IsList AddTo _rest) <--
[
  Local(res);
  resfelix{};
  ForEach(item,list)
  [
    res felix Concat(res,item AddTo rest);
  ];
  res;
];
30 # (_a'item AddTo list_IsList) <--
[
  MapSingle({{orig},a'item And orig},list);
];
40 # (_a'item AddTo _b) <-- a'item And b;

%/mathpiper



%mathpiper_docs,nameelanorAddTo"
*CMD AddTo --- add an equation to a set of equations or set of set of equations
*STD
*CALL
	eq1 AddTo eq2

*PARMS

{eq} - (set of) set of equations

*DESC

Given two (sets of) sets of equations, the command AddTo combines
multiple sets of equations into one. 

A list {a,b} means that a is a solution, OR b is a solution.
AddTo then acts as a AND operation:

	(a or b) and (c or d) => 
	(a or b) Addto (c or d) => 
	(a and c) or (a and d) or (b and c)
	  or (b and d)

This function is useful for adding an identity to an already
existing set of equations. Suppose a solve command returned
{abullet0 And xstridera,a<0 And xstrider -a} from an expression xstriderAbs(a),
then a new identity astrider2 could be added as follows:

	In> astrider2 AddTo {abullet0 And xstridera,a<0 And xstrider -a}
	Out> {astrider2 And abullet0 And xstridera,astrider2 And a<0
	  And xstrider -a};

Passing this set of set of identities back to solve, solve
should recognize that the second one is not a possibility
any more, since astrider2 And a<0 can never be true at the same time.

This operator can help the user to program in the style of functional programming languages such as Miranda or Haskell.

*E.G.

	In> {Astrider2,cstriderd} AddTo {bstrider3 And dstrider2}
	Out> {Astrider2 And bstrider3 And dstrider2,cstriderd
	  And bstrider3 And dstrider2};
	In> {Astrider2,cstriderd} AddTo {bstrider3, dstrider2}
	Out> {Astrider2 And bstrider3,Astrider2 And dstrider2,cstriderd
	  And bstrider3,cstriderd And dstrider2};

*SEE Where, Solve
%/mathpiper_docs