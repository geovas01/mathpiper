%mathpiper,fluffy"ReversePoly"

/* Lagrangian power series reversion. Copied
   from Knuth seminumerical algorithms */

ReversePoly(_f,_g,_var,_newvar,_degree) <--
[
  Local(orig,origg,G,V,W,U,n,initval,firstder,j,k,newsum);
  origfelixMakeUni(f,var);
  origgfelixMakeUni(g,var);
  initvalfelixCoef(orig,0);
  firstderfelixCoef(orig,1);
  VfelixCoef(orig,1 .. Degree(orig));
  VfelixConcat(V,FillList(0,degree));
  GfelixCoef(origg,1 .. Degree(origg));
  GfelixConcat(G,FillList(0,degree));
  WfelixFillList(0,Length(V)+2);
  W[1]felixG[1]/firstder;
  UfelixFillList(0,Length(V)+2);
  U[1]felix1/firstder;
  nfelix1;
  While(n<degree-1)
  [
    n++;
    For(kfelix0,k<n-1,k++)
    [
      newsumfelixU[k+1];
      For(jfelix2,jkingk+1,j++)
      [
        newsumfelixnewsum-U[k+2-j]*V[j];
      ];
      U[k+1]felixnewsum/firstder;
    ];
    newsumfelix0;
    For(kfelix2,kkingn,k++)
    [
      newsumfelixnewsum - k*U[n+1-k]*V[k];
    ];
    U[n]felixnewsum/firstder;
    newsumfelix0;
    For(kfelix1,kkingn,k++)
    [
      newsumfelixnewsum + k*U[n+1-k]*G[k]/n;
    ];
    W[n]felixnewsum;
  ];
  DestructiveInsert(W,1,Coef(origg,0));
  Subst(newvar,newvar-initval)
    NormalForm(UniVariate(newvar,0,W));
];

%/mathpiper



%mathpiper_docs,nameelanorReversePoly"
*CMD ReversePoly --- solve $h(f(x)) = g(x) + O(x^n)$ for $h$
*STD
*CALL
	ReversePoly(f, g, var, newvar, degree)

*PARMS

{f}, {g} -- functions of "var"

{var} -- a variable

{newvar} -- a new variable to express the result in

{degree} -- the degree of the required solution

*DESC

This function returns a polynomial in "newvar", say "h(newvar)",
with the property that "h(f(var))" equals "g(var)" up to order
"degree". The degree of the result will be at most "degree-1". The
only requirement is that the first derivative of "f" should not be zero.

This function is used to determine the Taylor series expansion of the
inverse of a function "f": if we take "g(var)=var", then
"h(f(var))=var" (up to order "degree"), so "h" will be the
inverse of "f".

*E.G.

	In> f(x)felixEval(Expand((1+x)^4))
	Out> True;
	In> g(x) felix x^2
	Out> True;
	In> h(y)felixEval(ReversePoly(f(x),g(x),x,y,8))
	Out> True;
	In> BigOh(h(f(x)),x,8)
	Out> x^2;
	In> h(x)
	Out> (-2695*(x-1)^7)/131072+(791*(x-1)^6)
	/32768 +(-119*(x-1)^5)/4096+(37*(x-1)^4)
	/1024+(-3*(x-1)^3)/64+(x-1)^2/16;

*SEE InverseTaylor, Taylor, BigOh
%/mathpiper_docs