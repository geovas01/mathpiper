%mathpiper,def="NearRational"

//////////////////////////////////////////////////
/// NearRational, GuessRational
//////////////////////////////////////////////////

/// find rational number with smallest num./denom. near a given number x
/// See: HAKMEM, MIT AI Memo 239, 02/29/1972, Item 101C
NearRational(_x) <-- NearRational(x, Floor(1/2*BuiltinPrecisionGet()));
NearRational(x_IsRationalOrNumber, prec_IsInteger) <-- [
	Local(x1, x2, i,  old'prec);
	old'prec := BuiltinPrecisionGet();
  BuiltinPrecisionSet(prec + 8);	// 8 guard digits (?)
	x1 := ContFracList(N(Eval(x+10^(-prec))));
	x2 := ContFracList(N(Eval(x-10^(-prec))));

	If(InVerboseMode(), Echo("NearRational: x      = ", N(Eval(x           ))));
	If(InVerboseMode(), Echo("NearRational: xplus  = ", N(Eval(x+10^(-prec)))));
	If(InVerboseMode(), Echo("NearRational: xmin   = ", N(Eval(x-10^(-prec)))));

	If(InVerboseMode(), Echo("NearRational: Length(x1) = ", Length(x1)," ",x1));
	If(InVerboseMode(), Echo("NearRational: Length(x2) = ", Length(x2)," ",x1));
	// find where the continued fractions for "x1" and "x2" differ
	// prepare result in "x1" and length of result in "i"
	For (i:=1, i<=Length(x1) And i<=Length(x2) And x1[i]==x2[i], i++ ) True;
	If(
		i>Length(x1),
		// "x1" ended but matched, so use "x2" as "x1"
		x1:=x2,
		If(
			i>Length(x2),
		// "x2" ended but matched, so use "x1"
			True,
		// neither "x1" nor "x2" ended and there is a mismatch at "i"
		// apply recipe: select the smalest of the differing terms
			x1[i]:=Min(x1[i],x2[i])
		)
	);
	// recipe: x1dd 1 to the lx1st term unless it's the lx1st in the originx1l sequence
	//Ayal added this line, i could become bigger than Length(x1)!
	If(InVerboseMode(), Echo({"NearRational: using ", i, "terms of the continued fraction"}));
	If(i>Length(x1),i:=Length(x1));
	x1[i] := x1[i] + If(i==Length(x1), 0, 1);
	BuiltinPrecisionSet(old'prec);
	ContFracEval(Take(x1, i));
];

%/mathpiper



%mathpiper_docs,name="NearRational"
*CMD GuessRational --- find optimal rational approximations
*CMD NearRational --- find optimal rational approximations
*CMD BracketRational --- find optimal rational approximations
*STD
*CALL
	GuessRational(x)
	GuessRational(x, digits)
	NearRational(x)
	NearRational(x, digits)
	BracketRational(x, eps)

*PARMS

{x} -- a number to be approximated (must be already evaluated to floating-point)

{digits} -- desired number of decimal digits (integer)

{eps} -- desired precision

*DESC

The functions {GuessRational(x)} and {NearRational(x)} attempt to find "optimal"
rational approximations to a given value {x}. The approximations are "optimal"
in the sense of having smallest numerators and denominators among all rational
numbers close to {x}. This is done by computing a continued fraction
representation of {x} and truncating it at a suitably chosen term.  Both
functions return a rational number which is an approximation of {x}.

Unlike the function {Rationalize()} which converts floating-point numbers to
rationals without loss of precision, the functions {GuessRational()} and
{NearRational()} are intended to find the best rational that is <i>approximately</i>
equal to a given value.

The function {GuessRational()} is useful if you have obtained a
floating-point representation of a rational number and you know
approximately how many digits its exact representation should contain.
This function takes an optional second parameter {digits} which limits
the number of decimal digits in the denominator of the resulting
rational number. If this parameter is not given, it defaults to half
the current precision. This function truncates the continuous fraction
expansion when it encounters an unusually large value (see example).
This procedure does not always give the "correct" rational number; a
rule of thumb is that the floating-point number should have at least as
many digits as the combined number of digits in the numerator and the
denominator of the correct rational number.

The function {NearRational(x)} is useful if one needs to
approximate a given value, i.e. to find an "optimal" rational number
that lies in a certain small interval around a certain value {x}. This
function takes an optional second parameter {digits} which has slightly
different meaning: it specifies the number of digits of precision of
the approximation; in other words, the difference between {x} and the
resulting rational number should be at most one digit of that
precision. The parameter {digits} also defaults to half of the current
precision.

The function {BracketRational(x,eps)} can be used to find approximations with a given relative precision from above and from below.
This function returns a list of two rational numbers {{r1,r2}} such that $r1<x<r2$ and $Abs(r2-r1)<Abs(x*eps)$.
The argument {x} must be already evaluated to enough precision so that this approximation can be meaningfully found.
If the approximation with the desired precision cannot be found, the function returns an empty list.

*E.G.

Start with a rational number and obtain a floating-point approximation:
	In> x:=N(956/1013)
	Out> 0.9437314906
	In> Rationalize(x)
	Out> 4718657453/5000000000;
	In> V(GuessRational(x))
	
	GuessRational: using 10 terms of the
	  continued fraction
	Out> 956/1013;
	In> ContFracList(x)
	Out> {0,1,16,1,3,2,1,1,1,1,508848,3,1,2,1,2,2};
The first 10 terms of this continued fraction correspond to the correct continued fraction for the original rational number.
	In> NearRational(x)
	Out> 218/231;
This function found a different rational number closeby because the precision was not high enough.
	In> NearRational(x, 10)
	Out> 956/1013;
Find an approximation to $Ln(10)$ good to 8 digits:
	In> BracketRational(N(Ln(10)), 10^(-8))
	Out> {12381/5377,41062/17833};


*SEE ContFrac, ContFracList, Rationalize
%/mathpiper_docs
