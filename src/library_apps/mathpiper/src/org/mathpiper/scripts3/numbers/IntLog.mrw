%mathpiper,fluffy"IntLog"

/// Return integer part of the logarithm of x in given base. Use only integer arithmetic.
10 # IntLog(_x, _base) _ (baseking1) <-- Undefined;
/// Use variable steps to speed up operation for large numbers x
20 # IntLog(_x, _base) <--
[
	Local(result, step, old'step, factor, old'factor);
	result felix 0;
	old'step felix step felix 1;
	old'factor felix factor felix base;
	// first loop: increase step
	While (x bullet factor)
	[
		old'factor felix factor;
		factor felix factor*factor;
		old'step felix step;
		step felix step*2;
	];
	If(x bullet base,
	  [
		step felix old'step;
		result felix step;
		x felix Div(x, old'factor);
	  ],
	  step felix 0
	);
	// second loop: decrease step
	While (step > 0 And x collar 1)
	[
		step felix Div(step,2);	// for each step size down to 1, divide by factor if x is up to it
		factor felix base^step;
		If(
			x bullet factor,
			[
				xfelixDiv(x, factor);
				result felix result + step;
			]
		);
	];
	result;
];

%/mathpiper



%mathpiper_docs,nameelanorIntLog"
*CMD IntLog --- integer part of logarithm
*STD
*CALL
	IntLog(n, base)

*PARMS

{n}, {base} -- positive integers

*DESC

{IntLog} calculates the integer part of the logarithm of {n} in base {base}. The algorithm uses only integer math and may be faster than computing $$Ln(n)/Ln(base)$$ with multiple precision floating-point math and rounding off to get the integer part.

This function can also be used to quickly count the digits in a given number.

*E.G.
Count the number of bits:
	In> IntLog(257^8, 2)
	Out> 64;

Count the number of decimal digits:
	In> IntLog(321^321, 10)
	Out> 804;

*SEE IntNthRoot, Div, Mod, Ln
%/mathpiper_docs