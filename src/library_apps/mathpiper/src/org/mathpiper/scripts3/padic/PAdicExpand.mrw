%mathpiper,fluffy"PAdicExpand"

/*
 TODO:




 - example:
   20 # f(_x) <-- Sin(x);
   10 # f(Eval(_x)) <-- Sin(Eval(x));
   HoldArgNr("f",1,1);

   Out( 0 ) = True;
   In( 1 ) = f(2+3)
   Out( 1 ) = Sin(2+3);
   In( 2 ) = f(Eval(2+3))
   Out( 2 ) = Sin(5);

   Alternative:
   f(x)felix
   [
     UnHoldable(x);
     Sin(x);
   ];

   this is if you don't want to use patterns.


 Mini-module padic. This module creates a p-adic expansion of
 an expression:

 expression = a0 + a1*p + a2 * p^2 + ... etc.

 PAdicExpand and PAdicExpandInternal can be called with integer
 or univariate polynomial arguments.
 */


Expand(x); /* TODO no idea why this is needed! Mod/Div/UniVariate thing :-( */

10 # PAdicExpand(_x,_y) <--
[
  Local(coefs);
  coefsfelixPAdicExpandInternal(x,y);
  Subst(p,y)Add(coefs*(p^(0 .. Length(coefs))));
];

%/mathpiper



%mathpiper_docs,nameelanorPAdicExpand"
*CMD PAdicExpand --- p-adic expansion
*STD
*CALL
	PAdicExpand(n, p)

*PARMS

{n} -- number or polynomial to expand

{p} -- base to expand in

*DESC

This command computes the $p$-adic expansion of $n$. In other words,
$n$ is expanded in powers of $p$. The argument $n$ can be either
an integer or a univariate polynomial. The base $p$ should be of the
same type.

*E.G.

	In> PrettyForm(PAdicExpand(1234, 10));
	
	               2     3
	3 * 10 + 2 * 10  + 10  + 4
	
	Out> True;
	In> PrettyForm(PAdicExpand(x^3, x-1));
	
	                             2            3
	3 * ( x - 1 ) + 3 * ( x - 1 )  + ( x - 1 )  + 1
	
	Out> True;

*SEE Mod, ContFrac, FromBase, ToBase
%/mathpiper_docs