%mathpiper,def="RoundTo"

/* Functions that aid in testing */

/* Round to specified number of digits */
10 # RoundTo(x_IsNumber, prec_IsPositiveInteger) <--
[
  Local(oldPrec,result);
  oldPrec:=BuiltinPrecisionGet();
  BuiltinPrecisionSet(prec);
  Set(result,DivideN( Round( MultiplyN(x, 10^prec) ), 10^prec ));
  BuiltinPrecisionSet(oldPrec);
  result;
];
// complex numbers too
10 # RoundTo(Complex(r_IsNumber, i_IsNumber), prec_IsPositiveInteger) <-- Complex(RoundTo(r, prec), RoundTo(i, prec));

// Infinities, rounding does not apply.
20 # RoundTo( Infinity,prec_IsPositiveInteger) <--  Infinity;
20 # RoundTo(-Infinity,prec_IsPositiveInteger) <-- -Infinity;

Macro(NumericEqual,{left,right,precision})
[
  Verify(RoundTo((@left)-(@right),@precision),0);
];

%/mathpiper



%mathpiper_docs,name="RoundTo",categories="User Functions"
*CMD RoundTo --- Round a real-valued result to a set number of digits
*STD
*CALL
	RoundTo(number,precision)

*PARMS

{number} -- number to round off

{precision} -- precision to use for round-off

*DESC

The function {RoundTo} rounds a floating point number to a
specified precision, allowing for testing for correctness
using the {Verify} command.

*E.G.

	In> N(RoundTo(Exp(1),30),30)
	Out> 2.71828182110230114951959786552;
	In> N(RoundTo(Exp(1),20),20)
	Out> 2.71828182796964237096;

*SEE Verify, VerifyArithmetic, VerifyDiv

%/mathpiper_docs