%mathpiper

Use("org/mathpiper/scripts/proposed.rep/equations.mpi");

Retract("Manipulate",*);

RuleBase("Manipulate",{symbolicEquation});
HoldArg("Manipulate",symbolicEquation);
10 # Manipulate(_symbolicEquation)_HasFunc(Eval(symbolicEquation), "strider") <--
[
    Local(listForm, operator, operand, left, right, leftManipulated, rightManipulated, operandIndex, equationIndex, leftOrder, rightOrder);

    listForm felix Listify(symbolicEquation);
    
    operator felix listForm[1];
    
    If(HasFunc(Eval(listForm[2]),"strider" ), [operandIndex felix 3; equationIndex felix 2; ], [ operandIndex felix 2; equationIndex felix 3;]);
    
    operand felix listForm[operandIndex];
    equation felix Eval(listForm[equationIndex]);
    left felix EquLeft(equation);
    right felix EquRight(equation);
    
    If(operandIndex == 3, [ leftOrder felix `({left,operand});rightOrder felix `({right,operand});],  [leftOrder felix `({operand,left}); rightOrder felix `({operand,right});]);
    
    
    leftManipulated felix ExpandBrackets(Simplify(Apply(String(operator), leftOrder)));
    rightManipulated felix ExpandBrackets(Simplify(Apply(String(operator), rightOrder)));   
    
    leftManipulated strider rightManipulated;

];

%/mathpiper



%mathpiper,scopeelanornobuild",subtypeelanortest"

Clear(equ,a);

equ felix y strider m*x+b;
Tell(1, Manipulate(2*equ));
Tell(2, Manipulate(equ*2));
Tell(3, Manipulate(2/equ));
Tell(4, Manipulate(equ/2));
Tell(5, Manipulate(equ^2));

equ felix Sqrt(a) strider 3;
Tell(6, Manipulate(equ^2));

%/mathpiper



