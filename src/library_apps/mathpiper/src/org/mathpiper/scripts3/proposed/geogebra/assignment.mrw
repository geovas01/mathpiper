%mathpiper

Retract(":",*);

Infix(":",10000);
RightAssociative(":");

/* := assignment. */
RuleBase(":",{aLeftAssign,aRightAssign});
UnFence(":",2);
HoldArg(":",aLeftAssign);
HoldArg(":",aRightAssign);

/* =: assignment. */
// assign a variable
Rule(":",2,0,IsAtom(aLeftAssign))
[
  //MacroSet(aLeftAssign,Eval(aRightAssign));
  //Eval(aLeftAssign);
  
  Echo(test,aLeftAssign, aRightAssign);
  
  
  
  //JavaCall(GeoGebra,evalCommand,
  
  
];




Point(x,y) :=
[

//JavaCall(GeoGebra,evalCommand,"(2,2)");

    Local(command);
    
    command := (ConcatStrings("(",String(x),String(,),String(y),")"));

    JavaCall("geogebra","evalCommand",command);
    //ConcatStrings("(",String(x),String(,),String(y),")");

];




/*
// assign lists
Rule("=:",2,0,IsList(aLeftAssign))
[
  Map("=:",{aLeftAssign,Eval(aRightAssign)});
];
*/

/*// auxiliary function to help assign arrays using =:
RuleBase("AssignArray",{setlistterm,setlistindex,setlistresult});
UnFence("AssignArray",3);
Rule("AssignArray",3,1,IsString(setlistindex))
[
  Local(item);
  item:=Assoc(setlistindex,setlistterm);
  If(item = Empty,
     DestructiveInsert(setlistterm,1,{setlistindex,setlistresult}),
     DestructiveReplace(item,2,setlistresult)
     );
  True;
];*/
/*// assign generic arrays
Rule("AssignArray",3,1,
   And(
           Equals(IsGeneric(setlistterm),True),
           Equals(GenericTypeName(setlistterm),"Array")
          )
    )
[
  ArraySet(setlistterm,setlistindex,setlistresult);
];


Rule("AssignArray",3,2,True)
[
  DestructiveReplace(setlistterm ,setlistindex, setlistresult);
  True;
];

// a[x] =: ... assigns to an array element
Rule("=:",2,10,IsFunction(aLeftAssign) And (Head(Listify(aLeftAssign)) = Nth))
[
 Local(frst,scnd);

 Local(lst);
 Set(lst,(Listify(aLeftAssign)));
 Set(lst,Tail(lst));
 Set(frst, Eval(Head(lst)));
 Set(lst,Tail(lst));
 Set(scnd, Eval(Head(lst)));

 AssignArray(frst,scnd,Eval(aRightAssign));
];*/


/*
// f(x)=:... defines a new function
Rule("=:",2,30,IsFunction(aLeftAssign) And Not(Equals(aLeftAssign[0], Atom("=:"))))
[
  Local(oper,args,arity);
  Set(oper,String(aLeftAssign[0]));
  Set(args,Tail(Listify(aLeftAssign)));
  If(
	And(GreaterThan(Length(args), 1), Equals( MathNth(args, Length(args)), Atom("...") )),
	// function with variable number of arguments
	[
	  DestructiveDelete(args,Length(args));	// remove trailing "..."
	  Set(arity,Length(args));
	  Retract(oper,arity);
	  MacroRuleBaseListed(oper, args);
	],
	// function with a fixed number of arguments
	[
	  Set(arity,Length(args));
	  Retract(oper,arity);
	  MacroRuleBase(oper, args);
	]
  );
  UnHoldable(aRightAssign);
  MacroRule(oper,arity,1025,True) aRightAssign;
];
*/


%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output




%mathpiper
ForEach(x,1 .. 10)
[
    command := (ConcatStrings("(",String(x),String(,),String(2),")"));

    JavaCall("geogebra","evalCommand",command);

];

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output


