%mathpiper
Retract("GPlot",*);
//MacroRuleBase("GPlot",{function});
//HoldArg("GPlot",function);

RuleBaseListed("GPlot",{arg1,arg2});


5 # GPlot(_arg1) <-- GPlot(arg1,{});  //Handle single argument call.


20 # GPlot(function_IsFunction, options_IsList)_(Not IsList(function)) <--
[
   Echo("options: ", options);
    function2 := (Subst(==,=) function);
    
    command := ConcatStrings(ToString()Write(function2));
    
    //JavaCall("geogebra","evalCommand",command);
];




10 # GPlot(list_IsList, options_IsList)_(IsEven(Length(list)And IsNumericList(list)) )  <--
[
    Write(options);
    Local();
    length := Length(list);
    index := 1;
    labelIndex := 1;
    template := "<element type=\"point\" label=\"A<?Write(labelIndex)?>\"> <show object=\"true\" label=\"false\"/><objColor r=\"0\" g=\"0\" b=\"255\" alpha=\"0.0\"/>	<layer val=\"0\"/>	<animation step=\"0.1\" speed=\"1\" type=\"0\" playing=\"false\"/>	<coords x=\"<?Write(x)?>\" y=\"<?Write(y)?>\" z=\"1.0\"/>	<pointSize val=\"3\"/></element>";

    
    While(index < length+1)
    [
        x := list[index];
        index++;
        y := list[index];
        index++;
        
        
        code := PatchString(template);
        //Echo(code);
        //JavaCall("geogebra","evalXML",code);
       
        labelIndex++;
    ];

];


5 # GPlot(list_IsList, options_IsList)_(IsMatrix(IsInteger,list)) <--
[
    flatList := {};
    
    ForEach(subList,list)
    [
        DestructiveAppend(flatList,subList[1]);
        DestructiveAppend(flatList, subList[2]);
    ];
    
    GPlot(flatList);

];

HoldArg("GPlot",arg2);

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output








%mathpiper
Retract("GPoint",*);

10 # GPoint(name_IsString, x_IsNumber, y_IsNumber)  <--
[
    command := PatchString("<?Write(Atom(name))?>=(<?Write(x)?>,<?Write(y)?>)");
    
    JavaCall("geogebra","evalCommand",command);
];

%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output







%mathpiper

// Histogram[{1, 2, 3, 4},{1.0, 1.1, 1.1, 1.2, 1.7, 2.2, 2.5, 4.0}]
GHistogram(classBoundaries, data) := 
[
    //todo:tk: a check must be made to make sure that all data items fit into the class boundaries.
    // If they don't, GeoGebra will not accept them.
    
    command := PatchString("Histogram[<?Write(classBoundaries)?>,<?Write(data)?>]");
    JavaCall("geogebra", "evalCommand", command);
];
%/mathpiper





//************************************************************************************************



%mathpiper,output="trace"


//TraceSome("GPlot", GPlot({5,5,10,10},test1=3,test2));

tmp := 7;
list := {test1->3,test2};
//GPlot({5,5,10,10},test1->3,tmp -> 3);
GPlot(x^2,test1->3,tmp -> 3);
//GPlot({5,5,10,10},lst);

%/mathpiper

    %mathpiper_trace,preserve="false"
      Result: "x^2"
      
      Side Effects:
      options: {test1->3,tmp->3}
.   %/mathpiper_trace





%mathpiper
classBoundaries := N(Table(x,x,14,20,1/4));

E := N({16+3/8, 16+3/8, 17+1/8, 16, 14+3/8, 17+1/4, 16+5/8, 16, 17, 17+1/4, 17, 15+7/8, 16+5/8, 16+1/8, 17+1/8, 16+7/8, 16+3/8, 16+3/8, 16+7/8, 17+1/8, 17, 16+3/4, 17+1/4, 17+1/8, 15+3/8});

D := N({18+1/4, 19+1/4, 18+1/4, 15+5/8, 17+5/8, 17+1/2, 17+1/8, 17+1/8, 17+1/2, 14+1/2, 17+3/8, 16+7/8, 17+3/4, 18+7/8, 14+7/8, 19+1/4, 18+1/8, 16+1/4, 16+1/8, 16+3/4, 17+1/4, 17+3/8, 17+1/8, 17+1/2, 16+5/8});
GHistogram(classBoundaries,Concat(D,E));


%/mathpiper








