%mathpiper,def="RForm",scope="private"

/* RForm: convert MathPiper objects to R code. */



RuleBase("RForm",{expression});
RuleBase("RForm",{expression, precedence});

Function ("RFormBracketIf", {predicate, string})
[
	Check(IsBoolean(predicate) And IsString(string), "RForm internal error: non-boolean and/or non-string argument of RFormBracketIf");
	If(predicate, ConcatStrings("( ", string, ") "), string);
];

/* Proceed just like TeXForm()
*/

// RFormMaxPrec should perhaps only be used from within this file, it is thus not in the .def file.
RFormMaxPrec() := 60000;	 /* This precedence will never be bracketed. It is equal to KMaxPrec */

100 # RForm(_x) <-- RForm(x, RFormMaxPrec());

/* Replace numbers and variables -- never bracketed except explicitly */
110 # RForm(x_IsInteger, _p) <-- String(x);
111 # RForm(x_IsZero, _p) <-- "0.";
112 # RForm(x_IsNumber, _p) <-- String(x);
/* Variables are left as is, except some special ones */
190 # RForm(False, _p) <-- "false";
190 # RForm(True, _p) <-- "true";
200 # RForm(x_IsAtom, _p) <-- String(x);

/* Strings must be quoted but not bracketed */
100 # RForm(x_IsString, _p) <-- ConcatStrings("\"", x, "\"");

/* Replace operations */

/* arithmetic */

/* addition, subtraction, multiplication, all comparison and logical operations are "regular" */


LocalSymbols(RFormRegularOps) [
  RFormRegularOps := { {"+"," + "}, {"-"," - "}, {"*"," * "},
                       {"/"," / "}, {":="," = "}, {"=="," == "},
                       {"="," == "}, {"!="," != "}, {"<="," <= "},
                       {">="," >= "}, {"<"," < "}, {">"," > "},
                       {"And"," && "}, {"Or"," || "}, {">>", " >> "},
                       { "<<", " << " }, { "&", " & " }, { "|", " | " },
                       { "%", " % " }, { "^", " ^ " },
                     };

  RFormRegularOps() := RFormRegularOps;
]; // LocalSymbols(RFormRegularOps)

	/* This is the template for "regular" binary infix operators:
100 # RForm(_x + _y, _p) <-- RFormBracketIf(p<OpPrecedence("+"), ConcatStrings(RForm(x, OpLeftPrecedence("+")), " + ", RForm(y, OpRightPrecedence("+")) ) );
	*/

	/* unary addition */
100 # RForm(+ _y, _p) <-- RFormBracketIf(p<OpPrecedence("+"), ConcatStrings(" + ", RForm(y, OpRightPrecedence("+")) ) );

	/* unary subtraction */
100 # RForm(- _y, _p) <-- RFormBracketIf(p<OpPrecedence("-"), ConcatStrings(" - ", RForm(y, OpRightPrecedence("-")) ) );

	/* power's argument is never bracketed but it must be put in braces. */
100 # RForm(_x ^ _y, _p) <-- RFormBracketIf(p<=OpPrecedence("^"), ConcatStrings("pow(", RForm(x, RFormMaxPrec()), ", ", RForm(y, RFormMaxPrec()), ")" ) );

100 # RForm(if(_pred)_body, _p) <-- "if (":RForm(pred,60000):") ":RForm(body);
100 # RForm(_left else _right, _p) <-- RForm(left):" else ":RForm(right);


LocalSymbols(RFormMathFunctions) [
  RFormMathFunctions :=
    {
      {"Sqrt","sqrt"},
      {"Cos","cos"},
      {"Sin","sin"},
      {"Tan","tan"},
      {"Cosh","cosh"},
      {"Sinh","sinh"},
      {"Tanh","tanh"},
      {"Exp","exp"},
      {"Ln","log"},
      {"ArcCos","acos"},
      {"ArcSin","asin"},
      {"ArcTan","atan"},
      {"ArcCosh","acosh"},
      {"ArcSinh","asinh"},
      {"ArcTanh","atanh"},
      {"Max","max"},
      {"Min","min"},
      {"Abs","fabs"},
      {"Floor","floor"},
      {"Ceil","ceil"},
    {"!","factorial"}
    };

  RFormMathFunctions() := RFormMathFunctions;

]; // LocalSymbols(RFormMathFunctions)

/* Precedence of 120 because we'd like to process some special functions like pow() first */


120 # RForm(expr_IsFunction, _p)_(NrArgs(expr)=2 And Contains(AssocIndices(RFormRegularOps()), Type(expr)) ) <--
      RFormBracketIf(p<OpPrecedence(Type(expr)), ConcatStrings(RForm(Listify(expr)[2], OpLeftPrecedence(Type(expr))), RFormRegularOps()[Type(expr)], RForm(Listify(expr)[3], OpRightPrecedence(Type(expr))) ) );


/* Sin, Cos, etc. and their argument is always bracketed */

120 # RForm(expr_IsFunction, _p) _
      (NrArgs(expr)=1 And Contains(AssocIndices(RFormMathFunctions()), Type(expr)) ) <--
      ConcatStrings(RFormMathFunctions()[Type(expr)], "(", RForm( Listify(expr)[2], RFormMaxPrec()),")" );

/* functions */

/* Unknown function, precedence 200. Leave as is, never bracket the function itself and bracket the argumentPointer(s) automatically since it's a list. Other functions are precedence 100 */

RFormArgs(list_IsList) <--
[
  Local(i,nr,result);
  result:="";
  nr:=Length(list);
  For (i:=1,i<=nr,i++)
  [
    result:=result:RForm(list[i]);
    If (i<nr, result:=result:", ");
  ];
  result;
];


200 # RForm(_x, _p)_(IsFunction(x)) <--
[
  ConcatStrings(Type(x), "(", RFormArgs(Rest(Listify(x))),")" );
];

/* Complex numbers */
100 # RForm(Complex(0, 1), _p) <-- "I";
100 # RForm(Complex(_x, 0), _p) <-- RForm(x, p);
110 # RForm(Complex(_x, 1), _p) <-- RForm(x+Hold(I), p);
110 # RForm(Complex(0, _y), _p) <-- RForm(Hold(I)*y, p);
120 # RForm(Complex(_x, _y), _p) <-- RForm(x+Hold(I)*y, p);

/* Some special functions: Mod */

100 # RForm(Mod(_x, _y), _p) <-- RFormBracketIf(p<OpPrecedence("/"), ConcatStrings(RForm(x, OpPrecedence("/")), " % ", RForm(y, OpPrecedence("/")) ) )
;

/* Indexed expressions are never bracketed */
// the rule with [ ] seems to have no effect?
//100 # RForm(_x [ _i ], _p) <-- ConcatStrings(RForm(x, RFormMaxPrec()), "[", RForm(i, RFormMaxPrec()), "]");
100 # RForm(Nth(_x, _i), _p) <-- ConcatStrings(RForm(x, RFormMaxPrec()), "[", RForm(i, RFormMaxPrec()), "]");

LocalSymbols(cindent) [
  cindent:=1;

  NlIndented():=
  [
    Local(result);
// carriage return, so needs to start at the beginning of the line
    result:=
"
";
    Local(i);
    For(i:=1,i<cindent,i++)
    [
      result:=result:"  ";
    ];
    result;
  ];
  CIndent() :=
  [
  (cindent++);
  "";
  ];
  CUndent() :=
  [
  (cindent--);
  "";
  ];
]; // LocalSymbols(cindent)

RFormStatement(_x) <-- RForm(x) : ";" : NlIndented();

120 # RForm(_x,_p)_(Type(x) = "Prog") <--
[
  Local(result);
  result:=CIndent():"{":NlIndented();
  ForEach(item,Rest(Listify(x)))
  [
    result:=result:RFormStatement(item);
  ];
  result:=result:"}":CUndent():NlIndented();
  result;
];

120 # RForm(For(_from,_to,_step)_body,_p) <--
  "for(" : RForm(from,RFormMaxPrec()) : ";"
	: RForm(to,RFormMaxPrec()) : ";"
	: RForm(step,RFormMaxPrec()) : ")"
	: CIndent() : NlIndented()
	: RFormStatement(body) : CUndent();

120 # RForm(While(_pred)_body, _p) <--
	"while(" : RForm(pred,RFormMaxPrec()) : ")"
	: CIndent() : NlIndented()
	: RFormStatement(body) : CUndent();

%/mathpiper



%mathpiper_docs,name="RForm",categories="User Functions;Input/Output"
*CMD RForm --- export expression to R code
*STD
*CALL
	RForm(expr)

*PARMS

{expr} -- expression to be exported

*DESC

{RForm} returns a string containing R code that attempts to implement the MathPiper expression {expr}.
Currently the exporter handles most expression types but not all.

*E.G.

	In> RForm(Sin(a1)+2*Cos(b1));
	Out> "sin(a1) + 2 * cos(b1)";

*SEE PrettyForm, TeXForm, CForm
%/mathpiper_docs