%mathpiper,title="xSolvePoly"

Retract("xSolve'Poly",*);

/******************** xSolve'Poly ********************/

/* Tries to solve by calling PSolve */
/* Returns Failed if this doesn't work, and the solution otherwise */

/* CanBeUni is not documented, but defined in org/mathpiper/assembledscripts/univar.rep/code.mpi */
/* It returns True iff 'expr' is or can be considered to be a univariate polynomial in 'var' */

10 # xSolve'Poly(_expr, _var)_(Not CanBeUni(var, expr)) <-- 
  [
      If(iDebug=True,Tell("xSolvePoly_NoUni",{expr,var}));
      Failed;
  ];

  
20 # xSolve'Poly(_expr, _var) <--
  LocalSymbols(x)
  [
      If(iDebug=True,Tell("xSolvePoly_Uni_F",{expr,var}));
      Local(factors,nfactors,roots);
      factors  := Factors(expr);
      nfactors := Length(factors);
      If(iDebug=True,Tell("  1",{nfactors,factors}));
      roots := {};
      ForEach(factor,factors) 
          If(Contains(VarList(factor[1]),var),
              Push(roots,PSolve(factor[1],var))
          );
      If(iDebug=True,Tell("  4",roots));
      If(Type(roots) = "List",
          MapSingle({{x},var==x}, roots),  
          {var == roots}
       );                 
  ];
  
  
/* 
 * The call to PSolve (below) can have three kind of results
 *   1) PSolve returns a single root
 *   2) PSolve returns a list of roots
 *   3) PSolve remains unevaluated
 */

30 # xSolve'Poly(_expr, _var) <--
  LocalSymbols(x)
  [
      If(iDebug=True,Tell("xSolvePoly_Uni_P",{expr,var}));
      Local(roots);
      roots := PSolve(expr, var);
      If(Type(roots) = "PSolve",
         Failed,                               /* Case 3 */
         If(Type(roots) = "List",
             MapSingle({{x},var==x}, roots),   /* Case 2 */
             {var == roots})                   /* Case 1 */
      );
  ];


%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output



