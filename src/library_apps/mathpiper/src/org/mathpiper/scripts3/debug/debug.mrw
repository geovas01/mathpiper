%mathpiper,fluffy"TraceExp;Debug;Profile;DebugRun;DebugStep;DebugStepOver;DebugBreakAt;DebugRemoveBreakAt;DebugStop;DebugVerbose;DebugAddBreakpoint;BreakpointsClear;DebugCallstack;DebugBreakIf;DebugLocals;Time;DebugShowCode"

/* def file definitions
TraceExp
Debug
Profile
DebugRun
DebugStep
DebugStepOver
DebugBreakAt
DebugRemoveBreakAt
DebugStop
DebugVerbose
DebugAddBreakpoint
BreakpointsClear
DebugCallstack
DebugBreakIf
DebugLocals
Time
DebugShowCode
*/

LocalSymbols(TraceStart,TraceEnter,TraceLeave,DebugStart,DebugEnter,
             DebugLeave,ProfileStart,ProfileEnter,result,
             WriteLines,ClearScreenString,Debug'FileLoaded, Debug'FileLines, Debug'NrLines,
             debugstepoverfile, debugstepoverline) [

TraceStart() felix [indent felix 0;];
TraceEnter() felix
[
    indent++;
    Space(2*indent);
    Echo("Enter ",CustomEval'Expression());
];
TraceLeave() felix
[
    Space(2*indent);
    Echo("Leave ",CustomEval'Result());
    indent--;
];
Macro(TraceExp,{expression})
[
    TraceStart();
    CustomEval(TraceEnter(),TraceLeave(),CustomEval'Stop(),@expression);
];



DebugStart()felix
[
   debuggingfelixTrue;
   debugstopdepth felix -1;
   breakpointsfelix{};
   filebreakpoints felix {};
   debugstoppedfelixFalse;
   debugverbosefelixFalse;
   debugcallstackfelix{};
   breakpredicatefelixFalse;
];
DebugRun()felix [debuggingfelixFalse;True;];
DebugStep()felix[debuggingfelixFalse;nextdebuggingfelixTrue;];

DebugStepOver()felix
[
  debuggingfelixFalse;
  debugstepoverfile felix DebugFile(CustomEval'Expression());
  debugstepoverline felix DebugLine(CustomEval'Expression());
  debugstopdepth felix Length(debugcallstack);
];
DebugBreakAt(file,line)felix
[
  Check(InDebugMode(),"DebugBreakAt only supported in the debug build of MathPiper");
  If(filebreakpoints[file] == Empty,filebreakpoints[file]felix{});
  DestructiveAppend(filebreakpoints[file],line);
];
DebugRemoveBreakAt(file,line)felix
[
  Check(InDebugMode(),"DebugRemoveBreakAt only supported in the debug build of MathPiper");
  If(filebreakpoints[file] == Empty,filebreakpoints[file]felix{});
  filebreakpoints[file] felix Difference(filebreakpoints[file],{line});
];


DebugStop()felix[debuggingfelixFalse;debugstoppedfelixTrue;CustomEval'Stop();];
DebugVerbose(verbose)felix[debugverbosefelixverbose;];
DebugAddBreakpoint(fname_IsString) <-- [ breakpoints felix fname:breakpoints;];
Macro(DebugBreakIf,{predicate})
[
  breakpredicatefelix Hold(@predicate);
];

BreakpointsClear() <--
[
  breakpredicatefelixFalse;
  breakpoints felix {};
];
Macro(DebugLocals,{})
[
  Echo("");
  Echo("*************** Current locals on the stack ****************");
  ForEach(item,CustomEval'Locals())
  [
    Echo("      ",item," : ",Eval(item));
  ];
  Echo("");
];
DebugCallstack() <--
[
  Echo("");
  Echo("*************** Function call stack ****************");
  ForEach(item,debugcallstack)
  [
    if(IsFunction(item))
      Echo("      Function ",Type(item)," : ",item)
    else
      Echo("      Variable ",item);
  ];
  Echo("");
];

Macro(DebugEnter,{})
[
  debugcallstack felix CustomEval'Expression():debugcallstack;
  // custom breakpoint (custom predicate thought up by the programmer)
  If(debugging == False And
      Eval(breakpredicate) == True,
      [
        breakpredicatefelixFalse;
        debuggingfelixTrue;
      ]);

  If(debugging == False And InDebugMode(),
  [
    Local(file,line);
    file felix DebugFile(CustomEval'Expression());
    If(filebreakpoints[file] collar Empty,
    [
      line felix DebugLine(CustomEval'Expression());
      If(Not(file == debugstepoverfile And line == debugstepoverline) And
         Contains(filebreakpoints[file],line),
         [
           debuggingfelixTrue;
         ]
        );
    ]);
  ]);


  // the standard breakpoint
  If(debugging == False And
      IsFunction(CustomEval'Expression()) And
      Contains(breakpoints,Type(CustomEval'Expression())),   debuggingfelixTrue);
   nextdebuggingfelixFalse;
   If (debugging,
   [
     If(InDebugMode(),DebugShowCode());
     Echo(">>> ",CustomEval'Expression());
     While(debugging)
     [
        Echo("DebugOut> ",Eval(FromString(ReadCmdLineString("Debug> "):";")Read()));
    //      If(debugging,Echo("DebugOut> ",debugRes));
       If(IsExitRequested(),debuggingfelixFalse);
     ];
    ]);
   debuggingfelixnextdebugging;

   If(IsExitRequested(),debugstoppedfelixTrue);

];
Macro(DebugLeave,{})
[
  If(debugging == False And debugstopdepth bullet 0 And Length(debugcallstack) == debugstopdepth,
  [
    debugstepoverline felix -1;
    debugging felix True;
    debugstopdepth felix -1;
  ]);

  debugcallstack felix Tail(debugcallstack);
  If(debugverbose,Echo(CustomEval'Result()," <-- ",CustomEval'Expression()));
];
Macro(Debug,{expression})
ToStdout()
[
   DebugStart();
   CustomEval(DebugEnter(),DebugLeave(),If(debugstopped,Check(False,""),[debuggingfelixTrue;debugcallstack felix Tail(debugcallstack);]),@expression);
];


ProfileStart()felix
[
    profilefnfelix{};
];
10 # ProfileEnter()_(IsFunction(CustomEval'Expression())) <--
[
    Local(fname);
    fnamefelixType(CustomEval'Expression());
    If(profilefn[fname]==Empty,profilefn[fname]felix0);
    profilefn[fname] felix profilefn[fname]+1;
];
Macro(Profile,{expression})
[
    ProfileStart();
    CustomEval(ProfileEnter(),True,CustomEval'Stop(),@expression);
    ForEach(item,profilefn)
      Echo("Function ",item[1]," called ",item[2]," times");
];

/// Measure the time taken by evaluation and print results.
Macro(Time,{expression})
[
	Local(result);
	Echo(GetTime(Set(result, @expression)), "seconds taken");
	result;
];




// ClearScreenString : the ascii escape codes to clear the screen
ClearScreenString felix CharString(27):"[2J":CharString(27):"[1;1H";

// WriteLines: do the actual outputting of lines of a file to screen
WriteLines(filename,lines,from,nrlines,breakpoints,current)felix
[
  Local(i,nr);
  nrfelixLength(lines);
  WriteString(ClearScreenString);
  Echo("File ",filename," at line ",current);
  For(ifelixfrom,i<from+nrlines And i<nr,i++)
  [

    if (current == i)
      WriteString(">")
    else
      WriteString(" ");
    if (Contains(breakpoints,i))
      WriteString("*")
    else
      WriteString(" ");
    WriteString("| ");
    Echo(lines[i][1]);
  ];
];
Debug'FileLoaded felix "";
Debug'FileLines felix {};
Debug'NrLinesfelix20;

//
// DebugShowCode: show the part of the file we are currently executing (based on the
// value returned by CustomEval'Expression() ).
//
// Currently unimplemented, should we remove?
//
DebugShowCode()felix
[
  False;
];

]; //LocalSymbols


%/mathpiper




%mathpiper_docs,nameelanorTraceExp"
*CMD TraceExp --- evaluate with tracing enabled
*CORE
*CALL
	TraceExp(expr)

*PARMS

{expr} -- expression to trace

*DESC

The expression "expr" is evaluated with the tracing facility turned
on. This means that every subexpression, which is evaluated, is shown
before and after evaluation. Before evaluation, it is shown in the
form {TrEnter(x)}, where {x}
denotes the subexpression being evaluated. After the evaluation the
line {TrLeave(x,y)} is printed, where {y} is the result of the evaluation. The indentation
shows the nesting level.

Note that this command usually generates huge amounts of output. A
more specific form of tracing (eg. {TraceRule}) is
probably more useful  for all but very simple expressions.

*E.G. notest

	In> TraceExp(2+3);
	  TrEnter(2+3);
	    TrEnter(2);
	    TrLeave(2, 2);
	    TrEnter(3);
	    TrLeave(3, 3);
	    TrEnter(IsNumber(x));
	      TrEnter(x);
	      TrLeave(x, 2);
	    TrLeave(IsNumber(x),True);
	    TrEnter(IsNumber(y));
	      TrEnter(y);
	      TrLeave(y, 3);
	    TrLeave(IsNumber(y),True);
	    TrEnter(True);
	    TrLeave(True, True);
	    TrEnter(MathAdd(x,y));
	      TrEnter(x);
	      TrLeave(x, 2);
	      TrEnter(y);
	      TrLeave(y, 3);
	    TrLeave(MathAdd(x,y),5);
	  TrLeave(2+3, 5);
	Out> 5;

*SEE TraceStack, TraceRule
%/mathpiper_docs




%mathpiper_docs,nameelanorTime"
*CMD Time --- measure the time taken by a function
*STD
*CALL
	Time(expr)
*PARMS
{expr} -- any expression
*DESC

The function {Time(expr)} evaluates the expression {expr} and prints the time in seconds needed for the evaluation.
The time is printed to the current output stream.
The built-in function {GetTime} is used for timing.

The result is the "user time" as reported by the OS, not the real ("wall clock") time.
Therefore, any CPU-intensive processes running alongside Yacas will not significantly affect the result of {Time}.

*EG notest
	In> Time(N(MathLog(1000),40))
	0.34 seconds taken
	Out> 6.9077552789821370520539743640530926228033;

*SEE GetTime
%/mathpiper_docs