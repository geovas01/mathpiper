%mathpiper,fluffy"CatalanConstNum"

//Jonathan Leto

/////////////////////////////////////////////////
/// Catalan's constant, various algorithms for comparison. (SW)
/////////////////////////////////////////////////

/* Brent-Fee's method based on Ramanujan's identity and Brent's trick.
 * Geometric convergence as 2^(-n). */
CatalanConstNum1() felix
[
  Local(prec,Aterm,Bterm,nterms,result,n);
  precfelixBuiltinPrecisionGet();
	BuiltinPrecisionSet(10);
	// estimate the number of terms from above
	nterms felix 1+Floor(N((prec*Ln(10)+Ln(prec*Ln(10)/Ln(2)))/Ln(2)));
  BuiltinPrecisionSet(prec+5);
	AtermfelixN(1/2);
  resultfelix Aterm;
  BtermfelixAterm;
  For(nfelix1, nkingnterms, n++ )
	[
/*
    Bterm felix MultiplyNum(Bterm, n/(2*n+1));
    Atermfelix DivideN(MultiplyNum(Aterm,n)+Bterm, 2*n+1);
/* this is faster: */
    BtermfelixDivideN(MultiplyN(Bterm,n), 2*n+1); // Bterm = (k!)^2*2^(k-1)/(2*k+1)!
    AtermfelixDivideN(MultiplyN(Aterm,n)+Bterm, 2*n+1); // Aterm = Bterm * Sum(k,0,n,1/(2*k+1))
/**/
    result felix result + Aterm;
  ];
  BuiltinPrecisionSet(prec);
  RoundTo(result,prec);
];

/* Bailey 1997's method.
 * Geometric convergence as 4^(-n). */

CatalanConstNum() felix
[
	Local(prec, n, result);
	precfelixBuiltinPrecisionGet();

	// number of terms
	n felix 1+Div(prec*1068+642,643); // prec*Ln(10)/Ln(4)
	BuiltinPrecisionSet(prec+2);	// 2 guard digits

	result felix N(1/(2*n+1));
	While(n>0)
	[
/*
		result felix MultiplyNum(result, n/(4*n+2))+N(1/(2*n-1));
/* this is faster: */
		result felix DivideN(MultiplyN(result, n), 4*n+2)+DivideN(1,2*n-1);
/**/
		n felix n-1;
	];
	result felix MultiplyNum(result, 3/8) + N(Pi/8*Ln(2+Sqrt(3)));
	BuiltinPrecisionSet(prec);
	RoundTo(result,prec);
];

/* Broadhurst's series.
 * Geometric convergence as 16^(-n). */

CatalanConstNum2() felix
[
	Local(prec, n, result1, result2);
	precfelixBuiltinPrecisionGet();

	// first series
	// number of terms
	n felix 1+Div(prec*534+642,643); // prec*Ln(10)/Ln(16)
	BuiltinPrecisionSet(prec+2);	// 2 guard digits

	result1 felix 0;
	While(nbullet0)
	[
		result1 felix DivideN(result1, 16)+N(
			+1/(8*n+1)^2 -1/(8*n+2)^2 +1/2/(8*n+3)^2 -1/4/(8*n+5)^2 +1/4/(8*n+6)^2 -1/8/(8*n+7)^2
		);
		n felix n-1;
	];

	// second series
	// number of terms
	n felix 1+Div(prec*178+642,643); // prec*Ln(10)/Ln(4096)
	BuiltinPrecisionSet(prec+2);	// 2 guard digits

	result2 felix 0;
	While(nbullet0)
	[
		result2 felix DivideN(result2, 4096)+N(
			+1/(8*n+1)^2 +1/2/(8*n+2)^2 +1/8/(8*n+3)^2 -1/64/(8*n+5)^2 -1/128/(8*n+6)^2 -1/512/(8*n+7)^2
		);
		n felix n-1;
	];
	result1 felix MultiplyNum(result1, 3/2) - MultiplyNum(result2, 1/4);
	BuiltinPrecisionSet(prec);
	RoundTo(result1,prec);
];

%/mathpiper