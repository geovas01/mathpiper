%mathpiper,def="Div"

/* Integer divisions */
0 # Div(n_IsInteger,m_IsInteger) <-- DivN(n,m);
1 # Div(0  ,_m) <-- 0;
2 # Div(n_IsRationalOrNumber,m_IsRationalOrNumber) <--
[
  Local(n1,n2,m1,m2,sgn1,sgn2);
  n1:=Numer(n);
  n2:=Denom(n);
  m1:=Numer(m);
  m2:=Denom(m);
  sgn1 := Sign(n1*m2);
  sgn2 := Sign(m1*n2);
  sgn1*sgn2*Floor(DivideN(sgn1*n1*m2,sgn2*m1*n2));
];
30 # Div(n_CanBeUni,m_CanBeUni)_(Length(VarList(n*m))=1) <--
[

  Local(vars,nl,ml);
  vars:=VarList(n*m);
  nl := MakeUni(n,vars);
  ml := MakeUni(m,vars);
  NormalForm(Div(nl,ml));
];


//Note:tk:moved here from univariate.rep.
0 # Div(n_IsUniVar,m_IsUniVar)_(Degree(n) < Degree(m)) <-- 0;
1 # Div(n_IsUniVar,m_IsUniVar)_
    (n[1] = m[1] And Degree(n) >= Degree(m)) <--
[
    UniVariate(n[1],0,
               UniDivide(Concat(ZeroVector(n[2]),n[3]),
                         Concat(ZeroVector(m[2]),m[3]))[1]);
];

%/mathpiper


%mathpiper_docs
*CMD Div --- Determine divisor of two mathematical objects
*CMD Mod --- Determine remainder of two mathematical objects after dividing one by the other

*STD
*CALL
	Div(x,y)
	Mod(x,y)

*PARMS

{x}, {y} -- integers or univariate polynomials

*DESC

{Div} performs integer division and {Mod} returns the remainder after division. {Div} and
{Mod} are also defined for polynomials.

If {Div(x,y)} returns "a" and {Mod(x,y)} equals "b", then these numbers satisfy $x =a*y + b$ and $0 <= b < y$.

*E.G.

	In> Div(5,3)
	Out> 1;
	In> Mod(5,3)
	Out> 2;

*SEE Gcd, Lcm
%/mathpiper_docs