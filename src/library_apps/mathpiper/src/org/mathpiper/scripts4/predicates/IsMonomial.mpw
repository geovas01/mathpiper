%mathpiper,def="IsMonomial"

Retract("CanBeMonomial",*);
Retract("IsMonomial",*);

10 # CanBeMonomial(_expr)_(Type(expr)="UniVariate") <-- False;

10 # CanBeMonomial(_expr)<--Not (HasFunc(expr,ToAtom("+")) Or HasFunc(expr,ToAtom("-")));

10 # IsMonomial(expr_CanBeMonomial) <-- 
[
    Local(r);
    If( IsRationalFunction(expr),
        r := (VarList(Denominator(expr)) = {}),
        r := True
    );
];

15 # IsMonomial(_expr) <-- False;

%/mathpiper

    %output,preserve="false"
      Result: True
      
      Side Effects:
      Enter<builtin>{(LoadScript, LoadScript(C:/Users/shermo/AppData/Local/Temp/mathpiperide258369849873711763.mpw_tmp));
          Arg(parameter1 -> C:/Users/shermo/AppData/Local/Temp/mathpiperide258369849873711763.mpw_tmp);
          Enter<builtin>{(Retract, Retract(CanBeMonomial,*));
              Arg(parameter1 -> CanBeMonomial);
              Arg(parameter2 -> *);
          Leave<builtin>}(Retract(CanBeMonomial,*) -> True,    Local variables: );
          Enter<builtin>{(Retract, Retract(IsMonomial,*));
              Arg(parameter1 -> IsMonomial);
              Arg(parameter2 -> *);
          Leave<builtin>}(Retract(IsMonomial,*) -> True,    Local variables: );
          Enter<**** user rulebase>{(<--, 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate)<--False);
              Arg(leftOperand -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
              Arg(rightOperand -> False);
              Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),#));
                  Enter<builtin>{(Type, Type(leftOperand));
                      Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                  Leave<builtin>}(Type(leftOperand) -> #,    Local variables: rightOperand -> False, leftOperand -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                  Arg(parameter1 -> #);
                  Arg(parameter2 -> #);
              Leave<builtin>}(IsEqual(Type(leftOperand),#) -> True,    Local variables: rightOperand -> False, leftOperand -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
              **** Rule in function (<--) matched: Precedence: 1, Parameters: leftOperand<hold=true>, rightOperand<hold=true>, Predicates: IsEqual(Type(leftOperand),"#"),    Body: [    DefinePattern(leftOperand[2], rightOperand, leftOperand[1], True);]
              Enter<builtin>{(Prog, [    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);]);
                  Arg(parameter1 -> DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                  Enter<**** user rulebase>{(DefinePattern, DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                      Enter<**** user rulebase>{(Nth, leftOperand[2]);
                          Arg(alist -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                          Arg(aindex -> 2);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 2);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,CanBeMonomial(_expr)_(Type(expr)=UniVariate)},    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                          Arg(parameter1 -> {#,10,CanBeMonomial(_expr)_(Type(expr)=UniVariate)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                              Arg(parameter2 -> 2);
                          Leave<builtin>}(MathNth(alist,aindex) -> CanBeMonomial(_expr)_(Type(expr)=UniVariate),    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                      Leave<**** user rulebase>}(leftOperand[2] -> CanBeMonomial(_expr)_(Type(expr)=UniVariate),    Local variables: aindex -> 2, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                      Enter<**** user rulebase>{(Nth, leftOperand[1]);
                          Arg(alist -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                          Arg(aindex -> 1);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 1);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,CanBeMonomial(_expr)_(Type(expr)=UniVariate)},    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                          Arg(parameter1 -> {#,10,CanBeMonomial(_expr)_(Type(expr)=UniVariate)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                              Arg(parameter2 -> 1);
                          Leave<builtin>}(MathNth(alist,aindex) -> 10,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                      Leave<**** user rulebase>}(leftOperand[1] -> 10,    Local variables: aindex -> 1, alist -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
                      Arg(leftOperand -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                      Arg(rightOperand -> False);
                      Arg(rulePrecedence -> 10);
                      Arg(postPredicate -> True);
                      Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),_));
                          Enter<builtin>{(Type, Type(leftOperand));
                              Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                          Leave<builtin>}(Type(leftOperand) -> _,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> False, leftOperand -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                          Arg(parameter1 -> _);
                          Arg(parameter2 -> _);
                      Leave<builtin>}(IsEqual(Type(leftOperand),_) -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> False, leftOperand -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                      **** Rule in function (DefinePattern) matched: Precedence: 9, Parameters: leftOperand<hold=false>, rightOperand<hold=false>, rulePrecedence<hold=false>, postPredicate<hold=false>, Predicates: IsEqual(Type(leftOperand),"_"),    Body: [    DefinePattern(leftOperand[1], rightOperand, rulePrecedence, leftOperand[2]);]
                      Enter<builtin>{(Prog, [    DefinePattern(leftOperand[1],rightOperand,rulePrecedence,leftOperand[2]);]);
                          Arg(parameter1 -> DefinePattern(leftOperand[1],rightOperand,rulePrecedence,leftOperand[2]));
                          Enter<**** user rulebase>{(DefinePattern, DefinePattern(leftOperand[1],rightOperand,rulePrecedence,leftOperand[2]));
                              Enter<**** user rulebase>{(Nth, leftOperand[1]);
                                  Arg(alist -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                  Arg(aindex -> 1);
                                  Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                                      Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                                      Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                                      Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                          Enter<builtin>{(IsFunction, IsFunction(alist));
                                              Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                          Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> True);
                                          Arg(parameter2 -> True);
                                      Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                      Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                          Enter<builtin>{(IsInteger, IsInteger(aindex));
                                              Arg(parameter1 -> 1);
                                          Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> True);
                                          Arg(parameter2 -> True);
                                      Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                      Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                          Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                              Enter<builtin>{(First, First(FunctionToList(alist)));
                                                  Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                                      Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                                  Leave<builtin>}(FunctionToList(alist) -> {_,CanBeMonomial(_expr),Type(expr)=UniVariate},    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                                  Arg(parameter1 -> {_,CanBeMonomial(_expr),Type(expr)=UniVariate});
                                              Leave<builtin>}(First(FunctionToList(alist)) -> _,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                              Arg(parameter1 -> _);
                                              Arg(parameter2 -> Nth);
                                          Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> False);
                                      Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                  Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                                  Enter<builtin>{(MathNth, MathNth(alist,aindex));
                                      Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                      Arg(parameter2 -> 1);
                                  Leave<builtin>}(MathNth(alist,aindex) -> CanBeMonomial(_expr),    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                              Leave<**** user rulebase>}(leftOperand[1] -> CanBeMonomial(_expr),    Local variables: aindex -> 1, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                              Enter<**** user rulebase>{(Nth, leftOperand[2]);
                                  Arg(alist -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                  Arg(aindex -> 2);
                                  Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                                      Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                                      Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                                      Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                          Enter<builtin>{(IsFunction, IsFunction(alist));
                                              Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                          Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> True);
                                          Arg(parameter2 -> True);
                                      Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                      Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                          Enter<builtin>{(IsInteger, IsInteger(aindex));
                                              Arg(parameter1 -> 2);
                                          Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> True);
                                          Arg(parameter2 -> True);
                                      Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                      Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                          Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                              Enter<builtin>{(First, First(FunctionToList(alist)));
                                                  Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                                      Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                                  Leave<builtin>}(FunctionToList(alist) -> {_,CanBeMonomial(_expr),Type(expr)=UniVariate},    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                                  Arg(parameter1 -> {_,CanBeMonomial(_expr),Type(expr)=UniVariate});
                                              Leave<builtin>}(First(FunctionToList(alist)) -> _,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                              Arg(parameter1 -> _);
                                              Arg(parameter2 -> Nth);
                                          Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                          Arg(parameter1 -> False);
                                      Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                  Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                                  **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                                  Enter<builtin>{(MathNth, MathNth(alist,aindex));
                                      Arg(parameter1 -> CanBeMonomial(_expr)_(Type(expr)=UniVariate));
                                      Arg(parameter2 -> 2);
                                  Leave<builtin>}(MathNth(alist,aindex) -> Type(expr)=UniVariate,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                              Leave<**** user rulebase>}(leftOperand[2] -> Type(expr)=UniVariate,    Local variables: aindex -> 2, alist -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                              Arg(leftOperand -> CanBeMonomial(_expr));
                              Arg(rightOperand -> False);
                              Arg(rulePrecedence -> 10);
                              Arg(postPredicate -> Type(expr)=UniVariate);
                              Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),_));
                                  Enter<builtin>{(Type, Type(leftOperand));
                                      Arg(parameter1 -> CanBeMonomial(_expr));
                                  Leave<builtin>}(Type(leftOperand) -> CanBeMonomial,    Local variables: postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Arg(parameter1 -> CanBeMonomial);
                                  Arg(parameter2 -> _);
                              Leave<builtin>}(IsEqual(Type(leftOperand),_) -> False,    Local variables: postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                              **** Rule in function (DefinePattern) matched: Precedence: 10, Parameters: leftOperand<hold=false>, rightOperand<hold=false>, rulePrecedence<hold=false>, postPredicate<hold=false>, Predicates: None.,    Body: [    Local(patternFlat, patternVariables, pattern, patternOperator, arg, arity);    Bind(patternFlat, FunctionToList(leftOperand));    Bind(patternVariables, Rest(patternFlat));    Bind(patternOperator, ToString(First(patternFlat)));    Bind(arity, Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator, arity), [        MacroRulebase(patternOperator, MakeVector(arg, arity));]);    Bind(pattern, Pattern'Create(patternVariables, postPredicate));    MacroRulePattern(patternOperator, arity, rulePrecedence, pattern)rightOperand;    True;]
                              Enter<builtin>{(Prog, [    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;]);
                                  Arg(parameter1 -> Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                                  Arg(parameter2 -> Bind(patternFlat,FunctionToList(leftOperand)));
                                  Arg(parameter3 -> Bind(patternVariables,Rest(patternFlat)));
                                  Arg(parameter4 -> Bind(patternOperator,ToString(First(patternFlat))));
                                  Arg(parameter5 -> Bind(arity,Length(patternVariables)));
                                  Arg(parameter6 -> DefLoadFunction(patternOperator));
                                  Arg(parameter7 -> If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                                  Arg(parameter8 -> Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                                  Arg(parameter9 -> MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                                  Arg(parameter10 -> True);
                                  Enter<builtin>{(Local, Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                                      Arg(parameter1 -> patternFlat);
                                      Arg(parameter2 -> patternVariables);
                                      Arg(parameter3 -> pattern);
                                      Arg(parameter4 -> patternOperator);
                                      Arg(parameter5 -> arg);
                                      Arg(parameter6 -> arity);
                                  Leave<builtin>}(Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(Bind, Bind(patternFlat,FunctionToList(leftOperand)));
                                      Arg(parameter1 -> patternFlat);
                                      Arg(parameter2 -> FunctionToList(leftOperand));
                                      Enter<builtin>{(FunctionToList, FunctionToList(leftOperand));
                                          Arg(parameter1 -> CanBeMonomial(_expr));
                                      Leave<builtin>}(FunctionToList(leftOperand) -> {CanBeMonomial,_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(Bind(patternFlat,FunctionToList(leftOperand)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(Bind, Bind(patternVariables,Rest(patternFlat)));
                                      Arg(parameter1 -> patternVariables);
                                      Arg(parameter2 -> Rest(patternFlat));
                                      Enter<builtin>{(Rest, Rest(patternFlat));
                                          Arg(parameter1 -> {CanBeMonomial,_expr});
                                      Leave<builtin>}(Rest(patternFlat) -> {_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(Bind(patternVariables,Rest(patternFlat)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(Bind, Bind(patternOperator,ToString(First(patternFlat))));
                                      Arg(parameter1 -> patternOperator);
                                      Arg(parameter2 -> ToString(First(patternFlat)));
                                      Enter<builtin>{(ToString, ToString(First(patternFlat)));
                                          Enter<builtin>{(First, First(patternFlat));
                                              Arg(parameter1 -> {CanBeMonomial,_expr});
                                          Leave<builtin>}(First(patternFlat) -> CanBeMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                          Arg(parameter1 -> CanBeMonomial);
                                      Leave<builtin>}(ToString(First(patternFlat)) -> CanBeMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(Bind(patternOperator,ToString(First(patternFlat))) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(Bind, Bind(arity,Length(patternVariables)));
                                      Arg(parameter1 -> arity);
                                      Arg(parameter2 -> Length(patternVariables));
                                      Enter<builtin>{(Length, Length(patternVariables));
                                          Arg(parameter1 -> {_expr});
                                      Leave<builtin>}(Length(patternVariables) -> 1,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(Bind(arity,Length(patternVariables)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(DefLoadFunction, DefLoadFunction(patternOperator));
                                      Arg(parameter1 -> CanBeMonomial);
                                  Leave<builtin>}(DefLoadFunction(patternOperator) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(If, If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                                      Arg(parameter1 -> NotRulebaseDefined(patternOperator,arity));
                                      Arg(parameter2 -> [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                                      Enter<builtin>{(Not, NotRulebaseDefined(patternOperator,arity));
                                          Enter<builtin>{(RulebaseDefined, RulebaseDefined(patternOperator,arity));
                                              Arg(parameter1 -> CanBeMonomial);
                                              Arg(parameter2 -> 1);
                                          Leave<builtin>}(RulebaseDefined(patternOperator,arity) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                          Arg(parameter1 -> False);
                                      Leave<builtin>}(NotRulebaseDefined(patternOperator,arity) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                      Enter<builtin>{(Prog, [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                                          Arg(parameter1 -> MacroRulebase(patternOperator,MakeVector(arg,arity)));
                                          Enter<builtin>{(MacroRulebase, MacroRulebase(patternOperator,MakeVector(arg,arity)));
                                              Enter<**** user rulebase>{(MakeVector, MakeVector(arg,arity));
                                                  Arg(vec -> arg);
                                                  Arg(dimension -> 1);
                                                  **** Rule in function (MakeVector) matched: Precedence: 1, Parameters: vec<hold=false>, dimension<hold=false>, Predicates: None.,    Body: [    Local(res, i);    res:={};    i:=1;    Bind(dimension, AddN(dimension, 1));    While(IsLessThan(i, dimension))[        DestructiveInsert(res, 1, ToAtom(ConcatStrings(ToString(vec), ToString(i))));        Bind(i, AddN(i, 1));];    DestructiveReverse(res);]
                                                  Enter<builtin>{(Prog, [    Local(res,i);    res:={};    i:=1;    Bind(dimension,AddN(dimension,1));    While(IsLessThan(i,dimension))[        DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));        Bind(i,AddN(i,1));];    DestructiveReverse(res);]);
                                                      Arg(parameter1 -> Local(res,i));
                                                      Arg(parameter2 -> res:={});
                                                      Arg(parameter3 -> i:=1);
                                                      Arg(parameter4 -> Bind(dimension,AddN(dimension,1)));
                                                      Arg(parameter5 -> While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                      Arg(parameter6 -> DestructiveReverse(res));
                                                      Enter<builtin>{(Local, Local(res,i));
                                                          Arg(parameter1 -> res);
                                                          Arg(parameter2 -> i);
                                                      Leave<builtin>}(Local(res,i) -> True,    Local variables: i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                      Enter<**** user rulebase>{(:=, res:={});
                                                          Arg(aLeftAssign -> res);
                                                          Arg(aRightAssign -> {});
                                                          Enter<builtin>{(IsList, IsList(aLeftAssign));
                                                              Arg(parameter1 -> res);
                                                          Leave<builtin>}(IsList(aLeftAssign) -> False,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                          Enter<builtin>{(IsAtom, IsAtom(aLeftAssign));
                                                              Arg(parameter1 -> res);
                                                          Leave<builtin>}(IsAtom(aLeftAssign) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                          **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign),    Body: [    Check(NotIsNumber(aLeftAssign), "Only a variable can be placed on the left side of an := operator.");    MacroBind(aLeftAssign, Eval(aRightAssign));    Eval(aLeftAssign);]
                                                          Enter<builtin>{(Prog, [    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                              Arg(parameter1 -> Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                              Arg(parameter2 -> MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                              Arg(parameter3 -> Eval(aLeftAssign));
                                                              Enter<builtin>{(Check, Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                                  Arg(parameter1 -> NotIsNumber(aLeftAssign));
                                                                  Arg(parameter2 -> Only a variable can be placed on the left side of an := operator.);
                                                                  Enter<builtin>{(Not, NotIsNumber(aLeftAssign));
                                                                      Enter<builtin>{(IsNumber, IsNumber(aLeftAssign));
                                                                          Arg(parameter1 -> res);
                                                                      Leave<builtin>}(IsNumber(aLeftAssign) -> False,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                                      Arg(parameter1 -> False);
                                                                  Leave<builtin>}(NotIsNumber(aLeftAssign) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                              Leave<builtin>}(Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                              Enter<builtin>{(MacroBind, MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                                  Arg(parameter1 -> aLeftAssign);
                                                                  Arg(parameter2 -> Eval(aRightAssign));
                                                                  Enter<builtin>{(Eval, Eval(aRightAssign));
                                                                      Arg(parameter1 -> {});
                                                                      Enter<builtin>{(List, {});
                                                                      Leave<builtin>}({} -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                                  Leave<builtin>}(Eval(aRightAssign) -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                              Leave<builtin>}(MacroBind(aLeftAssign,Eval(aRightAssign)) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Enter<builtin>{(Eval, Eval(aLeftAssign));
                                                                  Arg(parameter1 -> res);
                                                              Leave<builtin>}(Eval(aLeftAssign) -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                          Leave<builtin>}([    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);] -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Leave<**** user rulebase>}(res:={} -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Enter<**** user rulebase>{(:=, i:=1);
                                                          Arg(aLeftAssign -> i);
                                                          Arg(aRightAssign -> 1);
                                                          Enter<builtin>{(IsList, IsList(aLeftAssign));
                                                              Arg(parameter1 -> i);
                                                          Leave<builtin>}(IsList(aLeftAssign) -> False,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                          Enter<builtin>{(IsAtom, IsAtom(aLeftAssign));
                                                              Arg(parameter1 -> i);
                                                          Leave<builtin>}(IsAtom(aLeftAssign) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                          **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign),    Body: [    Check(NotIsNumber(aLeftAssign), "Only a variable can be placed on the left side of an := operator.");    MacroBind(aLeftAssign, Eval(aRightAssign));    Eval(aLeftAssign);]
                                                          Enter<builtin>{(Prog, [    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                              Arg(parameter1 -> Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                              Arg(parameter2 -> MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                              Arg(parameter3 -> Eval(aLeftAssign));
                                                              Enter<builtin>{(Check, Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                                  Arg(parameter1 -> NotIsNumber(aLeftAssign));
                                                                  Arg(parameter2 -> Only a variable can be placed on the left side of an := operator.);
                                                                  Enter<builtin>{(Not, NotIsNumber(aLeftAssign));
                                                                      Enter<builtin>{(IsNumber, IsNumber(aLeftAssign));
                                                                          Arg(parameter1 -> i);
                                                                      Leave<builtin>}(IsNumber(aLeftAssign) -> False,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                                      Arg(parameter1 -> False);
                                                                  Leave<builtin>}(NotIsNumber(aLeftAssign) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Leave<builtin>}(Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Enter<builtin>{(MacroBind, MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                                  Arg(parameter1 -> aLeftAssign);
                                                                  Arg(parameter2 -> Eval(aRightAssign));
                                                                  Enter<builtin>{(Eval, Eval(aRightAssign));
                                                                      Arg(parameter1 -> 1);
                                                                  Leave<builtin>}(Eval(aRightAssign) -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Leave<builtin>}(MacroBind(aLeftAssign,Eval(aRightAssign)) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Enter<builtin>{(Eval, Eval(aLeftAssign));
                                                                  Arg(parameter1 -> i);
                                                              Leave<builtin>}(Eval(aLeftAssign) -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                          Leave<builtin>}([    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);] -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Leave<**** user rulebase>}(i:=1 -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Enter<builtin>{(Bind, Bind(dimension,AddN(dimension,1)));
                                                          Arg(parameter1 -> dimension);
                                                          Arg(parameter2 -> AddN(dimension,1));
                                                          Enter<builtin>{(AddN, AddN(dimension,1));
                                                              Arg(parameter1 -> 1);
                                                              Arg(parameter2 -> 1);
                                                          Leave<builtin>}(AddN(dimension,1) -> 2,    Local variables: i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Leave<builtin>}(Bind(dimension,AddN(dimension,1)) -> True,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                      Enter<builtin>{(While, While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                          Arg(parameter1 -> IsLessThan(i,dimension));
                                                          Arg(parameter2 -> [    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                          Enter<builtin>{(IsLessThan, IsLessThan(i,dimension));
                                                              Arg(parameter1 -> 1);
                                                              Arg(parameter2 -> 2);
                                                          Leave<builtin>}(IsLessThan(i,dimension) -> True,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                          Enter<builtin>{(Prog, [    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                              Arg(parameter1 -> DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))));
                                                              Arg(parameter2 -> Bind(i,AddN(i,1)));
                                                              Enter<builtin>{(DestructiveInsert, DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))));
                                                                  Enter<builtin>{(ToAtom, ToAtom(ConcatStrings(ToString(vec),ToString(i))));
                                                                      Enter<builtin>{(ConcatStrings, ConcatStrings(ToString(vec),ToString(i)));
                                                                          Enter<builtin>{(List, {ToString(vec),ToString(i)});
                                                                              Arg(parameter1 -> ToString(vec));
                                                                              Arg(parameter2 -> ToString(i));
                                                                              Enter<builtin>{(ToString, ToString(vec));
                                                                                  Arg(parameter1 -> arg);
                                                                              Leave<builtin>}(ToString(vec) -> arg,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                              Enter<builtin>{(ToString, ToString(i));
                                                                                  Arg(parameter1 -> 1);
                                                                              Leave<builtin>}(ToString(i) -> 1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                          Leave<builtin>}({ToString(vec),ToString(i)} -> {arg,1},    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                          Arg(parameter1 -> ToString(vec));
                                                                          Arg(parameter2 -> ToString(i));
                                                                      Leave<builtin>}(ConcatStrings(ToString(vec),ToString(i)) -> arg1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                      Arg(parameter1 -> arg1);
                                                                  Leave<builtin>}(ToAtom(ConcatStrings(ToString(vec),ToString(i))) -> arg1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                  Arg(parameter1 -> {});
                                                                  Arg(parameter2 -> 1);
                                                                  Arg(parameter3 -> arg1);
                                                              Leave<builtin>}(DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))) -> {arg1},    Local variables: i -> 1, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                              Enter<builtin>{(Bind, Bind(i,AddN(i,1)));
                                                                  Arg(parameter1 -> i);
                                                                  Arg(parameter2 -> AddN(i,1));
                                                                  Enter<builtin>{(AddN, AddN(i,1));
                                                                      Arg(parameter1 -> 1);
                                                                      Arg(parameter2 -> 1);
                                                                  Leave<builtin>}(AddN(i,1) -> 2,    Local variables: i -> 1, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                              Leave<builtin>}(Bind(i,AddN(i,1)) -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                          Leave<builtin>}([    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));] -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                          Enter<builtin>{(IsLessThan, IsLessThan(i,dimension));
                                                              Arg(parameter1 -> 2);
                                                              Arg(parameter2 -> 2);
                                                          Leave<builtin>}(IsLessThan(i,dimension) -> False,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                      Leave<builtin>}(While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));] -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                      Enter<builtin>{(DestructiveReverse, DestructiveReverse(res));
                                                          Arg(parameter1 -> {arg1});
                                                      Leave<builtin>}(DestructiveReverse(res) -> {arg1},    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                  Leave<builtin>}([    Local(res,i);    res:={};    i:=1;    Bind(dimension,AddN(dimension,1));    While(IsLessThan(i,dimension))[        DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));        Bind(i,AddN(i,1));];    DestructiveReverse(res);] -> {arg1},    Local variables: dimension -> 2, vec -> arg, );
                                              Leave<**** user rulebase>}(MakeVector(arg,arity) -> {arg1},    Local variables: dimension -> 2, vec -> arg, );
                                              Arg(parameter1 -> CanBeMonomial);
                                              Arg(parameter2 -> {arg1});
                                          Leave<builtin>}(MacroRulebase(patternOperator,MakeVector(arg,arity)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                      Leave<builtin>}([    MacroRulebase(patternOperator,MakeVector(arg,arity));] -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(Bind, Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                                      Arg(parameter1 -> pattern);
                                      Arg(parameter2 -> Pattern'Create(patternVariables,postPredicate));
                                      Enter<builtin>{(Pattern'Create, Pattern'Create(patternVariables,postPredicate));
                                          Arg(parameter1 -> {_expr});
                                          Arg(parameter2 -> Type(expr)=UniVariate);
                                      Leave<builtin>}(Pattern'Create(patternVariables,postPredicate) -> Pattern,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Leave<builtin>}(Bind(pattern,Pattern'Create(patternVariables,postPredicate)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                                  Enter<builtin>{(MacroRulePattern, MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                                      Arg(parameter1 -> CanBeMonomial);
                                      Arg(parameter2 -> 1);
                                      Arg(parameter3 -> 10);
                                      Arg(parameter4 -> Pattern);
                                      Arg(parameter5 -> False);
                                  Leave<builtin>}(MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                              Leave<builtin>}([    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;] -> True,    Local variables: postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<**** user rulebase>}(DefinePattern(leftOperand[1],rightOperand,rulePrecedence,leftOperand[2]) -> True,    Local variables: postPredicate -> (= (Type expr )"UniVariate" ), rulePrecedence -> 10, rightOperand -> False, leftOperand -> (CanBeMonomial (_ expr )), );
                      Leave<builtin>}([    DefinePattern(leftOperand[1],rightOperand,rulePrecedence,leftOperand[2]);] -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> False, leftOperand -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
                  Leave<**** user rulebase>}(DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True) -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> False, leftOperand -> (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" )), );
              Leave<builtin>}([    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);] -> True,    Local variables: rightOperand -> False, leftOperand -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
          Leave<**** user rulebase>}(10#CanBeMonomial(_expr)_(Type(expr)=UniVariate)<--False -> True,    Local variables: rightOperand -> False, leftOperand -> (# 10 (_ (CanBeMonomial (_ expr ))(= (Type expr )"UniVariate" ))), );
          Enter<**** user rulebase>{(<--, 10#CanBeMonomial(_expr)<--Not(HasFunc(expr,ToAtom(+))OrHasFunc(expr,ToAtom(-))));
              Arg(leftOperand -> 10#CanBeMonomial(_expr));
              Arg(rightOperand -> Not(HasFunc(expr,ToAtom(+))OrHasFunc(expr,ToAtom(-))));
              Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),#));
                  Enter<builtin>{(Type, Type(leftOperand));
                      Arg(parameter1 -> 10#CanBeMonomial(_expr));
                  Leave<builtin>}(Type(leftOperand) -> #,    Local variables: rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (# 10 (CanBeMonomial (_ expr ))), );
                  Arg(parameter1 -> #);
                  Arg(parameter2 -> #);
              Leave<builtin>}(IsEqual(Type(leftOperand),#) -> True,    Local variables: rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (# 10 (CanBeMonomial (_ expr ))), );
              **** Rule in function (<--) matched: Precedence: 1, Parameters: leftOperand<hold=true>, rightOperand<hold=true>, Predicates: IsEqual(Type(leftOperand),"#"),    Body: [    DefinePattern(leftOperand[2], rightOperand, leftOperand[1], True);]
              Enter<builtin>{(Prog, [    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);]);
                  Arg(parameter1 -> DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                  Enter<**** user rulebase>{(DefinePattern, DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                      Enter<**** user rulebase>{(Nth, leftOperand[2]);
                          Arg(alist -> 10#CanBeMonomial(_expr));
                          Arg(aindex -> 2);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#CanBeMonomial(_expr));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 2);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#CanBeMonomial(_expr));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,CanBeMonomial(_expr)},    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                          Arg(parameter1 -> {#,10,CanBeMonomial(_expr)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#CanBeMonomial(_expr));
                              Arg(parameter2 -> 2);
                          Leave<builtin>}(MathNth(alist,aindex) -> CanBeMonomial(_expr),    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                      Leave<**** user rulebase>}(leftOperand[2] -> CanBeMonomial(_expr),    Local variables: aindex -> 2, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                      Enter<**** user rulebase>{(Nth, leftOperand[1]);
                          Arg(alist -> 10#CanBeMonomial(_expr));
                          Arg(aindex -> 1);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#CanBeMonomial(_expr));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 1);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#CanBeMonomial(_expr));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,CanBeMonomial(_expr)},    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                          Arg(parameter1 -> {#,10,CanBeMonomial(_expr)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#CanBeMonomial(_expr));
                              Arg(parameter2 -> 1);
                          Leave<builtin>}(MathNth(alist,aindex) -> 10,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                      Leave<**** user rulebase>}(leftOperand[1] -> 10,    Local variables: aindex -> 1, alist -> (# 10 (CanBeMonomial (_ expr ))), );
                      Arg(leftOperand -> CanBeMonomial(_expr));
                      Arg(rightOperand -> Not(HasFunc(expr,ToAtom(+))OrHasFunc(expr,ToAtom(-))));
                      Arg(rulePrecedence -> 10);
                      Arg(postPredicate -> True);
                      Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),_));
                          Enter<builtin>{(Type, Type(leftOperand));
                              Arg(parameter1 -> CanBeMonomial(_expr));
                          Leave<builtin>}(Type(leftOperand) -> CanBeMonomial,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Arg(parameter1 -> CanBeMonomial);
                          Arg(parameter2 -> _);
                      Leave<builtin>}(IsEqual(Type(leftOperand),_) -> False,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                      **** Rule in function (DefinePattern) matched: Precedence: 10, Parameters: leftOperand<hold=false>, rightOperand<hold=false>, rulePrecedence<hold=false>, postPredicate<hold=false>, Predicates: None.,    Body: [    Local(patternFlat, patternVariables, pattern, patternOperator, arg, arity);    Bind(patternFlat, FunctionToList(leftOperand));    Bind(patternVariables, Rest(patternFlat));    Bind(patternOperator, ToString(First(patternFlat)));    Bind(arity, Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator, arity), [        MacroRulebase(patternOperator, MakeVector(arg, arity));]);    Bind(pattern, Pattern'Create(patternVariables, postPredicate));    MacroRulePattern(patternOperator, arity, rulePrecedence, pattern)rightOperand;    True;]
                      Enter<builtin>{(Prog, [    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;]);
                          Arg(parameter1 -> Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                          Arg(parameter2 -> Bind(patternFlat,FunctionToList(leftOperand)));
                          Arg(parameter3 -> Bind(patternVariables,Rest(patternFlat)));
                          Arg(parameter4 -> Bind(patternOperator,ToString(First(patternFlat))));
                          Arg(parameter5 -> Bind(arity,Length(patternVariables)));
                          Arg(parameter6 -> DefLoadFunction(patternOperator));
                          Arg(parameter7 -> If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                          Arg(parameter8 -> Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                          Arg(parameter9 -> MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                          Arg(parameter10 -> True);
                          Enter<builtin>{(Local, Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> patternVariables);
                              Arg(parameter3 -> pattern);
                              Arg(parameter4 -> patternOperator);
                              Arg(parameter5 -> arg);
                              Arg(parameter6 -> arity);
                          Leave<builtin>}(Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternFlat,FunctionToList(leftOperand)));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> FunctionToList(leftOperand));
                              Enter<builtin>{(FunctionToList, FunctionToList(leftOperand));
                                  Arg(parameter1 -> CanBeMonomial(_expr));
                              Leave<builtin>}(FunctionToList(leftOperand) -> {CanBeMonomial,_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternFlat,FunctionToList(leftOperand)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternVariables,Rest(patternFlat)));
                              Arg(parameter1 -> patternVariables);
                              Arg(parameter2 -> Rest(patternFlat));
                              Enter<builtin>{(Rest, Rest(patternFlat));
                                  Arg(parameter1 -> {CanBeMonomial,_expr});
                              Leave<builtin>}(Rest(patternFlat) -> {_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternVariables,Rest(patternFlat)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternOperator,ToString(First(patternFlat))));
                              Arg(parameter1 -> patternOperator);
                              Arg(parameter2 -> ToString(First(patternFlat)));
                              Enter<builtin>{(ToString, ToString(First(patternFlat)));
                                  Enter<builtin>{(First, First(patternFlat));
                                      Arg(parameter1 -> {CanBeMonomial,_expr});
                                  Leave<builtin>}(First(patternFlat) -> CanBeMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                                  Arg(parameter1 -> CanBeMonomial);
                              Leave<builtin>}(ToString(First(patternFlat)) -> CanBeMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternOperator,ToString(First(patternFlat))) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(arity,Length(patternVariables)));
                              Arg(parameter1 -> arity);
                              Arg(parameter2 -> Length(patternVariables));
                              Enter<builtin>{(Length, Length(patternVariables));
                                  Arg(parameter1 -> {_expr});
                              Leave<builtin>}(Length(patternVariables) -> 1,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(Bind(arity,Length(patternVariables)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(DefLoadFunction, DefLoadFunction(patternOperator));
                              Arg(parameter1 -> CanBeMonomial);
                          Leave<builtin>}(DefLoadFunction(patternOperator) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(If, If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                              Arg(parameter1 -> NotRulebaseDefined(patternOperator,arity));
                              Arg(parameter2 -> [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                              Enter<builtin>{(Not, NotRulebaseDefined(patternOperator,arity));
                                  Enter<builtin>{(RulebaseDefined, RulebaseDefined(patternOperator,arity));
                                      Arg(parameter1 -> CanBeMonomial);
                                      Arg(parameter2 -> 1);
                                  Leave<builtin>}(RulebaseDefined(patternOperator,arity) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                                  Arg(parameter1 -> True);
                              Leave<builtin>}(NotRulebaseDefined(patternOperator,arity) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                              Arg(parameter1 -> pattern);
                              Arg(parameter2 -> Pattern'Create(patternVariables,postPredicate));
                              Enter<builtin>{(Pattern'Create, Pattern'Create(patternVariables,postPredicate));
                                  Arg(parameter1 -> {_expr});
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(Pattern'Create(patternVariables,postPredicate) -> Pattern,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Leave<builtin>}(Bind(pattern,Pattern'Create(patternVariables,postPredicate)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                          Enter<builtin>{(MacroRulePattern, MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                              Arg(parameter1 -> CanBeMonomial);
                              Arg(parameter2 -> 1);
                              Arg(parameter3 -> 10);
                              Arg(parameter4 -> Pattern);
                              Arg(parameter5 -> Not(HasFunc(expr,ToAtom(+))OrHasFunc(expr,ToAtom(-))));
                          Leave<builtin>}(MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "CanBeMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List CanBeMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                      Leave<builtin>}([    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;] -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
                  Leave<**** user rulebase>}(DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True) -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (CanBeMonomial (_ expr )), );
              Leave<builtin>}([    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);] -> True,    Local variables: rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (# 10 (CanBeMonomial (_ expr ))), );
          Leave<**** user rulebase>}(10#CanBeMonomial(_expr)<--Not(HasFunc(expr,ToAtom(+))OrHasFunc(expr,ToAtom(-))) -> True,    Local variables: rightOperand -> (Not (Or (HasFunc expr (ToAtom "+" ))(HasFunc expr (ToAtom "-" )))), leftOperand -> (# 10 (CanBeMonomial (_ expr ))), );
          Enter<**** user rulebase>{(<--, 10#IsMonomial(expr_CanBeMonomial)<--[    Local(r);    If(IsRationalFunction(expr),r:=VarList(Denominator(expr))={},r:=True);]);
              Arg(leftOperand -> 10#IsMonomial(expr_CanBeMonomial));
              Arg(rightOperand -> [    Local(r);    If(IsRationalFunction(expr),r:=VarList(Denominator(expr))={},r:=True);]);
              Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),#));
                  Enter<builtin>{(Type, Type(leftOperand));
                      Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                  Leave<builtin>}(Type(leftOperand) -> #,    Local variables: rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                  Arg(parameter1 -> #);
                  Arg(parameter2 -> #);
              Leave<builtin>}(IsEqual(Type(leftOperand),#) -> True,    Local variables: rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
              **** Rule in function (<--) matched: Precedence: 1, Parameters: leftOperand<hold=true>, rightOperand<hold=true>, Predicates: IsEqual(Type(leftOperand),"#"),    Body: [    DefinePattern(leftOperand[2], rightOperand, leftOperand[1], True);]
              Enter<builtin>{(Prog, [    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);]);
                  Arg(parameter1 -> DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                  Enter<**** user rulebase>{(DefinePattern, DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                      Enter<**** user rulebase>{(Nth, leftOperand[2]);
                          Arg(alist -> 10#IsMonomial(expr_CanBeMonomial));
                          Arg(aindex -> 2);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 2);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,IsMonomial(expr_CanBeMonomial)},    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                          Arg(parameter1 -> {#,10,IsMonomial(expr_CanBeMonomial)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                              Arg(parameter2 -> 2);
                          Leave<builtin>}(MathNth(alist,aindex) -> IsMonomial(expr_CanBeMonomial),    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                      Leave<**** user rulebase>}(leftOperand[2] -> IsMonomial(expr_CanBeMonomial),    Local variables: aindex -> 2, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                      Enter<**** user rulebase>{(Nth, leftOperand[1]);
                          Arg(alist -> 10#IsMonomial(expr_CanBeMonomial));
                          Arg(aindex -> 1);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 1);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,10,IsMonomial(expr_CanBeMonomial)},    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                          Arg(parameter1 -> {#,10,IsMonomial(expr_CanBeMonomial)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 10#IsMonomial(expr_CanBeMonomial));
                              Arg(parameter2 -> 1);
                          Leave<builtin>}(MathNth(alist,aindex) -> 10,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                      Leave<**** user rulebase>}(leftOperand[1] -> 10,    Local variables: aindex -> 1, alist -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
                      Arg(leftOperand -> IsMonomial(expr_CanBeMonomial));
                      Arg(rightOperand -> [    Local(r);    If(IsRationalFunction(expr),r:=VarList(Denominator(expr))={},r:=True);]);
                      Arg(rulePrecedence -> 10);
                      Arg(postPredicate -> True);
                      Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),_));
                          Enter<builtin>{(Type, Type(leftOperand));
                              Arg(parameter1 -> IsMonomial(expr_CanBeMonomial));
                          Leave<builtin>}(Type(leftOperand) -> IsMonomial,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Arg(parameter1 -> IsMonomial);
                          Arg(parameter2 -> _);
                      Leave<builtin>}(IsEqual(Type(leftOperand),_) -> False,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                      **** Rule in function (DefinePattern) matched: Precedence: 10, Parameters: leftOperand<hold=false>, rightOperand<hold=false>, rulePrecedence<hold=false>, postPredicate<hold=false>, Predicates: None.,    Body: [    Local(patternFlat, patternVariables, pattern, patternOperator, arg, arity);    Bind(patternFlat, FunctionToList(leftOperand));    Bind(patternVariables, Rest(patternFlat));    Bind(patternOperator, ToString(First(patternFlat)));    Bind(arity, Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator, arity), [        MacroRulebase(patternOperator, MakeVector(arg, arity));]);    Bind(pattern, Pattern'Create(patternVariables, postPredicate));    MacroRulePattern(patternOperator, arity, rulePrecedence, pattern)rightOperand;    True;]
                      Enter<builtin>{(Prog, [    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;]);
                          Arg(parameter1 -> Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                          Arg(parameter2 -> Bind(patternFlat,FunctionToList(leftOperand)));
                          Arg(parameter3 -> Bind(patternVariables,Rest(patternFlat)));
                          Arg(parameter4 -> Bind(patternOperator,ToString(First(patternFlat))));
                          Arg(parameter5 -> Bind(arity,Length(patternVariables)));
                          Arg(parameter6 -> DefLoadFunction(patternOperator));
                          Arg(parameter7 -> If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                          Arg(parameter8 -> Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                          Arg(parameter9 -> MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                          Arg(parameter10 -> True);
                          Enter<builtin>{(Local, Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> patternVariables);
                              Arg(parameter3 -> pattern);
                              Arg(parameter4 -> patternOperator);
                              Arg(parameter5 -> arg);
                              Arg(parameter6 -> arity);
                          Leave<builtin>}(Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(Bind, Bind(patternFlat,FunctionToList(leftOperand)));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> FunctionToList(leftOperand));
                              Enter<builtin>{(FunctionToList, FunctionToList(leftOperand));
                                  Arg(parameter1 -> IsMonomial(expr_CanBeMonomial));
                              Leave<builtin>}(FunctionToList(leftOperand) -> {IsMonomial,expr_CanBeMonomial},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(Bind(patternFlat,FunctionToList(leftOperand)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(Bind, Bind(patternVariables,Rest(patternFlat)));
                              Arg(parameter1 -> patternVariables);
                              Arg(parameter2 -> Rest(patternFlat));
                              Enter<builtin>{(Rest, Rest(patternFlat));
                                  Arg(parameter1 -> {IsMonomial,expr_CanBeMonomial});
                              Leave<builtin>}(Rest(patternFlat) -> {expr_CanBeMonomial},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(Bind(patternVariables,Rest(patternFlat)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(Bind, Bind(patternOperator,ToString(First(patternFlat))));
                              Arg(parameter1 -> patternOperator);
                              Arg(parameter2 -> ToString(First(patternFlat)));
                              Enter<builtin>{(ToString, ToString(First(patternFlat)));
                                  Enter<builtin>{(First, First(patternFlat));
                                      Arg(parameter1 -> {IsMonomial,expr_CanBeMonomial});
                                  Leave<builtin>}(First(patternFlat) -> IsMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                                  Arg(parameter1 -> IsMonomial);
                              Leave<builtin>}(ToString(First(patternFlat)) -> IsMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(Bind(patternOperator,ToString(First(patternFlat))) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(Bind, Bind(arity,Length(patternVariables)));
                              Arg(parameter1 -> arity);
                              Arg(parameter2 -> Length(patternVariables));
                              Enter<builtin>{(Length, Length(patternVariables));
                                  Arg(parameter1 -> {expr_CanBeMonomial});
                              Leave<builtin>}(Length(patternVariables) -> 1,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(Bind(arity,Length(patternVariables)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(DefLoadFunction, DefLoadFunction(patternOperator));
                              Arg(parameter1 -> IsMonomial);
                          Leave<builtin>}(DefLoadFunction(patternOperator) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(If, If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                              Arg(parameter1 -> NotRulebaseDefined(patternOperator,arity));
                              Arg(parameter2 -> [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                              Enter<builtin>{(Not, NotRulebaseDefined(patternOperator,arity));
                                  Enter<builtin>{(RulebaseDefined, RulebaseDefined(patternOperator,arity));
                                      Arg(parameter1 -> IsMonomial);
                                      Arg(parameter2 -> 1);
                                  Leave<builtin>}(RulebaseDefined(patternOperator,arity) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotRulebaseDefined(patternOperator,arity) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                              Enter<builtin>{(Prog, [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                                  Arg(parameter1 -> MacroRulebase(patternOperator,MakeVector(arg,arity)));
                                  Enter<builtin>{(MacroRulebase, MacroRulebase(patternOperator,MakeVector(arg,arity)));
                                      Enter<**** user rulebase>{(MakeVector, MakeVector(arg,arity));
                                          Arg(vec -> arg);
                                          Arg(dimension -> 1);
                                          **** Rule in function (MakeVector) matched: Precedence: 1, Parameters: vec<hold=false>, dimension<hold=false>, Predicates: None.,    Body: [    Local(res, i);    res:={};    i:=1;    Bind(dimension, AddN(dimension, 1));    While(IsLessThan(i, dimension))[        DestructiveInsert(res, 1, ToAtom(ConcatStrings(ToString(vec), ToString(i))));        Bind(i, AddN(i, 1));];    DestructiveReverse(res);]
                                          Enter<builtin>{(Prog, [    Local(res,i);    res:={};    i:=1;    Bind(dimension,AddN(dimension,1));    While(IsLessThan(i,dimension))[        DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));        Bind(i,AddN(i,1));];    DestructiveReverse(res);]);
                                              Arg(parameter1 -> Local(res,i));
                                              Arg(parameter2 -> res:={});
                                              Arg(parameter3 -> i:=1);
                                              Arg(parameter4 -> Bind(dimension,AddN(dimension,1)));
                                              Arg(parameter5 -> While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                              Arg(parameter6 -> DestructiveReverse(res));
                                              Enter<builtin>{(Local, Local(res,i));
                                                  Arg(parameter1 -> res);
                                                  Arg(parameter2 -> i);
                                              Leave<builtin>}(Local(res,i) -> True,    Local variables: i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                              Enter<**** user rulebase>{(:=, res:={});
                                                  Arg(aLeftAssign -> res);
                                                  Arg(aRightAssign -> {});
                                                  Enter<builtin>{(IsList, IsList(aLeftAssign));
                                                      Arg(parameter1 -> res);
                                                  Leave<builtin>}(IsList(aLeftAssign) -> False,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                  Enter<builtin>{(IsAtom, IsAtom(aLeftAssign));
                                                      Arg(parameter1 -> res);
                                                  Leave<builtin>}(IsAtom(aLeftAssign) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                  **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign),    Body: [    Check(NotIsNumber(aLeftAssign), "Only a variable can be placed on the left side of an := operator.");    MacroBind(aLeftAssign, Eval(aRightAssign));    Eval(aLeftAssign);]
                                                  Enter<builtin>{(Prog, [    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                      Arg(parameter1 -> Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                      Arg(parameter2 -> MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                      Arg(parameter3 -> Eval(aLeftAssign));
                                                      Enter<builtin>{(Check, Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                          Arg(parameter1 -> NotIsNumber(aLeftAssign));
                                                          Arg(parameter2 -> Only a variable can be placed on the left side of an := operator.);
                                                          Enter<builtin>{(Not, NotIsNumber(aLeftAssign));
                                                              Enter<builtin>{(IsNumber, IsNumber(aLeftAssign));
                                                                  Arg(parameter1 -> res);
                                                              Leave<builtin>}(IsNumber(aLeftAssign) -> False,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                              Arg(parameter1 -> False);
                                                          Leave<builtin>}(NotIsNumber(aLeftAssign) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                      Leave<builtin>}(Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                      Enter<builtin>{(MacroBind, MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                          Arg(parameter1 -> aLeftAssign);
                                                          Arg(parameter2 -> Eval(aRightAssign));
                                                          Enter<builtin>{(Eval, Eval(aRightAssign));
                                                              Arg(parameter1 -> {});
                                                              Enter<builtin>{(List, {});
                                                              Leave<builtin>}({} -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                          Leave<builtin>}(Eval(aRightAssign) -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> unbound, dimension -> 1, vec -> arg, );
                                                      Leave<builtin>}(MacroBind(aLeftAssign,Eval(aRightAssign)) -> True,    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Enter<builtin>{(Eval, Eval(aLeftAssign));
                                                          Arg(parameter1 -> res);
                                                      Leave<builtin>}(Eval(aLeftAssign) -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                  Leave<builtin>}([    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);] -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                              Leave<**** user rulebase>}(res:={} -> {},    Local variables: aRightAssign -> (List ), aLeftAssign -> res, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                              Enter<**** user rulebase>{(:=, i:=1);
                                                  Arg(aLeftAssign -> i);
                                                  Arg(aRightAssign -> 1);
                                                  Enter<builtin>{(IsList, IsList(aLeftAssign));
                                                      Arg(parameter1 -> i);
                                                  Leave<builtin>}(IsList(aLeftAssign) -> False,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                  Enter<builtin>{(IsAtom, IsAtom(aLeftAssign));
                                                      Arg(parameter1 -> i);
                                                  Leave<builtin>}(IsAtom(aLeftAssign) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                  **** Rule in function (:=) matched: Precedence: 0, Parameters: aLeftAssign<hold=true>, aRightAssign<hold=true>, Predicates: IsAtom(aLeftAssign),    Body: [    Check(NotIsNumber(aLeftAssign), "Only a variable can be placed on the left side of an := operator.");    MacroBind(aLeftAssign, Eval(aRightAssign));    Eval(aLeftAssign);]
                                                  Enter<builtin>{(Prog, [    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);]);
                                                      Arg(parameter1 -> Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                      Arg(parameter2 -> MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                      Arg(parameter3 -> Eval(aLeftAssign));
                                                      Enter<builtin>{(Check, Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.));
                                                          Arg(parameter1 -> NotIsNumber(aLeftAssign));
                                                          Arg(parameter2 -> Only a variable can be placed on the left side of an := operator.);
                                                          Enter<builtin>{(Not, NotIsNumber(aLeftAssign));
                                                              Enter<builtin>{(IsNumber, IsNumber(aLeftAssign));
                                                                  Arg(parameter1 -> i);
                                                              Leave<builtin>}(IsNumber(aLeftAssign) -> False,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                              Arg(parameter1 -> False);
                                                          Leave<builtin>}(NotIsNumber(aLeftAssign) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Leave<builtin>}(Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Enter<builtin>{(MacroBind, MacroBind(aLeftAssign,Eval(aRightAssign)));
                                                          Arg(parameter1 -> aLeftAssign);
                                                          Arg(parameter2 -> Eval(aRightAssign));
                                                          Enter<builtin>{(Eval, Eval(aRightAssign));
                                                              Arg(parameter1 -> 1);
                                                          Leave<builtin>}(Eval(aRightAssign) -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> unbound, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Leave<builtin>}(MacroBind(aLeftAssign,Eval(aRightAssign)) -> True,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                      Enter<builtin>{(Eval, Eval(aLeftAssign));
                                                          Arg(parameter1 -> i);
                                                      Leave<builtin>}(Eval(aLeftAssign) -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                                  Leave<builtin>}([    Check(NotIsNumber(aLeftAssign),Only a variable can be placed on the left side of an := operator.);    MacroBind(aLeftAssign,Eval(aRightAssign));    Eval(aLeftAssign);] -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                              Leave<**** user rulebase>}(i:=1 -> 1,    Local variables: aRightAssign -> 1, aLeftAssign -> i, i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                              Enter<builtin>{(Bind, Bind(dimension,AddN(dimension,1)));
                                                  Arg(parameter1 -> dimension);
                                                  Arg(parameter2 -> AddN(dimension,1));
                                                  Enter<builtin>{(AddN, AddN(dimension,1));
                                                      Arg(parameter1 -> 1);
                                                      Arg(parameter2 -> 1);
                                                  Leave<builtin>}(AddN(dimension,1) -> 2,    Local variables: i -> 1, res -> (List ), dimension -> 1, vec -> arg, );
                                              Leave<builtin>}(Bind(dimension,AddN(dimension,1)) -> True,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                              Enter<builtin>{(While, While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                  Arg(parameter1 -> IsLessThan(i,dimension));
                                                  Arg(parameter2 -> [    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                  Enter<builtin>{(IsLessThan, IsLessThan(i,dimension));
                                                      Arg(parameter1 -> 1);
                                                      Arg(parameter2 -> 2);
                                                  Leave<builtin>}(IsLessThan(i,dimension) -> True,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                  Enter<builtin>{(Prog, [    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));]);
                                                      Arg(parameter1 -> DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))));
                                                      Arg(parameter2 -> Bind(i,AddN(i,1)));
                                                      Enter<builtin>{(DestructiveInsert, DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))));
                                                          Enter<builtin>{(ToAtom, ToAtom(ConcatStrings(ToString(vec),ToString(i))));
                                                              Enter<builtin>{(ConcatStrings, ConcatStrings(ToString(vec),ToString(i)));
                                                                  Enter<builtin>{(List, {ToString(vec),ToString(i)});
                                                                      Arg(parameter1 -> ToString(vec));
                                                                      Arg(parameter2 -> ToString(i));
                                                                      Enter<builtin>{(ToString, ToString(vec));
                                                                          Arg(parameter1 -> arg);
                                                                      Leave<builtin>}(ToString(vec) -> arg,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                      Enter<builtin>{(ToString, ToString(i));
                                                                          Arg(parameter1 -> 1);
                                                                      Leave<builtin>}(ToString(i) -> 1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                  Leave<builtin>}({ToString(vec),ToString(i)} -> {arg,1},    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                                  Arg(parameter1 -> ToString(vec));
                                                                  Arg(parameter2 -> ToString(i));
                                                              Leave<builtin>}(ConcatStrings(ToString(vec),ToString(i)) -> arg1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                              Arg(parameter1 -> arg1);
                                                          Leave<builtin>}(ToAtom(ConcatStrings(ToString(vec),ToString(i))) -> arg1,    Local variables: i -> 1, res -> (List ), dimension -> 2, vec -> arg, );
                                                          Arg(parameter1 -> {});
                                                          Arg(parameter2 -> 1);
                                                          Arg(parameter3 -> arg1);
                                                      Leave<builtin>}(DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i)))) -> {arg1},    Local variables: i -> 1, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                      Enter<builtin>{(Bind, Bind(i,AddN(i,1)));
                                                          Arg(parameter1 -> i);
                                                          Arg(parameter2 -> AddN(i,1));
                                                          Enter<builtin>{(AddN, AddN(i,1));
                                                              Arg(parameter1 -> 1);
                                                              Arg(parameter2 -> 1);
                                                          Leave<builtin>}(AddN(i,1) -> 2,    Local variables: i -> 1, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                      Leave<builtin>}(Bind(i,AddN(i,1)) -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                  Leave<builtin>}([    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));] -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                                  Enter<builtin>{(IsLessThan, IsLessThan(i,dimension));
                                                      Arg(parameter1 -> 2);
                                                      Arg(parameter2 -> 2);
                                                  Leave<builtin>}(IsLessThan(i,dimension) -> False,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                              Leave<builtin>}(While(IsLessThan(i,dimension))[    DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));    Bind(i,AddN(i,1));] -> True,    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                              Enter<builtin>{(DestructiveReverse, DestructiveReverse(res));
                                                  Arg(parameter1 -> {arg1});
                                              Leave<builtin>}(DestructiveReverse(res) -> {arg1},    Local variables: i -> 2, res -> (List arg1 ), dimension -> 2, vec -> arg, );
                                          Leave<builtin>}([    Local(res,i);    res:={};    i:=1;    Bind(dimension,AddN(dimension,1));    While(IsLessThan(i,dimension))[        DestructiveInsert(res,1,ToAtom(ConcatStrings(ToString(vec),ToString(i))));        Bind(i,AddN(i,1));];    DestructiveReverse(res);] -> {arg1},    Local variables: dimension -> 2, vec -> arg, );
                                      Leave<**** user rulebase>}(MakeVector(arg,arity) -> {arg1},    Local variables: dimension -> 2, vec -> arg, );
                                      Arg(parameter1 -> IsMonomial);
                                      Arg(parameter2 -> {arg1});
                                  Leave<builtin>}(MacroRulebase(patternOperator,MakeVector(arg,arity)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                              Leave<builtin>}([    MacroRulebase(patternOperator,MakeVector(arg,arity));] -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(Bind, Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                              Arg(parameter1 -> pattern);
                              Arg(parameter2 -> Pattern'Create(patternVariables,postPredicate));
                              Enter<builtin>{(Pattern'Create, Pattern'Create(patternVariables,postPredicate));
                                  Arg(parameter1 -> {expr_CanBeMonomial});
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(Pattern'Create(patternVariables,postPredicate) -> Pattern,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Leave<builtin>}(Bind(pattern,Pattern'Create(patternVariables,postPredicate)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                          Enter<builtin>{(MacroRulePattern, MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                              Arg(parameter1 -> IsMonomial);
                              Arg(parameter2 -> 1);
                              Arg(parameter3 -> 10);
                              Arg(parameter4 -> Pattern);
                              Arg(parameter5 -> [    Local(r);    If(IsRationalFunction(expr),r:=VarList(Denominator(expr))={},r:=True);]);
                          Leave<builtin>}(MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr CanBeMonomial )), patternFlat -> (List IsMonomial (_ expr CanBeMonomial )), postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                      Leave<builtin>}([    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;] -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
                  Leave<**** user rulebase>}(DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True) -> True,    Local variables: postPredicate -> True, rulePrecedence -> 10, rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (IsMonomial (_ expr CanBeMonomial )), );
              Leave<builtin>}([    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);] -> True,    Local variables: rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
          Leave<**** user rulebase>}(10#IsMonomial(expr_CanBeMonomial)<--[    Local(r);    If(IsRationalFunction(expr),r:=VarList(Denominator(expr))={},r:=True);] -> True,    Local variables: rightOperand -> (Prog (Local r )(If (IsRationalFunction expr )(:= r (= (VarList (Denominator expr ))(List )))(:= r True ))), leftOperand -> (# 10 (IsMonomial (_ expr CanBeMonomial ))), );
          Enter<**** user rulebase>{(<--, 15#IsMonomial(_expr)<--False);
              Arg(leftOperand -> 15#IsMonomial(_expr));
              Arg(rightOperand -> False);
              Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),#));
                  Enter<builtin>{(Type, Type(leftOperand));
                      Arg(parameter1 -> 15#IsMonomial(_expr));
                  Leave<builtin>}(Type(leftOperand) -> #,    Local variables: rightOperand -> False, leftOperand -> (# 15 (IsMonomial (_ expr ))), );
                  Arg(parameter1 -> #);
                  Arg(parameter2 -> #);
              Leave<builtin>}(IsEqual(Type(leftOperand),#) -> True,    Local variables: rightOperand -> False, leftOperand -> (# 15 (IsMonomial (_ expr ))), );
              **** Rule in function (<--) matched: Precedence: 1, Parameters: leftOperand<hold=true>, rightOperand<hold=true>, Predicates: IsEqual(Type(leftOperand),"#"),    Body: [    DefinePattern(leftOperand[2], rightOperand, leftOperand[1], True);]
              Enter<builtin>{(Prog, [    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);]);
                  Arg(parameter1 -> DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                  Enter<**** user rulebase>{(DefinePattern, DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True));
                      Enter<**** user rulebase>{(Nth, leftOperand[2]);
                          Arg(alist -> 15#IsMonomial(_expr));
                          Arg(aindex -> 2);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 15#IsMonomial(_expr));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 2);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 15#IsMonomial(_expr));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,15,IsMonomial(_expr)},    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                                          Arg(parameter1 -> {#,15,IsMonomial(_expr)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 15#IsMonomial(_expr));
                              Arg(parameter2 -> 2);
                          Leave<builtin>}(MathNth(alist,aindex) -> IsMonomial(_expr),    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                      Leave<**** user rulebase>}(leftOperand[2] -> IsMonomial(_expr),    Local variables: aindex -> 2, alist -> (# 15 (IsMonomial (_ expr ))), );
                      Enter<**** user rulebase>{(Nth, leftOperand[1]);
                          Arg(alist -> 15#IsMonomial(_expr));
                          Arg(aindex -> 1);
                          Enter<builtin>{(And, And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)));
                              Arg(parameter1 -> IsEqual(IsFunction(alist),True));
                              Arg(parameter2 -> IsEqual(IsInteger(aindex),True));
                              Arg(parameter3 -> NotIsEqual(First(FunctionToList(alist)),Nth));
                              Enter<builtin>{(IsEqual, IsEqual(IsFunction(alist),True));
                                  Enter<builtin>{(IsFunction, IsFunction(alist));
                                      Arg(parameter1 -> 15#IsMonomial(_expr));
                                  Leave<builtin>}(IsFunction(alist) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsFunction(alist),True) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                              Enter<builtin>{(IsEqual, IsEqual(IsInteger(aindex),True));
                                  Enter<builtin>{(IsInteger, IsInteger(aindex));
                                      Arg(parameter1 -> 1);
                                  Leave<builtin>}(IsInteger(aindex) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> True);
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(IsEqual(IsInteger(aindex),True) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                              Enter<builtin>{(Not, NotIsEqual(First(FunctionToList(alist)),Nth));
                                  Enter<builtin>{(IsEqual, IsEqual(First(FunctionToList(alist)),Nth));
                                      Enter<builtin>{(First, First(FunctionToList(alist)));
                                          Enter<builtin>{(FunctionToList, FunctionToList(alist));
                                              Arg(parameter1 -> 15#IsMonomial(_expr));
                                          Leave<builtin>}(FunctionToList(alist) -> {#,15,IsMonomial(_expr)},    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                                          Arg(parameter1 -> {#,15,IsMonomial(_expr)});
                                      Leave<builtin>}(First(FunctionToList(alist)) -> #,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                                      Arg(parameter1 -> #);
                                      Arg(parameter2 -> Nth);
                                  Leave<builtin>}(IsEqual(First(FunctionToList(alist)),Nth) -> False,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                                  Arg(parameter1 -> False);
                              Leave<builtin>}(NotIsEqual(First(FunctionToList(alist)),Nth) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                          Leave<builtin>}(And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)) -> True,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                          **** Rule in function (Nth) matched: Precedence: 10, Parameters: alist<hold=false>, aindex<hold=false>, Predicates: And(IsEqual(IsFunction(alist),True),IsEqual(IsInteger(aindex),True),NotIsEqual(First(FunctionToList(alist)),Nth)),    Body: MathNth(alist, aindex)
                          Enter<builtin>{(MathNth, MathNth(alist,aindex));
                              Arg(parameter1 -> 15#IsMonomial(_expr));
                              Arg(parameter2 -> 1);
                          Leave<builtin>}(MathNth(alist,aindex) -> 15,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                      Leave<**** user rulebase>}(leftOperand[1] -> 15,    Local variables: aindex -> 1, alist -> (# 15 (IsMonomial (_ expr ))), );
                      Arg(leftOperand -> IsMonomial(_expr));
                      Arg(rightOperand -> False);
                      Arg(rulePrecedence -> 15);
                      Arg(postPredicate -> True);
                      Enter<builtin>{(IsEqual, IsEqual(Type(leftOperand),_));
                          Enter<builtin>{(Type, Type(leftOperand));
                              Arg(parameter1 -> IsMonomial(_expr));
                          Leave<builtin>}(Type(leftOperand) -> IsMonomial,    Local variables: postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Arg(parameter1 -> IsMonomial);
                          Arg(parameter2 -> _);
                      Leave<builtin>}(IsEqual(Type(leftOperand),_) -> False,    Local variables: postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                      **** Rule in function (DefinePattern) matched: Precedence: 10, Parameters: leftOperand<hold=false>, rightOperand<hold=false>, rulePrecedence<hold=false>, postPredicate<hold=false>, Predicates: None.,    Body: [    Local(patternFlat, patternVariables, pattern, patternOperator, arg, arity);    Bind(patternFlat, FunctionToList(leftOperand));    Bind(patternVariables, Rest(patternFlat));    Bind(patternOperator, ToString(First(patternFlat)));    Bind(arity, Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator, arity), [        MacroRulebase(patternOperator, MakeVector(arg, arity));]);    Bind(pattern, Pattern'Create(patternVariables, postPredicate));    MacroRulePattern(patternOperator, arity, rulePrecedence, pattern)rightOperand;    True;]
                      Enter<builtin>{(Prog, [    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;]);
                          Arg(parameter1 -> Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                          Arg(parameter2 -> Bind(patternFlat,FunctionToList(leftOperand)));
                          Arg(parameter3 -> Bind(patternVariables,Rest(patternFlat)));
                          Arg(parameter4 -> Bind(patternOperator,ToString(First(patternFlat))));
                          Arg(parameter5 -> Bind(arity,Length(patternVariables)));
                          Arg(parameter6 -> DefLoadFunction(patternOperator));
                          Arg(parameter7 -> If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                          Arg(parameter8 -> Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                          Arg(parameter9 -> MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                          Arg(parameter10 -> True);
                          Enter<builtin>{(Local, Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> patternVariables);
                              Arg(parameter3 -> pattern);
                              Arg(parameter4 -> patternOperator);
                              Arg(parameter5 -> arg);
                              Arg(parameter6 -> arity);
                          Leave<builtin>}(Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternFlat,FunctionToList(leftOperand)));
                              Arg(parameter1 -> patternFlat);
                              Arg(parameter2 -> FunctionToList(leftOperand));
                              Enter<builtin>{(FunctionToList, FunctionToList(leftOperand));
                                  Arg(parameter1 -> IsMonomial(_expr));
                              Leave<builtin>}(FunctionToList(leftOperand) -> {IsMonomial,_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> unbound, postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternFlat,FunctionToList(leftOperand)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternVariables,Rest(patternFlat)));
                              Arg(parameter1 -> patternVariables);
                              Arg(parameter2 -> Rest(patternFlat));
                              Enter<builtin>{(Rest, Rest(patternFlat));
                                  Arg(parameter1 -> {IsMonomial,_expr});
                              Leave<builtin>}(Rest(patternFlat) -> {_expr},    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> unbound, patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternVariables,Rest(patternFlat)) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(patternOperator,ToString(First(patternFlat))));
                              Arg(parameter1 -> patternOperator);
                              Arg(parameter2 -> ToString(First(patternFlat)));
                              Enter<builtin>{(ToString, ToString(First(patternFlat)));
                                  Enter<builtin>{(First, First(patternFlat));
                                      Arg(parameter1 -> {IsMonomial,_expr});
                                  Leave<builtin>}(First(patternFlat) -> IsMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                                  Arg(parameter1 -> IsMonomial);
                              Leave<builtin>}(ToString(First(patternFlat)) -> IsMonomial,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> unbound, pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(Bind(patternOperator,ToString(First(patternFlat))) -> True,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(arity,Length(patternVariables)));
                              Arg(parameter1 -> arity);
                              Arg(parameter2 -> Length(patternVariables));
                              Enter<builtin>{(Length, Length(patternVariables));
                                  Arg(parameter1 -> {_expr});
                              Leave<builtin>}(Length(patternVariables) -> 1,    Local variables: arity -> unbound, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(Bind(arity,Length(patternVariables)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(DefLoadFunction, DefLoadFunction(patternOperator));
                              Arg(parameter1 -> IsMonomial);
                          Leave<builtin>}(DefLoadFunction(patternOperator) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(If, If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]));
                              Arg(parameter1 -> NotRulebaseDefined(patternOperator,arity));
                              Arg(parameter2 -> [    MacroRulebase(patternOperator,MakeVector(arg,arity));]);
                              Enter<builtin>{(Not, NotRulebaseDefined(patternOperator,arity));
                                  Enter<builtin>{(RulebaseDefined, RulebaseDefined(patternOperator,arity));
                                      Arg(parameter1 -> IsMonomial);
                                      Arg(parameter2 -> 1);
                                  Leave<builtin>}(RulebaseDefined(patternOperator,arity) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                                  Arg(parameter1 -> True);
                              Leave<builtin>}(NotRulebaseDefined(patternOperator,arity) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(If(NotRulebaseDefined(patternOperator,arity),[    MacroRulebase(patternOperator,MakeVector(arg,arity));]) -> False,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(Bind, Bind(pattern,Pattern'Create(patternVariables,postPredicate)));
                              Arg(parameter1 -> pattern);
                              Arg(parameter2 -> Pattern'Create(patternVariables,postPredicate));
                              Enter<builtin>{(Pattern'Create, Pattern'Create(patternVariables,postPredicate));
                                  Arg(parameter1 -> {_expr});
                                  Arg(parameter2 -> True);
                              Leave<builtin>}(Pattern'Create(patternVariables,postPredicate) -> Pattern,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> unbound, patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Leave<builtin>}(Bind(pattern,Pattern'Create(patternVariables,postPredicate)) -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                          Enter<builtin>{(MacroRulePattern, MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand);
                              Arg(parameter1 -> IsMonomial);
                              Arg(parameter2 -> 1);
                              Arg(parameter3 -> 15);
                              Arg(parameter4 -> Pattern);
                              Arg(parameter5 -> False);
                          Leave<builtin>}(MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand -> True,    Local variables: arity -> 1, arg -> unbound, patternOperator -> "IsMonomial", pattern -> [BuiltinObject], patternVariables -> (List (_ expr )), patternFlat -> (List IsMonomial (_ expr )), postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                      Leave<builtin>}([    Local(patternFlat,patternVariables,pattern,patternOperator,arg,arity);    Bind(patternFlat,FunctionToList(leftOperand));    Bind(patternVariables,Rest(patternFlat));    Bind(patternOperator,ToString(First(patternFlat)));    Bind(arity,Length(patternVariables));    DefLoadFunction(patternOperator);    If(NotRulebaseDefined(patternOperator,arity),[        MacroRulebase(patternOperator,MakeVector(arg,arity));]);    Bind(pattern,Pattern'Create(patternVariables,postPredicate));    MacroRulePattern(patternOperator,arity,rulePrecedence,pattern)rightOperand;    True;] -> True,    Local variables: postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
                  Leave<**** user rulebase>}(DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True) -> True,    Local variables: postPredicate -> True, rulePrecedence -> 15, rightOperand -> False, leftOperand -> (IsMonomial (_ expr )), );
              Leave<builtin>}([    DefinePattern(leftOperand[2],rightOperand,leftOperand[1],True);] -> True,    Local variables: rightOperand -> False, leftOperand -> (# 15 (IsMonomial (_ expr ))), );
          Leave<**** user rulebase>}(15#IsMonomial(_expr)<--False -> True,    Local variables: rightOperand -> False, leftOperand -> (# 15 (IsMonomial (_ expr ))), );
      Leave<builtin>}(LoadScript(C:/Users/shermo/AppData/Local/Temp/mathpiperide258369849873711763.mpw_tmp) -> True,    Local variables: );
      True
.   %/output







%mathpiper_docs,name="IsMonomial",categories="User Functions;Predicates"
*CMD IsMonomial --- determine if {expr} is a Monomial
*STD
*CALL
	IsMonomial(expr)

*PARMS
{expr} -- an expression

*DESC
This function returns {True} if {expr} satisfies the definition of a {Monomial}.
Otherwise, {False}.
A {Monomial} is defined to be a single term, consisting of a product of numbers
and variables.

*E.G.
    In> IsMonomial(24)
    Result: True
    
    In> IsMonomial(24*a*x^2*y^3)
    Result: True
    
    In> IsMonomial(24*a*x^2*y^3/15)
    Result: True
    
    In> IsMonomial(24*a*x^2*y^3/15+1)
    Result: False
    
%/mathpiper_docs
