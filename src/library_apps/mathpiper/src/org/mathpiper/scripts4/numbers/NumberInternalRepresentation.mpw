%mathpiper,title="NumberInternalRepresentation"

Retract("NumberInternalRepresentation",*);

10 # NumberInternalRepresentation( N_IsNumber ) <--
[
    //Tell(NumberInternalRepresentation,N);
    Local(oldPrecision,c,str,lst,strN,lenN,numChars,inNum,ss,ans);
    numChars     := "0123456789.+-";
    numChars     := StringToList(numChars);
    oldPrecision := BuiltinPrecisionGet();
    inNum        := False;
    str          := "";
    lst          := {};
    BuiltinPrecisionSet(300);
    /*   NOTE: the above arbitrary 'magic number' is used because it is 
     *   currently necessary to set BuiltinPrecision to a value large 
     *   enough to handle any forseeable input.  Of course, even 300
     *   might not be enough!  I am looking for a way to base the 
     *   setting directly on the input number itself.                   */
    strN         := PipeToString() DumpNumber(N);
    lenN         := Length(strN);
    For(ii:=1,ii<=lenN,ii++)
    [
        c := strN[ii];
        If(Contains(numChars,c),
          [ If( Not inNum, inNum := True ); str := ConcatStrings(str,c); ],
          [ If( inNum, [ inNum := False; Push(lst,str); str := ""; ] );  ]
        );
    ];
    ans := StringToNumber /@ Reverse(lst);
    BuiltinPrecisionSet(oldPrecision);
    ans;
];



12 # NumberInternalRepresentation( N_IsComplex ) <--
[
    {NumberInternalRepresentation(Re(N)),NumberInternalRepresentation(Im(N))};
];


%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output





%mathpiper_docs,name="NumberInternalRepresentation",categories="ProgrammerFunctions;Numerical(Arbitrary Precision)"
*CMD NumberInternalRepresentation --- returns a List showing MathPiper's internal representation of a number
*STD
*CALL
	NumberInternalRepresentation(number)
	
*PARMS

{number} -- an Integer, Decimal, or Complex number


*DESC

Internally, MathPiper represents {arbitrary precision} numbers as Java BigIntegers or
BigDecimals.  Java code handles calculations using such numbers.

All the information needed to correctly understand the precision attached to a number,
and the rounding and comparison thereof, is contained in the Java structure.

For a Decimal number (essentially anything with a decimal point), the representation
consists of an arbitrary-precision integer containing {all} the significant digits of
the number, and a {scale factor} telling where the implied decimal point is supposed to
be placed with respect to the end of the integer.  The {precision} of the number is
just the number of digits in the integer.

The four components of the List returned for a decimal number are, respectively,
{{BigDecimal, Precision, BigInteger (unscaled), ScaleFactor}}.
Note that some of these are redundent: only the BigInteger and the ScaleFactor
are needed to completely define the number.

For an Integer number, the integer is its own representation, and again, the number of
its digits gives its precision.

For a Complex number, this function returns a List containing the representations of
the Real and Imaginary parts of the number.

The best way to {consistently} deal with precision and rounding issues is by making use
of the information given by this function.

*E.G.
    
In> NumberInternalRepresentation(123.45678)
Result: {123.45678,8,12345678,5}
    
In> NumberInternalRepresentation(34700)
Result: {34700}
    
In> NumberInternalRepresentation(1.5+6.75*I)
Result: {{1.50,3,150,2},{6.75,3,675,2}}
    
In> NumberInternalRepresentation(123.45678E-10)
Result: {0.000000012345678,8,12345678,15}
    
In> NumberInternalRepresentation(123.45678E+10)
Result: {1234567800000,8,12345678,-5}

NOTICE that the first,fourth, and fifth of these have the same 
BigInteger representation, and hence the same precision, namely 8.  
The ScaleFactor tells how many places the decimal point must be 
moved {leftward} from the {end} of the integer.  A negative 
ScaleFactor says to move the decimal point to the right -- 
i.e., add terminal zeros.

*SEE 
%/mathpiper_docs

    %output,preserve="false"
      
.   %/output


