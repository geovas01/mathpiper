m = eval `[f(x,y=...),  ...]
or
m = [f(x,y=...),  ...]
or
m = import "<modulename>"

results in a variable binding (exported bindings + previous bindings).
If the block starts with  "Module", all previous definitions are
ingored. If the block is imported via the code loader, and if
it is a module, then the resulting variable binding is saved in
memory until the source (actively) signals it has changed or
some other internal policy demands to remove the binding from
memory.

It is possible to use bindings from an evaluated module:

use m

copies all exported bindings from m into the current binding.
For rules, this means they are preceeded with m's definitions.
One has to be careful if m is not the result of a context-less
definition: In this case, also the relevant rules that have
been extended at the time of executing m's definition are
imported into the current binding.



What is:

f = [g(x)=3*x, f(x)=g(x)+2 ].f;
f(2)

?

a) g(2)+2 (unevaluated g cause g is undefined in the outer context or
b) 8, because f "knows" about the lexically closer defintion of g.

A strong case can be made that b) is the desired behavior, otherwise
module encapsulation does not work for function objects.

How can we achieve this?

If f is a contant, we don't need t care. If f is an uninterpreted
block, it should also be treated like a constant.
Otherwise, f will be extended by the definition of the inner block,
just like in the import statement. However, the co-related
definition is lost. A solution would be that each rule keeps
a reference on the variable binding where it has been defined,
and before the predicate or the body is evaluated, this variable
binding is pushed onto the stack. So a rule should look like:

name, arguments, binding, predicate, body, [precedence]


what about control structures like "forEach"?

The discussion will clarify some further concepts:

forEach(i, {1, 2, 3}, [writeLn i]) should print 1, 2, 3.

In slightly different syntax than the reference manual:

forEach(i, list, body) = [

  local k = 0
  local n = length(list)
  while (k < n) [
    &i = list[k]
    k = k + 1
    
    eval(body)
  ]
]

The difference is that locals should only be local to
the current context and not be passed to inner blocks.
Non-local variables have dynamic scope, so unfencing
is not necessary. Global variables do not exist, state
can be modelled by threads. 
&i ist similar to MacrosSet, but this should not concern
us here. We will clarify difference and ensure (partial)
compatibility to Yacas/Piper along our way.
For simplicity, there is n
support for tail-recursion, the while loop becomes part
of the execution model.
