%mathpiper,def="CUnparser;CUnparserDoublePrecisionNumber;CUnparserArgs;CUnparserStatement;CUnparserMathFunctions"

/* CUnparser: convert MathPiper objects to C/C++ code. */

/* version 0.3 */

/* Changelog
        0.1        CUnparser() derived from TeXForm() v0.4. Have basic functionality. Do not allow list manipulation, unevaluated derivatives, set operations, limits, integrals, Infinity, explicit matrices. Complex numbers and expressions are handled just like real ones. Indexed symbols are assumed to be arrays and handled literally. No declarations or prototypes are supplied. Function definitions are not handled. Sum() is left as is (can be defined as a C function).
        0.2 Fix for extra parens in Sin() and other functions; fixes for Exp(), Abs() and inverse trig functions
        0.3 Fix for indexed expressions: support a[2][3][4]
        0.3.1 Fix for CUnparser(integer): add a decimal point
        0.4 Support While()[]. Added CUnparsable?. Use Concat() instead of Union() on lists.
        0.4.1 Support False, True
  0.4.2 Changed it so that integers are not coerced to floats any more automatically (one can coerce integers to floats manually nowadays by adding a decimal point to the string representation, eg. 1. instead of 1).
*/

/* To do:
        0. Find and fix bugs.
        1. Chop strings that are longer than 80 chars?
        2. Optimization of C code?
*/

RulebaseHoldArguments("CUnparser",[expression]);
RulebaseHoldArguments("CUnparser",[expression, precedence]);

Function ("CUnparserBracketIf", [predicate, string])
{
        Check(Boolean?(predicate) And? String?(string), "Argument", "CUnparser internal error: non-boolean and/or non-string argument of CUnparserBracketIf");
        Decide(predicate, ConcatStrings("( ", string, ") "), string);
};

CUnparserDoublePrecisionNumber(x_Number?) <--
{
    Local(i,n,s,f);
    s := ToString(x);
    n := Length(s);
    f := False;
    For(i := 1, i <=? n, i++)
    {
        Decide(s[i] =? "e" Or? s[i] =? ".", f := True);
    };
    Decide(f, s, s ~ ".");
};

/* Proceed just like TeXForm()
*/

// CUnparserMaxPrec should perhaps only be used from within this file, it is thus not in the .def file.
CUnparserMaxPrec() := 60000;         /* This precedence will never be bracketed. It is equal to KMaxPrec */

100 # CUnparser(_x) <-- CUnparser(x, CUnparserMaxPrec());

/* Replace numbers and variables -- never bracketed except explicitly */
110 # CUnparser(x_Integer?, _p) <-- ToString(x);
111 # CUnparser(x_Zero?, _p) <-- "0.";
112 # CUnparser(x_Number?, _p) <-- CUnparserDoublePrecisionNumber(x);
/* Variables are left as is, except some special ones */
190 # CUnparser(False, _p) <-- "false";
190 # CUnparser(True, _p) <-- "true";
200 # CUnparser(x_Atom?, _p) <-- ToString(x);

/* Strings must be quoted but not bracketed */
100 # CUnparser(x_String?, _p) <-- ConcatStrings("\"", x, "\"");

/* Replace operations */

/* arithmetic */

/* addition, subtraction, multiplication, all comparison and logical operations are "regular" */


LocalSymbols(cUnparserRegularOps) {
  cUnparserRegularOps := [ ["+"," + "], ["-"," - "], ["*"," * "],
                       ["/"," / "], [":="," = "], ["=="," == "],
                       ["=?"," == "], ["!=?"," != "], ["<=?"," <=? "],
                       [">=?"," >= "], ["<?"," < "], [">?"," > "],
                       ["And?"," && "], ["Or?"," || "], [">>", " >> "],
                       [ "<<", " << " ], [ "&", " & " ], [ "|", " | " ],
                       [ "%", " % " ], [ "^", " ^ " ],
                     ];

  CUnparserRegularOps() := cUnparserRegularOps;
}; // LocalSymbols(cUnparserRegularOps)

        /* This is the template for "regular" binary infix operators:
100 # CUnparser(_x + _y, _p) <-- CUnparserBracketDecide(p<?PrecedenceGet("+"), ConcatStrings(CUnparser(x, LeftPrecedenceGet("+")), " + ", CUnparser(y, RightPrecedenceGet("+")) ) );
        */

        /* unary addition */
100 # CUnparser(+ _y, _p) <-- CUnparserBracketDecide(p<?PrecedenceGet("+"), ConcatStrings(" + ", CUnparser(y, RightPrecedenceGet("+")) ) );

        /* unary subtraction */
100 # CUnparser(- _y, _p) <-- CUnparserBracketDecide(p<?PrecedenceGet("-"), ConcatStrings(" - ", CUnparser(y, RightPrecedenceGet("-")) ) );

        /* power's argument is never bracketed but it must be put in braces. */
100 # CUnparser(_x ^ _y, _p) <-- CUnparserBracketDecide(p<=?PrecedenceGet("^"), ConcatStrings("pow(", CUnparser(x, CUnparserMaxPrec()), ", ", CUnparser(y, CUnparserMaxPrec()), ")" ) );

100 # CUnparser(If(_pred)_body, _p) <-- "If("~CUnparser(pred,60000)~") "~CUnparser(body);
100 # CUnparser(_left Else _right, _p) <-- CUnparser(left)~" Else "~CUnparser(right);


LocalSymbols(cUnparserMathFunctions) {
  cUnparserMathFunctions :=
    [
      ["Sqrt","sqrt"],
      ["Cos","cos"],
      ["Sin","sin"],
      ["Tan","tan"],
      ["Cosh","cosh"],
      ["Sinh","sinh"],
      ["Tanh","tanh"],
      ["Exp","exp"],
      ["Ln","log"],
      ["ArcCos","acos"],
      ["ArcSin","asin"],
      ["ArcTan","atan"],
      ["ArcCosh","acosh"],
      ["ArcSinh","asinh"],
      ["ArcTanh","atanh"],
      ["Maximum","max"],
      ["Minimum","min"],
      ["Abs","fabs"],
      ["Floor","floor"],
      ["Ceil","ceil"],
    ["!","factorial"]
    ];

  CUnparserMathFunctions() := cUnparserMathFunctions;

}; // LocalSymbols(cUnparserMathFunctions)

/* Precedence of 120 because we'd like to process some special functions like pow() first */


120 # CUnparser(expr_Function?, _p)_(ArgumentsCount(expr)=?2 And? Contains?(AssocIndices(CUnparserRegularOps()), Type(expr)) ) <--
      CUnparserBracketDecide(p<?PrecedenceGet(Type(expr)), ConcatStrings(CUnparser(FunctionToList(expr)[2], LeftPrecedenceGet(Type(expr))), CUnparserRegularOps()[Type(expr)], CUnparser(FunctionToList(expr)[3], RightPrecedenceGet(Type(expr))) ) );


/* Sin, Cos, etc. and their argument is always bracketed */

120 # CUnparser(expr_Function?, _p) _
      (ArgumentsCount(expr)=?1 And? Contains?(AssocIndices(CUnparserMathFunctions()), Type(expr)) ) <--
      ConcatStrings(CUnparserMathFunctions()[Type(expr)], "(", CUnparser( FunctionToList(expr)[2], CUnparserMaxPrec()),")" );

/* functions */

/* Unknown function, precedence 200. Leave as is, never bracket the function itself and bracket the argumentPointer(s) automatically since it's a list. Other functions are precedence 100 */

CUnparserArgs(list_List?) <--
{
  Local(i,nr,result);
  result:="";
  nr:=Length(list);
  For (i:=1,i<=?nr,i++)
  {
    result:=result~CUnparser(list[i]);
    Decide(i<?nr, result:=result~", ");
  };
  result;
};


200 # CUnparser(_x, _p)_(Function?(x)) <--
{
  ConcatStrings(Type(x), "(", CUnparserArgs(Rest(FunctionToList(x))),")" );
};

/* Complex numbers */
100 # CUnparser(Complex(0, 1), _p) <-- "I";
100 # CUnparser(Complex(_x, 0), _p) <-- CUnparser(x, p);
110 # CUnparser(Complex(_x, 1), _p) <-- CUnparser(x+Hold(I), p);
110 # CUnparser(Complex(0, _y), _p) <-- CUnparser(Hold(I)*y, p);
120 # CUnparser(Complex(_x, _y), _p) <-- CUnparser(x+Hold(I)*y, p);

/* Some special functions: Mod */

100 # CUnparser(Modulo(_x, _y), _p) <-- CUnparserBracketDecide(p<?PrecedenceGet("/"), ConcatStrings(CUnparser(x, PrecedenceGet("/")), " % ", CUnparser(y, PrecedenceGet("/")) ) )
;

/* Indexed expressions are never bracketed */
// the rule with [ ] seems to have no effect?
//100 # CUnparser(_x [ _i ], _p) <-- ConcatStrings(CUnparser(x, CUnparserMaxPrec()), "[", CUnparser(i, CUnparserMaxPrec()), "]");
100 # CUnparser(Nth(_x, _i), _p) <-- ConcatStrings(CUnparser(x, CUnparserMaxPrec()), "[", CUnparser(i, CUnparserMaxPrec()), "]");

LocalSymbols(cindent) {
  cindent:=1;

  NlIndented():=
  {
    Local(result);
// carriage return, so needs to start at the beginning of the line
    result:=
"
";
    Local(i);
    For(i:=1,i<?cindent,i++)
    {
      result:=result~"  ";
    };
    result;
  };
  CIndent() :=
  {
  (cindent++);
  "";
  };
  CUndent() :=
  {
  (cindent--);
  "";
  };
}; // LocalSymbols(cindent)

CUnparserStatement(_x) <-- CUnparser(x) ~ ";" ~ NlIndented();

120 # CUnparser(_x,_p)_(Type(x) =? "Block") <--
{
  Local(result);
  result:=CIndent()~"{"~NlIndented();
  ForEach(item,Rest(FunctionToList(x)))
  {
    result:=result~CUnparserStatement(item);
  };
  result:=result~"}"~CUndent()~NlIndented();
  result;
};

120 # CUnparser(For(_from,_to,_step)_body,_p) <--
  "for(" ~ CUnparser(from,CUnparserMaxPrec()) ~ ";"
        ~ CUnparser(to,CUnparserMaxPrec()) ~ ";"
        ~ CUnparser(step,CUnparserMaxPrec()) ~ ")"
        ~ CIndent() ~ NlIndented()
        ~ CUnparserStatement(body) ~ CUndent();

120 # CUnparser(While(_pred)_body, _p) <--
        "while(" ~ CUnparser(pred,CUnparserMaxPrec()) ~ ")"
        ~ CIndent() ~ NlIndented()
        ~ CUnparserStatement(body) ~ CUndent();

%/mathpiper



%mathpiper_docs,name="CUnparser",categories="User Functions;Input/Output"
*CMD CUnparser --- export expression to C++ code
*STD
*CALL
        CUnparser(expr)
        
*PARMS

{expr} -- expression to be exported

*DESC

{CUnparser} returns a string containing C++ code that attempts to implement the MathPiper expression {expr}. Currently the exporter handles most expression types but not all.

*E.G.

In> CUnparser(Sin(a1)+2*Cos(b1));
Result: "sin(a1) + 2 * cos(b1)";

*SEE PrettyForm, TeXForm, CUnparsable?
%/mathpiper_docs






%mathpiper,name="CUnparser",subtype="automatic_test"

Verify(
CUnparser(Hold(Cos(A-B)*Sin(a)*func(b,c,d*(e+Pi))*Sqrt(Abs(C)+D)-(g(a+b)^(c+d))^(c+d)))
,"cos(A - B) * sin(a) * func(b, c, d * ( e + Pi) ) * sqrt(fabs(C) + D) - pow(pow(g(a + b), c + d), c + d)"
);

Verify(
CUnparser(Hold({i:=0;While(i<?10){i++; a:=a+Floor(i);};}))
, "{
  i = 0;
  while(i <? 10)
    {
      ++(i);
      a = a + floor(i);
      }
    ;
    ;
  }
"
);

/* Check that we can still force numbers to be floats in stead of integers if we want to */
Verify(
CUnparser(Hold({i:=0.;While(i<?10.){i++; a:=a+Floor(i);};}))
, "{
  i = 0.;
  while(i <? 10.)
    {
      ++(i);
      a = a + floor(i);
      }
    ;
    ;
  }
"
);

%/mathpiper





%mathpiper,name="CUnparser",subtype="automatic_test"

/* Jitse's bug report, extended with the changes that do not coerce integers to floats automatically
   any more (just enter a dot and the number becomes float if that is what is intended).
 */
Verify(CUnparser(4), "4");
Verify(CUnparser(4.), "4.");
Verify(CUnparser(0), "0");
Verify(CUnparser(0.), "0.");

%/mathpiper