%mathpiper,def="PatternsCompile;PatternCompile;LocPredicate;LocChange"

LocalSymbols(localResult) {

  localResult := True;
  
  
  10 # LocPredicate(exp_Atom?) <--
  {
    Local(patternsList, result);
    
    patternsList := patterns;
    
    result := False;
    
    While (patternsList !=? [])
    {
      Decide(First(First(patternsList)) =? exp,
      {
        Decide(Verbose?() =? True,  Echo(Last(First(patternsList))));
        
        Assign(localResult,Eval(First(Rest(First(patternsList)))));
        
        result := True;
        
        patternsList:=[];
      },
      {
        patternsList := Rest(patternsList);
      });
    };
    
    result;
  };
  
  

  10 # LocPredicate(exp_Function?) <--
  {
    Local(patternsList, result, head);
    
    patternsList := patterns;
    
    result := False;
    
    While (patternsList !=? [])
    {
      Assign(head, First(patternsList));
     
      Decide(Not?(Atom?(head)) And? exp[0] =? head[1] And? PatternMatch?(head[2], exp),
      {
        Decide(Verbose?() =? True, Echo(Last(First(patternsList))));
        
        Assign(localResult, Eval(First(Rest(Rest(First(patternsList))))));
        
        Assign(result, True);
        
        Assign(patternsList, []);
      },
      {
        Assign(patternsList, Rest(patternsList));
      });
    };
    
    result;
  };
  
  
  
  20 # LocPredicate(exp_) <-- False;

  
  
  LocChange(exp_) <-- localResult;
  
  
}; // LocalSymbols(localResult)

UnFence("LocPredicate",1);

UnFence("LocChange",1);


//============== PatternCompile ===============================
//Convert a local rule into a rule which has its pattern replaced by a ParametersPatternMatcher.


/*
// This is the original local rule syntax.
10 # PatternCompile([pat_, post_, exp_]) <-- [ pat[0], PatternCreate(pat, post), exp, "UNNAMED" ];

20 # PatternCompile([pat_Function?, exp_]) <-- [ pat[0], PatternCreate(pat,True), exp, "UNNAMED" ];

30 # PatternCompile([pat_Atom?, exp_]) <-- [ pat, pat, exp, "UNNAMED" ];
*/

40 # PatternCompile(pat_Function? <- exp_) <-- 
{
    Local(justPattern, postPredicate, ruleName);
    
    justPattern := pat;
    
    
    If(justPattern[0] =? ToAtom("#"))
    {
    	ruleName := pat[1];
    	justPattern := pat[2];
    }
    Else
    {
    	ruleName := "UNNAMED";
    };
    
    
    If(justPattern[0] =? ToAtom("::"))
    {
    	postPredicate := justPattern[2];
    	justPattern := justPattern[1];
    }
    Else
    {
    	postPredicate := True;
    };
    
    
	If(Function?(justPattern))
	{
		[justPattern[0], PatternCreate(justPattern, postPredicate), exp , ruleName];
	}
	Else
	{
		//Atom.
		[justPattern, exp, ruleName ];
	};
                
};


50 # PatternCompile(pat_Atom? <- exp_) <-- [pat, exp, "UNNAMED" ];



/*
 Convert
*/
PatternsCompile(patterns) :=
{
  MapSingle("PatternCompile", patterns);
};


%/mathpiper