%mathpiper,def="CompilePatterns;LocProcess;LocProcessSingle;LocPredicate;LocChange"

LocalSymbols(localResult) ⊕

  localResult := True;
  
  
  10 # LocPredicate(exp_Atom?) <--
  ⊕
    Local(tr, result);
    
    tr := patterns;
    
    result := False;
    
    While (tr !=? {})
    ⊕
      If (First(First(tr)) =? exp,
      ⊕
        If(InVerboseMode() =? True,  Echo(Last(First(tr))));
        
        Bind(localResult,Eval(First(Rest(First(tr)))));
        
        result := True;
        
        tr:={};
      ⊖,
      ⊕
        tr := Rest(tr);
      ⊖);
    ⊖;
    
    result;
  ⊖;
  
  

  10 # LocPredicate(exp_Function?) <--
  ⊕
    Local(tr, result, head);
    
    tr := patterns;
    
    result := False;
    
    While (tr !=? {})
    ⊕
      Bind(head, First(First(tr)));
      
      If (Not?(Atom?(head)) And? exp[0] =? head[1] And? PatternMatches(head[2], exp),
      ⊕
        If(InVerboseMode() =? True, Echo(Last(First(tr))));
        
        Bind(localResult, Eval(First(Rest(First(tr)))));
        
        Bind(result, True);
        
        Bind(tr, {});
      ⊖,
      ⊕
        Bind(tr, Rest(tr));
      ⊖);
    ⊖;
    
    result;
  ⊖;
  
  
  
  20 # LocPredicate(_exp) <-- False;

  
  
  LocChange(_exp) <-- localResult;
  
  
⊖; // LocalSymbols(localResult)

UnFence("LocPredicate",1);

UnFence("LocChange",1);


//============== LocProcessSingle ===============================
//Convert a local rule into a rule which has its pattern replaced by a ParametersPatternMatchers.

10 # LocProcessSingle({_pat, _post, _exp}) <-- { {pat[0], PatternCreate(pat, post)}, exp, "UNNAMED" };


20 # LocProcessSingle({pat_Function?, _exp}) <-- { {pat[0], PatternCreate(pat,True)}, exp, "UNNAMED" };


30 # LocProcessSingle({pat_Atom?, _exp}) <-- { pat, exp, "UNNAMED" };


/*
    40 # LocProcessSingle(pat_Function? <- _exp) <-- { {pat[0],PatternCreate(pat,True)},exp };
    todo:tk:this rule was not handling post predicates so I replaced it with a new version that does.
    I suspect that the other rules for this Rulebase have problems too. 
*/
40 # LocProcessSingle(pat_Function? <- _exp) <-- 
⊕
    Local(justPattern, postPredicate, ruleName);
    
    justPattern := pat;
    
    If(Type(justPattern) =? "_",
        ⊕
            //A post predicate was submitted.
	        justPattern := pat[1];
	        postPredicate := pat[2];
        ⊖,
        ⊕
            //No post predicate was submitted.
            postPredicate := True;
        ⊖
    );
            
            
            
    If(Type(justPattern) =? "#",
        ⊕
           //A name has been given to the rule.
           ruleName := pat[1];
           justPattern := pat[2];
           
           If(Function?(justPattern),
             ⊕
               { {justPattern[0], PatternCreate(justPattern, postPredicate)}, exp , ruleName};
             ⊖,
             ⊕
               //Atom.
               { justPattern, exp, ruleName };
             ⊖
           
           );
        ⊖,
        ⊕
           ruleName := "UNNAMED";
           justPattern := pat;
           { {justPattern[0], PatternCreate(justPattern, postPredicate)}, exp , ruleName};
        ⊖
    );
            
⊖;



50 # LocProcessSingle(pat_Atom? <- _exp) <-- { pat, exp, "UNNAMED" };




/*
 Convert
*/
LocProcess(patterns) :=
⊕
  MapSingle("LocProcessSingle", patterns);
⊖;



CompilePatterns(patterns) := LocPatterns(LocProcess(patterns));



%/mathpiper