%mathpiper,def="jFactorsPoly;jFactorsPrimitivePart;jFactorsHomogeneousBivariate;RealToRationalConvert;RationalToIntegerConvert;CombineNumericalFactors;jFactorsBivariateBinomial;jFB;IsPureRational;IsPureRational;HasRealCoefficients;HasRealCoefficients;HasRationalCoefficients;HasRationalCoefficients;FixUpMonicFactors"

//Retract("jFactorsPoly",*);
//Retract("HasRealCoefficients",*);      
//Retract("RealToRationalConvert",*);
//Retract("HasRationalCoefficients",*);   
//Retract("RationalToIntegerConvert",*);
//Retract("jFactorsPrimitivePart",*);
//Retract("jFactorsBivariateBinomial",*);
//Retract("jFactorsHomogeneousBivariate",*);

//Retract("jFB",*);
//Retract("jFac",*);

//Retract("FixUpMonicFactors",*);
//Retract("CombineNumericalFactors",*);
//Retract("IsPureRational",*);

/* -------------    POLYNOMIALS -- CAN BE UNI   --------------*/

50 # jFactorsPoly( poly_CanBeUni ) <--
{
    Decide(InVerboseMode(),Tell("jFactorsPoly_100612",poly));
    Local(content,pp,ppFactors,monomialFactors,result,moreDetails);
    Local(vars,nvars,disassem,degrees,mpoly,nterms,allCoeffs,allPowers);
    Local(hasRealCoefficients,hasRationalCoefficients,isHomogeneous);
    Local(extraFactor);
    
    moreDetails := False;
    disassem  := DisassembleExpression(poly);
    allCoeffs := disassem[3];

    //  First, check to see if the polynomial has any REAL coefficients.
    //  If so, convert to approximate integers (with divisor).
    hasRealCoefficients := HasRealCoefficients(poly);
    Decide( hasRealCoefficients, 
      {
         Local(realPoly);
         realPoly  := poly;   //  just in case -- save original form
         allPowers := Flatten(disassem[2],"List");
         poly      := RealToRationalConvert(poly);
         // From now on we operate on a polynomial over Integers
         hasRealCoefficients := False;          }
    );
    
    //  Also, check to see if the polynomial has Rational coeffs
    hasRationalCoefficients := HasRationalCoefficients(poly);
    Decide(hasRationalCoefficients, 
      {
         Local(rationalPoly);
         rationalPoly  := poly;   //  just in case -- save original form
         Decide(InVerboseMode(),Tell("   RATIONAL",rationalPoly));
         // convert to equivalent polynomial over Integers
         poly := RationalToIntegerConvert(poly);
         // From now on we operate on a polynomial over Integers
         hasRationalCoefficients := False;    
      }
    );

    // Now: get Content and Primitive Part
    content := xContent( poly );
    pp      := Simplify( poly / content );
    Decide(Bound?(extraFactor),content := content / extraFactor);
    Decide(InVerboseMode(),Tell("   ",[content,pp]));
    //Decide(Constant?(pp) And? Length(VarList(content))>?0,[content,pp]:=[pp,content]);
    Decide( Length(VarList(pp))=?0, result := [[pp*content,1]],
      {
         //Decide(InVerboseMode(),Tell("  ",[content,pp]));
         vars     := VarList(pp);
         nvars    := Length(vars);
         disassem := DisassembleExpression(pp);
         nterms   := Length(disassem[3]);
         degrees  := [];
         allCoeffs         := disassem[3];
         allPowers         := Flatten(disassem[2],"List");
         Decide(nvars >? 0,
           {
             ForEach(v,vars)
                { DestructiveAppend(degrees,Degree(pp,v)); };
             isHomogeneous     := {
                 // A polynomial is homogeneous of degree n 
                 // if all terms have degree n.   
                 Local(sd,cmp); 
                 sd  := Sum /@ disassem[2];
                 cmp := FillList(sd[1],Length(sd));
                 ZeroVector?(sd - cmp);
             };
           }
         );
    
         Decide(InVerboseMode() And? moreDetails,
           {
             Tell("               ",vars);
             Tell("              ",nvars);
             Tell("             ",nterms);
             Tell("            ",degrees);
             Tell("           ",disassem);
             Tell("          ",allCoeffs);
             Tell("          ",allPowers);
             Tell("      ",isHomogeneous);
             NewLine();
           }
         );
    
         //  Does the Content have factors?  If so, get them.
         //Decide(InVerboseMode(),NewLine());
         monomialFactors := FactorsMonomial(content);
         Decide(InVerboseMode(),Tell("  ",monomialFactors));
    
         //  OK.  Now factor the PrimitivePart
         ppFactors := jFactorsPrimitivePart( pp );
         Decide(InVerboseMode(),Tell("                    ",ppFactors));
         Decide( Not? ListOfLists?(ppFactors),
           {
               Local(L,op,var,exp);
               L := Decide(Atom?(ppFactors[1]), ppFactors, FunctionToList(ppFactors[1]) );
               Decide(InVerboseMode(),Tell("                    ",L));
               Decide( L[1] =? ^, ppFactors := [L[2],L[3]] );
               ppFactors := [ppFactors];
           }
         );
         Decide(InVerboseMode(),Tell("  ",ppFactors));
    
         // Next, include the factors of the Content, if any
         Decide( monomialFactors[1][1] =? 1,
             result := ppFactors,        
             //result := Concat(monomialFactors,[ppFactors])    // hso 100801
             result := Concat(monomialFactors,ppFactors)      // hso 100803
         );
      }
    );
    
    Decide(InVerboseMode(),
      {
          NewLine();
          Tell("  ",monomialFactors);
          Tell("        ",ppFactors);
          Tell("  final    ",result);
      }
    );
    result;
};
UnFence("jFactorsPoly",1);



// -----------------  FACTOR PRIMITIVE PART  -----------------

     //  special case: binomials
60 # jFactorsPrimitivePart( _pp )_(isHomogeneous And? nterms=?2 And? nvars=?2) <--
{
    Decide(InVerboseMode(),Tell("Bivariate Binomial",pp));
    Local(ppFactors,isDiagonal);
    isDiagonal := Diagonal?(disassem[2]);   //  mod hso 10-11-25
    ppFactors := Decide(isDiagonal,jFactorsBivariateBinomial(pp),jasFactorsInt(pp) );
};
UnFence("jFactorsPrimitivePart",1);


     //  special case: homogeneous bivariates
65 # jFactorsPrimitivePart( _pp )_(isHomogeneous And? nterms>?1 And? nvars=?2) <--
{
    Decide(InVerboseMode(),Tell("Homogeneous and Bivariate"));
    Local(ppFactors);
    ppFactors := jFactorsHomogeneousBivariate(disassem);
};
UnFence("jFactorsPrimitivePart",1);


     //  special case:  no variables in pp!
70 # jFactorsPrimitivePart( _pp )_(nvars=?0) <--
{
    Local(ppFactors);
    ppfactors := [];
};


     //  general case
100 # jFactorsPrimitivePart( _pp ) <-- 
{
    Decide(InVerboseMode(),Tell("jFactorsPrimitivePart_usingJAS",pp));
    Local(answer);
    answer := Decide(Monomial?(pp),[pp,1],jasFactorsInt(pp));
    Decide(InVerboseMode(),Tell("          ",answer));
    answer;
};
UnFence("jFactorsPrimitivePart",1);

// ------------------  HOMOGENEOUS BIVARIATE  ------------------

10 # jFactorsHomogeneousBivariate( dis_List? ) <-- 
{
    Decide(InVerboseMode(),{NewLine();Tell("jFactorsHomogeneousBivariate",dis);});
    Local(dis1,f,dis2,poly1,ppFactors,residuals);
    Local(ii,lst,f,preassem);
    dis1  := [[xi],[[X],[X[1]]] /@ dis[2],dis[3]];
    Decide(InVerboseMode(),Tell("   ",dis1));
    poly1 := Sum(ReassembleListTerms(dis1));
    Decide(InVerboseMode(),Tell("   ",poly1));
    ppFactors := BinaryFactors(poly1);
    [ppFactors,residuals] := FixUpMonicFactors(ppFactors);
    For(ii:=1,ii<=?Length(ppFactors),ii++)
    {
        f := ppFactors[ii];
        Decide(InVerboseMode(),Tell("          ",f[1]));
        lst := DisassembleExpression(f[1]);
        Decide(InVerboseMode(),
          {
             Tell("               ",lst);
             Tell("                            ",dis[1]);
          }
        );
        DestructiveReplace(lst,1,dis[1]);
        DestructiveAppend(lst[2][1],0);
        DestructiveAppend(lst[2][2],1);
        Decide(Length(lst[2])=?3, DestructiveAppend(lst[2][3],2));
        Decide(InVerboseMode(),Tell("               ",lst));
        preassem  := Sum(ReassembleListTerms(lst)) ;
        Decide(InVerboseMode(),Tell("               ",preassem));
        ppFactors[ii][1] := preassem;
    };
    Decide(InVerboseMode(),{Tell("   ",ppFactors); Tell("   ",residuals);NewLine();} );  
    ppFactors;
};
UnFence("jFactorsHomogeneousBivariate",1);

// ---------------------   OTHER STUFF ------------------------

10 # RealToRationalConvert( poly_Polynomial? ) <--
{
    // If the polynomial has REAL coefficients, convert them to
    // approximate RATIONALS
    Decide(InVerboseMode(),{NewLine();Tell("  REAL",poly);});
    Local(coeffs,gcd,lcm);
    coeffs := Rationalize /@ (allCoeffs);
    Decide(InVerboseMode(),{Tell("      to-Q",coeffs);Tell("      to-Z",coeffs);});
    Local(gcd,lcm);
    gcd    := Gcd(Numerator /@ coeffs);
    lcm    := Lcm(Denominator /@ coeffs);
    Decide(InVerboseMode(),{Tell("       ",gcd);Tell("       ",lcm);});
    disassem[3] := coeffs;
    allCoeffs   := coeffs;
    poly        := Sum(ReassembleListTerms(disassem));
    Decide(InVerboseMode(),Tell("   new",poly));
    poly;
};
UnFence("RealToRationalConvert",1);


10 # RationalToIntegerConvert( poly_Polynomial? ) <--
{
    // If the polynomial has RATIONAL coefficients, convert to
    // approximate INTEGER
    Local(coeffs,gcd,lcm);
    coeffs := allCoeffs;
    Decide(InVerboseMode(),Tell("  ",coeffs));
    lcm         := Lcm(Denominator /@ coeffs);
    extraFactor := lcm;
    Decide(InVerboseMode(),{Tell("     ",extraFactor);});
    poly := Simplify(extraFactor*poly);
    Decide(InVerboseMode(),Tell("  new ",poly));
    poly;
};
UnFence("RationalToIntegerConvert",1);


100 # CombineNumericalFactors( factrs_List? ) <--
{
      Decide( InVerboseMode(), Tell("Combine",factrs) );
      Local(q,a,b,t,f,ff,err);
      err := False;
      t   := 1;
      f   := [];
      ForEach(q,factrs)
      {
          Decide( InVerboseMode(), Tell(1,q) );
          Decide( List?(q) And? Length(q)=?2,
            {
                [a,b] := q;
                Decide( InVerboseMode(), Echo("     ",[a,b]) );
                Decide( NumericList?( [a,b] ),
                    t := t * a^b,
                    f := [a,b]~f
                );
            },
              err := True
          );
      };
      Decide( InVerboseMode(),
        {
            Echo("      t = ",t);
            Echo("      f = ",f);
            Echo("    err = ",err);
        }
      );
      ff := Decide(Not? err And? t !=? 1, [t,1]~Reverse(f), factrs);
      ff := Select(Lambda([x],x!=?[1,1]),ff);
      Decide(ff[1]<?0,ff[1]:=-ff[1]);
};


// ----------------  RATIONAL POLYNOMIALS  -----------------

150 # jFactors( expr_RationalFunction? )_
        (Polynomial?(Numerator(expr)) And? Polynomial?(Denominator(expr))) <--
{
    Decide(InVerboseMode(),{NewLine();Tell("jFactors_Rational_Function",expr);});
    Local(Numer,Denom,fNumer,fDenom);
    Numer  := Numerator(expr);
    Denom  := Denominator(expr);
    fNumer := jFactors(Numer);
    fDenom := jFactors(Denom);
    Decide(InVerboseMode(),{Tell("   ",fNumer); Tell("   ",fDenom);});
    fNumer/fDenom;
};


152 # jFactors( expr_RationalFunction? )_
        (Constant?(Numerator(expr)) And? Polynomial?(Denominator(expr))) <--
{
    Decide(InVerboseMode(),{NewLine();Tell("jFactors_Rational_Denom",expr);});
    Local(Numer,Denom,fNumer,fDenom);
    Numer  := Numerator(expr);
    Denom  := Denominator(expr);
    fNumer := jFactors(Numer);
    fDenom := jFactors(Denom);
    Decide(InVerboseMode(),{Tell("   ",fNumer); Tell("   ",fDenom);});
    fNumer/fDenom;
};


// ----------   POSSIBLE NON-INTEGER EXPONENTS  ----------

200 # jFactors( _expr )_(Length(VarList(expr)) =? 1) <--
{
    Decide(InVerboseMode(),{NewLine();Tell("Some other kind of expression",expr);});
    Local(dis,X,pows);
    dis := DisassembleExpression(expr);
    X   := VarList(expr)[1];
    pows := matchPower /@ dis[1];
    rats := NearRational /@ pows;
    dis[1] := x^rats;
    p := Sum(ReassembleListTerms(dis));
    Decide(InVerboseMode(),Tell("    new ",p));
    jFactors(p);
};



/*-------------------------------------------------------------------
 *  Factoring Binomial expressions of the form  A X^n � B Y^n,
 *     Uses JAS library, but converts to univariate equivalent
 *     before factoring. (JAS is inefficient for multivariate
 *     factoring when degree is large.)
 *-------------------------------------------------------------------*/

10 # jFactorsBivariateBinomial( poly_Polynomial? )_(Length(VarList(poly))=?2)  <--
{
    Decide(InVerboseMode(),Tell(jFactorsBivariateBinomial,poly));
    Local(dis,n,X,Y,vars,A,B,s,Ar,Br,Arr,Brr,DAr,DBr,result);
    dis := DisassembleExpression(poly);
    Decide(InVerboseMode(),Tell("   ",dis));
    n     := Maximum(dis[2])[1];
    X     := dis[1][1];
    Y     := dis[1][2];
    vars  := dis[1];
    A     := Abs(dis[3][1]);
    B     := Abs(dis[3][2]);
    s     := Sign(dis[3][1]*dis[3][2]);
    //Ar    := NearRational(N(A^(1/n)));
    //Br    := NearRational(N(B^(1/n)));
    Ar    := N(A^(1/n));    Arr := Round(Ar);   DAr := Abs(Ar-Arr);
    Br    := N(B^(1/n));    Brr := Round(Br);   DBr := Abs(Br-Brr);
    Decide(InVerboseMode(),
      {
          Tell("       ",[n,X,Y]); 
          Tell("       ",[vars,A,B]);
          Tell("       ",[Ar,Br,s]);
          Tell("       ",[Arr,Brr]);
          Tell("       ",[DAr,DBr]);
          Tell("       ",dis);
      }
    );
    result := Decide( DAr <? 10^(-9) And? DBr <? 10^(-9), jFB(dis), [[poly,1]] );
    result;
};
UnFence("jFactorsBivariateBinomial",1);


50 # jFB( dis_List? )_(Length(dis)=?3 And? Length(dis[3])=?2) <--
{
    Decide(InVerboseMode(),{NewLine();Tell("jFB",dis);});
    Local(ns,ii,fn,mx,my,fac);
    Decide(InVerboseMode(),
      {
         Tell("     ",n);
         Tell("     ",[X,Y]);
         Tell("     ",[A,B,s]);
         Tell("     ",[Ar,Br]);
      }
    );
    X     := Arr*X;
    Y     := Brr*Y;
    Decide(InVerboseMode(),Tell("     ",[X,Y]));
    
    fac  := jFac( X/Y,n,s);    //  factor using JAS and normalized variable
    Decide(InVerboseMode(),
      {
          NewLine();
          Tell("      ",X/Y);
          Tell("      ",fac);
      }
    );
    
    // now convert factorization back to actual variables if required
    Decide( Y !=? 1,
      {
          Local(f,d,fs);
          For(ii:=1,ii<=?Length(fac),ii++)
          {
              f := fac[ii][1];
              d := Degree(f,x);
              Decide(InVerboseMode(),Tell("             ",[ii,f,d]));
              fs := Subst(x,X/Y) f;
              Decide(InVerboseMode(),Tell("               ",[fs,d]));
              fac[ii][1] := Simplify(Simplify(Y^d*fs));
          };
      }
    );
    fac;
};
UnFence("jFB",1);



60 # jFac( _var, n_PositiveInteger?, s_Integer? ) <--
{
    //  Uses JAS to factor polynomial of form x^n � 1.
    Decide(InVerboseMode(),{NewLine();Tell("jFac",[var,n,s]);});
    Local(x,poly,result);
    poly := x^n+s;
    Decide(InVerboseMode(),Tell("   ",poly));
    result := jasFactorsInt(poly);     
};
UnFence("jFac",3);


10 # IsPureRational( N_Rational? )_(Not? Integer?(N)) <-- True;

12 # IsPureRational( _N ) <-- False;

10 # HasRealCoefficients( poly_Polynomial? ) <--
{
    Local(disassem);
    disassem := DisassembleExpression(poly);
    (Length(Select(disassem[3],"Decimal?")) >? 0);
};

10 # HasRealCoefficients( poly_Monomial? ) <--
{
    Local(disassem);
    disassem := DisassembleExpression(poly);
    (Length(Select(disassem[3],"Decimal?")) >? 0);
};


10 # HasRationalCoefficients( poly_Polynomial? ) <--
{
    Local(disassem,answer);
    Decide(InVerboseMode(),Tell("  HasRationalCoefficients",poly));
    disassem := DisassembleExpression(poly);
    //Tell("              ",disassem);
    answer := (Length(Select(disassem[3],"IsPureRational")) >? 0);
    Decide(InVerboseMode(),Tell("   ",answer));
    answer;
};

10 # HasRationalCoefficients( poly_Monomial?) <--
{
    Local(disassem);
    disassem := DisassembleExpression(poly);
    (Length(Select(disassem[3],"IsPureRational")) >? 0);
};


10 # FixUpMonicFactors( factrs_List? ) <--
{
    Decide(InVerboseMode(),{ NewLine(); Tell("   doing monic fixup"); } );
    Local(factrsnew,residuals,f,uni,);
    factrsnew := [];
    residuals := [];
    ForEach(f,factrs)
    {
        Decide(InVerboseMode(),Tell("               ",f));
        uni := MakeUni(f[1]);
        Decide(InVerboseMode(),Tell("                    ",uni));
        Decide( Degree(f[1])=?1,
          {
            Local(cc,lcm,fnew);
            Decide(InVerboseMode(),Tell("                          ",Degree(f[1])));
            cc      := Coef(f[1],uni[1],0 .. 1);
            //Tell("                       ",cc);
            lcm     := Lcm( Denominator /@ cc );
            uni[3]  := lcm * cc;
            fnew    := NormalForm(uni);
            Decide( hasRationalCoefficients,
              {
                 DestructiveAppend(factrsnew,f);
              },
              { 
                 DestructiveAppend(factrsnew,[fnew,f[2]]);
              }
            );
          }
        );
        Decide( Degree(f[1])=?2,
          {
            Decide(InVerboseMode(),Tell("                          ",Degree(f[1])));
            Local(pq);
            pq      := PrimitivePart(f[1]);
            DestructiveAppend(factrsnew,[pq,f[2]]);
          }
        );
        //  If any factors have degree >=3, store them in a 'residuals' array
        //  for further analysis
        Decide( Degree(f[1]) >? 2,
          {
            Decide(InVerboseMode(),Tell("                          ",Degree(f[1])));
            Local(pq);
            pq      := PrimitivePart(f[1]);
            DestructiveAppend(residuals,[pq,f[2]]);
            Decide(InVerboseMode(),Tell("                   appending to residuals",pq));
          }
        );       
    };
    [factrsnew,residuals];
};
UnFence("FixUpMonicFactors",1);


//10 # matchPower(_Z^n_Number?) <-- n;

//15 # matchPower(_Z) <-- 1;


//========================================================================

%/mathpiper





%mathpiper_docs,name="jFactorsPoly",categories="User Functions",access="undocumented"
*CMD jFactorsPoly --- *** UNDOCUMENTED ***

*CALL
        ?

*PARMS

?

*DESC

?

%/mathpiper_docs