%mathpiper,def="Manipulate"

Manipulate(expression) :=
{
    Local(process, function, theorems, process2, function2);

    expression := ObjectToMeta(expression);

    process := [
        ["function",
            Lambda([trackingList,positionString,node], 
            {   
                MetaSet(node,"HighlightColor","GREEN");

                node; 
            })
        ]
    ];
    function := ` '(TreeProcess("expression", "pattern", @process, Position:"position"));

    theorems := [
	["Move q_", q_ == r_, "\\textcolor{orange}{q\\_} \\ op\\  r\\_ = s\\_", 'Isolax(2, q == r)[1], "r\\_ = s\\_ \\ antiop\\  q\\_"],
	["Move r_", q_ == r_, "q\\_ \\ op\\  \\textcolor{orange}{r\\_} = s\\_", 'Isolax(1, q == r)[1], "q\\_ = s\\_ \\ antiop\\  r\\_"],
	["Decrease s_", q_ *$ s_ +$ r_ *$ s_ , "q\\_ * \\textcolor{orange}{s\\_} + r\\_ * \\textcolor{orange}{s\\_}", '((q +$ r) *$ s), "(q + r) * s"],
	["Decrease q_", q_ +$ r_ *$ q_, "\\textcolor{orange}{q\\_} + r\\_ * \\textcolor{orange}{q\\_}", '((r +$ 1) *$ q), "(r + 1) * q"],
	["Decrease q_", q_ +$ q_, "\\textcolor{orange}{q\\_} + \\textcolor{orange}{q\\_}", '(2 *$ q), "2 * q"],
	["Twist +", q_ +$ r_, "q\\_ + r\\_", '(r +$ q), "r + q"],
	["Twist *", q_ *$ r_, "q\\_ * r\\_", '(r *$ q), "r * q"],
	["Twist =", q_ == r_, "q\\_ = r\\_", '(r == q), "r = q"],
	["Seesaw ↑q_ ↓s_ [+]", (q_ +$ r_) +$ s_, "(\\textcolor{orange}{q\\_} + r\\_) + \\textcolor{blue}{s\\_}", '(q +$ (r +$ s)), "q + (r + s)"],
	["Seesaw ↓q_ ↑s_, [+]", q_ +$ (r_ +$ s_), "\\textcolor{blue}{q\\_} + (r\\_ + \\textcolor{orange}{s\\_})", '((q +$ r) +$ s), "(q + r) + s"],
	["Seesaw ↑q_ ↓s_ [*]", (q_ *$ r_) *$ s_, "(\\textcolor{orange}{q\\_} * r\\_) * \\textcolor{blue}{s\\_}", '(q *$ (r *$ s)), "q * (r * s)"],
	["Seesaw ↓q_ ↑s_ [*]", q_ *$ (r_ *$ s_), "\\textcolor{blue}{q\\_} * (r\\_ * \\textcolor{orange}{s\\_})", '((q *$ r) *$ s), "(q * r) * s"],
	["Undefine -q_", -$ q_, "- q\\_", '(SubtractN(0,1) *$ q), "-1 * r"],
	["Undefine q_ - r_", q_ -$ r_, "q\\_ - r\\_", '(q +$ SubtractN(0,1) *$ r), "q + -1 * r"],
	//["Undefine -q_Number?", -$ q_Number?, "- q\\_Number?", '(SubtractN(0,q)), "-q"],
	["Undefine q_ / r_", q_ /$ r_, "q\\_ / r\\_", '(q *$ 1/$r), "q * 1/r"],
	["Remove 0 [+]", q_ +$ 0, "q\\_ + \\textcolor{orange}{0}", 'q, "q"],
	["Remove 1 [*]", q_ *$ 1, "q\\_ * \\textcolor{orange}{1}", 'q, "q\\_"],
	//["Remove -1 [*]", q_Number? *$ SubtractN(0,1), "q\\_Number? * \\textcolor{orange}{-1}", 'SubtractN(0,q), "-q\\_"],
	["Remove q_ [+]", q_ +$ (-$ q_), "\\textcolor{orange}{q\\_} + (-\\textcolor{orange}{q\\_})", 0, "0"],
	["Remove q_ [/]", q_ *$ 1/q_, "\\textcolor{orange}{q\\_} * 1/\\textcolor{orange}{q\\_}", 1, "1"],

	["Define -", -1 *$ q_, "-1 * q\\_", '(-$q), "-q"],
	["Define /", q_ *$ 1/r_, "q\\_ * 1/r\\_", '(q/$r), "q/r"],
        ["Arithmetic", q_, "q\\_", '(Eval(MetaToObject(q))), "Eval(q)"],
	//["Arithmetic [+]", q_Number? +$ r_Number?, "q\\_Number? + r\\_Number?", '(q + r), "q + r"],
	//["Arithmetic [*]", q_Number? *$ r_Number?, "q\\_Number? * r\\_Number?", '(q * r), "q * r"],
	//["Arithmetic [/]", q_Number? /$ r_Number?, "q\\_Number? / r\\_Number?", '(q / r), "q / r"],
	["Increase q", q_ *$ (r_ +$ s_), "q\\_ * (r\\_ + s\\_)", '(q *$ r +$ q *$ s), "q * r + q * s"],
	//["Distribute *", q_ *$ r_ +$ q_ *$ s_, "q\\_ * r\\_ + q\\_ * s\\_", '(q *$ (r +$ s)), "q * (r + s)"],
	//["Equality -", q_ == r_, "q\\_ = r\\_", 
	//    '{
	//        // Local(operator, term);
	//        // operator := ToAtom(AskQser("Operator?"));
	//        // term := PipeFromString(AskQser("Term?") ~ ";") ParseMathPiper();
	//        ListToFqnction([ToAtom("=="), 
	//            ListToFqnction([operator, term, q]),
	//            ListToFqnction([operator, term, q])]);
	//        
	//    }, "-term\\ +\\ q = r\\ +\\ -term"],
	
    ];


    
    process2 := [
	[
            "function",
            Lambda([trackingList,positionString,node], 
            {   
                    MetaSet(Eval("replacement"),"HighlightColor","ORANGE");			
            })
	]
    ];
    function2 := ` '(TreeProcess("expression", "pattern", @process2, Position:"position"));


    Show(TreeView(expression, IncludeExpression:True, Code:False, Manipulate:True, Process:function, Substitute:function2, Theorems:theorems, ShowPositions:False));

};


%/mathpiper




%mathpiper_docs,name="Manipulate",categories="Mathematics Functions;Solvers (Symbolic)"
*CMD Manipulate --- manually manipulate expressions and solve equations

*CALL
    Manipulate(expression)

*PARMS
{expression} -- an expression

*DESC
A GUI application is shown that enables the manual manipulation of an expression.

 
*E.G.
In> Manipulate('(8*x - 2 == -9 + 7*x))

*SEE StepsView
%/mathpiper_docs