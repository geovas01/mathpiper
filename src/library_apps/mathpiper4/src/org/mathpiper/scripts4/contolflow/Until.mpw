%mathpiper,def="Until"

TemplateFunction("Until",[_predicate,_body])
{
  Eval(body);
  While (Equal?(Eval(predicate),False))
  {
    Eval(body);
  };
  True;
};
UnFence("Until",2);
HoldArgumentNumber("Until",2,1);
HoldArgumentNumber("Until",2,2);

%/mathpiper



%mathpiper_docs,name="Until",categories="Programming Functions;Control Flow"
*CMD Until --- loop until a condition is met
*STD
*CALL
        Until(pred) body

*PARMS

{pred} -- predicate deciding whether to stop

{body} -- expression to loop over

*DESC

Keep on evaluating "body" until "pred" becomes {True}. More precisely, {Until} first
evaluates the expression "body". Then the predicate "pred" is
evaluated, which should yield either {True} or {False}. In the latter case, the expressions "body"
and "pred" are again evaluated and this continues as long as
"pred" is {False}. As soon as "pred" yields {True}, the loop terminates and {Until} returns {True}.

The main difference with {While} is that {Until} always evaluates the body at 
least once, but {While} may not evaluate the body at all. Besides, the
meaning of the predicate is reversed: {While} stops
if "pred" is {False} while {Until} stops if "pred" is {True}.
The command
{Until(pred) body;} is equivalent to {pred; While(Not? pred) body;}. In fact, the
implementation of {Until} is based on the internal
command {While}. The {Until}
command can be compared to the {do ... while}
construct in the programming language C.

*E.G.

/%mathpiper
x := 1;

Until(x >=? 5)
{
   Echo(x); 
   x++;
};
/%/mathpiper

    /%output,sequence="4",timestamp="2013-09-16 22:36:36.156",preserve="false"
      Result: True
      
      Side Effects:
      1 
      2 
      3 
      4 
      
.   /%/output

*SEE While, For, ForEach, Break, Continue
%/mathpiper_docs