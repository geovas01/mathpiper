/* {{{ License.
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */ //}}}
// :indentSize=4:lineSeparator=\n:noTabs=false:tabSize=4:folding=explicit:collapseFolds=0:
package org.mathpiper.lisp;

import org.mathpiper.lisp.collections.OperatorMap;
import org.mathpiper.lisp.cons.SublistCons;
import org.mathpiper.lisp.cons.AtomCons;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import org.mathpiper.Scripts;
import org.mathpiper.io.MathPiperInputStream;
import org.mathpiper.io.MathPiperOutputStream;
import org.mathpiper.exceptions.EvaluationException;
import org.mathpiper.io.InputStatus;
import org.mathpiper.builtin.BigNumber;
import org.mathpiper.builtin.BuiltinFunction;
import org.mathpiper.lisp.substitute.BackQuoteSubstitute;
import org.mathpiper.lisp.substitute.Substitute;
import org.mathpiper.lisp.tokenizers.MathPiperTokenizer;
import org.mathpiper.lisp.printers.MathPiperPrinter;
import org.mathpiper.lisp.parsers.MathPiperParser;
import org.mathpiper.io.StringInputStream;
import org.mathpiper.io.StringOutput;
import org.mathpiper.io.StringOutputStream;
import org.mathpiper.lisp.cons.Cons;
import org.mathpiper.lisp.cons.NumberCons;
import org.mathpiper.lisp.parametermatchers.ParametersPatternMatcher;
import org.mathpiper.lisp.parametermatchers.PatternParameterMatcher;
import org.mathpiper.lisp.parsers.Parser;
import org.mathpiper.lisp.printers.LispPrinter;
import org.mathpiper.lisp.rulebases.Rule;
import org.mathpiper.lisp.rulebases.ParameterName;
import org.mathpiper.lisp.rulebases.MacroRulebase;
import org.mathpiper.lisp.rulebases.PatternRule;
import org.mathpiper.lisp.rulebases.SingleArityRulebase;

public class Utility {

    public static final int ATOM = 1;
    public static final int NUMBER = 2;
    public static final int SUBLIST = 3;
    public static final int OBJECT = 4;
    static int log2_table_size = 32;    // A lookup table of Ln(n)/Ln(2) for n = 1 .. 32.
    // With this we don't have to use math.h if all we need is to convert the number of digits from one base to another. This is also faster.
    // Generated by: PrintList(N(Ln(1 .. 32)/Ln(2)), ",") at getPrecision 40.
    static double log2_table[] = {
        0.,
        1.,
        1.5849625007211561814537389439478165087598,
        2.,
        2.3219280948873623478703194294893901758648,
        2.5849625007211561814537389439478165087598,
        2.807354922057604107441969317231830808641,
        3.,
        3.1699250014423123629074778878956330175196,
        3.3219280948873623478703194294893901758648,
        3.4594316186372972561993630467257929587032,
        3.5849625007211561814537389439478165087598,
        3.7004397181410921603968126542566947336284,
        3.807354922057604107441969317231830808641,
        3.9068905956085185293240583734372066846246,
        4.,
        4.0874628412503394082540660108104043540112,
        4.1699250014423123629074778878956330175196,
        4.2479275134435854937935194229068344226935,
        4.3219280948873623478703194294893901758648,
        4.3923174227787602888957082611796473174008,
        4.4594316186372972561993630467257929587032,
        4.5235619560570128722941482441626688444988,
        4.5849625007211561814537389439478165087598,
        4.6438561897747246957406388589787803517296,
        4.7004397181410921603968126542566947336284,
        4.7548875021634685443612168318434495262794,
        4.807354922057604107441969317231830808641,
        4.8579809951275721207197733246279847624768,
        4.9068905956085185293240583734372066846246,
        4.9541963103868752088061235991755544235489,
        5.
    };


    public static boolean isNumber(String ptr, boolean aAllowFloat) {

        if (ptr.length() == 0) {
            return false;
        }//end if.

        int pos = 0;
        if (ptr.charAt(pos) == '-' || ptr.charAt(pos) == '+') {
            pos++;
        }
        int nrDigits = 0;
        int index = 0;
        if (pos + index == ptr.length()) {
            return false;
        }
        while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
            nrDigits++;
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
        }
        if (ptr.charAt(pos + index) == '.') {
            if (!aAllowFloat) {
                return false;
            }
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
            while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
                nrDigits++;
                index++;
                if (pos + index == ptr.length()) {
                    return true;
                }
            }
        }
        if (nrDigits == 0) {
            return false;
        }
        if (ptr.charAt(pos + index) == 'e' || ptr.charAt(pos + index) == 'E') {
            if (!aAllowFloat) {
                return false;
            }
            if (!BigNumber.numericSupportForMantissa()) {
                return false;
            }
            index++;
            if (pos + index == ptr.length()) {
                return true;
            }
            if (ptr.charAt(pos + index) == '-' || ptr.charAt(pos + index) == '+') {
                index++;
            }
            while (ptr.charAt(pos + index) >= '0' && ptr.charAt(pos + index) <= '9') {
                index++;
                if (pos + index == ptr.length()) {
                    return true;
                }
            }
        }
        if (ptr.length() != (pos + index)) {
            return false;
        }
        return true;
    }

    public static int listLength(Environment aEnvironment, int aStackTop, Cons aOriginal) throws Exception {
        
        int length = 0;
        while (aOriginal != null) {
            aOriginal = aOriginal.cdr();
            length++;
        }
        return length;
    }

    public static Cons reverseList(Environment aEnvironment, Cons aOriginal) {

        Cons iter = aOriginal;

        Cons previous = null;

        Cons tail = aOriginal;

        while (iter != null) {

            tail = iter.cdr();

            iter.setCdr(previous);

            previous = iter;

            iter = tail;
        }

        return previous;
    }

    public static Cons returnUnEvaluated(int aStackTop, Cons aArguments, Environment aEnvironment) throws Exception {
        Cons full = aArguments.copy(false);

        Cons resultCons = SublistCons.getInstance(aEnvironment, full);

        Cons consTraverser = aArguments;
        consTraverser = consTraverser.cdr();

        while (consTraverser != null) {
            Cons next = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, consTraverser);
            full.setCdr(next);
            full = next;
            consTraverser = consTraverser.cdr();
        }
        full.setCdr(null);

        return resultCons;
    }

    //Evaluate a function which is in string form.
    public static Cons applyString(Environment aEnvironment, int aStackTop, String aOperator, Cons aArgs) throws Exception {
        if(! isString(aOperator)) LispError.throwError(aEnvironment, aStackTop, LispError.NOT_A_STRING, aOperator);

        Cons head = AtomCons.getInstance(aEnvironment, aStackTop, getSymbolName(aEnvironment, aOperator));
        head.setCdr(aArgs);
        Cons body = SublistCons.getInstance(aEnvironment, head);
        Cons result = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, body);
        return result;
    }

    public static Cons applyPure(int aStackTop, Cons oper, Cons args2, Environment aEnvironment) throws Exception {
        if(!(oper.car() instanceof Cons)) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);
        if(((Cons) oper.car()) == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);

        Cons oper2 = ((Cons) oper.car()).cdr();
        if( oper2 == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);

        Cons body;
        body = oper2.cdr();
        if(body == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);

        if(! (oper2.car() instanceof Cons)) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);
        if( ((Cons) oper2.car()) == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);
        oper2 = ((Cons) oper2.car()).cdr();

        aEnvironment.pushLocalFrame(false, "Pure");
        try {
            while (oper2 != null) {
                if( args2 == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);

                String var = (String) oper2.car();
                if( var == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);
                Cons newly = args2.copy(false);
                aEnvironment.newLocalVariable(var, newly, aStackTop);
                oper2 = oper2.cdr();
                args2 = args2.cdr();
            }
            if(args2 != null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, args2);
            return aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, body);
        } catch (EvaluationException e) {
            throw e;
        } finally {
            aEnvironment.popLocalFrame(aStackTop);
        }

    }

    public static Cons getTrueAtom(Environment aEnvironment) throws Exception {
        return aEnvironment.iTrueAtom.copy(false);
    }

    public static Cons getFalseAtom(Environment aEnvironment) throws Exception {
        return aEnvironment.iFalseAtom.copy(false);
    }

    public static Cons getBooleanAtom(Environment aEnvironment, boolean aValue) throws Exception {
        if (aValue) {
            return getTrueAtom(aEnvironment);
        } else {
            return getFalseAtom(aEnvironment);
        }
    }

    public static Cons nth(Environment aEnvironment, int aStackTop, Cons aArg, int n) throws Exception {
        if(aArg == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        if(! (aArg.car() instanceof Cons)) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        if(n < 0) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        Cons consTraverser = (Cons) aArg.car();

        while (n > 0) {
            if(consTraverser == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
            consTraverser = consTraverser.cdr();
            n--;
        }
        if(consTraverser == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        return consTraverser.copy(false);
    }

    public static Cons tail(Environment aEnvironment, int aStackTop, Cons aArg) throws Exception {
        if(aArg == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        if(! (aArg.car() instanceof Cons)) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);

        Cons iter = (Cons) aArg.car();

        if(iter == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, aArg);
        return SublistCons.getInstance(aEnvironment, iter.cdr());
    }


    public static boolean isTrue(Environment aEnvironment, Cons aExpression, int aStackTop) throws Exception {
        if(aExpression == null) LispError.lispAssert(aEnvironment, aStackTop);

        //return aExpression.car() == aEnvironment.iTrueAtom.car();
        return aExpression.car() instanceof String && ((String) aExpression.car()).equals(aEnvironment.iTrueString);

        /* Code which returns True for everything except False and {};
        String expressionString = aExpression.car();

        //return expressionString == aEnvironment.iTrueString;

        if (expressionString == aEnvironment.iTrueString) {
        return true;
        } else if (isSublist(aExpression)) {
        if (listLength(aExpression.car()) == 1) {
        //Empty list.
        return false;
        } else {
        //Non-empty list.
        return true;
        }
        } else {
        //Anything other than False returns true.
        return expressionString != null && expressionString != aEnvironment.iFalseString;
        }*/

    }//end method.
    public static boolean isFalse(Environment aEnvironment, Cons aExpression, int aStackTop) throws Exception {
        if(aExpression == null) LispError.lispAssert(aEnvironment, aStackTop);
        return aExpression.car() instanceof String && ((String) aExpression.car()).equals(aEnvironment.iFalseString);

        /* Code which returns True for everything except False and {};
        return aExpression.car() == aEnvironment.iFalseString || (isSublist(aExpression) && (listLength(aExpression.car()) == 1));
         */
    }

    public static String getSymbolName(Environment aEnvironment, String aSymbol) throws Exception {
        if (aSymbol.charAt(0) == '\"') {
            return Utility.stripEndQuotesIfPresent(aEnvironment, -1, aSymbol);
        } else {
            return aSymbol;
        }
    }

    public static boolean isSublist(Cons aPtr) throws Exception {
        /**
         * todo:tk: I am currently not sure why non nested lists are not supported in Yacas.
         */
        if (aPtr == null) {
            return false;
        }
        if (!(aPtr.car() instanceof Cons)) {
            return false;
        }
        if ((Cons) aPtr.car() == null) {
            return false;
            //TODO this StrEqual is far from perfect. We could pass in a Environment object...
        }
        if (!((Cons) aPtr.car()).car().equals("List")) {
            return false;
        }
        return true;

    }//end method.

    public static boolean isList(Cons aPtr) throws Exception {
        /**
         * todo:tk: I am currently not sure why non nested lists are not supported in Yacas.
         */
        if (aPtr == null) {
            return false;
        }

        if (aPtr.type() == Utility.ATOM) {
            if (((String) aPtr.car()).equalsIgnoreCase("List")) {
                return true;
            }//end if.
        }//end if.

        if (isSublist(aPtr)) {
            return true;
        }//end if.
        return false;

    }//end method.

    public static boolean isNestedList(Environment aEnvironment, int aStackTop, Cons clientList) throws Exception {

        Cons list = clientList;

        list = list.cdr();

        while (list != null) {
            if (list.car() instanceof Cons && isList((Cons) list.car())) {
                list = list.cdr();
            } else {
                return false;
            }
        }//end while.
        return true;
    }//end method.

    public static Map optionsListToJavaMap(Environment aEnvironment, int aStackTop, Cons arguments, Map defaultOptions) throws Exception {

        Map userOptions = (Map) ((HashMap) defaultOptions).clone();

        while (arguments != null) {
            //Obtain -> operator.
            Cons option = (Cons) arguments.car();
            if( option.type() != Utility.ATOM) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, arguments);
            String operator = (String) option.car();
            if(! operator.equals("->")) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, arguments);

            //Obtain key.
            option = option.cdr();
            if( option.type() != Utility.ATOM) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, arguments);
            String key = (String) option.car();
            key = Utility.stripEndQuotesIfPresent(aEnvironment, aStackTop, key);

            //Obtain value.
            option = option.cdr();
            if( option.type() != Utility.ATOM && option.type() != Utility.NUMBER) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, arguments);
            if (option.type() == Utility.ATOM) {
                String value = (String) option.car();
                value = Utility.stripEndQuotesIfPresent(aEnvironment, aStackTop, value);
                if (value.equalsIgnoreCase("true") || value.equalsIgnoreCase("false")) {
                    userOptions.put(key, Boolean.parseBoolean(value));
                } else {
                    userOptions.put(key, value);
                }//ende else.
            } else //Number
            {
                NumberCons numberCons = (NumberCons) option;
                BigNumber bigNumber = (BigNumber) numberCons.getNumber(10, aEnvironment);
                Double value = bigNumber.toDouble();
                userOptions.put(key, value);
            }//end if/else.



            arguments = arguments.cdr();

        }//end while

        return userOptions;
    }//end method.

    public static boolean isString(Object aOriginal) {

        if (!(aOriginal instanceof String)) {
            return false;
        }//end if.

        String stringVersion = (String) aOriginal;

        if (stringVersion != null) {
            if (stringVersion.charAt(0) == '\"') {
                if (stringVersion.charAt(stringVersion.length() - 1) == '\"') {
                    return true;
                }
            }
        }
        return false;
    }//end method


    public static String stripEndDollarSigns(String aOriginal) throws Exception {
        //If there are not dollar signs on both ends of the string then return without any changes.
        aOriginal = aOriginal.trim();
        if (aOriginal.startsWith("$") && aOriginal.endsWith("$")) {
            aOriginal = aOriginal.substring(1, aOriginal.length());
            aOriginal = aOriginal.substring(0, aOriginal.length() - 1);
        }//end if.

        return aOriginal;
    }//end method.

    public static Cons not(int aStackTop, Environment aEnvironment, Cons aExpression) throws Exception {
        if (isTrue(aEnvironment, aExpression, aStackTop)) {
            return getFalseAtom(aEnvironment);
        } else {
            if(isTrue(aEnvironment, aExpression, aStackTop)) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, BuiltinFunction.getArgument(aEnvironment, aStackTop, 1));
            return getTrueAtom(aEnvironment);
        }
    }

    public static Cons flatCopy(Environment aEnvironment, int aStackTop, Cons aOriginal) throws Exception {
        Cons orig = aOriginal;
        Cons copied = null;
        Cons head = null;
        Cons previous = null;

        boolean isHead = true;

        while (orig != null) {


            copied = orig.copy(false);

            if(isHead == true)
            {
                head = copied;
                previous = head;
                isHead = false;
            }
            else
            {
                previous.setCdr(copied);
                previous = copied;
            }


            orig = orig.cdr();

        }

        return head;
    }

    public static boolean equals(Environment aEnvironment, int aStackTop, Cons aExpression1, Cons aExpression2) throws Exception {
        // Handle pointers to same, or null
        if (aExpression1 == aExpression2) {
            return true;
        }
        //LispError.check(aExpression1.type().equals("Number"), LispError.INVALID_ARGUMENT);
        //LispError.check(aExpression2.type().equals("Number"), LispError.INVALID_ARGUMENT);
        BigNumber n1 = (BigNumber) aExpression1.getNumber(aEnvironment.getPrecision(), aEnvironment);
        BigNumber n2 = (BigNumber) aExpression2.getNumber(aEnvironment.getPrecision(), aEnvironment);
        if (!(n1 == null && n2 == null)) {
            if (n1 == n2) {
                return true;
            }
            if (n1 == null) {
                return false;
            }
            if (n2 == null) {
                return false;
            }
            if (n1.equals(n2)) {
                return true;
            }
            return false;
        }
       
        //Pointers to strings should be the same
        if ((aExpression1.car() instanceof String) && (aExpression2.car() instanceof String)) {
            if (!(((String)aExpression1.car()).equals(((String)aExpression2.car())))) {
                return false;
            }
            else
            {
                return true;
            }
        }


        // Handle same sublists, or null
        if (aExpression1.car() == aExpression2.car()) {
            return true;
        }

        // Now check the sublists
        if (aExpression1.car() instanceof Cons) {
            if (!(aExpression2.car() instanceof Cons)) {
                return false;
            }
            Cons consTraverser1 = (Cons) aExpression1.car();
            Cons consTraverser2 = (Cons) aExpression2.car();

            while (consTraverser1 != null && consTraverser2 != null) {
                // compare two list elements
                if (!equals(aEnvironment, aStackTop, consTraverser1, consTraverser2)) {
                    return false;
                }

                // Step to rest
                consTraverser1 = consTraverser1.cdr();
                consTraverser2 = consTraverser2.cdr();
            }
            // Lists don't have the same length
            if (consTraverser1 != consTraverser2) {
                return false;            // Same!
            }
            return true;
        }

        // expressions sublists are not the same!
        return false;
    }

    public static Cons substitute(Environment aEnvironment, int aStackTop, Cons aSource, Substitute aBehaviour) throws Exception {
        
        Cons sourceCons = aSource;

        Cons aDestination = null;

        if(sourceCons == null) LispError.lispAssert(aEnvironment, aStackTop);


        if((aDestination = aBehaviour.matches(aEnvironment, aStackTop,  aSource)) != null)
        {
            //Base case.
            return aDestination;
        }
        else
        {
            //Recursively process list.

            Object sourceListCar = sourceCons.car();

            Cons sourceList = null;

            if (sourceListCar instanceof Cons) {
                Cons cons = (Cons) sourceListCar;
                sourceList = cons;
            }

            if (sourceList != null) {

                Cons headCons = null;

                Cons indexCons = null;

                boolean isHead = true;

                while (sourceList != null) {


                    Cons result = substitute(aEnvironment, aStackTop, sourceList, aBehaviour);

                    if(isHead == true)
                    {
                        headCons = result;
                        indexCons = headCons;
                        isHead = false;
                    }
                    else
                    {
                        //Point to next cons in the destination list.
                        indexCons.setCdr(result);
                        indexCons = result;
                    }

                    //Point to next cons in the source list.
                    sourceList = sourceList.cdr();



                }
                
                aDestination = SublistCons.getInstance(aEnvironment, headCons);
                
            } else {
                //Handle atoms.
                aDestination = sourceCons.copy(false);
            }

            return aDestination;

        }//end matches if.
    }


    public static String stripEndQuotesIfPresent(Environment aEnvironment, int aStackTop, String aOriginal) throws Exception {
        //If there are not quotes on both ends of the string then return without any changes.
        if (aOriginal.startsWith("\"") && aOriginal.endsWith("\"")) {
            aOriginal = aOriginal.substring(1, aOriginal.length());
            aOriginal = aOriginal.substring(0, aOriginal.length() - 1);
        }//end if.

        return aOriginal;
    }//end method.

    

    public static String toNormalString(Environment aEnvironment, int aStackTop, String aOriginal) throws Exception {
        if( aOriginal == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, "Empty argument.");
        if(aOriginal.charAt(0) != '\"') LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, "Missing left quote character.");
        int nrc = aOriginal.length() - 1;
        if( aOriginal.charAt(nrc) != '\"') LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, "Missing right quote character.");
        return aOriginal.substring(1, nrc);
    }

    public static String toMathPiperString(Environment aEnvironment, int aStackTop, String aOriginal) throws Exception {
        if( aOriginal == null) LispError.throwError(aEnvironment, aStackTop, LispError.INVALID_ARGUMENT, "Empty argument.");

        return "\"" + aOriginal + "\"";
    }

    public static void doInternalLoad(Environment aEnvironment, int aStackTop, MathPiperInputStream aInput) throws Exception {
        MathPiperInputStream previous = aEnvironment.getCurrentInput();
        try {
            aEnvironment.setCurrentInput(aInput);
            // TODO make "EndOfFile" a global thing
            // read-parse-evaluate to the end of file
            String eof = "EndOfFile";
            boolean endoffile = false;

            MathPiperParser parser = new MathPiperParser(new MathPiperTokenizer(), aEnvironment.getCurrentInput(), aEnvironment, aEnvironment.iPrefixOperators, aEnvironment.iInfixOperators, aEnvironment.iPostfixOperators, aEnvironment.iBodiedOperators);
            //Parser parser = new Parser(new MathPiperTokenizer(), aEnvironment.iCurrentInput, aEnvironment);

            while (!endoffile) {
                // Read expression
                Cons readIn = parser.parse(aStackTop);

                if( readIn == null) LispError.throwError(aEnvironment, aStackTop, LispError.READING_FILE, "");
                // check for end of file
                if (readIn.car() instanceof String && ((String) readIn.car()).equals(eof)) {
                    endoffile = true;
                } // Else evaluate
                else {

                    Cons result = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, readIn);
                    if(aStackTop != -1)
                    {
                        aEnvironment.setLocalOrGlobalVariable(aStackTop, "$LoadResult", result, false);//Note:tk:added to make the result of executing Loaded code available.
                    }
                }
            }//end while.



        } catch (Exception e) {
            System.out.println(e.getMessage()); e.printStackTrace(); //todo:tk:uncomment for debugging.

            throw e;
        } finally {
            aEnvironment.setCurrentInput(previous);
        }
    }



    public static void doPatchString(String unpatchedString, MathPiperOutputStream aOutput, Environment aEnvironment, int aStackTop) throws Exception
    {
        String[] tags = unpatchedString.split("\\?\\>");
        if (tags.length > 1) {
            for (int x = 0; x < tags.length; x++) {
                String[] tag = tags[x].split("\\<\\?");
                if (tag.length > 1) {
                    aOutput.write(tag[0]);
                    String scriptCode = tag[1].trim();

                    StringInputStream scriptStream = 
                        new StringInputStream(scriptCode, aEnvironment.getCurrentInput().iStatus);
                    MathPiperOutputStream previous = 
                        aEnvironment.iCurrentOutput;
                    try {
                        aEnvironment.iCurrentOutput = aOutput;
                        Utility.doInternalLoad(aEnvironment, aStackTop, scriptStream);
                    } catch(Exception e) {
                        throw e;
                    } finally {
                        aEnvironment.iCurrentOutput = previous;
                    }
                }
            } // end for
            aOutput.write(tags[tags.length - 1]);
        } else {
            aOutput.write(unpatchedString);
        }
    }

    public static String printMathPiperExpression(int aStackTop, Cons aExpression, Environment aEnvironment, int aMaxChars) throws Exception {
        if(aExpression == null)
        {
            return "NULL";
        }

        StringBuffer result = new StringBuffer();
        StringOutputStream newOutput = new StringOutputStream(result);
        MathPiperPrinter infixprinter = new MathPiperPrinter(aEnvironment.iPrefixOperators,
                aEnvironment.iInfixOperators,
                aEnvironment.iPostfixOperators,
                aEnvironment.iBodiedOperators);
        infixprinter.print(aStackTop, aExpression, newOutput, aEnvironment);
        if (aMaxChars > 0 && result.length() > aMaxChars) {
            result.delete(aMaxChars, result.length());
            result.append((char) '.');
            result.append((char) '.');
            result.append((char) '.');
        }
        return result.toString();
    }//end method.


    public static String printLispExpression( int aStackTop, Cons aExpression, Environment aEnvironment, int aMaxChars) throws Exception {
        if(aExpression == null)
        {
            return "NULL";
        }

        StringOutput out = new StringOutput();

        LispPrinter printer = new LispPrinter();

        printer.print(aStackTop, aExpression, out, aEnvironment);

        //todo:tk:add the ability to truncate the result.

        return out.toString();
    }




    
    //////////////////////////////////////////////////
    ///// bits_to_digits and digits_to_bits implementation
    //////////////////////////////////////////////////

    // lookup table for transforming the number of digits
    // report the table size
    int log2TableRange() {
        return log2_table_size;
    }
    // table look-up of small integer logarithms, for converting the number of digits to binary and back

    static double log2TableLookup(int n) throws Exception {
        if (n <= log2_table_size && n >= 2) {
            return log2_table[n - 1];
        } else {
            throw new EvaluationException("log2_table_lookup: error: invalid argument " + n, "none", -1,-1,-1);
        }
    }

    /**
     * Convert the number of digits in given base to the number of bits.  To make sure there is no hysteresis, the returned
     * value is rounded up.
     *
     * @param digits
     * @param base
     * @return the number of bits
     * @throws java.lang.Exception
     */
    public static long digitsToBits(long digits, int base) throws Exception {
        return (long) Math.ceil(((double) digits) * log2TableLookup(base));
    }

    /**
     * Convert the  number of bits in a given base to the number of digits.  To make sure there is no hysteresis, the returned
     * value is rounded down.
     *
     * @param bits
     * @param base
     * @return the number of digits
     * @throws java.lang.Exception
     */
    public static long bitsToDigits(long bits, int base) throws Exception {
        return (long) Math.floor(((double) bits) / log2TableLookup(base));
    }

    //************************* The following methods were taken from the Functions class.
    /**
     * Construct a {@link BigNumber}.
     * @param aEnvironment the current {@link Environment}.
     * @param aStackTop points to the the top of the argument stack.
     * @param aArgNr the index of the argument to be converted.
     * @return a BigNumber.
     * @throws java.lang.Exception
     */
    public static BigNumber getNumber(Environment aEnvironment, int aStackTop, int aArgNr) throws Exception {
        BigNumber x = (BigNumber) BuiltinFunction.getArgument(aEnvironment, aStackTop, aArgNr).getNumber(aEnvironment.iPrecision, aEnvironment);
        if( x == null) LispError.checkArgument(aEnvironment, aStackTop, aArgNr);
        return x;
    }

    public static void multiFix(Environment aEnvironment, int aStackTop, OperatorMap aOps) throws Exception {
        // Get operator
        if(BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        String orig = (String) BuiltinFunction.getArgument(aEnvironment, aStackTop, 1).car();
        if(orig == null) LispError.checkArgument(aEnvironment, aStackTop, 1);

        
        Cons precedence = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, BuiltinFunction.getArgument(aEnvironment, aStackTop, 2));
        if(! (precedence.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 2);
        int prec = Integer.parseInt((String) precedence.car(), 10);
        if(prec > MathPiperPrinter.KMaxPrecedence) LispError.checkArgument(aEnvironment, aStackTop, 2);
        aOps.setOperator(prec, Utility.getSymbolName(aEnvironment, orig));
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }

    public static void singleFix(int aPrecedence, Environment aEnvironment, int aStackTop, OperatorMap aOps) throws Exception {
        // Get operator
        if(BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        String orig = (String) BuiltinFunction.getArgument(aEnvironment, aStackTop, 1).car();
        if(orig == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        aOps.setOperator(aPrecedence, Utility.getSymbolName(aEnvironment, orig));
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }

    public static Operator operatorInfo(Environment aEnvironment, int aStackTop, OperatorMap aOperators) throws Exception {
        // Get operator
        if(BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);

        Cons evaluated = BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);

        String orig = (String) evaluated.car();
        if(orig == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        //
        Operator op = (Operator) aOperators.lookUp(Utility.getSymbolName(aEnvironment, orig));
        return op;
    }

    /**
     * Sets a variable in the current {@link Environment}.
     * @param aEnvironment holds the execution environment of the program.
     * @param aStackTop
     * @param aMacroMode boolean which determines whether the getFirstPointer argument should be evaluated.
     * @param aGlobalLazyVariable
     * @throws java.lang.Exception
     */
    public static void setVariableOrConstant(Environment aEnvironment, int aStackTop, boolean aMacroMode, boolean aGlobalLazyVariable, boolean aConstant) throws Exception {
        String variableString = null;
        if (aMacroMode) {
            Cons result = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, BuiltinFunction.getArgument(aEnvironment, aStackTop, 1));
            variableString = (String) result.car();
        } else {
            variableString = (String) BuiltinFunction.getArgument(aEnvironment, aStackTop, 1).car();
        }
        if(variableString == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        if(Utility.isNumber(variableString, true)) LispError.checkArgument(aEnvironment, aStackTop, 1);

        Cons value = null;

        if(aConstant == true)
        {
            value = BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);
        }
        else
        {
            value = aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, BuiltinFunction.getArgument(aEnvironment, aStackTop, 2));
        }
        
        aEnvironment.setLocalOrGlobalVariable(aStackTop, variableString, value, aGlobalLazyVariable); //Variable setting is deligated to Environment.


        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }



    public static void delete(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {
        Cons evaluated = BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);
        LispError.checkIsList(aEnvironment, aStackTop, evaluated, 1);

        Cons copied = null;
        if (aDestructive) {
            copied = ((Cons) evaluated.car());
        } else {
            copied = Utility.flatCopy(aEnvironment, aStackTop, (Cons) evaluated.car());
        }

        Cons index = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);
        if(index == null) LispError.checkArgument(aEnvironment, aStackTop, 2);
        if(! (index.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 2);
        int ind = Integer.parseInt((String) index.car(), 10);
        if( ind <= 0) LispError.checkArgument(aEnvironment, aStackTop, 2);

        Cons  consTraverser = copied;
        Cons previousCons = null;
        while (ind > 0) {
            previousCons = consTraverser;
            consTraverser = consTraverser.cdr();
            ind--;
        }
        if(consTraverser == null) LispError.throwError(aEnvironment, aStackTop,  LispError.NOT_LONG_ENOUGH);

        previousCons.setCdr(consTraverser.cdr());

        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, SublistCons.getInstance(aEnvironment, copied));
    }

    public static void insert(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {
        Cons evaluated = BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);
        LispError.checkIsList(aEnvironment, aStackTop, evaluated, 1);

        Cons copied = null;
        if (aDestructive) {
            copied = (Cons) evaluated.car();
        } else {
             copied = Utility.flatCopy(aEnvironment, aStackTop, (Cons) evaluated.car());
        }

        Cons index = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);
        if(index == null) LispError.checkArgument(aEnvironment, aStackTop, 2);
        if(! (index.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 2);
        int ind = Integer.parseInt((String) index.car(), 10);
        if( ind <= 0) LispError.checkArgument(aEnvironment, aStackTop, 2);

        Cons previousCons = null;
        Cons consTraverser = copied;
        while (ind > 0) {
            previousCons = consTraverser;
            consTraverser = consTraverser.cdr();
            ind--;
        }

        Cons toInsert = BuiltinFunction.getArgument(aEnvironment, aStackTop, 3);

        toInsert.setCdr(consTraverser);

        previousCons.setCdr(toInsert);
        
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, SublistCons.getInstance(aEnvironment, copied));
    }

    public static void replace(Environment aEnvironment, int aStackTop, boolean aDestructive) throws Exception {

        Cons evaluated = BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);
        // Ok, so lets not check if it is a list, but it needs to be at least a 'function'
        if(! (evaluated.car() instanceof Cons)) LispError.checkArgument(aEnvironment, aStackTop, 1);

        Cons index = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);
        if( index == null) LispError.checkArgument(aEnvironment, aStackTop, 2);
        if(! (index.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 2);
        int ind = Integer.parseInt((String) index.car(), 10);

        Cons copied = null;
        if (aDestructive) {
            copied = ((Cons) evaluated.car());
        } else {
            copied = Utility.flatCopy(aEnvironment, aStackTop, (Cons) evaluated.car());
        }
        if(ind <= 0) LispError.checkArgument(aEnvironment, aStackTop, 2);

        Cons consTraverser = copied;
        
        Cons previousCons = null;

        while (ind > 0) {
            previousCons = consTraverser;
            consTraverser = consTraverser.cdr();
            ind--;
        }

        Cons toInsert = BuiltinFunction.getArgument(aEnvironment, aStackTop, 3);

        if(consTraverser == null) LispError.checkArgument(aEnvironment, aStackTop, 2);

        toInsert.setCdr(consTraverser.cdr());

        previousCons.setCdr(toInsert);

        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, SublistCons.getInstance(aEnvironment, copied));
    }

    /**
     *Implements the MathPiper functions Rulebase and MacroRulebase .
     * The real work is done by Environment.defineRulebase().
     */
    public static void defineRulebase(Environment aEnvironment, int aStackTop, boolean aListed) throws Exception {

        // Get operator
        String functionName = null;

        if( BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        Cons argument =  BuiltinFunction.getArgument(aEnvironment, aStackTop, 1);
        functionName = (String) argument.car();
        if( functionName == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        Cons args = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);

        // Check the arguments.
        LispError.checkIsList(aEnvironment, aStackTop, args, 2);

        // Finally define the rule database.
        aEnvironment.defineRulebase(aStackTop, Utility.getSymbolName(aEnvironment, functionName), ((Cons) args.car()).cdr(), aListed);

        // Return true
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }

    public static void newRule(Environment aEnvironment, int aStackTop, boolean aPattern) throws Exception {

        int arity;
        int precedence;

        String orig = null;

        // Get operator
        if( BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        orig = (String) BuiltinFunction.getArgument(aEnvironment, aStackTop, 1).car();
        if( orig == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        Cons arityCons = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);
        Cons precedenceCons = BuiltinFunction.getArgument(aEnvironment, aStackTop, 3);
        Cons predicate = BuiltinFunction.getArgument(aEnvironment, aStackTop, 4);
        Cons body = BuiltinFunction.getArgument(aEnvironment, aStackTop, 5);

        // The arity
        if( arityCons  == null) LispError.checkArgument(aEnvironment, aStackTop, 2);
        if(! (arityCons.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 2);
        arity = Integer.parseInt((String) arityCons.car(), 10);

        // The precedence
        if( precedenceCons  == null) LispError.checkArgument(aEnvironment, aStackTop, 3);
        if(! (precedenceCons.car() instanceof String)) LispError.checkArgument(aEnvironment, aStackTop, 3);
        precedence = Integer.parseInt((String) precedenceCons.car(), 10);

        // Finally define the rule base
        if(aPattern == true)
        {
            aEnvironment.definePatternRule(aStackTop, Utility.getSymbolName(aEnvironment, orig),
                arity,
                precedence,
                predicate,
                body);
        }
        else
        {
            aEnvironment.defineRule(aStackTop, Utility.getSymbolName(aEnvironment, orig),
                arity,
                precedence,
                predicate,
                body);
        }

        // Return true
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }

    public static void defineMacroRulebase(Environment aEnvironment, int aStackTop, boolean aListed) throws Exception {
        // Get operator
        String orig = null;

        if(BuiltinFunction.getArgument(aEnvironment, aStackTop, 1) == null) LispError.checkArgument(aEnvironment, aStackTop, 1);
        orig = (String) BuiltinFunction.getArgument(aEnvironment, aStackTop, 1).car();
        if(orig == null) LispError.checkArgument(aEnvironment, aStackTop, 1);

        // The arguments
        Cons args = BuiltinFunction.getArgument(aEnvironment, aStackTop, 2);
        LispError.checkIsList(aEnvironment, aStackTop, args, 2);

        // Finally define the rule base
        aEnvironment.defineMacroRulebase(aStackTop, Utility.getSymbolName(aEnvironment, orig), ((Cons) args.car()).cdr(), aListed);

        // Return true
        BuiltinFunction.setTopOfStack(aEnvironment, aStackTop, Utility.getTrueAtom(aEnvironment));
    }



    public static String dumpRule(int aStackTop, Rule rule, Environment aEnvironment, SingleArityRulebase userFunction) {
        StringBuilder dumpResult = new StringBuilder();
        try {
            int precedence = rule.getPrecedence();

            Cons predicate1 = rule.getPredicateOrPattern(aEnvironment, aStackTop);
            String predicate = "";


            if (predicate1 == null || predicate1.toString().equalsIgnoreCase("Empty.")) {
                predicate = "None.";
            } else {
                predicate = Utility.printMathPiperExpression(aStackTop, predicate1, aEnvironment, 0);
            }

            if (rule instanceof PatternRule) {
                predicate = "(Pattern) ";
                PatternRule branchPattern = (PatternRule) rule;
                ParametersPatternMatcher pattern = branchPattern.getPattern();

                Iterator variablesIterator = pattern.getVariables().iterator();
                String patternVariables = "";
                while (variablesIterator.hasNext()) {
                    String patternVariable = (String) variablesIterator.next();
                    patternVariables += patternVariable + ", ";
                }
                if (patternVariables.contains(",")) {
                    patternVariables = patternVariables.substring(0, patternVariables.lastIndexOf(","));
                }


                Iterator parameterMatchersIterator = pattern.getParameterMatchers().iterator();
                String parameterTypes = "";
                while (parameterMatchersIterator.hasNext()) {
                    PatternParameterMatcher parameter = (PatternParameterMatcher) parameterMatchersIterator.next();
                    String parameterType = (String) parameter.getType();
                    parameterTypes += parameterType + ": " + parameter.toString();
                    parameterTypes += "; ";
                }
                if (parameterTypes.contains(",")) {
                    parameterTypes = parameterTypes.substring(0, parameterTypes.lastIndexOf(","));
                }



                Iterator patternPredicatesIterator = pattern.getPredicates().iterator();
                while (patternPredicatesIterator.hasNext()) {
                    Cons predicateCons = (Cons) patternPredicatesIterator.next();
                    String patternPredicate = Utility.printMathPiperExpression(aStackTop, predicateCons, aEnvironment, 0);
                    predicate += patternPredicate + ", ";
                }
                /*if (predicate.contains(",")) {
                predicate = predicate.substring(0, predicate.lastIndexOf(","));
                }*/
                predicate += "\n    Variables: " + patternVariables + ", ";
                predicate += "\n    Types: " + parameterTypes;

            }//end if.

            Iterator paremetersIterator = userFunction.getParameters();
            String parameters = "";
            boolean isHold = false;
            while (paremetersIterator.hasNext()) {
                ParameterName branchParameter = (ParameterName) paremetersIterator.next();
                String parameter = branchParameter.getName();
                isHold = branchParameter.isHold();
                parameters += parameter + "<hold=" + isHold + ">, ";
            }
            if (parameters.contains(",")) {
                parameters = parameters.substring(0, parameters.lastIndexOf(","));
            }

            String body = Utility.printMathPiperExpression(aStackTop, rule.getBody(), aEnvironment, 0);
            body = body.replace(",", ", ");
            //System.out.println(data);

            String substitutedMacroBody = "";

            if (userFunction instanceof MacroRulebase) {
                BackQuoteSubstitute backQuoteSubstitute = new BackQuoteSubstitute(aEnvironment);
                Cons substitutedBody = Utility.substitute(aEnvironment, aStackTop, rule.getBody(), backQuoteSubstitute);
                substitutedMacroBody = Utility.printMathPiperExpression(aStackTop, substitutedBody, aEnvironment, 0);
            }

            dumpResult.append("Precedence: " + precedence + ", ");
            dumpResult.append("\n" + "Rule Type: " + rule.getClass().getName() + ", ");
            dumpResult.append("\n" + "Arity: " + userFunction.arity() + ", ");
            dumpResult.append("\n" + "Parameters: " + parameters + ", ");
            dumpResult.append("\n" + "Predicates: " + predicate + ",    ");

            if (userFunction instanceof MacroRulebase) {
                dumpResult.append("\n" + "Body: \n" + body + ", ");
                dumpResult.append("\n" + "Substituted Macro Body: \n" + substitutedMacroBody + "\n");
            } else {
                dumpResult.append("\n" + "Body: \n" + body + "\n");
            }



        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return dumpResult.toString();

    }//end method.

    public static Cons associativeListGet(Environment aEnvironment, int aStackTop, Cons key, Cons listCons) throws Exception {


        while (listCons != null) {
            if (listCons.car() instanceof Cons) {
                Cons sub = (Cons) listCons.car();
                if (sub != null) {
                    sub = sub.cdr();
                    Cons temp = sub;
                    if (Utility.equals(aEnvironment, aStackTop, key, temp)) {
                        return listCons;
                    }//end if.

                }//end if.

            }//end if.

            listCons = listCons.cdr();

        }//end if.

        return null;
    }//end method.

    /**
     * Returns the type of a.
     * @param aEnvironment
     * @param expression
     * @throws java.lang.Exception
     */
    public static String functionType(Cons expression) throws Exception {
        if (!(expression.car() instanceof Cons)) {
            return "";
        }

        Cons subList = (Cons) expression.car();
        Cons head = null;
        head = subList;

     if(head == null)
     {
         int xx = 1;
     }
        if (!(head.car() instanceof String)) {
            return "";
        }//end if.

        return (String) head.car();

    }//end method.

    /**
     * Converts a =Java Iterable into a MathPiper List.
     *
     * @param aEnvironment
     * @param iterable
     * @return cons
     * @throws java.lang.Exception
     */
    public static Cons iterableToList(Environment aEnvironment, int aStackTop, java.lang.Iterable iterable) throws Exception {
        
        Cons head = aEnvironment.iListAtom.copy(false);

        Cons cons = head;

        Iterator iterator = iterable.iterator();

        while (iterator.hasNext()) {
            Object object = iterator.next();

            if(object instanceof String)
            {
                String key = (String) object;

                Cons stringCons = AtomCons.getInstance(aEnvironment, aStackTop, key);

                cons.setCdr(stringCons);
            }
            else
            {
                throw new Exception("Operation not supported.");
            }

            cons = cons.cdr();

        }//end while.

        return head;

    }//end method.


    public static Cons mathPiperParse(Environment aEnvironment, int aStackTop, String inputExpression) throws Exception {
        MathPiperTokenizer tokenizer = new MathPiperTokenizer();
        InputStatus someStatus = new InputStatus();

        StringBuffer inp = new StringBuffer();
        inp.append(inputExpression);
        inp.append(";");
        StringInputStream inputExpressionBuffer = new StringInputStream(inp.toString(), someStatus);

        Parser infixParser = new MathPiperParser(tokenizer, inputExpressionBuffer, aEnvironment, aEnvironment.iPrefixOperators, aEnvironment.iInfixOperators, aEnvironment.iPostfixOperators, aEnvironment.iBodiedOperators);
        Cons inputExpressionCons = infixParser.parse(aStackTop);

        return inputExpressionCons;
    }//end method.




    public static Cons lispEvaluate(Environment aEnvironment, int aStackTop, String inputExpression) throws Exception {

        Cons inputExpressionCons = mathPiperParse(aEnvironment, aStackTop, inputExpression);

        return aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, inputExpressionCons);
    }//end method.




    public static Cons lispEvaluate(Environment aEnvironment, int aStackTop, Cons inputExpression) throws Exception {

        return aEnvironment.iLispExpressionEvaluator.evaluate(aEnvironment, aStackTop, inputExpression);

    }//end method.



    public static void declareFunction(String functionName, String[] parameters, String body, Environment aEnvironment, int aStackTop) throws Exception
    {

        Cons parameterTraverser = null;

        Cons head = null;

        boolean isHead = true;

        for(String parameterName:parameters)
        {
           Cons atomCons = AtomCons.getInstance(aEnvironment, aStackTop, parameterName);

           if(isHead)
           {
               parameterTraverser = atomCons;

               head = parameterTraverser;

               isHead = false;
           }
           else
           {
               parameterTraverser.setCdr(atomCons);
               parameterTraverser = atomCons;
           }
        }//end for.

        aEnvironment.defineRulebase(aStackTop, functionName, head, false);

        Cons expressionCons = Utility.mathPiperParse(aEnvironment, aStackTop, body);

        aEnvironment.defineRule(aStackTop, functionName, parameters.length, 100, Utility.getTrueAtom(aEnvironment), expressionCons);
    }



    public static void loadLibraryFunction(String functionName, Environment aEnvironment, int aStackTop) throws Exception {
        Scripts scripts = aEnvironment.scripts;

        String[] scriptCode = scripts.getScript(functionName);


        if (scriptCode == null) {
            LispError.throwError(aEnvironment, aStackTop, "No script returned for function: " + functionName + " from Scripts.java.");
        }

        if (scriptCode[0] == null) {

            if (scriptCode[1] == null) {
                LispError.throwError(aEnvironment, aStackTop, "No script returned for function: " + functionName + " from Scripts.java.");
            }

            if (Evaluator.DEBUG) {
                /*Show loading... */

                if (Evaluator.VERBOSE_DEBUG) {

                    if (Evaluator.TRACE_TO_STANDARD_OUT) {
                        System.out.print("Debug> Reading function " + functionName + "\n");
                    } else {
                        aEnvironment.write("Debug> Reading function " + functionName + "\n");
                    }

                }
            }

            String scriptString = scriptCode[1];

            /*
            if(scriptCode.length == 2)
            {
                aEnvironment.iInputStatus.setTo(functionName);
            }
            else
            {
                aEnvironment.iInputStatus.setTo(scriptCode[2]);
            }

             */
            
            StringInputStream functionInputStream = new StringInputStream(scriptString, aEnvironment.getCurrentInput().iStatus);

            scriptCode[0] = "+";

            Utility.doInternalLoad(aEnvironment, aStackTop, functionInputStream);

            if (Evaluator.DEBUG) {

                if (Evaluator.VERBOSE_DEBUG) {

                    if (Evaluator.TRACE_TO_STANDARD_OUT) {
                        System.out.print("Debug> Finished reading " + functionName + "\n");
                    } else {
                        aEnvironment.write("Debug> Finished reading " + functionName + "\n");
                    }

                }
            }
        }
    }

}//end class.

