%mathpiper,title="xSolvePoly"

//Retract("xSolvePoly",*);

/******************** xSolvePoly ********************/

/* Tries to solve by calling PSolve */
/* Returns Failed if this doesn't work, and the solution otherwise */

/* CanBeUni is not documented, but defined in univar.rep/code.mpi */
/* It returns True iff 'expr' is or can be considered to be a univariate polynomial in 'var' */

10 # xSolvePoly(_expr, _var)_(Not? CanBeUni(var, expr)) <-- 
  [
      Decide(iDebug=True,Tell("xSolvePoly_NoUni",[expr,var]));
      Failed;
  ];

  
20 # xSolvePoly(_expr, _var) <--
  LocalSymbols(x)
  [
      Decide(iDebug=True,Tell("xSolvePoly_Uni_F",[expr,var]));
      Local(factors,nfactors,roots);
      factors  := Factors(expr);
      nfactors := Length(factors);
      Decide(iDebug=True,Tell("  sp1",[nfactors,factors]));
      roots := [];
      ForEach(factor,factors) 
          Decide(Contains?(VarList(factor[1]),var),
              [
                  Local(rs,r);
                  rs := PSolve(factor[1],var);
                  Decide(iDebug=True,Tell("    sp2",rs));
                  Decide( Type(rs)="List",
                      ForEach(r,rs) Push(roots,r),
                      Push(roots,rs)
                  );
              ]
          );
      Decide(iDebug=True,Tell("  sp3",roots));
      Local(result);
      Decide(Type(roots) = "List",
          [
              Decide(iDebug=True,Tell("   sp4_is_list",Length(roots)));
              Decide(Length(roots) >? 1, 
                  [Tell("      >1"); result := MapSingle([[t],var==t], roots);],
                  Decide( Type(roots[1]) = "List",
                      [Tell("        List"); result := MapSingle([[t],var==t], roots[1]);],
                      [Tell("        Not? List"); result := [var == roots[1]];]
                  )
              );
          ],  
          [
              Decide(iDebug=True,Tell("   sp4_not_list"));
              result := [var == roots];
          ]
       );  
       result;
  ];
  
  
/* 
 * The call to PSolve (below) can have three kind of results
 *   1) PSolve returns a single root
 *   2) PSolve returns a list of roots
 *   3) PSolve remains unevaluated
 */

30 # xSolvePoly(_expr, _var) <--
  LocalSymbols(x)
  [
      Decide(iDebug=True,Tell("xSolvePoly_Uni_P",[expr,var]));
      Local(roots);
      roots := PSolve(expr, var);
      Decide(Type(roots) = "PSolve",
         Failed,                               /* Case 3 */
         Decide(Type(roots) = "List",
             MapSingle([[x],var==x], roots),   /* Case 2 */
             [var == roots])                   /* Case 1 */
      );
  ];


%/mathpiper

    %output,preserve="false"
      Result: True
.   %/output



