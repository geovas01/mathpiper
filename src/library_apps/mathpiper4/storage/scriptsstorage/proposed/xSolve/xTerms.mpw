%mathpiper,title="xTerms"

//Retract("xTerms",*);
//Retract("xTerms2",*);

xTerms(_expr) <--
[
    Local(L,n,h,s,t,f,stack,qs,topLevelPM,nTerms,firstH);
    Decide( InVerboseMode(),[ Echo("in xTerms()"); Echo("  input expression: ",expr); ]);    
    Decide( Not? List?( stack ), stack := [] );
    topLevelPM := 0;
    firstH     := 0;
    qs         := 1;
    f          := expr;      
    
    While( Function?(f) )
        [
            L  := FunctionToList(f);
            n  := Length(L);
            h  := Head( L );
            Decide(h=ToAtom("+") Or? h=ToAtom("-"),[Decide(firstH=0,firstH=1);topLevelPM++;]);
            Decide(InVerboseMode(),Echo("  f=",f,"  n=",n,"  L=",L,"   h=",h,"   firstH=",firstH,"  tlpm=",topLevelPM));
            Decide(n=3, 
                [
                    Decide( h=ToAtom("-"), s:=-1, s:=1 );
                    t := s * L[3];
                    Decide(InVerboseMode(),Echo("                     t= ",t));
                    Decide( (h=ToAtom("*") Or? h=ToAtom("/") Or? h=ToAtom("^")), Push(stack,f), Push(stack,t) );
                    f := L[2];   
                    Decide(InVerboseMode(), [
                        Echo("         new f=",f);
                        Echo("                                     stack=",stack); ]
                    );
                ],
                [
                    Decide( h=ToAtom("-"),[f:=L[2];qs:=-1;],
                        [
                            Push(stack,ListToFunction(L));
                            Decide( InVerboseMode(), [
                                Echo("          n=",n,"      L=",L,"     h=",h);
                                Echo("DONE");
                                Echo("|---> ",stack," <---|"); ]
                            );
                            f:="STOP";
                        ]
                    );
                ]
            );    
        ];
    Decide( (Not? Function?(f)) And? (Length(stack)=0), stack := [f]);
    stack := qs * stack;
    Decide(qs>0,nTerms:=topLevelPM+1,nTerms:=topLevelPM);
    Decide(InVerboseMode(),Echo("==========================  stack = ",stack));
    Decide( nTerms >? Length(stack), Echo("  >>>> RESULT should be one term longer"));
    //Decide(firstH != ToAtom("+") And?  firstH != ToAtom("-") And? tlpm >?0,Echo("  >>>> RESULT should be one term shorter"));
    stack;
];

UnFence( "xTerms", 1 );

xTerms2(_expr) <--
[
    Local(L,stack,result,lenL);
    Decide(InVerboseMode(),[ Tell("in xTerms2()"); Tell("   input expression: ",expr); ]);    
    Decide( Not? List?( stack ), stack := [] );
    Decide( Atom?(expr), L:=[expr], L:=FunctionToList(expr) );
    lenL := Length(L);
    Decide(InVerboseMode(), Tell("   0",[L,lenL]) );  
    Decide( lenL = 1, [ stack := L:stack; Tell("   1",stack); ] );
    Decide( lenL = 2, [ stack := L[1]:L[2]:stack; Tell("   2",stack); ] );
    Decide( lenL = 3, [ stack := L[1]:L[2]:L[3]:stack; Tell("   3",stack); ] );
    
    result := stack;
];

UnFence( "xTerms2", 1 );

%/mathpiper
